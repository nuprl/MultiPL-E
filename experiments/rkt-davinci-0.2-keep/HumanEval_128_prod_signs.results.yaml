name: HumanEval_128_prod_signs
language: racket
results:
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr)])\n       (let ([magnitudes\
    \ (map abs arr)])\n         (let ([sign-prod (apply * signs)])\n           (let\
    \ ([mag-sum (apply + magnitudes)])\n             (* sign-prod mag-sum)))))]))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpwtsguprw.rkt:29:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) (error \"Empty array\")]\n        [else\n      \
    \   (let ([signs (map (lambda (x) (if (zero? x) 0 (if (< x 0) -1 1))) arr)])\n\
    \           (* (apply * signs) (apply + (map abs arr))))]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnrr_t__c.rkt:25:4\n\
    \nEmpty array\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (< x 0) -1 1))) arr)])\n       (apply * (map abs arr))\n\
    \       (apply * signs))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp2g88xeep.rkt:24:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp2g88xeep.rkt:26:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp2g88xeep.rkt:28:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp2g88xeep.rkt:29:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp2g88xeep.rkt:30:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr)])\n       (* (apply * signs)\
    \ (apply + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpcypyqihc.rkt:26:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp8wbciqzr.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp8wbciqzr.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp8wbciqzr.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp8wbciqzr.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp8wbciqzr.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp8wbciqzr.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpp_nmfkc1.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpp_nmfkc1.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpp_nmfkc1.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpp_nmfkc1.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpp_nmfkc1.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpp_nmfkc1.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) (error \"empty arr\")]\n    [(every? zero?\
    \ arr) 0]\n    [else\n     (apply * (map sign arr))\n     (* (apply * (map sign\
    \ arr))\n        (apply + (map abs arr)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate\
    \ (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal?\
    \ (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list ))\
    \ #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal?\
    \ (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1))\
    \ -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpyqppla8n.rkt:14:6: every?: unbound identifier\n  in: every?\n \
    \ location...:\n   /tmp/tmpyqppla8n.rkt:14:6\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * signs)\n        (apply + (map\
    \ abs arr)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpie0buzix.rkt:23:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpie0buzix.rkt:24:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpie0buzix.rkt:25:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpie0buzix.rkt:29:4\nactual:     4\nexpected:   -4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpie0buzix.rkt:30:4\n\
    actual:     3\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x)\n   \
    \                       (if (zero? x)\n                              0\n     \
    \                         (if (positive? x)\n                                \
    \  1\n                                  -1)))\n                        arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpt1qqihe4.rkt:29:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpt1qqihe4.rkt:31:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpt1qqihe4.rkt:33:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpt1qqihe4.rkt:34:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpt1qqihe4.rkt:35:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply +\
    \ (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpxed988jt.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod\
    \ 1])\n        (if (null? arr)\n            (* sum prod)\n            (let ([x\
    \ (car arr)])\n              (loop (cdr arr) (+ sum (abs x)) (* prod (if (zero?\
    \ x) 0 (if (> x 0) 1 -1)))))))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpcy23vckh.rkt:28:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (negative? x) -1 1))) arr)]\n             [magnitudes (map abs\
    \ arr)])\n        (apply * signs)\n        (apply + magnitudes))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpca1sihd5.rkt:24:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpca1sihd5.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpca1sihd5.rkt:26:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpca1sihd5.rkt:30:4\nactual:     4\nexpected:   -4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpca1sihd5.rkt:31:4\n\
    actual:     3\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp77p7aghz.rkt:26:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (negative? x) -1 1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmppvx3fnhz.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (negative? x) -1 1))) arr))\
    \ (apply + (map abs arr)))\n  location...:\n   /tmp/tmppvx3fnhz.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply + (map abs\
    \ arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal?\
    \ (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1))\
    \ -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate\
    \ (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1))\
    \ 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (positive? x) 1 -1))) arr)]\n             [magnitudes (map abs\
    \ arr)])\n        (apply * signs)\n        (apply + magnitudes))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmplo3nxksk.rkt:24:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmplo3nxksk.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmplo3nxksk.rkt:26:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmplo3nxksk.rkt:30:4\nactual:     4\nexpected:   -4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmplo3nxksk.rkt:31:4\n\
    actual:     3\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (positive? x) 1 -1))) arr))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpbgwn4etx.rkt:21:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpbgwn4etx.rkt:23:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpbgwn4etx.rkt:25:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpbgwn4etx.rkt:26:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpbgwn4etx.rkt:27:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (positive? x) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp5qtc_uth.rkt:12:2: if: bad syntax\n  in: (if (empty? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\
    \ (apply + (map abs arr)))\n  location...:\n   /tmp/tmp5qtc_uth.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * signs)\n        (apply + (map\
    \ abs arr)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpqnlxkof3.rkt:23:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpqnlxkof3.rkt:24:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpqnlxkof3.rkt:25:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpqnlxkof3.rkt:29:4\nactual:     4\nexpected:   -4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpqnlxkof3.rkt:30:4\n\
    actual:     3\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (positive? x) 1 -1)) arr)])\n       (* (apply * signs) (apply + (map\
    \ abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpvomfyvcw.rkt:24:4\n\
    actual:     -1\nexpected:   0\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpvomfyvcw.rkt:30:4\nactual:     3\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let* ([magnitudes (map abs arr)]\n\
    \             [signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n\
    \             [magnitude-sum (apply + magnitudes)]\n             [sign-prod (apply\
    \ * signs)])\n        (* magnitude-sum sign-prod))))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp29jf6r5c.rkt:28:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod\
    \ 1])\n        (if (null? arr)\n            (* sum prod)\n            (let ([x\
    \ (car arr)])\n              (cond\n                [(positive? x) (loop (cdr\
    \ arr) (+ sum x) prod)]\n                [(negative? x) (loop (cdr arr) (+ sum\
    \ (- x)) (* prod -1))]\n                [else (loop (cdr arr) sum prod)]))))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpte6cmymr.rkt:29:4\n\
    actual:     1\nexpected:   0\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpte6cmymr.rkt:31:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpte6cmymr.rkt:35:4\nactual:     -3\nexpected:\
    \   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (positive? x) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpb97f3c3y.rkt:12:2: if: bad syntax\n  in: (if (empty? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\
    \ (apply + (map abs arr)))\n  location...:\n   /tmp/tmpb97f3c3y.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x)\n\
    \                          (if (= x 0)\n                              0\n    \
    \                          (if (> x 0)\n                                  1\n\
    \                                  -1)))\n                        arr)])\n   \
    \     (let ([magnitudes (map abs arr)])\n          (let ([sign-prod (apply * signs)])\n\
    \            (let ([mag-sum (apply + magnitudes)])\n              (* sign-prod\
    \ mag-sum)))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpfku6qipj.rkt:34:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) #f]\n    [else\n     (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n            [magnitudes (map\
    \ abs arr)])\n       (apply * signs)\n       (apply + magnitudes))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmplmtt2wdu.rkt:25:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmplmtt2wdu.rkt:26:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmplmtt2wdu.rkt:27:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmplmtt2wdu.rkt:31:4\nactual:     4\nexpected:   -4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmplmtt2wdu.rkt:32:4\n\
    actual:     3\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) 'None]\n        [else\n         (apply *\n     \
    \           (map (lambda (x)\n                       (cond [(zero? x) 0]\n   \
    \                          [(positive? x) 1]\n                             [else\
    \ -1]))\n                     arr))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmphk5rtljg.rkt:26:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmphk5rtljg.rkt:28:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmphk5rtljg.rkt:29:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmphk5rtljg.rkt:30:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmphk5rtljg.rkt:31:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmphk5rtljg.rkt:32:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (=\
    \ x 0) 0 (if (> x 0) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp5wgj4hcr.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (= x 0) 0 (if (> x 0) 1 -1))) arr)) (apply\
    \ + (map abs arr)))\n  location...:\n   /tmp/tmp5wgj4hcr.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [prod (apply * signs)]\n\
    \             [mags (map abs arr)])\n        (apply + (map * mags signs)))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp0tw3f6mi.rkt:24:4\n\
    actual:     1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp0tw3f6mi.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmp0tw3f6mi.rkt:26:4\nactual:     8\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp0tw3f6mi.rkt:28:4\nactual:     16\nexpected:   20\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp0tw3f6mi.rkt:29:4\n\
    actual:     0\nexpected:   4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp0tw3f6mi.rkt:30:4\nactual:     2\n\
    expected:   -4\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp0tw3f6mi.rkt:31:4\nactual:     1\nexpected:\
    \   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * signs)\n        (apply\
    \ + (map abs arr)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n \
    \ (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmphdwohp6_.rkt:23:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmphdwohp6_.rkt:24:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmphdwohp6_.rkt:25:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmphdwohp6_.rkt:26:4\nactual:     'None\nexpected:   #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmphdwohp6_.rkt:29:4\n\
    actual:     4\nexpected:   -4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmphdwohp6_.rkt:30:4\nactual:     3\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply +\
    \ (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpiqqsxvug.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x)\n\
    \                          (if (zero? x)\n                              0\n  \
    \                            (if (negative? x)\n                             \
    \     -1\n                                  1)))\n                        arr)])\n\
    \        (let ([magnitudes (map abs arr)])\n          (apply * (map * signs magnitudes))))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_8bebyo8.rkt:29:4\n\
    actual:     -16\nexpected:   -9\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_8bebyo8.rkt:31:4\nactual:\
    \     -6\nexpected:   -10\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp_8bebyo8.rkt:32:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp_8bebyo8.rkt:33:4\nactual:     144\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp_8bebyo8.rkt:34:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_8bebyo8.rkt:35:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ((signs (map (lambda (x)\n\
    \                          (if (zero? x)\n                              0\n  \
    \                            (if (positive? x)\n                             \
    \     1\n                                  -1)))\n                        arr)))\n\
    \        (* (apply * signs)\n           (apply + (map abs arr))))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpbo0zkyg6.rkt:32:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) (error \"empty arr\")]\n    [(empty? (rest\
    \ arr)) (abs (first arr))]\n    [else\n     (* (signum (first arr))\n        (abs\
    \ (first arr))\n        (prod_signs (rest arr)))]))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpjemzze45.rkt:16:9: signum: unbound identifier\n  in: signum\n \
    \ location...:\n   /tmp/tmpjemzze45.rkt:16:9\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * signs)\n        (apply\
    \ + (map abs arr)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n \
    \ (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpbkwujhgw.rkt:23:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpbkwujhgw.rkt:24:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpbkwujhgw.rkt:25:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpbkwujhgw.rkt:26:4\nactual:     'None\nexpected:   #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpbkwujhgw.rkt:29:4\n\
    actual:     4\nexpected:   -4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpbkwujhgw.rkt:30:4\nactual:     3\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) 'None]\n        [else\n         (apply *\n     \
    \           (map (lambda (x)\n                       (cond [(zero? x) 0]\n   \
    \                          [(negative? x) -1]\n                             [else\
    \ 1]))\n                     arr))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp8bustgsd.rkt:26:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp8bustgsd.rkt:28:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp8bustgsd.rkt:29:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp8bustgsd.rkt:30:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp8bustgsd.rkt:31:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp8bustgsd.rkt:32:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ((signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp6qrdj3d2.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp6qrdj3d2.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp6qrdj3d2.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp6qrdj3d2.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp6qrdj3d2.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp6qrdj3d2.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) 'None]\n        [else\n         (let ([magnitudes\
    \ (map abs arr)])\n           (apply * (map signum arr))\n           (apply +\
    \ magnitudes))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpkn5whbyj.rkt:15:25: signum: unbound identifier\n  in: signum\n\
    \  location...:\n   /tmp/tmpkn5whbyj.rkt:15:25\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (=\
    \ x 0) 0 (if (> x 0) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmplsxypgal.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (= x 0) 0 (if (> x 0) 1 -1))) arr)) (apply\
    \ + (map abs arr)))\n  location...:\n   /tmp/tmplsxypgal.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (< x 0) -1 1))) arr)]\n             [magnitudes (map abs arr)])\n\
    \        (apply * signs)\n        (apply + magnitudes))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpp975qwx7.rkt:24:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpp975qwx7.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpp975qwx7.rkt:26:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpp975qwx7.rkt:30:4\nactual:     4\nexpected:   -4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpp975qwx7.rkt:31:4\n\
    actual:     3\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) 'None]\n        [else\n         (let ([signs (map\
    \ abs arr)])\n           (apply * (map signum arr))\n           (apply + signs))]))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpdzx4e8qq.rkt:15:25: signum: unbound identifier\n  in: signum\n\
    \  location...:\n   /tmp/tmpdzx4e8qq.rkt:15:25\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n\
    \        (apply * signs)\n        (apply + magnitudes))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpkadax62a.rkt:24:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpkadax62a.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpkadax62a.rkt:26:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpkadax62a.rkt:27:4\nactual:     'None\nexpected:   #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpkadax62a.rkt:30:4\n\
    actual:     4\nexpected:   -4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpkadax62a.rkt:31:4\nactual:     3\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([magnitudes (map abs arr)])\n\
    \        (apply * (map (lambda (x) (if (= x 0) 0 (if (> x 0) 1 -1))) arr))\n \
    \       (apply + magnitudes))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp3ay4ii42.rkt:23:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp3ay4ii42.rkt:24:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmp3ay4ii42.rkt:25:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp3ay4ii42.rkt:26:4\nactual:     'None\nexpected:   #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp3ay4ii42.rkt:29:4\n\
    actual:     4\nexpected:   -4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp3ay4ii42.rkt:30:4\nactual:     3\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply +\
    \ (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmprjqhzqqd.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ((signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (positive? x) 1 -1))) arr)))\n        (* (apply * signs) (apply\
    \ + (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzpwd2c3s.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpgvmiggqh.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpgvmiggqh.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpgvmiggqh.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpgvmiggqh.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpgvmiggqh.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpgvmiggqh.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp96ng2a8i.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp96ng2a8i.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp96ng2a8i.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp96ng2a8i.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp96ng2a8i.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply +\
    \ (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpg1tbciix.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (=\
    \ x 0) 0 (if (> x 0) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpk5tn1sfq.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (= x 0) 0 (if (> x 0) 1 -1))) arr)) (apply\
    \ + (map abs arr)))\n  location...:\n   /tmp/tmpk5tn1sfq.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ((signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)))\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpbph1q14a.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpbph1q14a.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpbph1q14a.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpbph1q14a.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpbph1q14a.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let loop ([arr arr] [sum 0] [prod\
    \ 1])\n        (if (null? arr)\n            (* sum prod)\n            (let ([x\
    \ (car arr)])\n              (if (= x 0)\n                  (* sum prod)\n   \
    \               (loop (cdr arr) (+ sum (abs x)) (* prod (if (> x 0) 1 -1)))))))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpgpnud0to.rkt:34:4\n\
    actual:     -3\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpo5epnat5.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpo5epnat5.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpo5epnat5.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpo5epnat5.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpo5epnat5.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpo5epnat5.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map sign arr))\n     \
    \ (apply + (map abs arr))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpx2efi2m6.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map sign arr)) (apply + (map abs arr)))\n  location...:\n  \
    \ /tmp/tmpx2efi2m6.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply +\
    \ (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpmuf524ek.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp66i1d_i5.rkt:12:2: if: bad syntax\n  in: (if (empty? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)) (apply\
    \ + (map abs arr)))\n  location...:\n   /tmp/tmp66i1d_i5.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) (error \"empty array\")]\n        [else\n      \
    \   (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \           (* (apply * signs) (apply + (map abs arr))))]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpme9ylreu.rkt:25:4\n\
    \nempty array\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (< x 0) -1 1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpg35bb_iz.rkt:12:2: if: bad syntax\n  in: (if (empty? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (< x 0) -1 1))) arr)) (apply\
    \ + (map abs arr)))\n  location...:\n   /tmp/tmpg35bb_iz.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) (error \"Empty array\")]\n    [(empty? (cdr\
    \ arr)) (car arr)]\n    [else\n     (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply + (map abs arr))))]))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpevbkwxii.rkt:27:4\n\
    \nEmpty array\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpai8e1i6l.rkt:26:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) 'None]\n        [else (apply * (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate\
    \ (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal?\
    \ (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list ))\
    \ #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal?\
    \ (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1))\
    \ -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp6_l80jby.rkt:20:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp6_l80jby.rkt:22:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp6_l80jby.rkt:23:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp6_l80jby.rkt:24:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp6_l80jby.rkt:25:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp6_l80jby.rkt:26:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod\
    \ 1])\n        (if (null? arr)\n            (* sum prod)\n            (loop (cdr\
    \ arr) (+ sum (abs (car arr))) (* prod (signum (car arr))))))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpogza1p3m.rkt:17:61: signum: unbound identifier\n  in: signum\n\
    \  location...:\n   /tmp/tmpogza1p3m.rkt:17:61\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (negative? x) -1 1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpg1y4znwo.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (negative? x) -1 1))) arr))\
    \ (apply + (map abs arr)))\n  location...:\n   /tmp/tmpg1y4znwo.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) (error \"Empty array\")]\n    [(empty? (rest\
    \ arr)) (abs (first arr))]\n    [else\n     (* (abs (first arr))\n        (prod_signs\
    \ (rest arr)))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp8lnbd2bx.rkt:24:4\n\
    actual:     16\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp8lnbd2bx.rkt:26:4\nactual:     6\n\
    expected:   -10\n--------------------\n--------------------\nERROR\nname:    \
    \   check-equal?\nlocation:   /tmp/tmp8lnbd2bx.rkt:27:4\n\nEmpty array\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp8lnbd2bx.rkt:28:4\n\
    actual:     144\nexpected:   20\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp8lnbd2bx.rkt:29:4\nactual:\
    \     1\nexpected:   4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp8lnbd2bx.rkt:30:4\nactual:     1\n\
    expected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x)\n\
    \                          (if (zero? x)\n                              0\n  \
    \                            (if (positive? x)\n                             \
    \     1\n                                  -1)))\n                        arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp3nyrdsid.rkt:29:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp3nyrdsid.rkt:31:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp3nyrdsid.rkt:32:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp3nyrdsid.rkt:33:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp3nyrdsid.rkt:34:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp3nyrdsid.rkt:35:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply +\
    \ (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp4xk4crjw.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n\
    \        (apply * signs)\n        (apply + magnitudes))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_fqrwglv.rkt:24:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp_fqrwglv.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmp_fqrwglv.rkt:26:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp_fqrwglv.rkt:30:4\nactual:     4\nexpected:   -4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_fqrwglv.rkt:31:4\n\
    actual:     3\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) (error \"empty arr\")]\n    [(empty? (rest\
    \ arr)) (abs (first arr))]\n    [else\n     (* (abs (first arr))\n        (prod_signs\
    \ (rest arr)))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpeqp6lv41.rkt:24:4\n\
    actual:     16\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpeqp6lv41.rkt:26:4\nactual:     6\n\
    expected:   -10\n--------------------\n--------------------\nERROR\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpeqp6lv41.rkt:27:4\n\nempty arr\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpeqp6lv41.rkt:28:4\n\
    actual:     144\nexpected:   20\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpeqp6lv41.rkt:29:4\nactual:\
    \     1\nexpected:   4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpeqp6lv41.rkt:30:4\nactual:     1\n\
    expected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x)\n\
    \                          (if (zero? x)\n                              0\n  \
    \                            (if (negative? x)\n                             \
    \     -1\n                                  1)))\n                        arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmperup1c4m.rkt:29:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmperup1c4m.rkt:31:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmperup1c4m.rkt:32:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmperup1c4m.rkt:33:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmperup1c4m.rkt:34:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmperup1c4m.rkt:35:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp8jaaw31v.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp8jaaw31v.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp8jaaw31v.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp8jaaw31v.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp8jaaw31v.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp8jaaw31v.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (positive? x) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmphp2ddi3u.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\
    \ (apply + (map abs arr)))\n  location...:\n   /tmp/tmphp2ddi3u.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let* ([signs (map (lambda (x)\n\
    \                           (if (zero? x)\n                               0\n\
    \                               (if (negative? x)\n                          \
    \         -1\n                                   1)))\n                      \
    \   arr)]\n             [magnitudes (map abs arr)])\n        (apply * signs)\n\
    \        (apply + magnitudes))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmponiu5x7f.rkt:30:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmponiu5x7f.rkt:31:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmponiu5x7f.rkt:32:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmponiu5x7f.rkt:33:4\nactual:     'None\nexpected:   #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmponiu5x7f.rkt:36:4\n\
    actual:     4\nexpected:   -4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmponiu5x7f.rkt:37:4\nactual:     3\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ((signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)))\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_2nar9se.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp_2nar9se.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp_2nar9se.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp_2nar9se.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_2nar9se.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      (error \"Empty array\")\n      (let ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply\
    \ * (map abs arr))\n        (apply * signs))))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate\
    \ (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal?\
    \ (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list ))\
    \ #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal?\
    \ (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1))\
    \ -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpj1kncemx.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpj1kncemx.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nERROR\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpj1kncemx.rkt:26:4\n\nEmpty array\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpj1kncemx.rkt:27:4\n\
    actual:     1\nexpected:   20\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpj1kncemx.rkt:28:4\nactual:     1\n\
    expected:   4\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpj1kncemx.rkt:29:4\nactual:     -1\nexpected:\
    \   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (positive? x) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp8gqnyou5.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\
    \ (apply + (map abs arr)))\n  location...:\n   /tmp/tmp8gqnyou5.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply + (map abs\
    \ arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal?\
    \ (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1))\
    \ -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate\
    \ (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1))\
    \ 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) #f]\n    [else\n     (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n            [prod (apply * signs)]\n\
    \            [mags (map abs arr)])\n       (apply + (map * mags signs)))]))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpnwyig5hh.rkt:25:4\n\
    actual:     1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpnwyig5hh.rkt:26:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpnwyig5hh.rkt:27:4\nactual:     8\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpnwyig5hh.rkt:29:4\nactual:     16\nexpected:   20\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpnwyig5hh.rkt:30:4\n\
    actual:     0\nexpected:   4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpnwyig5hh.rkt:31:4\nactual:     2\n\
    expected:   -4\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpnwyig5hh.rkt:32:4\nactual:     1\nexpected:\
    \   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) (error \"empty array\")]\n    [(= (length arr)\
    \ 1) (abs (first arr))]\n    [else\n     (let ([signs (map (lambda (x) (if (=\
    \ x 0) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply + (map abs\
    \ arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal?\
    \ (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1))\
    \ -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate\
    \ (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1))\
    \ 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1kf5eyy0.rkt:27:4\n\
    \nempty array\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x)\n\
    \                          (if (zero? x)\n                              0\n  \
    \                            (if (positive? x)\n                             \
    \     1\n                                  -1)))\n                        arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp5n_0q2wn.rkt:29:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp5n_0q2wn.rkt:31:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp5n_0q2wn.rkt:32:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp5n_0q2wn.rkt:33:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp5n_0q2wn.rkt:34:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp5n_0q2wn.rkt:35:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([magnitudes (map abs arr)])\n\
    \        (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\n\
    \        (apply + magnitudes))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpskfmazi9.rkt:23:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpskfmazi9.rkt:24:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpskfmazi9.rkt:25:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpskfmazi9.rkt:26:4\nactual:     'None\nexpected:   #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpskfmazi9.rkt:29:4\n\
    actual:     4\nexpected:   -4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpskfmazi9.rkt:30:4\nactual:     3\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x)\n    \
    \                  (if (zero? x)\n                          0\n              \
    \            (if (positive? x)\n                              1\n            \
    \                  -1)))\n                    arr))))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp6mrsw9kd.rkt:27:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp6mrsw9kd.rkt:29:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp6mrsw9kd.rkt:30:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp6mrsw9kd.rkt:31:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp6mrsw9kd.rkt:32:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp6mrsw9kd.rkt:33:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x)\n    \
    \                  (if (zero? x)\n                          0\n              \
    \            (if (positive? x)\n                              1\n            \
    \                  -1)))\n                    arr))))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpvd4z5w4r.rkt:27:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpvd4z5w4r.rkt:29:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpvd4z5w4r.rkt:30:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpvd4z5w4r.rkt:31:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpvd4z5w4r.rkt:32:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpvd4z5w4r.rkt:33:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n\
    \        (apply * signs)\n        (apply + magnitudes))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzk561ih4.rkt:24:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpzk561ih4.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpzk561ih4.rkt:26:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpzk561ih4.rkt:30:4\nactual:     4\nexpected:   -4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzk561ih4.rkt:31:4\n\
    actual:     3\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x)\n\
    \                          (if (zero? x)\n                              0\n  \
    \                            (if (negative? x)\n                             \
    \     -1\n                                  1)))\n                        arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpm830s0d9.rkt:29:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpm830s0d9.rkt:31:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpm830s0d9.rkt:32:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpm830s0d9.rkt:33:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpm830s0d9.rkt:34:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpm830s0d9.rkt:35:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) (error \"Empty array\")]\n    [(every? zero?\
    \ arr) 0]\n    [else\n     (apply * (map sign arr))\n     (* (apply * (map sign\
    \ arr))\n        (apply + (map abs arr)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate\
    \ (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal?\
    \ (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list ))\
    \ #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal?\
    \ (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1))\
    \ -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmptnkr2p7g.rkt:14:6: every?: unbound identifier\n  in: every?\n \
    \ location...:\n   /tmp/tmptnkr2p7g.rkt:14:6\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (let ([signs (map (lambda (x) (cond\
    \ [(> x 0) 1] [(< x 0) -1] [else 0])) arr)])\n        (* (apply * signs) (apply\
    \ + (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpx1edc9bu.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) 'None]\n        [else (apply * (map (lambda (x)\
    \ (if (zero? x) 0 (if (positive? x) 1 -1))) arr))]))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp4cteeae0.rkt:20:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp4cteeae0.rkt:22:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp4cteeae0.rkt:23:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp4cteeae0.rkt:24:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp4cteeae0.rkt:25:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp4cteeae0.rkt:26:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod\
    \ 1])\n        (if (null? arr)\n            (* sum prod)\n            (loop (cdr\
    \ arr) (+ sum (abs (car arr))) (* prod (signum (car arr))))))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpdb80homx.rkt:17:61: signum: unbound identifier\n  in: signum\n\
    \  location...:\n   /tmp/tmpdb80homx.rkt:17:61\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (let* ([signs (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs\
    \ arr)])\n        (* (apply * signs) (apply + magnitudes)))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpcru3n3a_.rkt:26:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) #f]\n        [else\n         (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply * signs)\
    \ (apply + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod\
    \ 1])\n        (if (null? arr)\n            (* sum prod)\n            (let ([n\
    \ (car arr)])\n              (cond [(> n 0) (loop (cdr arr) (+ sum n) prod)]\n\
    \                    [(= n 0) (loop (cdr arr) sum 0)]\n                    [(<\
    \ n 0) (loop (cdr arr) (+ sum (- n)) (* prod -1))]))))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmptt81236m.rkt:30:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply +\
    \ (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp4u45gx3h.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ((signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (positive? x) 1 -1))) arr)))\n        (apply * (map abs arr))\n   \
    \     (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpiyybcs__.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpiyybcs__.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpiyybcs__.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpiyybcs__.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpiyybcs__.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (* (apply * (map sign arr))\n  \
    \       (apply + (map abs arr)))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpsk4b_1e5.rkt:14:23: sign: unbound identifier\n  in: sign\n  location...:\n\
    \   /tmp/tmpsk4b_1e5.rkt:14:23\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      (error \"empty array\")\n      (let ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply *\
    \ signs) (apply + (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpt0fzeu5t.rkt:25:4\n\
    \nempty array\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (positive? x) 1 -1))) arr)])\n        (apply * (map abs arr))\n\
    \        (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpi8twjsfd.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpi8twjsfd.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpi8twjsfd.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpi8twjsfd.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpi8twjsfd.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpi8twjsfd.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpul1xte_a.rkt:12:2: if: bad syntax\n  in: (if (empty? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)) (apply\
    \ + (map abs arr)))\n  location...:\n   /tmp/tmpul1xte_a.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpqjchu0rd.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpqjchu0rd.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpqjchu0rd.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpqjchu0rd.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpqjchu0rd.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpqjchu0rd.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      (error \"empty array\")\n      (apply * (map\
    \ (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpr79exf5u.rkt:21:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpr79exf5u.rkt:23:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nERROR\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpr79exf5u.rkt:24:4\n\nempty array\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpr79exf5u.rkt:25:4\n\
    actual:     1\nexpected:   20\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpr79exf5u.rkt:26:4\nactual:     1\n\
    expected:   4\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpr79exf5u.rkt:27:4\nactual:     -1\nexpected:\
    \   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n\
    \        (apply * signs)\n        (apply + magnitudes))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpul_h9hfn.rkt:24:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpul_h9hfn.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpul_h9hfn.rkt:26:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpul_h9hfn.rkt:27:4\nactual:     'None\nexpected:   #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpul_h9hfn.rkt:30:4\n\
    actual:     4\nexpected:   -4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpul_h9hfn.rkt:31:4\nactual:     3\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      (void)\n      (let* ([signs (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs\
    \ arr)])\n        (apply * signs)\n        (apply + magnitudes))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp5vazaug6.rkt:24:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp5vazaug6.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmp5vazaug6.rkt:26:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp5vazaug6.rkt:27:4\nactual:     #<void>\nexpected:   #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp5vazaug6.rkt:30:4\n\
    actual:     4\nexpected:   -4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp5vazaug6.rkt:31:4\nactual:     3\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (< x 0) -1 1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpxx7yp0wn.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpxx7yp0wn.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpxx7yp0wn.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpxx7yp0wn.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpxx7yp0wn.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let loop ([arr arr] [acc 0])\n   \
    \     (if (null? arr)\n            acc\n            (loop (cdr arr) (+ (* (abs\
    \ (car arr)) (signum (car arr))) acc))))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp4g499npx.rkt:17:51: signum: unbound identifier\n  in: signum\n\
    \  location...:\n   /tmp/tmp4g499npx.rkt:17:51\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ((signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n        (* (apply * signs) (apply +\
    \ (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp71z5pem6.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) 'None]\n        [else\n         (let ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply\
    \ * signs) (apply + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpcqbxcng_.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (negative? x) -1 1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp8m3l0z50.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (negative? x) -1 1))) arr))\
    \ (apply + (map abs arr)))\n  location...:\n   /tmp/tmp8m3l0z50.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply +\
    \ (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpe1tf11u2.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (* (apply * (map sign arr))\n  \
    \       (apply + (map abs arr)))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpln10q82l.rkt:14:23: sign: unbound identifier\n  in: sign\n  location...:\n\
    \   /tmp/tmpln10q82l.rkt:14:23\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpnu3to3ry.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpnu3to3ry.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpnu3to3ry.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpnu3to3ry.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpnu3to3ry.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpnu3to3ry.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) #f]\n    [else\n     (let* ([signs (map (lambda\
    \ (x)\n                          (cond\n                            [(zero? x)\
    \ 0]\n                            [(negative? x) -1]\n                       \
    \     [else 1]))\n                        arr)]\n            [sign-prod (apply\
    \ * signs)]\n            [magnitudes (map abs arr)])\n       (apply + (map * magnitudes\
    \ signs)))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp2ixq9713.rkt:30:4\n\
    actual:     1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp2ixq9713.rkt:31:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmp2ixq9713.rkt:32:4\nactual:     8\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp2ixq9713.rkt:34:4\nactual:     16\nexpected:   20\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp2ixq9713.rkt:35:4\n\
    actual:     0\nexpected:   4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp2ixq9713.rkt:36:4\nactual:     2\n\
    expected:   -4\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp2ixq9713.rkt:37:4\nactual:     1\nexpected:\
    \   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) 'None]\n        [else (apply * (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate\
    \ (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal?\
    \ (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list ))\
    \ #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal?\
    \ (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1))\
    \ -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpj1eocwj1.rkt:20:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpj1eocwj1.rkt:22:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpj1eocwj1.rkt:23:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpj1eocwj1.rkt:24:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpj1eocwj1.rkt:25:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpj1eocwj1.rkt:26:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (* (apply * (map sign arr))\n  \
    \       (apply + (map abs arr)))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpa3rdtcmu.rkt:14:23: sign: unbound identifier\n  in: sign\n  location...:\n\
    \   /tmp/tmpa3rdtcmu.rkt:14:23\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      (void)\n      (let* ([magnitudes (map abs arr)]\n\
    \             [signs (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1)))\
    \ arr)]\n             [magnitude-sum (apply + magnitudes)]\n             [sign-prod\
    \ (apply * signs)])\n        (* magnitude-sum sign-prod))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmptxzrc0_k.rkt:28:4\n\
    actual:     #<void>\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) #f]\n        [else\n         (let* ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n                [magnitudes\
    \ (map abs arr)])\n           (apply * signs)\n           (apply + magnitudes))]))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpl44zfg5v.rkt:24:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpl44zfg5v.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpl44zfg5v.rkt:26:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpl44zfg5v.rkt:30:4\nactual:     4\nexpected:   -4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpl44zfg5v.rkt:31:4\n\
    actual:     3\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let loop ([arr arr] [sum 0] [prod\
    \ 1])\n        (if (null? arr)\n            (* sum prod)\n            (let ([x\
    \ (car arr)])\n              (loop (cdr arr) (+ sum (abs x)) (* prod (if (zero?\
    \ x) 1 (if (positive? x) 1 -1)))))))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpscigk_wt.rkt:26:4\n\
    actual:     1\nexpected:   0\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpscigk_wt.rkt:32:4\nactual:     -3\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpih29fsav.rkt:12:2: if: bad syntax\n  in: (if (empty? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)) (apply\
    \ + (map abs arr)))\n  location...:\n   /tmp/tmpih29fsav.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply +\
    \ (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp3wdemky4.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map sign arr))\n     \
    \ (apply + (map abs arr))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpeih3_m8l.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map sign arr)) (apply + (map abs arr)))\n  location...:\n  \
    \ /tmp/tmpeih3_m8l.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (positive? x) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpbr91a_d0.rkt:12:2: if: bad syntax\n  in: (if (empty? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\
    \ (apply + (map abs arr)))\n  location...:\n   /tmp/tmpbr91a_d0.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) 'None]\n        [else\n         (let ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply\
    \ * signs) (apply + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpgyj8bne9.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) #f]\n        [else\n         (let* ([signs (map\
    \ sign arr)]\n                [magnitudes (map abs arr)]\n                [prod\
    \ (apply * signs)]\n                [sum (apply + magnitudes)])\n           (*\
    \ prod sum))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp30pode_l.rkt:14:28: sign: unbound identifier\n  in: sign\n  location...:\n\
    \   /tmp/tmp30pode_l.rkt:14:28\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (=\
    \ x 0) 0 (if (> x 0) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpk_046ydu.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (= x 0) 0 (if (> x 0) 1 -1))) arr)) (apply\
    \ + (map abs arr)))\n  location...:\n   /tmp/tmpk_046ydu.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (negative? x) -1 1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpdt5b9bq0.rkt:12:2: if: bad syntax\n  in: (if (empty? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (negative? x) -1 1))) arr))\
    \ (apply + (map abs arr)))\n  location...:\n   /tmp/tmpdt5b9bq0.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) #f]\n        [else\n         (let* ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr)]\n              \
    \  [magnitudes (map abs arr)])\n           (* (apply * signs) (apply + magnitudes)))]))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (positive? x) 1 -1))) arr)]\n             [magnitudes (map abs\
    \ arr)])\n        (apply * signs)\n        (apply + magnitudes))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmphx5b5o30.rkt:24:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmphx5b5o30.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmphx5b5o30.rkt:26:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmphx5b5o30.rkt:30:4\nactual:     4\nexpected:   -4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmphx5b5o30.rkt:31:4\n\
    actual:     3\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (positive? x) 1 -1))) arr))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpf7iddw8z.rkt:21:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpf7iddw8z.rkt:23:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpf7iddw8z.rkt:24:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpf7iddw8z.rkt:25:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpf7iddw8z.rkt:26:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpf7iddw8z.rkt:27:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (positive? x) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpseu0xla5.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\
    \ (apply + (map abs arr)))\n  location...:\n   /tmp/tmpseu0xla5.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpb24tu9pb.rkt:26:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) (error \"Empty array\")]\n    [(empty? (rest\
    \ arr)) (abs (first arr))]\n    [else\n     (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (positive? x) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpd3xjows6.rkt:27:4\n\
    \nEmpty array\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n\
    \        (apply * signs)\n        (apply + magnitudes))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpugz2uab5.rkt:24:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpugz2uab5.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpugz2uab5.rkt:26:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpugz2uab5.rkt:30:4\nactual:     4\nexpected:   -4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpugz2uab5.rkt:31:4\n\
    actual:     3\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'none\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpkbxat2l_.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpkbxat2l_.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpkbxat2l_.rkt:26:4\nactual:     'none\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpkbxat2l_.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpkbxat2l_.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpkbxat2l_.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpbib0u6sa.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpbib0u6sa.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpbib0u6sa.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpbib0u6sa.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpbib0u6sa.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp1o0vfo50.rkt:26:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      (error \"empty arr\")\n      (let ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (< x 0) -1 1))) arr)])\n        (apply * (map\
    \ abs arr))\n        (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpgkvux_d9.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpgkvux_d9.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nERROR\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpgkvux_d9.rkt:26:4\n\nempty arr\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpgkvux_d9.rkt:27:4\n\
    actual:     1\nexpected:   20\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpgkvux_d9.rkt:28:4\nactual:     1\n\
    expected:   4\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpgkvux_d9.rkt:29:4\nactual:     -1\nexpected:\
    \   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([prod (apply * (map (lambda (x)\
    \ (if (zero? x) 0 (if (> x 0) 1 -1))) arr))])\n        (apply + (map (lambda (x)\
    \ (abs x)) arr))\n        (* prod (apply + (map (lambda (x) (abs x)) arr))))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp876dlr7k.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp876dlr7k.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp876dlr7k.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp876dlr7k.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp876dlr7k.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp876dlr7k.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (< x 0) -1 1))) arr)]\n             [magnitudes (map abs arr)])\n\
    \        (apply * signs)\n        (apply + magnitudes))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpa3p5aebz.rkt:24:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpa3p5aebz.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpa3p5aebz.rkt:26:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpa3p5aebz.rkt:27:4\nactual:     'None\nexpected:   #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpa3p5aebz.rkt:30:4\n\
    actual:     4\nexpected:   -4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpa3p5aebz.rkt:31:4\nactual:     3\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([sums (apply + (map abs arr))]\n\
    \            [prods (apply * (map signum arr))])\n        (* sums prods))))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp285x9rva.rkt:15:33: signum: unbound identifier\n  in: signum\n\
    \  location...:\n   /tmp/tmp285x9rva.rkt:15:33\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) 'None]\n        [else\n         (let ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply\
    \ * signs) (apply + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpwz5uym9m.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod\
    \ 1])\n        (if (null? arr)\n            (* sum prod)\n            (loop (cdr\
    \ arr) (+ sum (abs (car arr))) (* prod (signum (car arr))))))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp93ceq8ma.rkt:17:61: signum: unbound identifier\n  in: signum\n\
    \  location...:\n   /tmp/tmp93ceq8ma.rkt:17:61\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) #f]\n        [else\n         (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n           (* (apply * signs)\
    \ (apply + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpy3p643om.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpy3p643om.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpy3p643om.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpy3p643om.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpy3p643om.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [sign-prod (apply * signs)]\n\
    \             [magnitudes (map abs arr)])\n        (apply + (map * magnitudes\
    \ signs)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal?\
    \ (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1))\
    \ -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate\
    \ (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1))\
    \ 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp6bt8oe7z.rkt:24:4\n\
    actual:     1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp6bt8oe7z.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmp6bt8oe7z.rkt:26:4\nactual:     8\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp6bt8oe7z.rkt:27:4\nactual:     'None\nexpected:   #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp6bt8oe7z.rkt:28:4\n\
    actual:     16\nexpected:   20\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp6bt8oe7z.rkt:29:4\nactual:     0\n\
    expected:   4\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmp6bt8oe7z.rkt:30:4\nactual:     2\nexpected:\
    \   -4\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp6bt8oe7z.rkt:31:4\nactual:     1\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) 'None]\n        [else (apply * (map (lambda (x)\
    \ (cond [(positive? x) 1]\n                                              [(negative?\
    \ x) -1]\n                                              [else 0]))\n         \
    \                   arr))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpaz378u47.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpaz378u47.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpaz378u47.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpaz378u47.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpaz378u47.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpaz378u47.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply + (map abs\
    \ arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal?\
    \ (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1))\
    \ -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate\
    \ (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1))\
    \ 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [prod (apply * signs)]\n\
    \             [magnitudes (map abs arr)])\n        (apply + (map * magnitudes\
    \ signs)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal?\
    \ (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1))\
    \ -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate\
    \ (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1))\
    \ 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpkhu0nr32.rkt:24:4\n\
    actual:     1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpkhu0nr32.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpkhu0nr32.rkt:26:4\nactual:     8\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpkhu0nr32.rkt:27:4\nactual:     'None\nexpected:   #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpkhu0nr32.rkt:28:4\n\
    actual:     16\nexpected:   20\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpkhu0nr32.rkt:29:4\nactual:     0\n\
    expected:   4\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpkhu0nr32.rkt:30:4\nactual:     2\nexpected:\
    \   -4\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpkhu0nr32.rkt:31:4\nactual:     1\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([signs (map abs arr)])\n    \
    \    (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpfg7pvhaf.rkt:22:4\n\
    actual:     16\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpfg7pvhaf.rkt:24:4\nactual:     6\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpfg7pvhaf.rkt:26:4\nactual:     144\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpfg7pvhaf.rkt:27:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpfg7pvhaf.rkt:28:4\n\
    actual:     1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([sum (apply + (map abs arr))]\n\
    \            [prod (apply * (map sign arr))])\n        (* sum prod))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpuhy6btxp.rkt:15:32: sign: unbound identifier\n  in: sign\n  location...:\n\
    \   /tmp/tmpuhy6btxp.rkt:15:32\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n\
    \        (apply * signs)\n        (apply + magnitudes))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpjiwpwmcr.rkt:24:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpjiwpwmcr.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpjiwpwmcr.rkt:26:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpjiwpwmcr.rkt:27:4\nactual:     'None\nexpected:   #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpjiwpwmcr.rkt:30:4\n\
    actual:     4\nexpected:   -4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpjiwpwmcr.rkt:31:4\nactual:     3\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr)])\n       (* (apply * signs)\
    \ (apply + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod\
    \ 1])\n        (cond [(null? arr) (* sum prod)]\n              [(zero? (car arr))\
    \ (loop (cdr arr) sum prod)]\n              [(negative? (car arr)) (loop (cdr\
    \ arr) (+ sum (abs (car arr))) (* prod -1))]\n              [else (loop (cdr arr)\
    \ (+ sum (abs (car arr))) prod)]))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpocsek594.rkt:26:4\n\
    actual:     1\nexpected:   0\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpocsek594.rkt:28:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpocsek594.rkt:32:4\nactual:     -3\nexpected:\
    \   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let* ([magnitudes (map abs arr)]\n\
    \             [signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n\
    \             [magnitude-sum (apply + magnitudes)]\n             [sign-prod (apply\
    \ * signs)])\n        (* magnitude-sum sign-prod))))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpsigggqto.rkt:28:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) #f]\n        [else (apply * (map (lambda (x) (if\
    \ (zero? x) 0 (if (negative? x) -1 1))) arr))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate\
    \ (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal?\
    \ (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list ))\
    \ #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal?\
    \ (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1))\
    \ -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpmrqml_zz.rkt:20:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpmrqml_zz.rkt:22:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpmrqml_zz.rkt:24:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpmrqml_zz.rkt:25:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpmrqml_zz.rkt:26:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (=\
    \ x 0) 0 (if (> x 0) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp6cul25fq.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (= x 0) 0 (if (> x 0) 1 -1))) arr)) (apply\
    \ + (map abs arr)))\n  location...:\n   /tmp/tmp6cul25fq.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpmumdp2jj.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpmumdp2jj.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpmumdp2jj.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpmumdp2jj.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpmumdp2jj.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * signs)\n        (apply\
    \ + (map abs arr)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n \
    \ (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmppk3k6fcr.rkt:23:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmppk3k6fcr.rkt:24:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmppk3k6fcr.rkt:25:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmppk3k6fcr.rkt:26:4\nactual:     'None\nexpected:   #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmppk3k6fcr.rkt:29:4\n\
    actual:     4\nexpected:   -4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmppk3k6fcr.rkt:30:4\nactual:     3\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([sums (map abs arr)])\n  \
    \      (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\n\
    \        (apply + sums))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpr0io9okg.rkt:23:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpr0io9okg.rkt:24:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpr0io9okg.rkt:25:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpr0io9okg.rkt:26:4\nactual:     'None\nexpected:   #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpr0io9okg.rkt:29:4\n\
    actual:     4\nexpected:   -4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpr0io9okg.rkt:30:4\nactual:     3\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ((signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n        (* (apply * signs) (apply +\
    \ (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpyh1yncfr.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply +\
    \ (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp9andmg3u.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpprg7me70.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpprg7me70.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpprg7me70.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpprg7me70.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpprg7me70.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpprg7me70.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let loop ([arr arr] [prod 1] [sum\
    \ 0])\n        (if (null? arr)\n            (* prod sum)\n            (let ([x\
    \ (car arr)])\n              (cond\n                [(> x 0) (loop (cdr arr) (*\
    \ prod 1) (+ sum x))]\n                [(< x 0) (loop (cdr arr) (* prod -1) (+\
    \ sum (- x)))]\n                [else (loop (cdr arr) prod sum)]))))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpctsl2hr1.rkt:29:4\n\
    actual:     1\nexpected:   0\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpctsl2hr1.rkt:31:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpctsl2hr1.rkt:35:4\nactual:     -3\nexpected:\
    \   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (positive? x) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpzdkhfc03.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\
    \ (apply + (map abs arr)))\n  location...:\n   /tmp/tmpzdkhfc03.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) 'None]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpk8kmbjqd.rkt:26:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ((signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n        (* (apply * signs) (apply +\
    \ (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp5eetmyl0.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (negative? x) -1 1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp94e1fr91.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (negative? x) -1 1))) arr))\
    \ (apply + (map abs arr)))\n  location...:\n   /tmp/tmp94e1fr91.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod\
    \ 1])\n        (if (null? arr)\n            (* sum prod)\n            (let* ([x\
    \ (car arr)]\n                   [sign (if (zero? x) 0 (if (positive? x) 1 -1))])\n\
    \              (loop (cdr arr) (+ sum (abs x)) (* prod sign)))))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpb1gnpbyc.rkt:29:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'none\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (positive? x) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpk0zih5kh.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ none) (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\
    \ (apply + (map abs arr)))\n  location...:\n   /tmp/tmpk0zih5kh.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpg4tketn9.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpg4tketn9.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpg4tketn9.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpg4tketn9.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpg4tketn9.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpg4tketn9.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map sign\
    \ arr)])\n       (apply * (map abs arr))\n       (apply * signs))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp5nrg5eqa.rkt:15:23: sign: unbound identifier\n  in: sign\n  location...:\n\
    \   /tmp/tmp5nrg5eqa.rkt:15:23\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (positive? x) 1 -1))) arr))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp3b6vw8gk.rkt:21:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp3b6vw8gk.rkt:23:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp3b6vw8gk.rkt:24:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp3b6vw8gk.rkt:25:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp3b6vw8gk.rkt:26:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp3b6vw8gk.rkt:27:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpqcr3ns7s.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpqcr3ns7s.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpqcr3ns7s.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpqcr3ns7s.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpqcr3ns7s.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpqcr3ns7s.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (* (apply * (map sign arr))\n  \
    \       (apply + (map abs arr)))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpg4bqfw7u.rkt:14:23: sign: unbound identifier\n  in: sign\n  location...:\n\
    \   /tmp/tmpg4bqfw7u.rkt:14:23\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let loop ([arr arr] [acc 0])\n\
    \        (if (null? arr)\n            acc\n            (loop (cdr arr) (+ (* (abs\
    \ (car arr)) (signum (car arr))) acc))))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpqdcu86sf.rkt:17:51: signum: unbound identifier\n  in: signum\n\
    \  location...:\n   /tmp/tmpqdcu86sf.rkt:17:51\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod\
    \ 1])\n        (cond [(null? arr) (* sum prod)]\n              [(zero? (car arr))\
    \ (loop (cdr arr) sum prod)]\n              [(negative? (car arr)) (loop (cdr\
    \ arr) (+ sum (abs (car arr))) (* prod -1))]\n              [else (loop (cdr arr)\
    \ (+ sum (abs (car arr))) prod)]))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpwf81ifde.rkt:26:4\n\
    actual:     1\nexpected:   0\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpwf81ifde.rkt:28:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpwf81ifde.rkt:32:4\nactual:     -3\nexpected:\
    \   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n\
    \        (apply * signs)\n        (apply + magnitudes))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpgelp81jv.rkt:24:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpgelp81jv.rkt:25:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpgelp81jv.rkt:26:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpgelp81jv.rkt:30:4\nactual:     4\nexpected:   -4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpgelp81jv.rkt:31:4\n\
    actual:     3\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply +\
    \ (map abs arr))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpta6d99r1.rkt:25:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (* (apply * (map sign arr))\n  \
    \       (apply + (map abs arr)))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpvs70cjbm.rkt:14:23: sign: unbound identifier\n  in: sign\n  location...:\n\
    \   /tmp/tmpvs70cjbm.rkt:14:23\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzhh0du4r.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpzhh0du4r.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpzhh0du4r.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpzhh0du4r.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpzhh0du4r.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzhh0du4r.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (define (sign x)\n    (cond\n      [(> x 0) 1]\n      [(< x 0) -1]\n\
    \      [else 0]))\n  (define (magnitude x)\n    (abs x))\n  (define (prod-signs-helper\
    \ arr)\n    (if (null? arr)\n        1\n        (* (sign (car arr)) (prod-signs-helper\
    \ (cdr arr)))))\n  (define (magnitude-sum arr)\n    (if (null? arr)\n        0\n\
    \        (+ (magnitude (car arr)) (magnitude-sum (cdr arr)))))\n  (if (null? arr)\n\
    \      'None\n      (* (prod-signs-helper arr) (magnitude-sum arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpniif78z5.rkt:39:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) #f]\n    [else\n     (define signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr))\n     (define magnitudes (map\
    \ abs arr))\n     (apply * signs)\n     (* (apply * signs) (apply + magnitudes))]))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) (error \"empty array\")]\n    [(empty? (rest\
    \ arr)) (if (zero? (first arr)) 0 (first arr))]\n    [else\n     (let* ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (negative? x) -1 1))) arr)]\n         \
    \   [prod (apply * signs)]\n            [magnitudes (map abs arr)])\n       (apply\
    \ + (map * magnitudes signs)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpinmnqi52.rkt:26:4\n\
    actual:     1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpinmnqi52.rkt:27:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpinmnqi52.rkt:28:4\nactual:     8\nexpected:\
    \   -10\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpinmnqi52.rkt:29:4\n\nempty array\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpinmnqi52.rkt:30:4\nactual:\
    \     16\nexpected:   20\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpinmnqi52.rkt:31:4\nactual:     0\n\
    expected:   4\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpinmnqi52.rkt:32:4\nactual:     2\nexpected:\
    \   -4\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpinmnqi52.rkt:33:4\nactual:     1\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpt_tyivfu.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpt_tyivfu.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpt_tyivfu.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpt_tyivfu.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpt_tyivfu.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([magnitudes (map abs arr)])\n\
    \        (apply * (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr))\n\
    \        (apply + magnitudes))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpnlcn6awi.rkt:23:4\n\
    actual:     9\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpnlcn6awi.rkt:24:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmpnlcn6awi.rkt:25:4\nactual:     10\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpnlcn6awi.rkt:29:4\nactual:     4\nexpected:   -4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpnlcn6awi.rkt:30:4\n\
    actual:     3\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (apply * (map (lambda (x) (if (=\
    \ x 0) 0 (if (> x 0) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp1roics47.rkt:12:2: if: bad syntax\n  in: (if (null? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (= x 0) 0 (if (> x 0) 1 -1))) arr)) (apply\
    \ + (map abs arr)))\n  location...:\n   /tmp/tmp1roics47.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpm3bxbuiq.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpm3bxbuiq.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpm3bxbuiq.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpm3bxbuiq.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpm3bxbuiq.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond [(empty? arr) 'None]\n        [else\n         (apply *\n     \
    \           (map (lambda (x)\n                       (cond [(zero? x) 0]\n   \
    \                          [(negative? x) -1]\n                             [else\
    \ 1]))\n                     arr))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2\
    \ 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpdthjwc_k.rkt:26:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpdthjwc_k.rkt:28:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpdthjwc_k.rkt:29:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpdthjwc_k.rkt:30:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpdthjwc_k.rkt:31:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpdthjwc_k.rkt:32:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (empty? arr)\n      'None\n      (apply * (map (lambda (x) (if (zero?\
    \ x) 0 (if (positive? x) 1 -1))) arr))\n      (apply + (map abs arr))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
    \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
    \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n \
    \   (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list\
    \ 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n \
    \   (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate\
    \ (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpj_euln_x.rkt:12:2: if: bad syntax\n  in: (if (empty? arr) (quote\
    \ None) (apply * (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr))\
    \ (apply + (map abs arr)))\n  location...:\n   /tmp/tmpj_euln_x.rkt:12:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let loop ([arr arr] [sum 0] [prod\
    \ 1])\n        (if (null? arr)\n            (* sum prod)\n            (let ([x\
    \ (car arr)])\n              (cond\n                [(> x 0) (loop (cdr arr) (+\
    \ sum x) prod)]\n                [(< x 0) (loop (cdr arr) sum (* prod -1))]\n\
    \                [else (loop (cdr arr) sum prod)]))))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmppt9trknf.rkt:28:4\n\
    actual:     -5\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmppt9trknf.rkt:29:4\nactual:     1\n\
    expected:   0\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmppt9trknf.rkt:30:4\nactual:     -9\nexpected:\
    \   -10\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmppt9trknf.rkt:31:4\nactual:     'None\nexpected:   #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmppt9trknf.rkt:32:4\n\
    actual:     18\nexpected:   20\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmppt9trknf.rkt:33:4\nactual:     2\n\
    expected:   4\n--------------------\n--------------------\nFAILURE\nname:    \
    \   check-equal?\nlocation:   /tmp/tmppt9trknf.rkt:34:4\nactual:     -3\nexpected:\
    \   -4\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmppt9trknf.rkt:35:4\nactual:     -2\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) (error \"empty arr\")]\n    [(= 1 (length arr))\
    \ (abs (first arr))]\n    [else\n     (* (abs (first arr))\n        (prod_signs\
    \ (rest arr)))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp2yr0qyht.rkt:24:4\n\
    actual:     16\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp2yr0qyht.rkt:26:4\nactual:     6\n\
    expected:   -10\n--------------------\n--------------------\nERROR\nname:    \
    \   check-equal?\nlocation:   /tmp/tmp2yr0qyht.rkt:27:4\n\nempty arr\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp2yr0qyht.rkt:28:4\n\
    actual:     144\nexpected:   20\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp2yr0qyht.rkt:29:4\nactual:\
    \     1\nexpected:   4\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp2yr0qyht.rkt:30:4\nactual:     1\n\
    expected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let* ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)])\n\
    \        (* (apply * signs) (apply + magnitudes)))))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate prod_signs))\n    (check-equal?\
    \ (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate (list 0 1)) 0)\n\
    \    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate\
    \ (list )) #f)\n    (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n   \
    \ (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal? (candidate\
    \ (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpdpigfruf.rkt:26:4\n\
    actual:     'None\nexpected:   #f\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmplpsxod_t.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmplpsxod_t.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmplpsxod_t.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmplpsxod_t.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmplpsxod_t.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmplpsxod_t.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ([signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp9p98uagq.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp9p98uagq.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp9p98uagq.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp9p98uagq.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp9p98uagq.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp9p98uagq.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) 'None]\n    [else\n     (apply *\n        \
    \    (map (lambda (x) (cond [(> x 0) 1] [(< x 0) -1] [else 0]))\n            \
    \     arr))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmptri0o8cv.rkt:24:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmptri0o8cv.rkt:26:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmptri0o8cv.rkt:27:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmptri0o8cv.rkt:28:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmptri0o8cv.rkt:29:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmptri0o8cv.rkt:30:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (cond\n    [(empty? arr) #f]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n       (* (apply * signs) (apply\
    \ + (map abs arr))))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4)) -9)\n\
    \    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate (list\
    \ 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
    \ (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1\
    \ 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n    (check-equal?\
    \ (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpydivv7p2.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpydivv7p2.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpydivv7p2.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpydivv7p2.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpydivv7p2.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given an array arr of integers and you need\
    \ to return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
    ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
    \ for empty arr.\n;; Example:\n;; >>> prod_signs([1, 2, 2, -4]) == -9\n;; >>>\
    \ prod_signs([0, 1]) == 0\n;; >>> prod_signs([]) == None\n(define (prod_signs\
    \ arr)\n  (if (null? arr)\n      'None\n      (let ((signs (map (lambda (x) (if\
    \ (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n        (apply * (map abs arr))\n  \
    \      (apply * signs))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate prod_signs))\n    (check-equal? (candidate (list 1 2 2 -4))\
    \ -9)\n    (check-equal? (candidate (list 0 1)) 0)\n    (check-equal? (candidate\
    \ (list 1 1 1 2 3 -1 1)) -10)\n    (check-equal? (candidate (list )) #f)\n   \
    \ (check-equal? (candidate (list 2 4 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate\
    \ (list -1 1 -1 1)) 4)\n    (check-equal? (candidate (list -1 1 1 1)) -4)\n  \
    \  (check-equal? (candidate (list -1 1 1 0)) 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpu8ioddwb.rkt:23:4\n\
    actual:     -1\nexpected:   -9\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpu8ioddwb.rkt:25:4\nactual:     -1\n\
    expected:   -10\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpu8ioddwb.rkt:26:4\nactual:     'None\n\
    expected:   #f\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpu8ioddwb.rkt:27:4\nactual:     1\nexpected:\
    \   20\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpu8ioddwb.rkt:28:4\nactual:     1\nexpected:   4\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpu8ioddwb.rkt:29:4\n\
    actual:     -1\nexpected:   -4\n--------------------\n"
  exit_code: 0
  status: Exception
