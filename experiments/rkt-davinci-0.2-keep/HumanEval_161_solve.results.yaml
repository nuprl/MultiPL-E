name: HumanEval_161_solve
language: racket
results:
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp283951yh.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp283951yh.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n</code>\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpc7sz8pjx.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpc7sz8pjx.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpilyebm0j.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpilyebm0j.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpfbqmm1am.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpfbqmm1am.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-ci? s #\\a)\n      (string-map (lambda (c)\n         \
    \           (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpsbhk3t85.rkt:13:7: string-contains-ci?: unbound identifier\n  in:\
    \ string-contains-ci?\n  location...:\n   /tmp/tmpsbhk3t85.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0)) (string-append\
    \ (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n    [(char-numeric?\
    \ (string-ref s 0)) (string-append (string-ref s 0) (solve (substring s 1)))]\n\
    \    [else (string-append (string-downcase (string-ref s 0)) (solve (substring\
    \ s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyn446sg2.rkt:24:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyn446sg2.rkt:25:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpyn446sg2.rkt:26:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpyn446sg2.rkt:27:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyn446sg2.rkt:28:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyn446sg2.rkt:29:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyn446sg2.rkt:30:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyn446sg2.rkt:31:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-upcase (string-ref s 0))\n      (solve (substring\
    \ s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append\n      (string-ref\
    \ s 0)\n      (solve (substring s 1)))]\n    [else\n     (string-append\n    \
    \  (string-downcase (string-ref s 0))\n      (solve (substring s 1)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprx29m096.rkt:33:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprx29m096.rkt:34:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprx29m096.rkt:35:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprx29m096.rkt:36:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprx29m096.rkt:37:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprx29m096.rkt:38:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprx29m096.rkt:39:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprx29m096.rkt:40:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n\
    \    [(char-numeric? (string-ref s 0))\n     (string-append (string-ref s 0) (solve\
    \ (substring s 1)))]\n    [else (string-append (string-downcase (string-ref s\
    \ 0)) (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwf8duo_x.rkt:26:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwf8duo_x.rkt:27:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwf8duo_x.rkt:28:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwf8duo_x.rkt:29:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwf8duo_x.rkt:30:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwf8duo_x.rkt:31:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwf8duo_x.rkt:32:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwf8duo_x.rkt:33:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map\n       (lambda (c)\n    \
    \     (if (char-alphabetic? c)\n             (char-upcase c)\n             (char-downcase\
    \ c)))\n       s)\n      (string-reverse s)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal? (candidate\
    \ \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal?\
    \ (candidate \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\"\
    )\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal?\
    \ (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\"\
    )\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp2t9covmr.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp2t9covmr.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-ci? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c)\n                                  (char-upcase c)\n                    \
    \              (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp3jwb4k9b.rkt:13:7: string-contains-ci?: unbound identifier\n  in:\
    \ string-contains-ci?\n  location...:\n   /tmp/tmp3jwb4k9b.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-empty? s)\n      s\n      (string-append (if (char-alphabetic?\
    \ (string-ref s 0))\n                         (if (char-lower-case? (string-ref\
    \ s 0))\n                             (string-upcase (string-ref s 0))\n     \
    \                        (string-downcase (string-ref s 0)))\n               \
    \          (string-ref s 0))\n                     (solve (substring s 1)))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpcptp_0ml.rkt:13:7: string-empty?: unbound identifier\n  in: string-empty?\n\
    \  location...:\n   /tmp/tmpcptp_0ml.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n\
    \    [(char-numeric? (string-ref s 0))\n     (string-append (string-ref s 0) (solve\
    \ (substring s 1)))]\n    [else\n     (string-append (string-downcase (string-ref\
    \ s 0)) (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnn5fddlp.rkt:27:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnn5fddlp.rkt:28:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpnn5fddlp.rkt:29:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpnn5fddlp.rkt:30:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnn5fddlp.rkt:31:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnn5fddlp.rkt:32:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnn5fddlp.rkt:33:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnn5fddlp.rkt:34:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-append\n       (string-append\n        (string-append\n\
    \         (string-append\n          (string-append\n           (string-append\n\
    \            (string-append\n             (string-append\n              (string-append\n\
    \               (string-append\n                (string-append\n             \
    \    (string-append\n                  (string-append\n                   (string-append\n\
    \                    (string-append\n                     (string-append\n   \
    \                   (string-append\n                       (string-append\n  \
    \                      (string-append\n                         (string-append\n\
    \                          (string-append\n                           (string-append\n\
    \                            (string-append\n                             (string-append\n\
    \                              (string-append\n                              \
    \ (string-append\n                                (string-append\n           \
    \                      (string-append\n                                  (string-append\n\
    \                                   (string-append\n                         \
    \           (string-append\n                                     (string-append\n\
    \                                      (string-append\n                      \
    \                 (string-append\n                                        (string-append\n\
    \                                         (string-append\n                   \
    \                       (string-append\n                                     \
    \      (string-append\n                                            (string-append\n\
    \                                             (string-append\n               \
    \                               (string-append\n                             \
    \                  (string-append\n                                          \
    \      (string-append\n                                                 (string-append\n\
    \                                                  (string-append\n          \
    \                                         (string-append\n                   \
    \                                 (string-append\n                           \
    \                          (string-append\n                                  \
    \                    (string-append\n                                        \
    \               (string-append\n                                             \
    \           (string-append\n                                                 \
    \        (string-append\n                                                    \
    \      (string-append\n                                                      \
    \     (string-append\n                                                       \
    \     (string-append\n                                                       \
    \      (string-append\n                                                      \
    \        (string-append\n                                                    \
    \           (string-append\n                                                 \
    \               (string-append\n                                             \
    \                    (string-append\n                                        \
    \                          (string-append\n                                  \
    \                                 (string-append\n                           \
    \                                         (string-append\n                   \
    \                                                  (string-append\n          \
    \                                                            (string-append\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpncdt71jb.rkt:81:70: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 83\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp9kmmzxaw.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp9kmmzxaw.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (x) (if (char-alphabetic?\
    \ x) (char-downcase x) (char-upcase x))) s)\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpyhu319y3.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpyhu319y3.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp6ktbnz7r.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp6ktbnz7r.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n\
    \    [(char-numeric? (string-ref s 0))\n     (string-append (string-ref s 0) (solve\
    \ (substring s 1)))]\n    [else\n     (string-append (string-downcase (string-ref\
    \ s 0)) (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbixkzhjw.rkt:27:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbixkzhjw.rkt:28:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbixkzhjw.rkt:29:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbixkzhjw.rkt:30:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbixkzhjw.rkt:31:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbixkzhjw.rkt:32:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbixkzhjw.rkt:33:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbixkzhjw.rkt:34:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) s]\n    [(char-alphabetic? (string-ref s 0))\n     (string-append\
    \ (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n    [(char-numeric?\
    \ (string-ref s 0))\n     (string-append (string-ref s 0) (solve (substring s\
    \ 1)))]\n    [else\n     (string-append (string-downcase (string-ref s 0)) (solve\
    \ (substring s 1)))]))\n</code>\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp9q8co_7b.rkt:21:0: </code>: unbound identifier\n  in: </code>\n\
    \  location...:\n   /tmp/tmp9q8co_7b.rkt:21:0\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp0j61vu3i.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp0j61vu3i.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c) (char-upcase c) (char-downcase c))) s)\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpnuc0cs5n.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpnuc0cs5n.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-empty? s)\n      \"\"\n      (let* ([c (string-ref s 0)]\n    \
    \         [c (if (char-alphabetic? c)\n                    (if (char-lower-case?\
    \ c)\n                        (char-upcase c)\n                        (char-downcase\
    \ c))\n                    c)])\n        (string-append (string c) (solve (substring\
    \ s 1))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp1xbp028a.rkt:13:7: string-empty?: unbound identifier\n  in: string-empty?\n\
    \  location...:\n   /tmp/tmp1xbp028a.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-empty? s)\n      \"\"\n      (string-append (solve (substring s\
    \ 1))\n                     (if (char-alphabetic? (string-ref s 0))\n        \
    \                 (if (char-lower-case? (string-ref s 0))\n                  \
    \           (string-upcase (string-ref s 0))\n                             (string-downcase\
    \ (string-ref s 0)))\n                         (string-ref s 0)))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpulpyfp0t.rkt:13:7: string-empty?: unbound identifier\n  in: string-empty?\n\
    \  location...:\n   /tmp/tmpulpyfp0t.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpelbpi15q.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpelbpi15q.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n\
    \    [(char-numeric? (string-ref s 0))\n     (string-append (string-ref s 0) (solve\
    \ (substring s 1)))]\n    [else\n     (string-append (string-downcase (string-ref\
    \ s 0)) (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwf9inire.rkt:27:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwf9inire.rkt:28:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwf9inire.rkt:29:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwf9inire.rkt:30:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwf9inire.rkt:31:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwf9inire.rkt:32:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwf9inire.rkt:33:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwf9inire.rkt:34:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpgxv3dph9.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpgxv3dph9.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (define (is-letter? c)\n    (and (char-alphabetic? c)\n         (not (char-numeric?\
    \ c))))\n  (define (reverse-case c)\n    (if (char-lower-case? c)\n        (char-upcase\
    \ c)\n        (char-downcase c)))\n  (define (reverse-string s)\n    (string-append\
    \ (reverse (string->list s))))\n  (define (reverse-case-string s)\n    (string-append\
    \ (map reverse-case (string->list s))))\n  (define (has-letters? s)\n    (for/or\
    \ ([c (in-string s)])\n      (is-letter? c)))\n  (cond\n    [(has-letters? s)\
    \ (reverse-case-string s)]\n    [else (reverse-string s)]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpztcrg5yd.rkt:36:4\n\
    \nstring-append: contract violation\n  expected: string?\n  given: '(#\\a #\\\
    S #\\d #\\F)\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpztcrg5yd.rkt:37:4\n\nstring-append: contract violation\n \
    \ expected: string?\n  given: '(#\\4 #\\3 #\\2 #\\1)\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpztcrg5yd.rkt:38:4\n\nstring-append:\
    \ contract violation\n  expected: string?\n  given: '(#\\A #\\B)\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpztcrg5yd.rkt:39:4\n\
    \nstring-append: contract violation\n  expected: string?\n  given: '(#\\# #\\\
    A #\\@ #\\c)\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpztcrg5yd.rkt:40:4\n\nstring-append: contract violation\n \
    \ expected: string?\n  given: '(#\\# #\\a #\\S #\\D #\\F #\\w #\\^ #\\4 #\\5)\n\
    --------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpztcrg5yd.rkt:41:4\n\nstring-append: contract violation\n \
    \ expected: string?\n  given: '(#\\2 #\\@ #\\6 #\\#)\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpztcrg5yd.rkt:42:4\n\nstring-append:\
    \ contract violation\n  expected: string?\n  given: '(#\\# #\\$ #\\A #\\^ #\\\
    d)\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpztcrg5yd.rkt:43:4\n\nstring-append: contract violation\n \
    \ expected: string?\n  given: '(#\\# #\\C #\\C #\\C)\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmppluu9bkm.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmppluu9bkm.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (string-join\n   (reverse\n    (map\n     (lambda (c)\n       (if (char-alphabetic?\
    \ c)\n           (if (char-lower-case? c)\n               (char-upcase c)\n  \
    \             (char-downcase c))\n           c))\n     (string->list s)))))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6c0mazz9.rkt:29:4\n\
    \nstring-join: contract violation\n  expected: (listof string?)\n  given: '(#\\\
    F #\\d #\\S #\\a)\n--------------------\n--------------------\nERROR\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp6c0mazz9.rkt:30:4\n\nstring-join: contract\
    \ violation\n  expected: (listof string?)\n  given: '(#\\4 #\\3 #\\2 #\\1)\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6c0mazz9.rkt:31:4\n\
    \nstring-join: contract violation\n  expected: (listof string?)\n  given: '(#\\\
    B #\\A)\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6c0mazz9.rkt:32:4\n\nstring-join: contract violation\n  expected:\
    \ (listof string?)\n  given: '(#\\c #\\@ #\\A #\\#)\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6c0mazz9.rkt:33:4\n\nstring-join:\
    \ contract violation\n  expected: (listof string?)\n  given: '(#\\5 #\\4 #\\^\
    \ #\\w #\\F #\\D #\\S #\\a #\\#)\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6c0mazz9.rkt:34:4\n\nstring-join:\
    \ contract violation\n  expected: (listof string?)\n  given: '(#\\2 #\\@ #\\6\
    \ #\\#)\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6c0mazz9.rkt:35:4\n\nstring-join: contract violation\n  expected:\
    \ (listof string?)\n  given: '(#\\d #\\^ #\\A #\\$ #\\#)\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6c0mazz9.rkt:36:4\n\
    \nstring-join: contract violation\n  expected: (listof string?)\n  given: '(#\\\
    C #\\C #\\C #\\#)\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (first s))\n     (string-append\n\
    \      (if (char-lower-case? (first s))\n          (string-upcase (string (first\
    \ s)))\n          (string-downcase (string (first s))))\n      (solve (rest s)))]\n\
    \    [else\n     (string-append (string (first s)) (solve (rest s)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb0g0h_zh.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"AsDf\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb0g0h_zh.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"1234\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb0g0h_zh.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ab\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb0g0h_zh.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#a@C\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb0g0h_zh.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#AsdfW^45\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb0g0h_zh.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#6@2\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb0g0h_zh.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#$a^D\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb0g0h_zh.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#ccc\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append (string-downcase (string-ref s 0)) (solve (substring s 1)))]\n\
    \    [(char-numeric? (string-ref s 0))\n     (string-append (string-ref s 0) (solve\
    \ (substring s 1)))]\n    [else (string-append (string-upcase (string-ref s 0))\
    \ (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpz5sdqynf.rkt:26:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpz5sdqynf.rkt:27:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpz5sdqynf.rkt:28:4\n\nstring-downcase: contract violation\n\
    \  expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpz5sdqynf.rkt:29:4\n\nstring-upcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpz5sdqynf.rkt:30:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpz5sdqynf.rkt:31:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpz5sdqynf.rkt:32:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpz5sdqynf.rkt:33:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (string-join\n   (reverse\n    (map\n     (lambda (c)\n       (if (char-alphabetic?\
    \ c)\n           (if (char-lower-case? c)\n               (char-upcase c)\n  \
    \             (char-downcase c))\n           c))\n     (string->list s)))))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpy4xovbj4.rkt:29:4\n\
    \nstring-join: contract violation\n  expected: (listof string?)\n  given: '(#\\\
    F #\\d #\\S #\\a)\n--------------------\n--------------------\nERROR\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpy4xovbj4.rkt:30:4\n\nstring-join: contract\
    \ violation\n  expected: (listof string?)\n  given: '(#\\4 #\\3 #\\2 #\\1)\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpy4xovbj4.rkt:31:4\n\
    \nstring-join: contract violation\n  expected: (listof string?)\n  given: '(#\\\
    B #\\A)\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpy4xovbj4.rkt:32:4\n\nstring-join: contract violation\n  expected:\
    \ (listof string?)\n  given: '(#\\c #\\@ #\\A #\\#)\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpy4xovbj4.rkt:33:4\n\nstring-join:\
    \ contract violation\n  expected: (listof string?)\n  given: '(#\\5 #\\4 #\\^\
    \ #\\w #\\F #\\D #\\S #\\a #\\#)\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpy4xovbj4.rkt:34:4\n\nstring-join:\
    \ contract violation\n  expected: (listof string?)\n  given: '(#\\2 #\\@ #\\6\
    \ #\\#)\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpy4xovbj4.rkt:35:4\n\nstring-join: contract violation\n  expected:\
    \ (listof string?)\n  given: '(#\\d #\\^ #\\A #\\$ #\\#)\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpy4xovbj4.rkt:36:4\n\
    \nstring-join: contract violation\n  expected: (listof string?)\n  given: '(#\\\
    C #\\C #\\C #\\#)\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp1cq0b68j.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp1cq0b68j.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-append\n       (string (char-downcase (string-ref\
    \ s 0)))\n       (substring s 1 (sub1 (string-length s))))\n      (solve (substring\
    \ s 1 (sub1 (string-length s)))))]\n    [else\n     (string-append\n      (string\
    \ (char-upcase (string-ref s 0)))\n      (substring s 1 (sub1 (string-length s))))]))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_hc_df26.rkt:31:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmp_hc_df26.rkt:32:4\nactual:     \"123\"\nexpected:   \"4321\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_hc_df26.rkt:33:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_hc_df26.rkt:34:4\nactual:\
    \     \"#a@\"\nexpected:   \"#A@c\"\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_hc_df26.rkt:35:4\nactual:\
    \     \"#AsdfW^4\"\nexpected:   \"#aSDFw^45\"\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_hc_df26.rkt:36:4\nactual:\
    \     \"#6@\"\nexpected:   \"2@6#\"\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_hc_df26.rkt:37:4\nactual:\
    \     \"#$a^\"\nexpected:   \"#$A^d\"\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_hc_df26.rkt:38:4\nactual:\
    \     \"#cc\"\nexpected:   \"#CCC\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-append\n       (string (char-upcase (string-ref\
    \ s 0)))\n       (solve (substring s 1)))\n      (string (char-downcase (string-ref\
    \ s 0))))]\n    [else (string-append (string-ref s 0) (solve (substring s 1)))]))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmbuyhlh6.rkt:28:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpmbuyhlh6.rkt:29:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpmbuyhlh6.rkt:30:4\n\nstring-ref:\
    \ index is out of range for empty string\n  index: 0\n  string: \"\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmbuyhlh6.rkt:31:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpmbuyhlh6.rkt:32:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpmbuyhlh6.rkt:33:4\n\nstring-ref:\
    \ index is out of range for empty string\n  index: 0\n  string: \"\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmbuyhlh6.rkt:34:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpmbuyhlh6.rkt:35:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n\
    \    [(char-numeric? (string-ref s 0))\n     (string-append (string-ref s 0) (solve\
    \ (substring s 1)))]\n    [else\n     (string-append (string-downcase (string-ref\
    \ s 0)) (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1j95p9wy.rkt:27:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1j95p9wy.rkt:28:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp1j95p9wy.rkt:29:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp1j95p9wy.rkt:30:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1j95p9wy.rkt:31:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1j95p9wy.rkt:32:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1j95p9wy.rkt:33:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1j95p9wy.rkt:34:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-empty? s)\n      \"\"\n      (string-append (solve (substring s\
    \ 1))\n                     (if (char-alphabetic? (string-ref s 0))\n        \
    \                 (if (char-lower-case? (string-ref s 0))\n                  \
    \           (string-upcase (string-ref s 0))\n                             (string-downcase\
    \ (string-ref s 0)))\n                         (string-ref s 0)))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmphz_15byv.rkt:13:7: string-empty?: unbound identifier\n  in: string-empty?\n\
    \  location...:\n   /tmp/tmphz_15byv.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) s]\n    [(char-alphabetic? (string-ref s 0))\n     (string-append\
    \ (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n    [(char-numeric?\
    \ (string-ref s 0))\n     (string-append (string-ref s 0) (solve (substring s\
    \ 1)))]\n    [else\n     (string-append (string-downcase (string-ref s 0)) (solve\
    \ (substring s 1)))]))\n</code>\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpc_ar6s3_.rkt:21:0: </code>: unbound identifier\n  in: </code>\n\
    \  location...:\n   /tmp/tmpc_ar6s3_.rkt:21:0\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c)\n                                  (char-upcase c)\n                    \
    \              (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpfke96xhk.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpfke96xhk.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp3ttqov3n.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp3ttqov3n.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-downcase c)\n\
    \                        (char-upcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpmderj2in.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpmderj2in.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp03xvy82v.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp03xvy82v.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-empty? s)\n      s\n      (string-append (string-reverse (string-map\
    \ (lambda (c)\n                                                   (if (char-alphabetic?\
    \ c)\n                                                       (if (char-lower-case?\
    \ c)\n                                                           (char-upcase\
    \ c)\n                                                           (char-downcase\
    \ c))\n                                                       c))\n          \
    \                                       s))\n                     (solve (substring\
    \ s 1)))))\n</code>\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n   \
    \ (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"\
    ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp2ayvp4o5.rkt:13:7: string-empty?: unbound identifier\n  in: string-empty?\n\
    \  location...:\n   /tmp/tmp2ayvp4o5.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-ci? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c) (char-upcase c) (char-downcase c))) s)\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpv5rzpuzo.rkt:13:7: string-contains-ci?: unbound identifier\n  in:\
    \ string-contains-ci?\n  location...:\n   /tmp/tmpv5rzpuzo.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (first s))\n     (string-append\n\
    \      (if (char-lower-case? (first s))\n          (string-upcase (string (first\
    \ s)))\n          (string-downcase (string (first s))))\n      (solve (rest s)))]\n\
    \    [else\n     (string-append (string (first s)) (solve (rest s)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv5qczt7d.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"AsDf\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpv5qczt7d.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"1234\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpv5qczt7d.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ab\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpv5qczt7d.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#a@C\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpv5qczt7d.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#AsdfW^45\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpv5qczt7d.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#6@2\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpv5qczt7d.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#$a^D\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpv5qczt7d.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#ccc\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append (string-downcase (string-ref s 0)) (solve (substring s 1)))]\n\
    \    [(char-numeric? (string-ref s 0))\n     (string-append (string-ref s 0) (solve\
    \ (substring s 1)))]\n    [else\n     (string-append (string-upcase (string-ref\
    \ s 0)) (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7gm2s2kd.rkt:27:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7gm2s2kd.rkt:28:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7gm2s2kd.rkt:29:4\n\nstring-downcase: contract violation\n\
    \  expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7gm2s2kd.rkt:30:4\n\nstring-upcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7gm2s2kd.rkt:31:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7gm2s2kd.rkt:32:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7gm2s2kd.rkt:33:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7gm2s2kd.rkt:34:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpu04_9dh2.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpu04_9dh2.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (first s))\n     (string-append\n\
    \      (string-upcase (first s))\n      (solve (rest s)))]\n    [(char-numeric?\
    \ (first s))\n     (string-append\n      (string (first s))\n      (solve (rest\
    \ s)))]\n    [else\n     (string-append\n      (string-downcase (first s))\n \
    \     (solve (rest s)))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcw_hc0zo.rkt:33:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"AsDf\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpcw_hc0zo.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"1234\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpcw_hc0zo.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ab\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpcw_hc0zo.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#a@C\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpcw_hc0zo.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#AsdfW^45\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpcw_hc0zo.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#6@2\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpcw_hc0zo.rkt:39:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#$a^D\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpcw_hc0zo.rkt:40:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#ccc\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpod7_3wez.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpod7_3wez.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-ci? s #\\a)\n      (for/fold ([res \"\"]\n           \
    \      [i (in-naturals)])\n          ([c (in-string s)])\n        (string-append\
    \ res (if (char-alphabetic? c)\n                               (char-upcase c)\n\
    \                               (char-downcase c))))\n      (string-reverse s)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpsxzu5l9b.rkt:13:7: string-contains-ci?: unbound identifier\n  in:\
    \ string-contains-ci?\n  location...:\n   /tmp/tmpsxzu5l9b.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpduu5l3ew.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpduu5l3ew.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpydzvln1j.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpydzvln1j.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append (string-upcase (string (string-ref s 0))) (solve (substring\
    \ s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append (string\
    \ (string-ref s 0)) (solve (substring s 1)))]\n    [else\n     (string-append\
    \ (string-downcase (string (string-ref s 0))) (solve (substring s 1)))]))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprjrhojlu.rkt:27:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprjrhojlu.rkt:28:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprjrhojlu.rkt:29:4\n\nstring-ref:\
    \ index is out of range for empty string\n  index: 0\n  string: \"\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprjrhojlu.rkt:30:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprjrhojlu.rkt:31:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprjrhojlu.rkt:32:4\n\nstring-ref:\
    \ index is out of range for empty string\n  index: 0\n  string: \"\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprjrhojlu.rkt:33:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprjrhojlu.rkt:34:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (first s))\n     (string-append\
    \ (string-upcase (first s)) (solve (rest s)))]\n    [(char-numeric? (first s))\n\
    \     (string-append (first s) (solve (rest s)))]\n    [else (string-append (string-downcase\
    \ (first s)) (solve (rest s)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph16pbvq6.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"AsDf\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph16pbvq6.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"1234\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph16pbvq6.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ab\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph16pbvq6.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#a@C\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph16pbvq6.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#AsdfW^45\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph16pbvq6.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#6@2\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph16pbvq6.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#$a^D\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph16pbvq6.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#ccc\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp7t2xv09o.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp7t2xv09o.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string (char-upcase (string-ref s 0)))\n      (solve\
    \ (substring s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append\n\
    \      (string (char-downcase (string-ref s 0)))\n      (solve (substring s 1)))]\n\
    \    [else\n     (string-append\n      (string (string-ref s 0))\n      (solve\
    \ (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpibmwdv7i.rkt:33:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpibmwdv7i.rkt:34:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpibmwdv7i.rkt:35:4\n\nstring-ref:\
    \ index is out of range for empty string\n  index: 0\n  string: \"\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpibmwdv7i.rkt:36:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpibmwdv7i.rkt:37:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpibmwdv7i.rkt:38:4\n\nstring-ref:\
    \ index is out of range for empty string\n  index: 0\n  string: \"\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpibmwdv7i.rkt:39:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpibmwdv7i.rkt:40:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (first s))\n     (string-append\n\
    \      (string (char-upcase (first s)))\n      (solve (rest s)))]\n    [(char-numeric?\
    \ (first s))\n     (string-append\n      (string (first s))\n      (solve (rest\
    \ s)))]\n    [else\n     (string-append\n      (string (char-downcase (first s)))\n\
    \      (solve (rest s)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpsriz9_bh.rkt:33:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"AsDf\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsriz9_bh.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"1234\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsriz9_bh.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ab\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsriz9_bh.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#a@C\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsriz9_bh.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#AsdfW^45\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsriz9_bh.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#6@2\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsriz9_bh.rkt:39:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#$a^D\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsriz9_bh.rkt:40:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#ccc\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c) (char-upcase c) (char-downcase c))) s)\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp524oxzu7.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp524oxzu7.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c)\n                                  (if (char-lower-case? c)\n           \
    \                           (char-upcase c)\n                                \
    \      (char-downcase c))\n                                  c)) s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp4pkqd3n0.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp4pkqd3n0.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-empty? s)\n      \"\"\n      (string-append (solve (substring s\
    \ 1))\n                     (if (char-alphabetic? (string-ref s 0))\n        \
    \                 (string-downcase (string-upcase (string-ref s 0)))\n       \
    \                  (string-ref s 0)))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpf288hgwt.rkt:13:7: string-empty?: unbound identifier\n  in: string-empty?\n\
    \  location...:\n   /tmp/tmpf288hgwt.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c)\n                                  (char-upcase c)\n                    \
    \              (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmppbtixz53.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmppbtixz53.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (first s))\n     (string-append\n\
    \      (string-upcase (first s))\n      (solve (rest s)))]\n    [(char-numeric?\
    \ (first s))\n     (string-append\n      (string (first s))\n      (solve (rest\
    \ s)))]\n    [else\n     (string-append\n      (string-downcase (first s))\n \
    \     (solve (rest s)))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpste8taf6.rkt:33:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"AsDf\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpste8taf6.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"1234\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpste8taf6.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ab\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpste8taf6.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#a@C\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpste8taf6.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#AsdfW^45\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpste8taf6.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#6@2\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpste8taf6.rkt:39:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#$a^D\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpste8taf6.rkt:40:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#ccc\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-ci? s #\\a)\n      (string-map (lambda (c)\n         \
    \           (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpk3hgw22g.rkt:13:7: string-contains-ci?: unbound identifier\n  in:\
    \ string-contains-ci?\n  location...:\n   /tmp/tmpk3hgw22g.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp7dgljluj.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp7dgljluj.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-ci? s #\\a)\n      (string-map (lambda (c)\n         \
    \           (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpzvt6oywq.rkt:13:7: string-contains-ci?: unbound identifier\n  in:\
    \ string-contains-ci?\n  location...:\n   /tmp/tmpzvt6oywq.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (x) (if (char-alphabetic?\
    \ x)\n                                  (char-downcase x)\n                  \
    \                (char-upcase x))) s)\n      (reverse s)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp9vpc8268.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp9vpc8268.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (string-reverse-case s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpgt08zrnr.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmpgt08zrnr.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n\
    \    [(char-numeric? (string-ref s 0))\n     (string-append (string-ref s 0) (solve\
    \ (substring s 1)))]\n    [else\n     (string-append (string-downcase (string-ref\
    \ s 0)) (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4e_pxooa.rkt:27:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4e_pxooa.rkt:28:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp4e_pxooa.rkt:29:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp4e_pxooa.rkt:30:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4e_pxooa.rkt:31:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4e_pxooa.rkt:32:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4e_pxooa.rkt:33:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4e_pxooa.rkt:34:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-append\n       (string-append\n        (string-append\n\
    \         (string-append\n          (string-append\n           (string-append\n\
    \            (string-append\n             (string-append\n              (string-append\n\
    \               (string-append\n                (string-append\n             \
    \    (string-append\n                  (string-append\n                   (string-append\n\
    \                    (string-append\n                     (string-append\n   \
    \                   (string-append\n                       (string-append\n  \
    \                      (string-append\n                         (string-append\n\
    \                          (string-append\n                           (string-append\n\
    \                            (string-append\n                             (string-append\n\
    \                              (string-append\n                              \
    \ (string-append\n                                (string-append\n           \
    \                      (string-append\n                                  (string-append\n\
    \                                   (string-append\n                         \
    \           (string-append\n                                     (string-append\n\
    \                                      (string-append\n                      \
    \                 (string-append\n                                        (string-append\n\
    \                                         (string-append\n                   \
    \                       (string-append\n                                     \
    \      (string-append\n                                            (string-append\n\
    \                                             (string-append\n               \
    \                               (string-append\n                             \
    \                  (string-append\n                                          \
    \      (string-append\n                                                 (string-append\n\
    \                                                  (string-append\n          \
    \                                         (string-append\n                   \
    \                                 (string-append\n                           \
    \                          (string-append\n                                  \
    \                    (string-append\n                                        \
    \               (string-append\n                                             \
    \           (string-append\n                                                 \
    \        (string-append\n                                                    \
    \      (string-append\n                                                      \
    \     (string-append\n                                                       \
    \     (string-append\n                                                       \
    \      (string-append\n                                                      \
    \        (string-append\n                                                    \
    \           (string-append\n                                                 \
    \               (string-append\n                                             \
    \                    (string-append\n                                        \
    \                          (string-append\n                                  \
    \                                 (string-append\n                           \
    \                                         (string-append\n                   \
    \                                                  (string-append\n          \
    \                                                            (string-append\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpjiukurih.rkt:81:70: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 83\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp_71cs02s.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp_71cs02s.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (reverse-case s)\n      (reverse s)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpc_d3u98x.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmpc_d3u98x.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) (string)]\n    [(char-alphabetic? (string-ref s 0))\n\
    \     (string-append\n      (string-upcase (string-ref s 0))\n      (solve (substring\
    \ s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append\n      (string-ref\
    \ s 0)\n      (solve (substring s 1)))]\n    [else\n     (string-append\n    \
    \  (string-downcase (string-ref s 0))\n      (solve (substring s 1)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk65y0t45.rkt:33:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk65y0t45.rkt:34:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpk65y0t45.rkt:35:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpk65y0t45.rkt:36:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk65y0t45.rkt:37:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk65y0t45.rkt:38:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk65y0t45.rkt:39:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk65y0t45.rkt:40:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append (string-downcase (string-ref s 0)) (solve (substring s 1)))]\n\
    \    [(char-numeric? (string-ref s 0))\n     (string-append (string-ref s 0) (solve\
    \ (substring s 1)))]\n    [else\n     (string-append (string-upcase (string-ref\
    \ s 0)) (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpt8jm8rja.rkt:27:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpt8jm8rja.rkt:28:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpt8jm8rja.rkt:29:4\n\nstring-downcase: contract violation\n\
    \  expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpt8jm8rja.rkt:30:4\n\nstring-upcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpt8jm8rja.rkt:31:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpt8jm8rja.rkt:32:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpt8jm8rja.rkt:33:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpt8jm8rja.rkt:34:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (string-reverse-case s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpedf79ew_.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmpedf79ew_.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpvi8iq0bq.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpvi8iq0bq.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-append\n       (string-append\n        (string-append\n\
    \         (string-append\n          (string-append\n           (string-append\n\
    \            (string-append\n             (string-append\n              (string-append\n\
    \               (string-append\n                (string-append\n             \
    \    (string-append\n                  (string-append\n                   (string-append\n\
    \                    (string-append\n                     (string-append\n   \
    \                   (string-append\n                       (string-append\n  \
    \                      (string-append\n                         (string-append\n\
    \                          (string-append\n                           (string-append\n\
    \                            (string-append\n                             (string-append\n\
    \                              (string-append\n                              \
    \ (string-append\n                                (string-append\n           \
    \                      (string-append\n                                  (string-append\n\
    \                                   (string-append\n                         \
    \           (string-append\n                                     (string-append\n\
    \                                      (string-append\n                      \
    \                 (string-append\n                                        (string-append\n\
    \                                         (string-append\n                   \
    \                       (string-append\n                                     \
    \      (string-append\n                                            (string-append\n\
    \                                             (string-append\n               \
    \                               (string-append\n                             \
    \                  (string-append\n                                          \
    \      (string-append\n                                                 (string-append\n\
    \                                                  (string-append\n          \
    \                                         (string-append\n                   \
    \                                 (string-append\n                           \
    \                          (string-append\n                                  \
    \                    (string-append\n                                        \
    \               (string-append\n                                             \
    \           (string-append\n                                                 \
    \        (string-append\n                                                    \
    \      (string-append\n                                                      \
    \     (string-append\n                                                       \
    \     (string-append\n                                                       \
    \      (string-append\n                                                      \
    \        (string-append\n                                                    \
    \           (string-append\n                                                 \
    \               (string-append\n                                             \
    \                    (string-append\n                                        \
    \                          (string-append\n                                  \
    \                                 (string-append\n                           \
    \                                         (string-append\n                   \
    \                                                  (string-append\n          \
    \                                                            (string-append\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpi8j26gsu.rkt:81:70: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 83\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (reverse-case s)\n      (reverse s)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpy43liesj.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmpy43liesj.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (string-join\n   (reverse\n    (map\n     (lambda (x)\n       (if (char-alphabetic?\
    \ x)\n           (if (char-lower-case? x)\n               (char-upcase x)\n  \
    \             (char-downcase x))\n           x))\n     (string->list s)))))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfe54cytp.rkt:29:4\n\
    \nstring-join: contract violation\n  expected: (listof string?)\n  given: '(#\\\
    F #\\d #\\S #\\a)\n--------------------\n--------------------\nERROR\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpfe54cytp.rkt:30:4\n\nstring-join: contract\
    \ violation\n  expected: (listof string?)\n  given: '(#\\4 #\\3 #\\2 #\\1)\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfe54cytp.rkt:31:4\n\
    \nstring-join: contract violation\n  expected: (listof string?)\n  given: '(#\\\
    B #\\A)\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfe54cytp.rkt:32:4\n\nstring-join: contract violation\n  expected:\
    \ (listof string?)\n  given: '(#\\c #\\@ #\\A #\\#)\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfe54cytp.rkt:33:4\n\nstring-join:\
    \ contract violation\n  expected: (listof string?)\n  given: '(#\\5 #\\4 #\\^\
    \ #\\w #\\F #\\D #\\S #\\a #\\#)\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfe54cytp.rkt:34:4\n\nstring-join:\
    \ contract violation\n  expected: (listof string?)\n  given: '(#\\2 #\\@ #\\6\
    \ #\\#)\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfe54cytp.rkt:35:4\n\nstring-join: contract violation\n  expected:\
    \ (listof string?)\n  given: '(#\\d #\\^ #\\A #\\$ #\\#)\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfe54cytp.rkt:36:4\n\
    \nstring-join: contract violation\n  expected: (listof string?)\n  given: '(#\\\
    C #\\C #\\C #\\#)\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c)\n                                  (char-upcase c)\n                    \
    \              (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp9sbkcoz4.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp9sbkcoz4.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpf0d3o91r.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpf0d3o91r.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map\n       (lambda (c)\n    \
    \     (if (char-alphabetic? c)\n             (char-upcase c)\n             (char-downcase\
    \ c)))\n       s)\n      (string-reverse s)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal? (candidate\
    \ \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal?\
    \ (candidate \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\"\
    )\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal?\
    \ (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\"\
    )\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpjzkgbvzw.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpjzkgbvzw.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (empty? s)\n      \"\"\n      (if (char-alphabetic? (string-ref s 0))\n\
    \          (string-append (string-upcase (string-ref s 0)) (solve (substring s\
    \ 1)))\n          (string-append (string-downcase (string-ref s 0)) (solve (substring\
    \ s 1))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk1ra_n_8.rkt:24:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk1ra_n_8.rkt:25:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\1\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk1ra_n_8.rkt:26:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\a\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk1ra_n_8.rkt:27:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk1ra_n_8.rkt:28:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk1ra_n_8.rkt:29:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk1ra_n_8.rkt:30:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk1ra_n_8.rkt:31:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-upcase (string-ref s 0))\n      (solve (substring\
    \ s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append\n      (string-ref\
    \ s 0)\n      (solve (substring s 1)))]\n    [else\n     (string-append\n    \
    \  (string-downcase (string-ref s 0))\n      (solve (substring s 1)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpodr2n04p.rkt:33:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpodr2n04p.rkt:34:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpodr2n04p.rkt:35:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpodr2n04p.rkt:36:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpodr2n04p.rkt:37:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpodr2n04p.rkt:38:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpodr2n04p.rkt:39:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpodr2n04p.rkt:40:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (first s))\n     (string-append\
    \ (string-upcase (first s)) (solve (rest s)))]\n    [(char-numeric? (first s))\n\
    \     (string-append (first s) (solve (rest s)))]\n    [else\n     (string-append\
    \ (string-downcase (first s)) (solve (rest s)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal? (candidate\
    \ \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal?\
    \ (candidate \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\"\
    )\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal?\
    \ (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\"\
    )\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpsx_3h7ki.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"AsDf\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsx_3h7ki.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"1234\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsx_3h7ki.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ab\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsx_3h7ki.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#a@C\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsx_3h7ki.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#AsdfW^45\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsx_3h7ki.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#6@2\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsx_3h7ki.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#$a^D\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsx_3h7ki.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#ccc\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpx1mw72fg.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpx1mw72fg.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string (char-upcase (string-ref s 0)))\n      (solve\
    \ (substring s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append\n\
    \      (string (char-downcase (string-ref s 0)))\n      (solve (substring s 1)))]\n\
    \    [else (string-append (string (string-ref s 0)) (solve (substring s 1)))]))\n\
    </code>\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpzrozpy_x.rkt:24:0: </code>: unbound identifier\n  in: </code>\n\
    \  location...:\n   /tmp/tmpzrozpy_x.rkt:24:0\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (x) (if (char-alphabetic?\
    \ x)\n                                  (if (char-lower-case? x)\n           \
    \                           (char-upcase x)\n                                \
    \      (char-downcase x))\n                                  x)) s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpnm3b84p3.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpnm3b84p3.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (first s))\n     (string-append\
    \ (string-upcase (string (first s))) (solve (rest s)))]\n    [(char-numeric? (first\
    \ s))\n     (string-append (string (first s)) (solve (rest s)))]\n    [else\n\
    \     (string-append (string-downcase (string (first s))) (solve (rest s)))]))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4mjxzk6l.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"AsDf\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp4mjxzk6l.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"1234\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp4mjxzk6l.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ab\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp4mjxzk6l.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#a@C\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp4mjxzk6l.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#AsdfW^45\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp4mjxzk6l.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#6@2\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp4mjxzk6l.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#$a^D\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp4mjxzk6l.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#ccc\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-append\n       (string-append\n        (string-append\n\
    \         (string-append\n          (string-append\n           (string-append\n\
    \            (string-append\n             (string-append\n              (string-append\n\
    \               (string-append\n                (string-append\n             \
    \    (string-append\n                  (string-append\n                   (string-append\n\
    \                    (string-append\n                     (string-append\n   \
    \                   (string-append\n                       (string-append\n  \
    \                      (string-append\n                         (string-append\n\
    \                          (string-append\n                           (string-append\n\
    \                            (string-append\n                             (string-append\n\
    \                              (string-append\n                              \
    \ (string-append\n                                (string-append\n           \
    \                      (string-append\n                                  (string-append\n\
    \                                   (string-append\n                         \
    \           (string-append\n                                     (string-append\n\
    \                                      (string-append\n                      \
    \                 (string-append\n                                        (string-append\n\
    \                                         (string-append\n                   \
    \                       (string-append\n                                     \
    \      (string-append\n                                            (string-append\n\
    \                                             (string-append\n               \
    \                               (string-append\n                             \
    \                  (string-append\n                                          \
    \      (string-append\n                                                 (string-append\n\
    \                                                  (string-append\n          \
    \                                         (string-append\n                   \
    \                                 (string-append\n                           \
    \                          (string-append\n                                  \
    \                    (string-append\n                                        \
    \               (string-append\n                                             \
    \           (string-append\n                                                 \
    \        (string-append\n                                                    \
    \      (string-append\n                                                      \
    \     (string-append\n                                                       \
    \     (string-append\n                                                       \
    \      (string-append\n                                                      \
    \        (string-append\n                                                    \
    \           (string-append\n                                                 \
    \               (string-append\n                                             \
    \                    (string-append\n                                        \
    \                          (string-append\n                                  \
    \                                 (string-append\n                           \
    \                                         (string-append\n                   \
    \                                                  (string-append\n          \
    \                                                            (string-append\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp3n2o_l7p.rkt:81:70: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 83\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (x) (if (char-alphabetic?\
    \ x) (char-downcase x) (char-upcase x))) s)\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpgth5iun7.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpgth5iun7.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (string-reverse-case s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpk1wdqgxi.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmpk1wdqgxi.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) empty]\n    [(char-alphabetic? (first s))\n     (string-append\
    \ (string-downcase (first s)) (solve (rest s)))]\n    [(char-numeric? (first s))\n\
    \     (string-append (first s) (solve (rest s)))]\n    [else\n     (string-append\
    \ (string-upcase (first s)) (solve (rest s)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal? (candidate\
    \ \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal?\
    \ (candidate \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\"\
    )\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal?\
    \ (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\"\
    )\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3lrlltdl.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"AsDf\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp3lrlltdl.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"1234\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp3lrlltdl.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ab\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp3lrlltdl.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#a@C\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp3lrlltdl.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#AsdfW^45\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp3lrlltdl.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#6@2\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp3lrlltdl.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#$a^D\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp3lrlltdl.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#ccc\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-append\n       (string-append\n        (string-append\n\
    \         (string-append\n          (string-append\n           (string-append\n\
    \            (string-append\n             (string-append\n              (string-append\n\
    \               (string-append\n                (string-append\n             \
    \    (string-append\n                  (string-append\n                   (string-append\n\
    \                    (string-append\n                     (string-append\n   \
    \                   (string-append\n                       (string-append\n  \
    \                      (string-append\n                         (string-append\n\
    \                          (string-append\n                           (string-append\n\
    \                            (string-append\n                             (string-append\n\
    \                              (string-append\n                              \
    \ (string-append\n                                (string-append\n           \
    \                      (string-append\n                                  (string-append\n\
    \                                   (string-append\n                         \
    \           (string-append\n                                     (string-append\n\
    \                                      (string-append\n                      \
    \                 (string-append\n                                        (string-append\n\
    \                                         (string-append\n                   \
    \                       (string-append\n                                     \
    \      (string-append\n                                            (string-append\n\
    \                                             (string-append\n               \
    \                               (string-append\n                             \
    \                  (string-append\n                                          \
    \      (string-append\n                                                 (string-append\n\
    \                                                  (string-append\n          \
    \                                         (string-append\n                   \
    \                                 (string-append\n                           \
    \                          (string-append\n                                  \
    \                    (string-append\n                                        \
    \               (string-append\n                                             \
    \           (string-append\n                                                 \
    \        (string-append\n                                                    \
    \      (string-append\n                                                      \
    \     (string-append\n                                                       \
    \     (string-append\n                                                       \
    \      (string-append\n                                                      \
    \        (string-append\n                                                    \
    \           (string-append\n                                                 \
    \               (string-append\n                                             \
    \                    (string-append\n                                        \
    \                          (string-append\n                                  \
    \                                 (string-append\n                           \
    \                                         (string-append\n                   \
    \                                                  (string-append\n          \
    \                                                            (string-append\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpv6umob3s.rkt:81:70: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 83\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpfg18shnf.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpfg18shnf.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-upcase (string-ref s 0))\n      (solve (substring\
    \ s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append\n      (string-ref\
    \ s 0)\n      (solve (substring s 1)))]\n    [else\n     (string-append\n    \
    \  (string-downcase (string-ref s 0))\n      (solve (substring s 1)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3t32cvyc.rkt:33:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3t32cvyc.rkt:34:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp3t32cvyc.rkt:35:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp3t32cvyc.rkt:36:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3t32cvyc.rkt:37:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3t32cvyc.rkt:38:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3t32cvyc.rkt:39:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3t32cvyc.rkt:40:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond [(empty? s) s]\n        [(char-alphabetic? (string-ref s 0))\n      \
    \   (string-append (string-upcase (string-ref s 0))\n                        (solve\
    \ (substring s 1)))]\n        [(char-numeric? (string-ref s 0))\n         (string-append\
    \ (string-ref s 0)\n                        (solve (substring s 1)))]\n      \
    \  [else\n         (string-append (string-downcase (string-ref s 0))\n       \
    \                 (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal? (candidate\
    \ \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal?\
    \ (candidate \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\"\
    )\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal?\
    \ (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\"\
    )\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwqtnxqo9.rkt:29:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwqtnxqo9.rkt:30:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwqtnxqo9.rkt:31:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwqtnxqo9.rkt:32:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwqtnxqo9.rkt:33:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwqtnxqo9.rkt:34:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwqtnxqo9.rkt:35:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwqtnxqo9.rkt:36:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmplo14i3d5.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmplo14i3d5.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-upcase (string-ref s 0))\n      (solve (substring\
    \ s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append\n      (string-ref\
    \ s 0)\n      (solve (substring s 1)))]\n    [else\n     (string-append\n    \
    \  (string-downcase (string-ref s 0))\n      (solve (substring s 1)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7yxy37wl.rkt:33:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7yxy37wl.rkt:34:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7yxy37wl.rkt:35:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7yxy37wl.rkt:36:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7yxy37wl.rkt:37:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7yxy37wl.rkt:38:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7yxy37wl.rkt:39:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7yxy37wl.rkt:40:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (string-reverse-case s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpftct78qx.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmpftct78qx.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpp4bxlsrb.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpp4bxlsrb.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpog9j5w4y.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpog9j5w4y.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n   \
    \ (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"\
    ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpmir22g0n.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpmir22g0n.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) s]\n    [(char-alphabetic? (string-ref s 0))\n     (string-append\
    \ (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n    [(char-numeric?\
    \ (string-ref s 0))\n     (string-append (string-ref s 0) (solve (substring s\
    \ 1)))]\n    [else\n     (string-append (string-downcase (string-ref s 0)) (solve\
    \ (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7g5o91gc.rkt:27:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7g5o91gc.rkt:28:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7g5o91gc.rkt:29:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7g5o91gc.rkt:30:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7g5o91gc.rkt:31:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7g5o91gc.rkt:32:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7g5o91gc.rkt:33:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7g5o91gc.rkt:34:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpll5p7_02.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpll5p7_02.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-ci? s #\\a)\n      (string-map (lambda (c)\n         \
    \           (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpji5wgmni.rkt:13:7: string-contains-ci?: unbound identifier\n  in:\
    \ string-contains-ci?\n  location...:\n   /tmp/tmpji5wgmni.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (reverse-case s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp1bczubje.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmp1bczubje.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map\n       (lambda (c)\n    \
    \     (if (char-alphabetic? c)\n             (if (char-lower-case? c)\n      \
    \           (char-upcase c)\n                 (char-downcase c))\n           \
    \  c))\n       s)\n      (string-reverse s)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal? (candidate\
    \ \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal?\
    \ (candidate \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\"\
    )\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal?\
    \ (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\"\
    )\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpknmpv7vx.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpknmpv7vx.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-append\n       (string-append\n        (string-append\n\
    \         (string-append\n          (string-append\n           (string-append\n\
    \            (string-append\n             (string-append\n              (string-append\n\
    \               (string-append\n                (string-append\n             \
    \    (string-append\n                  (string-append\n                   (string-append\n\
    \                    (string-append\n                     (string-append\n   \
    \                   (string-append\n                       (string-append\n  \
    \                      (string-append\n                         (string-append\n\
    \                          (string-append\n                           (string-append\n\
    \                            (string-append\n                             (string-append\n\
    \                              (string-append\n                              \
    \ (string-append\n                                (string-append\n           \
    \                      (string-append\n                                  (string-append\n\
    \                                   (string-append\n                         \
    \           (string-append\n                                     (string-append\n\
    \                                      (string-append\n                      \
    \                 (string-append\n                                        (string-append\n\
    \                                         (string-append\n                   \
    \                       (string-append\n                                     \
    \      (string-append\n                                            (string-append\n\
    \                                             (string-append\n               \
    \                               (string-append\n                             \
    \                  (string-append\n                                          \
    \      (string-append\n                                                 (string-append\n\
    \                                                  (string-append\n          \
    \                                         (string-append\n                   \
    \                                 (string-append\n                           \
    \                          (string-append\n                                  \
    \                    (string-append\n                                        \
    \               (string-append\n                                             \
    \           (string-append\n                                                 \
    \        (string-append\n                                                    \
    \      (string-append\n                                                      \
    \     (string-append\n                                                       \
    \     (string-append\n                                                       \
    \      (string-append\n                                                      \
    \        (string-append\n                                                    \
    \           (string-append\n                                                 \
    \               (string-append\n                                             \
    \                    (string-append\n                                        \
    \                          (string-append\n                                  \
    \                                 (string-append\n                           \
    \                                         (string-append\n                   \
    \                                                  (string-append\n          \
    \                                                            (string-append\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpk3990md5.rkt:81:70: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 83\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-upcase (string-ref s 0))\n      (solve (substring\
    \ s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append\n      (string-ref\
    \ s 0)\n      (solve (substring s 1)))]\n    [else\n     (string-append\n    \
    \  (string-downcase (string-ref s 0))\n      (solve (substring s 1)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwt6g736b.rkt:33:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwt6g736b.rkt:34:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwt6g736b.rkt:35:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwt6g736b.rkt:36:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwt6g736b.rkt:37:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwt6g736b.rkt:38:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwt6g736b.rkt:39:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwt6g736b.rkt:40:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append (string-upcase (string (string-ref s 0)))\n               \
    \     (solve (substring s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append\
    \ (string (string-ref s 0))\n                    (solve (substring s 1)))]\n \
    \   [else\n     (string-append (string-downcase (string (string-ref s 0)))\n \
    \                   (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal? (candidate\
    \ \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal?\
    \ (candidate \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\"\
    )\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal?\
    \ (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\"\
    )\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfsvx4f3h.rkt:30:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfsvx4f3h.rkt:31:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfsvx4f3h.rkt:32:4\n\nstring-ref:\
    \ index is out of range for empty string\n  index: 0\n  string: \"\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfsvx4f3h.rkt:33:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfsvx4f3h.rkt:34:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfsvx4f3h.rkt:35:4\n\nstring-ref:\
    \ index is out of range for empty string\n  index: 0\n  string: \"\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfsvx4f3h.rkt:36:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfsvx4f3h.rkt:37:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (first s))\n     (string-append\n\
    \      (if (char-lower-case? (first s))\n          (string-upcase (string (first\
    \ s)))\n          (string-downcase (string (first s))))\n      (solve (rest s)))]\n\
    \    [else\n     (string-append (string (first s)) (solve (rest s)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpz8cr4uf8.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"AsDf\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpz8cr4uf8.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"1234\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpz8cr4uf8.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ab\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpz8cr4uf8.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#a@C\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpz8cr4uf8.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#AsdfW^45\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpz8cr4uf8.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#6@2\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpz8cr4uf8.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#$a^D\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpz8cr4uf8.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#ccc\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpkzuq5e3f.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpkzuq5e3f.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-upcase (string-ref s 0))\n      (solve (substring\
    \ s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append\n      (string-ref\
    \ s 0)\n      (solve (substring s 1)))]\n    [else\n     (string-append\n    \
    \  (string-downcase (string-ref s 0))\n      (solve (substring s 1)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpay43epzz.rkt:33:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpay43epzz.rkt:34:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpay43epzz.rkt:35:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpay43epzz.rkt:36:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpay43epzz.rkt:37:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpay43epzz.rkt:38:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpay43epzz.rkt:39:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpay43epzz.rkt:40:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpsz2l4b2a.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpsz2l4b2a.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-append\n       (string-append\n        (string-append\n\
    \         (string-append\n          (string-append\n           (string-append\n\
    \            (string-append\n             (string-append\n              (string-append\n\
    \               (string-append\n                (string-append\n             \
    \    (string-append\n                  (string-append\n                   (string-append\n\
    \                    (string-append\n                     (string-append\n   \
    \                   (string-append\n                       (string-append\n  \
    \                      (string-append\n                         (string-append\n\
    \                          (string-append\n                           (string-append\n\
    \                            (string-append\n                             (string-append\n\
    \                              (string-append\n                              \
    \ (string-append\n                                (string-append\n           \
    \                      (string-append\n                                  (string-append\n\
    \                                   (string-append\n                         \
    \           (string-append\n                                     (string-append\n\
    \                                      (string-append\n                      \
    \                 (string-append\n                                        (string-append\n\
    \                                         (string-append\n                   \
    \                       (string-append\n                                     \
    \      (string-append\n                                            (string-append\n\
    \                                             (string-append\n               \
    \                               (string-append\n                             \
    \                  (string-append\n                                          \
    \      (string-append\n                                                 (string-append\n\
    \                                                  (string-append\n          \
    \                                         (string-append\n                   \
    \                                 (string-append\n                           \
    \                          (string-append\n                                  \
    \                    (string-append\n                                        \
    \               (string-append\n                                             \
    \           (string-append\n                                                 \
    \        (string-append\n                                                    \
    \      (string-append\n                                                      \
    \     (string-append\n                                                       \
    \     (string-append\n                                                       \
    \      (string-append\n                                                      \
    \        (string-append\n                                                    \
    \           (string-append\n                                                 \
    \               (string-append\n                                             \
    \                    (string-append\n                                        \
    \                          (string-append\n                                  \
    \                                 (string-append\n                           \
    \                                         (string-append\n                   \
    \                                                  (string-append\n          \
    \                                                            (string-append\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp9q3ysl6d.rkt:81:70: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 83\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map\n       (lambda (c)\n    \
    \     (if (char-alphabetic? c)\n             (if (char-lower-case? c)\n      \
    \           (char-upcase c)\n                 (char-downcase c))\n           \
    \  c))\n       s)\n      (string-reverse s)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal? (candidate\
    \ \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal?\
    \ (candidate \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\"\
    )\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal?\
    \ (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\"\
    )\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp7mdamlse.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp7mdamlse.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp_bpuuvmx.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp_bpuuvmx.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp_y230k53.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp_y230k53.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s (regexp \"[a-zA-Z]\"))\n      (string-map (lambda (c)\n\
    \                    (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp8fcmzw42.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp8fcmzw42.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-upcase (string-ref s 0))\n      (solve (substring\
    \ s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append\n      (string-ref\
    \ s 0)\n      (solve (substring s 1)))]\n    [else\n     (string-append\n    \
    \  (string-downcase (string-ref s 0))\n      (solve (substring s 1)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp353rqc19.rkt:33:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp353rqc19.rkt:34:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp353rqc19.rkt:35:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp353rqc19.rkt:36:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp353rqc19.rkt:37:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp353rqc19.rkt:38:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp353rqc19.rkt:39:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp353rqc19.rkt:40:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpu3iu7i7s.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpu3iu7i7s.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpsulooomu.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpsulooomu.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp065xeprb.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp065xeprb.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp9ft7bybp.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp9ft7bybp.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n\
    \    [(char-numeric? (string-ref s 0))\n     (string-append (string-ref s 0) (solve\
    \ (substring s 1)))]\n    [else\n     (string-append (string-downcase (string-ref\
    \ s 0)) (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw7yzam3x.rkt:27:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw7yzam3x.rkt:28:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpw7yzam3x.rkt:29:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpw7yzam3x.rkt:30:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw7yzam3x.rkt:31:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw7yzam3x.rkt:32:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw7yzam3x.rkt:33:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw7yzam3x.rkt:34:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpmh2hlizc.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpmh2hlizc.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpjjlp0jgt.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpjjlp0jgt.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(string=? s \"\") \"\"]\n    [(string-contains? s #\\a) (string-upcase\
    \ s)]\n    [(string-contains? s #\\A) (string-downcase s)]\n    [else (string-reverse\
    \ s)]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpv5g44v59.rkt:17:11: string-reverse: unbound identifier\n  in: string-reverse\n\
    \  location...:\n   /tmp/tmpv5g44v59.rkt:17:11\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpr46s3hjp.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpr46s3hjp.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (reverse-case s)\n      (reverse s)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpoywjxe98.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmpoywjxe98.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c) (char-downcase c) (char-upcase c))) s)\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpweqjyzy8.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpweqjyzy8.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpfyr9n97k.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpfyr9n97k.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (empty? s)\n      \"\"\n      (if (char-alphabetic? (string-ref s 0))\n\
    \          (string-append (string-upcase (string-ref s 0)) (solve (substring s\
    \ 1)))\n          (string-append (string-downcase (string-ref s 0)) (solve (substring\
    \ s 1))))))\n</code>\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n   \
    \ (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"\
    ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmppffvvaj6.rkt:18:0: </code>: unbound identifier\n  in: </code>\n\
    \  location...:\n   /tmp/tmppffvvaj6.rkt:18:0\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (x) (if (char-alphabetic?\
    \ x) (char-downcase x) (char-upcase x))) s)\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp5q306xcd.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp5q306xcd.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-upcase (string-ref s 0))\n      (solve (substring\
    \ s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append\n      (string-ref\
    \ s 0)\n      (solve (substring s 1)))]\n    [else\n     (string-append\n    \
    \  (string-downcase (string-ref s 0))\n      (solve (substring s 1)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpswjseq02.rkt:33:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpswjseq02.rkt:34:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpswjseq02.rkt:35:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpswjseq02.rkt:36:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpswjseq02.rkt:37:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpswjseq02.rkt:38:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpswjseq02.rkt:39:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpswjseq02.rkt:40:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (first s))\n     (string-append\n\
    \      (string-upcase (string (first s)))\n      (solve (rest s)))]\n    [(char-numeric?\
    \ (first s))\n     (string-append\n      (string (first s))\n      (solve (rest\
    \ s)))]\n    [else\n     (string-append\n      (string (first s))\n      (solve\
    \ (rest s)))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp9u0cyl55.rkt:33:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"AsDf\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp9u0cyl55.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"1234\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp9u0cyl55.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ab\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp9u0cyl55.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#a@C\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp9u0cyl55.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#AsdfW^45\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp9u0cyl55.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#6@2\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp9u0cyl55.rkt:39:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#$a^D\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp9u0cyl55.rkt:40:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#ccc\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (reverse-case s)\n      (reverse s)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmptfkd1y32.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmptfkd1y32.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n\
    \    [(char-numeric? (string-ref s 0))\n     (string-append (string-ref s 0) (solve\
    \ (substring s 1)))]\n    [else (string-append (string-downcase (string-ref s\
    \ 0)) (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2nqus35c.rkt:26:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2nqus35c.rkt:27:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp2nqus35c.rkt:28:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2nqus35c.rkt:29:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2nqus35c.rkt:30:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2nqus35c.rkt:31:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2nqus35c.rkt:32:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2nqus35c.rkt:33:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map\n       (lambda (c)\n    \
    \     (if (char-alphabetic? c)\n             (if (char-lower-case? c)\n      \
    \           (char-upcase c)\n                 (char-downcase c))\n           \
    \  c))\n       s)\n      (string-reverse s)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal? (candidate\
    \ \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal?\
    \ (candidate \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\"\
    )\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal?\
    \ (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\"\
    )\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpazj07l_h.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpazj07l_h.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c)\n                                  (char-upcase c)\n                    \
    \              (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmptu4ron_o.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmptu4ron_o.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c)\n                                  (char-upcase c)\n                    \
    \              (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp_pzi4zdp.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp_pzi4zdp.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmperacetnz.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmperacetnz.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-empty? s)\n      \"\"\n      (if (char-alphabetic? (string-ref\
    \ s 0))\n          (string-append (string-upcase (string-ref s 0)) (solve (substring\
    \ s 1)))\n          (string-append (string-downcase (string-ref s 0)) (solve (substring\
    \ s 1))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp8x8lu1yp.rkt:13:7: string-empty?: unbound identifier\n  in: string-empty?\n\
    \  location...:\n   /tmp/tmp8x8lu1yp.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (empty? s)\n      \"\"\n      (if (char-alphabetic? (string-ref s 0))\n\
    \          (string-append (string-downcase (string-ref s 0)) (solve (substring\
    \ s 1)))\n          (string-append (string-upcase (string-ref s 0)) (solve (substring\
    \ s 1))))))\n</code>\nI'm not sure if I'm doing it right. I'm not sure if I'm\
    \ using the right functions.\n\n\nA:\n\nI think you're on the right track.  You're\
    \ using the right functions, but you're using them in a way that's not quite right.\
    \  Here's a hint:\n<code>(define (solve s)\n  (if (empty? s)\n      \"\"\n   \
    \   (string-append (string-downcase (string-ref s 0)) (solve (substring s 1)))))\n\
    </code>\nThis will work, but it's not quite right.  It will always convert the\
    \ first character to lowercase.  You want to convert it to lowercase if it's uppercase,\
    \ and vice versa.  How can you do that?\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmphe7ecwoj.rkt:24:68: unquote: not in quasiquote\n  in: (unquote\
    \ but)\n  location...:\n   /tmp/tmphe7ecwoj.rkt:24:68\n  context...:\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/wrap-modbeg.rkt:46:4\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmppjofwze0.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmppjofwze0.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpgajbne0p.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpgajbne0p.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (define (is-letter? c)\n    (and (char-alphabetic? c) (not (char-numeric? c))))\n\
    \  (define (reverse-case c)\n    (if (char-lower-case? c)\n        (char-upcase\
    \ c)\n        (char-downcase c)))\n  (define (reverse-string s)\n    (string-reverse\
    \ s))\n  (define (has-letter? s)\n    (regexp-match? #rx\"[a-zA-Z]\" s))\n  (if\
    \ (has-letter? s)\n      (string-map reverse-case s)\n      (reverse-string s)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp8n7wt38u.rkt:20:5: string-reverse: unbound identifier\n  in: string-reverse\n\
    \  location...:\n   /tmp/tmp8n7wt38u.rkt:20:5\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) s]\n    [(char-alphabetic? (string-ref s 0))\n     (string-append\
    \ (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n    [(char-numeric?\
    \ (string-ref s 0))\n     (string-append (string-ref s 0) (solve (substring s\
    \ 1)))]\n    [else (string-append (string-downcase (string-ref s 0)) (solve (substring\
    \ s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8tw9tlkk.rkt:26:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8tw9tlkk.rkt:27:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8tw9tlkk.rkt:28:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8tw9tlkk.rkt:29:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8tw9tlkk.rkt:30:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8tw9tlkk.rkt:31:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8tw9tlkk.rkt:32:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8tw9tlkk.rkt:33:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0)) (string-append\
    \ (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n    [(char-numeric?\
    \ (string-ref s 0)) (string-append (string-ref s 0) (solve (substring s 1)))]\n\
    \    [else (string-append (string-downcase (string-ref s 0)) (solve (substring\
    \ s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp5hbv57ax.rkt:24:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp5hbv57ax.rkt:25:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5hbv57ax.rkt:26:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5hbv57ax.rkt:27:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp5hbv57ax.rkt:28:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp5hbv57ax.rkt:29:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp5hbv57ax.rkt:30:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp5hbv57ax.rkt:31:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-upcase (string-ref s 0))\n      (solve (substring\
    \ s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append\n      (string-ref\
    \ s 0)\n      (solve (substring s 1)))]\n    [else\n     (string-append\n    \
    \  (string-downcase (string-ref s 0))\n      (solve (substring s 1)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp7bvrfqv.rkt:33:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp7bvrfqv.rkt:34:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpp7bvrfqv.rkt:35:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpp7bvrfqv.rkt:36:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp7bvrfqv.rkt:37:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp7bvrfqv.rkt:38:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp7bvrfqv.rkt:39:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp7bvrfqv.rkt:40:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (string-reverse-case s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp5fufqztm.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmp5fufqztm.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s (regexp \"[a-zA-Z]\"))\n      (string-join (map (lambda\
    \ (c)\n                          (if (char-alphabetic? c)\n                  \
    \            (char-downcase c)\n                              (char-upcase c)))\n\
    \                        (string->list s)))\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp9sju54fj.rkt:19:7: string-reverse: unbound identifier\n  in: string-reverse\n\
    \  location...:\n   /tmp/tmp9sju54fj.rkt:19:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-ci? s #\\a)\n      (string-map (lambda (c)\n         \
    \           (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpri4opzco.rkt:13:7: string-contains-ci?: unbound identifier\n  in:\
    \ string-contains-ci?\n  location...:\n   /tmp/tmpri4opzco.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpou31ddk3.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpou31ddk3.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-ci? s #\\a)\n      (string-map (lambda (c)\n         \
    \           (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmprqc81tb2.rkt:13:7: string-contains-ci?: unbound identifier\n  in:\
    \ string-contains-ci?\n  location...:\n   /tmp/tmprqc81tb2.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c) (char-downcase c) (char-upcase c))) s)\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp0cfocbn8.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp0cfocbn8.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (first s))\n     (string-append\
    \ (string-upcase (first s)) (solve (rest s)))]\n    [(char-numeric? (first s))\n\
    \     (string-append (first s) (solve (rest s)))]\n    [else (string-append (string-downcase\
    \ (first s)) (solve (rest s)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpua29kzlk.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"AsDf\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpua29kzlk.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"1234\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpua29kzlk.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ab\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpua29kzlk.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#a@C\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpua29kzlk.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#AsdfW^45\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpua29kzlk.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#6@2\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpua29kzlk.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#$a^D\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpua29kzlk.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#ccc\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-any? s (string->list \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ))\n      (string-join (map (lambda (x) (if (char-alphabetic? x) (char-upcase\
    \ x) (char-downcase x))) (string->list s)))\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpf62sui7b.rkt:13:7: string-contains-any?: unbound identifier\n \
    \ in: string-contains-any?\n  location...:\n   /tmp/tmpf62sui7b.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-empty? s)\n      \"\"\n      (if (char-alphabetic? (string-ref\
    \ s 0))\n          (string-append (string-upcase (string-ref s 0)) (solve (substring\
    \ s 1)))\n          (string-append (string-downcase (string-ref s 0)) (solve (substring\
    \ s 1))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp88hm5bjx.rkt:13:7: string-empty?: unbound identifier\n  in: string-empty?\n\
    \  location...:\n   /tmp/tmp88hm5bjx.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp9tnygj1p.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp9tnygj1p.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (string-reverse-case s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpfx3jyxd_.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmpfx3jyxd_.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp7fbc6o49.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp7fbc6o49.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-append\n       (string-upcase (string (string-ref\
    \ s 0)))\n       (substring s 1 (- (string-length s) 1)))\n      (string-downcase\
    \ (string (string-ref s (- (string-length s) 1)))))\n    ]\n    [else\n     (string-append\n\
    \      (substring s 0 (- (string-length s) 1))\n      (string-reverse (string\
    \ (string-ref s (- (string-length s) 1)))))\n     ]\n    )\n  )\n</code>\nI am\
    \ getting the following error:\n<code>string-append: expects type &lt;string&gt;\
    \ as 1st argument, given: #\\A; other arguments were: #\\c\n</code>\nI don't understand\
    \ why this is happening.\nAny help would be appreciated.\n\n\nA:\n\nYou're trying\
    \ to concatenate a string and a character.\n<code>(string-append\n (string-append\n\
    \  (string-upcase (string (string-ref s 0)))\n  (substring s 1 (- (string-length\
    \ s) 1)))\n (string-downcase (string (string-ref s (- (string-length s) 1)))))\n\
    </code>\nThe first <code>string-append</code> is fine, but the second one is not.\n\
    <code>(string-downcase (string (string-ref s (- (string-length s) 1))))\n</code>\n\
    This expression evaluates to a character, not a string.\n<code>(string-downcase\
    \ (string (string-ref s (- (string-length s) 1))))\n=&gt; #\\c\n</code>\nYou can\
    \ fix this by wrapping the character in a string:\n<code>(string-append\n (string-append\n\
    \  (string-upcase (string (string-ref s 0)))\n  (substring s 1 (- (string-length\
    \ s) 1)))\n (string (string-downcase (string (string-ref s (- (string-length s)\
    \ 1))))))\n</code>\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n   \
    \ (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"\
    ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp1xgbbbyb.rkt:39:38: and: bad syntax\n  in: and\n  location...:\n\
    \   /tmp/tmp1xgbbbyb.rkt:39:38\n  context...:\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/private/qq-and-or.rkt:442:6\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/wrap-modbeg.rkt:46:4\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (string-reverse-case s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp6sdm1i4l.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmp6sdm1i4l.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n\
    \    [(char-numeric? (string-ref s 0))\n     (string-append (string-ref s 0) (solve\
    \ (substring s 1)))]\n    [else (string-append (string-downcase (string-ref s\
    \ 0)) (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ekpyivl.rkt:26:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ekpyivl.rkt:27:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7ekpyivl.rkt:28:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ekpyivl.rkt:29:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ekpyivl.rkt:30:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ekpyivl.rkt:31:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ekpyivl.rkt:32:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ekpyivl.rkt:33:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpndxk2u0o.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpndxk2u0o.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n</code>\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp1spi0uwe.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp1spi0uwe.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (string-reverse-case s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpc5_kodip.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmpc5_kodip.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-ci? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c)\n                                  (char-upcase c)\n                    \
    \              (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpkw3t3hkn.rkt:13:7: string-contains-ci?: unbound identifier\n  in:\
    \ string-contains-ci?\n  location...:\n   /tmp/tmpkw3t3hkn.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (x) (if (char-alphabetic?\
    \ x) (char-downcase x) (char-upcase x))) s)\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpn2jo6bsi.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpn2jo6bsi.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-append\n       (string-append\n        (string-append\n\
    \         (string-append\n          (string-append\n           (string-append\n\
    \            (string-append\n             (string-append\n              (string-append\n\
    \               (string-append\n                (string-append\n             \
    \    (string-append\n                  (string-append\n                   (string-append\n\
    \                    (string-append\n                     (string-append\n   \
    \                   (string-append\n                       (string-append\n  \
    \                      (string-append\n                         (string-append\n\
    \                          (string-append\n                           (string-append\n\
    \                            (string-append\n                             (string-append\n\
    \                              (string-append\n                              \
    \ (string-append\n                                (string-append\n           \
    \                      (string-append\n                                  (string-append\n\
    \                                   (string-append\n                         \
    \           (string-append\n                                     (string-append\n\
    \                                      (string-append\n                      \
    \                 (string-append\n                                        (string-append\n\
    \                                         (string-append\n                   \
    \                       (string-append\n                                     \
    \      (string-append\n                                            (string-append\n\
    \                                             (string-append\n               \
    \                               (string-append\n                             \
    \                  (string-append\n                                          \
    \      (string-append\n                                                 (string-append\n\
    \                                                  (string-append\n          \
    \                                         (string-append\n                   \
    \                                 (string-append\n                           \
    \                          (string-append\n                                  \
    \                    (string-append\n                                        \
    \               (string-append\n                                             \
    \           (string-append\n                                                 \
    \        (string-append\n                                                    \
    \      (string-append\n                                                      \
    \     (string-append\n                                                       \
    \     (string-append\n                                                       \
    \      (string-append\n                                                      \
    \        (string-append\n                                                    \
    \           (string-append\n                                                 \
    \               (string-append\n                                             \
    \                    (string-append\n                                        \
    \                          (string-append\n                                  \
    \                                 (string-append\n                           \
    \                                         (string-append\n                   \
    \                                                  (string-append\n          \
    \                                                            (string-append\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpilgtsioz.rkt:81:70: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 83\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond [(empty? s) s]\n        [(char-alphabetic? (string-ref s 0))\n      \
    \   (string-append (string-upcase (string-ref s 0))\n                        (solve\
    \ (substring s 1)))]\n        [(char-numeric? (string-ref s 0))\n         (string-append\
    \ (string-ref s 0)\n                        (solve (substring s 1)))]\n      \
    \  [else (string-append (string-downcase (string-ref s 0))\n                 \
    \            (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ki49fqa.rkt:28:4\n\
    \nstring-upcase: contract violation\n  expected: string?\n  given: #\\A\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ki49fqa.rkt:29:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7ki49fqa.rkt:30:4\n\nstring-upcase: contract violation\n \
    \ expected: string?\n  given: #\\a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ki49fqa.rkt:31:4\n\nstring-downcase:\
    \ contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ki49fqa.rkt:32:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ki49fqa.rkt:33:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ki49fqa.rkt:34:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ki49fqa.rkt:35:4\n\
    \nstring-downcase: contract violation\n  expected: string?\n  given: #\\#\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string (char-upcase (string-ref s 0)))\n      (solve\
    \ (substring s 1)))]\n    [(char-numeric? (string-ref s 0))\n     (string-append\n\
    \      (string (char-downcase (string-ref s 0)))\n      (solve (substring s 1)))]\n\
    \    [else\n     (string-append\n      (string (string-ref s 0))\n      (solve\
    \ (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpx6f7wm3x.rkt:33:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpx6f7wm3x.rkt:34:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpx6f7wm3x.rkt:35:4\n\nstring-ref:\
    \ index is out of range for empty string\n  index: 0\n  string: \"\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpx6f7wm3x.rkt:36:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpx6f7wm3x.rkt:37:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpx6f7wm3x.rkt:38:4\n\nstring-ref:\
    \ index is out of range for empty string\n  index: 0\n  string: \"\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpx6f7wm3x.rkt:39:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpx6f7wm3x.rkt:40:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (string-reverse-case s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpmi32hfoc.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmpmi32hfoc.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpzyk9pxaf.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpzyk9pxaf.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (x) (if (char-alphabetic?\
    \ x)\n                                  (if (char-lower-case? x)\n           \
    \                           (char-upcase x)\n                                \
    \      (char-downcase x))\n                                  x)) s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpc1vb20p3.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpc1vb20p3.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) empty]\n    [(char-alphabetic? (first s))\n     (string-append\
    \ (string-downcase (first s)) (solve (rest s)))]\n    [(char-numeric? (first s))\n\
    \     (string-append (first s) (solve (rest s)))]\n    [else\n     (string-append\
    \ (string-upcase (first s)) (solve (rest s)))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal? (candidate\
    \ \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal?\
    \ (candidate \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\"\
    )\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal?\
    \ (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\"\
    )\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpsgmalpsg.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"AsDf\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsgmalpsg.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"1234\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsgmalpsg.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ab\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsgmalpsg.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#a@C\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsgmalpsg.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#AsdfW^45\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsgmalpsg.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#6@2\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsgmalpsg.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#$a^D\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsgmalpsg.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#ccc\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-empty? s)\n      \"\"\n      (string-append (string (if (char-alphabetic?\
    \ (string-ref s 0))\n                                 (if (char-lower-case? (string-ref\
    \ s 0))\n                                     (char-upcase (string-ref s 0))\n\
    \                                     (char-downcase (string-ref s 0)))\n    \
    \                             (string-ref s 0)))\n                      (solve\
    \ (substring s 1)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n \
    \ (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n\
    \    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpkyxxnkxq.rkt:13:7: string-empty?: unbound identifier\n  in: string-empty?\n\
    \  location...:\n   /tmp/tmpkyxxnkxq.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-append\n       (string-append\n        (string-append\n\
    \         (string-append\n          (string-append\n           (string-append\n\
    \            (string-append\n             (string-append\n              (string-append\n\
    \               (string-append\n                (string-append\n             \
    \    (string-append\n                  (string-append\n                   (string-append\n\
    \                    (string-append\n                     (string-append\n   \
    \                   (string-append\n                       (string-append\n  \
    \                      (string-append\n                         (string-append\n\
    \                          (string-append\n                           (string-append\n\
    \                            (string-append\n                             (string-append\n\
    \                              (string-append\n                              \
    \ (string-append\n                                (string-append\n           \
    \                      (string-append\n                                  (string-append\n\
    \                                   (string-append\n                         \
    \           (string-append\n                                     (string-append\n\
    \                                      (string-append\n                      \
    \                 (string-append\n                                        (string-append\n\
    \                                         (string-append\n                   \
    \                       (string-append\n                                     \
    \      (string-append\n                                            (string-append\n\
    \                                             (string-append\n               \
    \                               (string-append\n                             \
    \                  (string-append\n                                          \
    \      (string-append\n                                                 (string-append\n\
    \                                                  (string-append\n          \
    \                                         (string-append\n                   \
    \                                 (string-append\n                           \
    \                          (string-append\n                                  \
    \                    (string-append\n                                        \
    \               (string-append\n                                             \
    \           (string-append\n                                                 \
    \        (string-append\n                                                    \
    \      (string-append\n                                                      \
    \     (string-append\n                                                       \
    \     (string-append\n                                                       \
    \      (string-append\n                                                      \
    \        (string-append\n                                                    \
    \           (string-append\n                                                 \
    \               (string-append\n                                             \
    \                    (string-append\n                                        \
    \                          (string-append\n                                  \
    \                                 (string-append\n                           \
    \                                         (string-append\n                   \
    \                                                  (string-append\n          \
    \                                                            (string-append\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpbwfe_w_r.rkt:81:70: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 83\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp2yvrs3j6.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmp2yvrs3j6.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (reverse-case s)\n      (reverse s)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp4n_ue4ty.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmp4n_ue4ty.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpgkaso4u1.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpgkaso4u1.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpu5cddudb.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpu5cddudb.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c) (char-upcase c) (char-downcase c))) s)\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmplhxfyzh1.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmplhxfyzh1.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (string-join (reverse (map (lambda (c)\n                               (if\
    \ (char-alphabetic? c)\n                                   (if (char-lower-case?\
    \ c)\n                                       (char-upcase c)\n               \
    \                        (char-downcase c))\n                                \
    \   c))\n                             (string->list s)))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpr411y4wy.rkt:26:4\n\
    \nstring-join: contract violation\n  expected: (listof string?)\n  given: '(#\\\
    F #\\d #\\S #\\a)\n--------------------\n--------------------\nERROR\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpr411y4wy.rkt:27:4\n\nstring-join: contract\
    \ violation\n  expected: (listof string?)\n  given: '(#\\4 #\\3 #\\2 #\\1)\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpr411y4wy.rkt:28:4\n\
    \nstring-join: contract violation\n  expected: (listof string?)\n  given: '(#\\\
    B #\\A)\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpr411y4wy.rkt:29:4\n\nstring-join: contract violation\n  expected:\
    \ (listof string?)\n  given: '(#\\c #\\@ #\\A #\\#)\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpr411y4wy.rkt:30:4\n\nstring-join:\
    \ contract violation\n  expected: (listof string?)\n  given: '(#\\5 #\\4 #\\^\
    \ #\\w #\\F #\\D #\\S #\\a #\\#)\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpr411y4wy.rkt:31:4\n\nstring-join:\
    \ contract violation\n  expected: (listof string?)\n  given: '(#\\2 #\\@ #\\6\
    \ #\\#)\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpr411y4wy.rkt:32:4\n\nstring-join: contract violation\n  expected:\
    \ (listof string?)\n  given: '(#\\d #\\^ #\\A #\\$ #\\#)\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpr411y4wy.rkt:33:4\n\
    \nstring-join: contract violation\n  expected: (listof string?)\n  given: '(#\\\
    C #\\C #\\C #\\#)\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (string-reverse-case s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpe0qs14tw.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmpe0qs14tw.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-ci? s #\\a)\n      (string-map (lambda (c)\n         \
    \           (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp675p4gku.rkt:13:7: string-contains-ci?: unbound identifier\n  in:\
    \ string-contains-ci?\n  location...:\n   /tmp/tmp675p4gku.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c)\n                                  (char-upcase c)\n                    \
    \              (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpnz62fm2b.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpnz62fm2b.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-append\n       (string-upcase (string (string-ref\
    \ s 0)))\n       (string-downcase (substring s 1)))\n      (solve (substring s\
    \ 1)))]\n    [else\n     (string-append\n      (string (string-ref s 0))\n   \
    \   (solve (substring s 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbicfuoqx.rkt:31:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbicfuoqx.rkt:32:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbicfuoqx.rkt:33:4\n\nstring-ref:\
    \ index is out of range for empty string\n  index: 0\n  string: \"\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbicfuoqx.rkt:34:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbicfuoqx.rkt:35:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbicfuoqx.rkt:36:4\n\nstring-ref:\
    \ index is out of range for empty string\n  index: 0\n  string: \"\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbicfuoqx.rkt:37:4\n\
    \nstring-ref: index is out of range for empty string\n  index: 0\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbicfuoqx.rkt:38:4\n\nstring-ref: index is out of range for\
    \ empty string\n  index: 0\n  string: \"\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (x) (if (char-alphabetic?\
    \ x)\n                                  (char-upcase x)\n                    \
    \              (char-downcase x))) s)\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmps_3hzcvx.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmps_3hzcvx.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (first s))\n     (string-append\n\
    \      (string-upcase (first s))\n      (solve (rest s)))]\n    [(char-numeric?\
    \ (first s))\n     (string-append\n      (first s)\n      (solve (rest s)))]\n\
    \    [else\n     (string-append\n      (string-downcase (first s))\n      (solve\
    \ (rest s)))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpr2zeoea2.rkt:33:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"AsDf\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpr2zeoea2.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"1234\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpr2zeoea2.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ab\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpr2zeoea2.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#a@C\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpr2zeoea2.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#AsdfW^45\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpr2zeoea2.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#6@2\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpr2zeoea2.rkt:39:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"#$a^D\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpr2zeoea2.rkt:40:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"#ccc\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-ci? s #\\a)\n      (string-map (lambda (x) (if (char-alphabetic?\
    \ x) (char-upcase x) (char-downcase x))) s)\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpnel5dldz.rkt:13:7: string-contains-ci?: unbound identifier\n  in:\
    \ string-contains-ci?\n  location...:\n   /tmp/tmpnel5dldz.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpoiyinvu2.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpoiyinvu2.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (char-upcase c)\n \
    \                       (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpp512qdcb.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpp512qdcb.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (define (is-letter? c)\n    (and (char-alphabetic? c)\n         (not (char-numeric?\
    \ c))))\n  (define (reverse-case c)\n    (if (char-lower-case? c)\n        (char-upcase\
    \ c)\n        (char-downcase c)))\n  (define (reverse-case-string s)\n    (string-map\
    \ reverse-case s))\n  (define (has-letters? s)\n    (for/or ([c (in-string s)])\n\
    \      (is-letter? c)))\n  (if (has-letters? s)\n      (reverse-case-string s)\n\
    \      (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmppgkafpk8.rkt:21:5: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmppgkafpk8.rkt:21:5\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c)\n                                  (char-upcase c)\n                    \
    \              (char-downcase c)))\n                  s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpu9sfuks3.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpu9sfuks3.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains-letter? s)\n      (string-reverse-case s)\n      (string-reverse\
    \ s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal?\
    \ (candidate \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\"\
    )\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate\
    \ \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\"\
    )\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate\
    \ \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp07u9bu8a.rkt:13:7: string-contains-letter?: unbound identifier\n\
    \  in: string-contains-letter?\n  location...:\n   /tmp/tmp07u9bu8a.rkt:13:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c)\n            \
    \        (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)\n   \
    \   (string-reverse s)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate solve))\n    (check-equal? (candidate \"AsDf\") \"aSdF\"\
    )\n    (check-equal? (candidate \"1234\") \"4321\")\n    (check-equal? (candidate\
    \ \"ab\") \"AB\")\n    (check-equal? (candidate \"#a@C\") \"#A@c\")\n    (check-equal?\
    \ (candidate \"#AsdfW^45\") \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\"\
    ) \"2@6#\")\n    (check-equal? (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal?\
    \ (candidate \"#ccc\") \"#CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpfiq0kcf5.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpfiq0kcf5.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n  \
    \   (string-append\n      (string-append\n       (string-append\n        (string-append\n\
    \         (string-append\n          (string-append\n           (string-append\n\
    \            (string-append\n             (string-append\n              (string-append\n\
    \               (string-append\n                (string-append\n             \
    \    (string-append\n                  (string-append\n                   (string-append\n\
    \                    (string-append\n                     (string-append\n   \
    \                   (string-append\n                       (string-append\n  \
    \                      (string-append\n                         (string-append\n\
    \                          (string-append\n                           (string-append\n\
    \                            (string-append\n                             (string-append\n\
    \                              (string-append\n                              \
    \ (string-append\n                                (string-append\n           \
    \                      (string-append\n                                  (string-append\n\
    \                                   (string-append\n                         \
    \           (string-append\n                                     (string-append\n\
    \                                      (string-append\n                      \
    \                 (string-append\n                                        (string-append\n\
    \                                         (string-append\n                   \
    \                       (string-append\n                                     \
    \      (string-append\n                                            (string-append\n\
    \                                             (string-append\n               \
    \                               (string-append\n                             \
    \                  (string-append\n                                          \
    \      (string-append\n                                                 (string-append\n\
    \                                                  (string-append\n          \
    \                                         (string-append\n                   \
    \                                 (string-append\n                           \
    \                          (string-append\n                                  \
    \                    (string-append\n                                        \
    \               (string-append\n                                             \
    \           (string-append\n                                                 \
    \        (string-append\n                                                    \
    \      (string-append\n                                                      \
    \     (string-append\n                                                       \
    \     (string-append\n                                                       \
    \      (string-append\n                                                      \
    \        (string-append\n                                                    \
    \           (string-append\n                                                 \
    \               (string-append\n                                             \
    \                    (string-append\n                                        \
    \                          (string-append\n                                  \
    \                                 (string-append\n                           \
    \                                         (string-append\n                   \
    \                                                  (string-append\n          \
    \                                                            (string-append\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
    \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
    \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
    \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\")\
    \ \"#aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
    \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"\
    #CCC\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpfrx_lj60.rkt:81:70: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 83\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (x) (if (char-alphabetic?\
    \ x) (char-downcase x) (char-upcase x))) s)\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpzi2c7d7c.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpzi2c7d7c.rkt:14:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter,\
    \ reverse its case from lower to upper or vise versa, \n;; otherwise keep it as\
    \ it is.\n;; If the string contains no letters, reverse the string.\n;; The function\
    \ should return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\
    \n;; solve(\"ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n\
    \  (if (string-contains? s #\\a)\n      (string-map (lambda (c) (if (char-alphabetic?\
    \ c) (char-upcase c) (char-downcase c))) s)\n      (string-reverse s)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n    (check-equal?\
    \ (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate \"1234\") \"4321\"\
    )\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal? (candidate\
    \ \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"#aSDFw^45\"\
    )\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal? (candidate\
    \ \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\")\n))\n\
    \n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpsxja5d_7.rkt:14:7: string-map: unbound identifier\n  in: string-map\n\
    \  location...:\n   /tmp/tmpsxja5d_7.rkt:14:7\n"
  exit_code: 1
  status: OK
