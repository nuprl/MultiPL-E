language: racket
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (cond\n      [(empty? paren_string)\
    \ 0]\n      [(char=? (first paren_string) #\\() (+ 1 (parse_parens (rest paren_string)))]\n\
    \      [(char=? (first paren_string) #\\)) (- 1 (parse_parens (rest paren_string)))]\n\
    \      [else (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_oxyc0_0.rkt:22:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_oxyc0_0.rkt:23:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_oxyc0_0.rkt:24:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (\u03BB (paren_group)\n         (let ([paren_group (string->list paren_group)])\n\
    \           (let loop ([paren_group paren_group] [nest_level 0] [max_nest_level\
    \ 0])\n             (cond [(empty? paren_group) max_nest_level]\n            \
    \       [else\n                    (let ([paren (first paren_group)])\n      \
    \                (cond [(equal? paren #\\()\n                             (loop\
    \ (rest paren_group) (+ nest_level 1) (max nest_level max_nest_level))]\n    \
    \                        [(equal? paren #\\))\n                             (loop\
    \ (rest paren_group) (- nest_level 1) max_nest_level)]\n                     \
    \       [else (loop (rest paren_group) nest_level max_nest_level)]))]))))\n  \
    \     (string-split paren_string #\\space)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4bd3ygmq.rkt:27:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp4bd3ygmq.rkt:28:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp4bd3ygmq.rkt:29:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens-helper paren_string paren_stack)\n    (cond\n      [(empty?\
    \ paren_string) (reverse paren_stack)]\n      [(char=? (first paren_string) #\\\
    ()\n       (parse-parens-helper (rest paren_string) (cons 1 paren_stack))]\n \
    \     [(char=? (first paren_string) #\\))\n       (parse-parens-helper (rest paren_string)\
    \ (cons (+ 1 (first paren_stack)) (rest paren_stack)))]\n      [(char=? (first\
    \ paren_string) #\\space)\n       (parse-parens-helper (rest paren_string) (cons\
    \ 0 (rest paren_stack)))]))\n  (parse-parens-helper paren_string (list 0)))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmplefi84fh.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplefi84fh.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmplefi84fh.rkt:27:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (parse_nested_parens_helper paren_group\
    \ 0))\n       (string-split paren_string #\\space)))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpenmsd4tv.rkt:10:10: parse_nested_parens_helper: unbound identifier\n\
    \  in: parse_nested_parens_helper\n  location...:\n   /tmp/tmpenmsd4tv.rkt:10:10\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [max_depth 0] [depth 0])\n      (cond [(empty? paren_string) max_depth]\n  \
    \          [(char=? (first paren_string) #\\()\n             (loop (rest paren_string)\n\
    \                   (if (> depth max_depth) depth max_depth)\n               \
    \    (+ depth 1))]\n            [(char=? (first paren_string) #\\))\n        \
    \     (loop (rest paren_string)\n                   (if (> depth max_depth) depth\
    \ max_depth)\n                   (- depth 1))]\n            [else (loop (rest\
    \ paren_string) max_depth depth)])))\n  (map parse_parens (string-split paren_string\
    \ #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyd0mg5dn.rkt:28:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpyd0mg5dn.rkt:29:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpyd0mg5dn.rkt:30:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parens-iter paren_string\
    \ max_level level)\n      (cond [(empty? paren_string) max_level]\n          \
    \  [(char=? (first paren_string) #\\()\n             (parens-iter (rest paren_string)\
    \ (max max_level (add1 level)) (add1 level))]\n            [(char=? (first paren_string)\
    \ #\\))\n             (parens-iter (rest paren_string) (max max_level level) (sub1\
    \ level))]\n            [else (parens-iter (rest paren_string) max_level level)]))\n\
    \    (parens-iter paren_string 0 0))\n  (map parse_parens (string-split paren_string\
    \ #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3fwubt_y.rkt:25:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp3fwubt_y.rkt:26:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp3fwubt_y.rkt:27:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ level)\n      (cond\n        [(empty? paren_string) level]\n        [(equal?\
    \ (first paren_string) #\\() (parse-parens-iter (rest paren_string) (+ level 1))]\n\
    \        [(equal? (first paren_string) #\\)) (parse-parens-iter (rest paren_string)\
    \ (- level 1))]\n        [else (parse-parens-iter (rest paren_string) level)]))\n\
    \    (parse-parens-iter paren_string 0))\n  (map parse_parens (string-split paren_string\
    \ #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv6ipqv42.rkt:24:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpv6ipqv42.rkt:25:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpv6ipqv42.rkt:26:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens-iter paren_string max_depth current_depth)\n \
    \   (cond\n      [(empty? paren_string) (list max_depth)]\n      [(eq? (first\
    \ paren_string) #\\()\n       (parse_nested_parens-iter (rest paren_string) (max\
    \ max_depth (add1 current_depth)) (add1 current_depth))]\n      [(eq? (first paren_string)\
    \ #\\))\n       (parse_nested_parens-iter (rest paren_string) (max max_depth current_depth)\
    \ (sub1 current_depth))]\n      [(eq? (first paren_string) #\\space)\n       (cons\
    \ max_depth (parse_nested_parens-iter (rest paren_string) 0 0))]))\n  (parse_nested_parens-iter\
    \ paren_string 0 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpdtbl41w1.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpdtbl41w1.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpdtbl41w1.rkt:27:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens-helper paren_string acc)\n    (cond\n      [(empty? paren_string)\
    \ acc]\n      [(equal? (first paren_string) #\\()\n       (parse-parens-helper\
    \ (rest paren_string) (add1 acc))]\n      [(equal? (first paren_string) #\\))\n\
    \       (parse-parens-helper (rest paren_string) (sub1 acc))]\n      [else (parse-parens-helper\
    \ (rest paren_string) acc)]))\n  (define (parse-parens-helper2 paren_string acc)\n\
    \    (cond\n      [(empty? paren_string) acc]\n      [(equal? (first paren_string)\
    \ #\\space)\n       (parse-parens-helper2 (rest paren_string) (cons (parse-parens-helper\
    \ (rest paren_string) 0) acc))]\n      [else (parse-parens-helper2 (rest paren_string)\
    \ acc)]))\n  (parse-parens-helper2 paren_string '()))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmk8e4c0g.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpmk8e4c0g.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpmk8e4c0g.rkt:32:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_iter paren_string\
    \ max_depth depth)\n      (cond\n        [(empty? paren_string) (list max_depth)]\n\
    \        [(char=? (first paren_string) #\\()\n         (parse_parens_iter (rest\
    \ paren_string) (max max_depth (add1 depth)) (add1 depth))]\n        [(char=?\
    \ (first paren_string) #\\))\n         (parse_parens_iter (rest paren_string)\
    \ (max max_depth depth) (sub1 depth))]\n        [else (parse_parens_iter (rest\
    \ paren_string) max_depth depth)]))\n    (parse_parens_iter paren_string 0 0))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwie2mls5.rkt:26:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwie2mls5.rkt:27:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwie2mls5.rkt:28:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-helper paren_string\
    \ level)\n      (cond\n        [(empty? paren_string) level]\n        [(char=?\
    \ (first paren_string) #\\() (parse-parens-helper (rest paren_string) (+ level\
    \ 1))]\n        [(char=? (first paren_string) #\\)) (parse-parens-helper (rest\
    \ paren_string) (- level 1))]\n        [else (parse-parens-helper (rest paren_string)\
    \ level)]))\n    (parse-parens-helper paren_string 0))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6ae0i0nw.rkt:24:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6ae0i0nw.rkt:25:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6ae0i0nw.rkt:26:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string level)\n    (cond\n      [(empty? paren_string)\
    \ level]\n      [(equal? (first paren_string) #\\()\n       (parse_parens (rest\
    \ paren_string) (+ level 1))]\n      [(equal? (first paren_string) #\\))\n   \
    \    (parse_parens (rest paren_string) (- level 1))]\n      [else (parse_parens\
    \ (rest paren_string) level)]))\n  (define (parse_parens_list paren_string level)\n\
    \    (cond\n      [(empty? paren_string) (list level)]\n      [(equal? (first\
    \ paren_string) #\\ )\n       (cons level (parse_parens_list (rest paren_string)\
    \ 0))]\n      [(equal? (first paren_string) #\\()\n       (parse_parens_list (rest\
    \ paren_string) (+ level 1))]\n      [(equal? (first paren_string) #\\))\n   \
    \    (parse_parens_list (rest paren_string) (- level 1))]\n      [else (parse_parens_list\
    \ (rest paren_string) level)]))\n  (parse_parens_list paren_string 0))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkmaj7qrl.rkt:34:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkmaj7qrl.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpkmaj7qrl.rkt:36:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [current_depth 0])\n           (cond [(empty? paren_group) max_depth]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) max_depth (+ current_depth 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group) (max max_depth\
    \ current_depth) (- current_depth 1))]\n                 [else (loop (rest paren_group)\
    \ max_depth current_depth)])))\n       (regexp-split #rx\" \" paren_string)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbkaf2gw6.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbkaf2gw6.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbkaf2gw6.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens-helper paren_string max-level)\n    (cond\n      [(empty?\
    \ paren_string) max-level]\n      [(string=? (first paren_string) \"(\") (parse-parens-helper\
    \ (rest paren_string) (+ max-level 1))]\n      [(string=? (first paren_string)\
    \ \")\") (parse-parens-helper (rest paren_string) (- max-level 1))]\n      [else\
    \ (parse-parens-helper (rest paren_string) max-level)]))\n  (parse-parens-helper\
    \ paren_string 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp5zstyw3h.rkt:22:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5zstyw3h.rkt:23:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmp5zstyw3h.rkt:24:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [nesting\
    \ 0] [max_nesting 0])\n           (cond [(empty? paren_group) max_nesting]\n \
    \                [(equal? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ nesting 1) (max nesting max_nesting))]\n                 [(equal?\
    \ (first paren_group) #\\))\n                  (loop (rest paren_group) (- nesting\
    \ 1) (max nesting max_nesting))]\n                 [else (loop (rest paren_group)\
    \ nesting max_nesting)])))\n       (split-string paren_string)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpvs_2ycds.rkt:17:8: split-string: unbound identifier\n  in: split-string\n\
    \  location...:\n   /tmp/tmpvs_2ycds.rkt:17:8\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_level\
    \ 0] [cur_level 0])\n           (cond [(empty? paren_group) max_level]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group)\n                        (if (> cur_level max_level)\n        \
    \                    cur_level\n                            max_level)\n     \
    \                   (+ cur_level 1))]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group)\n                        (if\
    \ (> cur_level max_level)\n                            cur_level\n           \
    \                 max_level)\n                        (- cur_level 1))]\n    \
    \             [else (loop (rest paren_group) max_level cur_level)])))\n      \
    \ (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwxrc5q6e.rkt:32:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwxrc5q6e.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwxrc5q6e.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ max-level level)\n      (cond\n        [(empty? paren_string) max-level]\n \
    \       [(char=? (first paren_string) #\\()\n         (parse-parens-iter (rest\
    \ paren_string) (max max-level (add1 level)) (add1 level))]\n        [(char=?\
    \ (first paren_string) #\\))\n         (parse-parens-iter (rest paren_string)\
    \ (max max-level level) (sub1 level))]\n        [else (parse-parens-iter (rest\
    \ paren_string) max-level level)]))\n    (parse-parens-iter paren_string 0 0))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjc0xi_c6.rkt:26:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpjc0xi_c6.rkt:27:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpjc0xi_c6.rkt:28:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (let loop ([paren_string paren_string] [paren_stack '()] [max_depth 0] [current_depth\
    \ 0])\n    (cond [(empty? paren_string)\n           (list max_depth)]\n      \
    \    [(char=? (first paren_string) #\\()\n           (loop (rest paren_string)\
    \ (cons #\\( paren_stack)\n                 (if (> current_depth max_depth)\n\
    \                     (add1 current_depth)\n                     max_depth)\n\
    \                 (add1 current_depth))]\n          [(char=? (first paren_string)\
    \ #\\))\n           (loop (rest paren_string) (rest paren_stack)\n           \
    \      (if (> current_depth max_depth)\n                     (add1 current_depth)\n\
    \                     max_depth)\n                 (sub1 current_depth))]\n  \
    \        [else\n           (loop (rest paren_string) paren_stack max_depth current_depth)])))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmppd7lp6_x.rkt:32:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmppd7lp6_x.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmppd7lp6_x.rkt:34:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let ([paren_group_list (string->list\
    \ paren_group)])\n           (let loop ([paren_group_list paren_group_list]\n\
    \                      [max_depth 0]\n                      [current_depth 0])\n\
    \             (cond [(empty? paren_group_list) max_depth]\n                  \
    \ [(char=? (first paren_group_list) #\\()\n                    (loop (rest paren_group_list)\n\
    \                          (max max_depth (add1 current_depth))\n            \
    \              (add1 current_depth))]\n                   [(char=? (first paren_group_list)\
    \ #\\))\n                    (loop (rest paren_group_list)\n                 \
    \         max_depth\n                          (sub1 current_depth))]\n      \
    \             [else (loop (rest paren_group_list)\n                          \
    \     max_depth\n                               current_depth)]))))\n       (string-split\
    \ paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string level)\n    (cond\n      [(empty? paren_string)\
    \ level]\n      [(equal? (first paren_string) #\\() (parse_parens (rest paren_string)\
    \ (+ level 1))]\n      [(equal? (first paren_string) #\\)) (parse_parens (rest\
    \ paren_string) (- level 1))]\n      [else (parse_parens (rest paren_string) level)]))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2zjht9r6.rkt:22:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp2zjht9r6.rkt:23:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2zjht9r6.rkt:24:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string)\n    (define (parse-parens-iter paren-string\
    \ max-depth depth)\n      (cond\n        [(empty? paren-string) max-depth]\n \
    \       [(char=? (first paren-string) #\\()\n         (parse-parens-iter (rest\
    \ paren-string) (max max-depth (+ depth 1)) (+ depth 1))]\n        [(char=? (first\
    \ paren-string) #\\))\n         (parse-parens-iter (rest paren-string) (max max-depth\
    \ depth) (- depth 1))]\n        [else (parse-parens-iter (rest paren-string) max-depth\
    \ depth)]))\n    (parse-parens-iter paren-string 0 0))\n  (map parse-parens (string-split\
    \ paren-string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpza34706y.rkt:19:34: paren-string: unbound identifier\n  in: paren-string\n\
    \  location...:\n   /tmp/tmpza34706y.rkt:19:34\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string current_level max_level)\n\
    \    (cond\n      [(empty? paren_string) max_level]\n      [(equal? (first paren_string)\
    \ #\\()\n       (parse_nested_parens_helper (rest paren_string) (+ current_level\
    \ 1) (max max_level current_level))]\n      [(equal? (first paren_string) #\\\
    ))\n       (parse_nested_parens_helper (rest paren_string) (- current_level 1)\
    \ max_level)]\n      [else (parse_nested_parens_helper (rest paren_string) current_level\
    \ max_level)]))\n  (define (parse_nested_parens_helper_2 paren_string current_level\
    \ max_level)\n    (cond\n      [(empty? paren_string) (list max_level)]\n    \
    \  [(equal? (first paren_string) #\\()\n       (parse_nested_parens_helper_2 (rest\
    \ paren_string) (+ current_level 1) (max max_level current_level))]\n      [(equal?\
    \ (first paren_string) #\\))\n       (parse_nested_parens_helper_2 (rest paren_string)\
    \ (- current_level 1) max_level)]\n      [(equal? (first paren_string) #\\space)\n\
    \       (append (list max_level) (parse_nested_parens_helper_2 (rest paren_string)\
    \ 0 0))]\n      [else (parse_nested_parens_helper_2 (rest paren_string) current_level\
    \ max_level)]))\n  (parse_nested_parens_helper_2 paren_string 0 0))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_tvtlebu.rkt:34:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_tvtlebu.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmp_tvtlebu.rkt:36:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string current_max)\n    (cond\n\
    \      [(empty? paren_string) current_max]\n      [(char=? (first paren_string)\
    \ #\\()\n       (parse_nested_parens_helper (rest paren_string) (+ current_max\
    \ 1))]\n      [(char=? (first paren_string) #\\))\n       (parse_nested_parens_helper\
    \ (rest paren_string) (- current_max 1))]\n      [else (parse_nested_parens_helper\
    \ (rest paren_string) current_max)]))\n  (map (lambda (paren_group)\n        \
    \ (parse_nested_parens_helper paren_group 0))\n       (string-split paren_string\
    \ #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgdxhyljb.rkt:26:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpgdxhyljb.rkt:27:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpgdxhyljb.rkt:28:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_level\
    \ 0] [cur_level 0])\n           (cond [(empty? paren_group) max_level]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group)\n                        (if (> (+ cur_level 1) max_level)\n  \
    \                          (+ cur_level 1)\n                            max_level)\n\
    \                        (+ cur_level 1))]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group)\n                        max_level\n\
    \                        (- cur_level 1))]\n                 [else (loop (rest\
    \ paren_group) max_level cur_level)])))\n       (string-split paren_string #\\\
    space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((())) () ((())()())\"\
    ) (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((())) (((())))\") (list\
    \ 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n\
    (test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvprq8lj3.rkt:30:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvprq8lj3.rkt:31:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvprq8lj3.rkt:32:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string current_depth max_depth)\n\
    \    (if (empty? paren_string)\n        max_depth\n        (cond\n         [(equal?\
    \ (first paren_string) #\\()\n          (parse_nested_parens_helper (rest paren_string)\
    \ (+ current_depth 1) (max max_depth current_depth))]\n         [(equal? (first\
    \ paren_string) #\\))\n          (parse_nested_parens_helper (rest paren_string)\
    \ (- current_depth 1) max_depth)]\n         [else\n          (parse_nested_parens_helper\
    \ (rest paren_string) current_depth max_depth)])))\n  (define (parse_nested_parens_helper_2\
    \ paren_string current_depth max_depth)\n    (if (empty? paren_string)\n     \
    \   (list max_depth)\n        (cond\n         [(equal? (first paren_string) #\\\
    ()\n          (parse_nested_parens_helper_2 (rest paren_string) (+ current_depth\
    \ 1) (max max_depth current_depth))]\n         [(equal? (first paren_string) #\\\
    ))\n          (parse_nested_parens_helper_2 (rest paren_string) (- current_depth\
    \ 1) max_depth)]\n         [else\n          (if (equal? (first paren_string) #\\\
    \ )\n              (cons max_depth (parse_nested_parens_helper_2 (rest paren_string)\
    \ 0 0))\n              (parse_nested_parens_helper_2 (rest paren_string) current_depth\
    \ max_depth))])))\n  (parse_nested_parens_helper_2 paren_string 0 0))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6e42zqcd.rkt:38:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6e42zqcd.rkt:39:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmp6e42zqcd.rkt:40:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (parse_parens paren_group 0))\n      \
    \ (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp5iyquuuj.rkt:10:10: parse_parens: unbound identifier\n  in: parse_parens\n\
    \  location...:\n   /tmp/tmp5iyquuuj.rkt:10:10\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [paren_count 0] [max_paren_count 0])\n      (cond [(empty? paren_string) max_paren_count]\n\
    \            [(char=? (first paren_string) #\\()\n             (loop (rest paren_string)\
    \ (+ paren_count 1) (max paren_count max_paren_count))]\n            [(char=?\
    \ (first paren_string) #\\))\n             (loop (rest paren_string) (- paren_count\
    \ 1) max_paren_count)]\n            [else (loop (rest paren_string) paren_count\
    \ max_paren_count)])))\n  (map parse_parens (string-split paren_string #\\space)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmps3wrv152.rkt:24:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmps3wrv152.rkt:25:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmps3wrv152.rkt:26:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ level max-level)\n      (cond [(empty? paren_string) max-level]\n          \
    \  [(char=? (first paren_string) #\\()\n             (parse-parens-iter (rest\
    \ paren_string) (+ level 1) (max level max-level))]\n            [(char=? (first\
    \ paren_string) #\\))\n             (parse-parens-iter (rest paren_string) (-\
    \ level 1) (max level max-level))]\n            [else (parse-parens-iter (rest\
    \ paren_string) level max-level)]))\n    (parse-parens-iter paren_string 0 0))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp527hidoc.rkt:25:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp527hidoc.rkt:26:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp527hidoc.rkt:27:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ level max-level)\n      (cond\n        [(empty? paren_string) max-level]\n \
    \       [(char=? (first paren_string) #\\()\n         (parse-parens-iter (rest\
    \ paren_string) (+ level 1) (max level max-level))]\n        [(char=? (first paren_string)\
    \ #\\))\n         (parse-parens-iter (rest paren_string) (- level 1) (max level\
    \ max-level))]\n        [else (parse-parens-iter (rest paren_string) level max-level)]))\n\
    \    (parse-parens-iter paren_string 0 0))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgofr2pcd.rkt:26:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpgofr2pcd.rkt:27:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpgofr2pcd.rkt:28:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [current_depth 0])\n           (cond [(empty? paren_group)\n            \
    \      (max max_depth current_depth)]\n                 [(char=? (first paren_group)\
    \ #\\()\n                  (loop (rest paren_group)\n                        max_depth\n\
    \                        (+ current_depth 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group)\n           \
    \             (max max_depth current_depth)\n                        (- current_depth\
    \ 1))]\n                 [else\n                  (loop (rest paren_group)\n \
    \                       max_depth\n                        current_depth)])))\n\
    \       (regexp-split #rx\" \" paren_string)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8yp2u444.rkt:32:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8yp2u444.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8yp2u444.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (define (count_parens paren_group)\n \
    \          (cond [(empty? paren_group) 0]\n                 [(equal? (first paren_group)\
    \ #\\() (+ 1 (count_parens (rest paren_group)))]\n                 [(equal? (first\
    \ paren_group) #\\)) (- 1 (count_parens (rest paren_group)))]))\n         (count_parens\
    \ paren_group))\n       (string-split paren_string)))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpt6qvfkb9.rkt:22:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpt6qvfkb9.rkt:23:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpt6qvfkb9.rkt:24:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [nesting\
    \ 0] [max-nesting 0])\n           (cond [(empty? paren_group) max-nesting]\n \
    \                [else (let ([c (first paren_group)])\n                      \
    \   (cond [(char=? c #\\()\n                                (loop (rest paren_group)\
    \ (+ nesting 1) (max max-nesting nesting))]\n                               [(char=?\
    \ c #\\))\n                                (loop (rest paren_group) (- nesting\
    \ 1))]\n                               [else (loop (rest paren_group) nesting\
    \ max-nesting)]))])))\n       (string-split paren_string)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgk9wllfb.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpgk9wllfb.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpgk9wllfb.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (parse_nested_parens_helper paren_group\
    \ 0))\n       (string-split paren_string #\\space)))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpm8n7x67p.rkt:10:10: parse_nested_parens_helper: unbound identifier\n\
    \  in: parse_nested_parens_helper\n  location...:\n   /tmp/tmpm8n7x67p.rkt:10:10\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [level\
    \ 0] [max_level 0])\n           (cond [(empty? paren_group) max_level]\n     \
    \            [(eq? (first paren_group) #\\()\n                  (loop (rest paren_group)\
    \ (+ level 1) (max level max_level))]\n                 [(eq? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group) (- level 1) (max level max_level))]\n\
    \                 [else (loop (rest paren_group) level max_level)])))\n      \
    \ (regexp-split #rx\" \" paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpm0qvs387.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpm0qvs387.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpm0qvs387.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string acc)\n    (cond\n      [(empty? paren_string)\
    \ (reverse acc)]\n      [(string=? (first paren_string) \"(\")\n       (parse_parens\
    \ (rest paren_string) (cons 1 acc))]\n      [(string=? (first paren_string) \"\
    )\")\n       (parse_parens (rest paren_string) (cons (add1 (first acc)) (rest\
    \ acc)))]\n      [(string=? (first paren_string) \" \")\n       (parse_parens\
    \ (rest paren_string) (cons 0 acc))]))\n  (parse_parens paren_string '()))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_idwa1z6.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_idwa1z6.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmp_idwa1z6.rkt:27:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens-helper paren_string current_level max_level)\n    (cond\n\
    \      [(empty? paren_string) max_level]\n      [(eq? (first paren_string) #\\\
    ()\n       (parse-parens-helper (rest paren_string) (+ current_level 1) (max max_level\
    \ current_level))]\n      [(eq? (first paren_string) #\\))\n       (parse-parens-helper\
    \ (rest paren_string) (- current_level 1) max_level)]\n      [else (parse-parens-helper\
    \ (rest paren_string) current_level max_level)]))\n  (define (parse-parens-group-helper\
    \ paren_string)\n    (cond\n      [(empty? paren_string) '()]\n      [(eq? (first\
    \ paren_string) #\\()\n       (cons (parse-parens-helper paren_string 0 0) (parse-parens-group-helper\
    \ (rest paren_string)))]\n      [else (parse-parens-group-helper (rest paren_string))]))\n\
    \  (parse-parens-group-helper paren_string))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnhyv460y.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpnhyv460y.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpnhyv460y.rkt:32:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string paren_count)\n    (cond\n      [(empty?\
    \ paren_string) paren_count]\n      [(string=? (first paren_string) \"(\") (parse_parens\
    \ (rest paren_string) (+ paren_count 1))]\n      [(string=? (first paren_string)\
    \ \")\") (parse_parens (rest paren_string) (- paren_count 1))]\n      [else (parse_parens\
    \ (rest paren_string) paren_count)]))\n  (map (lambda (paren_group) (parse_parens\
    \ paren_group 0)) (string-split paren_string)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpproe_2ek.rkt:22:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpproe_2ek.rkt:23:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpproe_2ek.rkt:24:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string max_depth)\n    (cond\n  \
    \    [(empty? paren_string) max_depth]\n      [(char=? (first paren_string) #\\\
    ()\n       (parse_nested_parens_helper (rest paren_string) (+ max_depth 1))]\n\
    \      [(char=? (first paren_string) #\\))\n       (parse_nested_parens_helper\
    \ (rest paren_string) (- max_depth 1))]\n      [else (parse_nested_parens_helper\
    \ (rest paren_string) max_depth)]))\n  (parse_nested_parens_helper paren_string\
    \ 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((())) () ((())()())\"\
    ) (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((())) (((())))\") (list\
    \ 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n\
    (test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb4i5g3od.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb4i5g3od.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpb4i5g3od.rkt:26:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ count max-count)\n      (cond\n        [(empty? paren_string) max-count]\n \
    \       [(char=? (first paren_string) #\\()\n         (parse-parens-iter (rest\
    \ paren_string) (+ count 1) (max count max-count))]\n        [(char=? (first paren_string)\
    \ #\\))\n         (parse-parens-iter (rest paren_string) (- count 1) (max count\
    \ max-count))]\n        [else (parse-parens-iter (rest paren_string) count max-count)]))\n\
    \    (parse-parens-iter paren_string 0 0))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpho9w378e.rkt:26:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpho9w378e.rkt:27:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpho9w378e.rkt:28:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ level)\n      (cond\n        [(empty? paren_string) level]\n        [(char=?\
    \ (first paren_string) #\\() (parse-parens-iter (rest paren_string) (+ level 1))]\n\
    \        [(char=? (first paren_string) #\\)) (parse-parens-iter (rest paren_string)\
    \ (- level 1))]\n        [else (parse-parens-iter (rest paren_string) level)]))\n\
    \    (parse-parens-iter paren_string 0))\n  (map parse_parens (string-split paren_string)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_kfkp73t.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_kfkp73t.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_kfkp73t.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string)\n    (cond\n      [(empty? paren-string)\
    \ 0]\n      [(string=? (first paren-string) \"(\")\n       (add1 (parse-parens\
    \ (rest paren-string)))]\n      [(string=? (first paren-string) \")\")\n     \
    \  (sub1 (parse-parens (rest paren-string)))]\n      [else (parse-parens (rest\
    \ paren-string))]))\n  (map parse-parens (string-split paren_string)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_0rcjpoh.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_0rcjpoh.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_0rcjpoh.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ level)\n      (cond ((null? paren_string) level)\n            ((char=? (car\
    \ paren_string) #\\() (parse-parens-iter (cdr paren_string) (+ level 1)))\n  \
    \          ((char=? (car paren_string) #\\)) (parse-parens-iter (cdr paren_string)\
    \ (- level 1)))\n            (else (parse-parens-iter (cdr paren_string) level))))\n\
    \    (parse-parens-iter paren_string 0))\n  (map parse_parens (string-split paren_string)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfczoxgb1.rkt:23:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"(()())\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfczoxgb1.rkt:24:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"()\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfczoxgb1.rkt:25:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"(()(())((())))\"\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ depth max-depth)\n      (cond ((null? paren_string) max-depth)\n           \
    \ ((char=? (car paren_string) #\\()\n             (parse-parens-iter (cdr paren_string)\
    \ (+ depth 1) (max depth max-depth)))\n            ((char=? (car paren_string)\
    \ #\\))\n             (parse-parens-iter (cdr paren_string) (- depth 1) (max depth\
    \ max-depth)))\n            (else (parse-parens-iter (cdr paren_string) depth\
    \ max-depth))))\n    (parse-parens-iter paren_string 0 0))\n  (map parse_parens\
    \ (string-split paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnp4yv9i0.rkt:25:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpnp4yv9i0.rkt:26:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpnp4yv9i0.rkt:27:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [current_depth 0])\n           (cond [(empty? paren_group) max_depth]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) max_depth (+ current_depth 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group) (max max_depth\
    \ current_depth) (- current_depth 1))]\n                 [else (loop (rest paren_group)\
    \ max_depth current_depth)])))\n       (regexp-split #rx\" +\" paren_string)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpuumr6mcw.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpuumr6mcw.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpuumr6mcw.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ max-level level)\n      (cond\n        [(empty? paren_string) (values max-level\
    \ level)]\n        [(char=? (first paren_string) #\\() (parse-parens-iter (rest\
    \ paren_string) (max max-level (add1 level)) (add1 level))]\n        [(char=?\
    \ (first paren_string) #\\)) (parse-parens-iter (rest paren_string) max-level\
    \ (sub1 level))]\n        [else (parse-parens-iter (rest paren_string) max-level\
    \ level)]))\n    (parse-parens-iter paren_string 0 0))\n  (define (parse-parens-iter\
    \ paren_string max-level level)\n    (cond\n      [(empty? paren_string) (values\
    \ max-level level)]\n      [(char=? (first paren_string) #\\() (parse-parens-iter\
    \ (rest paren_string) (max max-level (add1 level)) (add1 level))]\n      [(char=?\
    \ (first paren_string) #\\)) (parse-parens-iter (rest paren_string) max-level\
    \ (sub1 level))]\n      [else (parse-parens-iter (rest paren_string) max-level\
    \ level)]))\n  (define (parse-parens-iter paren_string max-level level)\n    (cond\n\
    \      [(empty? paren_string) (values max-level level)]\n      [(char=? (first\
    \ paren_string) #\\() (parse-parens-iter (rest paren_string) (max max-level (add1\
    \ level)) (add1 level))]\n      [(char=? (first paren_string) #\\)) (parse-parens-iter\
    \ (rest paren_string) max-level (sub1 level))]\n      [else (parse-parens-iter\
    \ (rest paren_string) max-level level)]))\n  (define (parse-parens-iter paren_string\
    \ max-level level)\n    (cond\n      [(empty? paren_\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp0huf2idu.rkt:31:7: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 32\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (\u03BB (paren_group)\n         (let loop ([paren_group paren_group] [max-level\
    \ 0] [cur-level 0])\n           (cond [(empty? paren_group) max-level]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group)\n                        (max max-level (add1 cur-level))\n   \
    \                     (add1 cur-level))]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group)\n                        max-level\n\
    \                        (sub1 cur-level))]\n                 [else (loop (rest\
    \ paren_group)\n                             max-level\n                     \
    \        cur-level)])))\n       (string-split paren_string #\\space)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpijoyrqjk.rkt:30:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpijoyrqjk.rkt:31:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpijoyrqjk.rkt:32:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [level\
    \ 0] [max_level 0])\n           (cond [(empty? paren_group) max_level]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ level 1) (if (> level max_level) level max_level))]\n      \
    \           [(char=? (first paren_group) #\\))\n                  (loop (rest\
    \ paren_group) (- level 1) max_level)]\n                 [else (loop (rest paren_group)\
    \ level max_level)])))\n       (string-split paren_string)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp376z999z.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp376z999z.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp376z999z.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens-helper paren_string current_level max_level)\n    (cond\n\
    \      [(null? paren_string) max_level]\n      [(equal? (car paren_string) #\\\
    ()\n       (parse-parens-helper (cdr paren_string) (+ current_level 1) (max max_level\
    \ current_level))]\n      [(equal? (car paren_string) #\\))\n       (parse-parens-helper\
    \ (cdr paren_string) (- current_level 1) max_level)]\n      [else (parse-parens-helper\
    \ (cdr paren_string) current_level max_level)]))\n  (define (parse-parens-group\
    \ paren_string)\n    (define (parse-parens-group-helper paren_string current_level\
    \ max_level)\n      (cond\n        [(null? paren_string) (list max_level)]\n \
    \       [(equal? (car paren_string) #\\()\n         (parse-parens-group-helper\
    \ (cdr paren_string) (+ current_level 1) (max max_level current_level))]\n   \
    \     [(equal? (car paren_string) #\\))\n         (parse-parens-group-helper (cdr\
    \ paren_string) (- current_level 1) max_level)]\n        [(equal? (car paren_string)\
    \ #\\space)\n         (append (list max_level) (parse-parens-group (cdr paren_string)))]\n\
    \        [else (parse-parens-group-helper (cdr paren_string) current_level max_level)]))\n\
    \    (parse-parens-group-helper paren_string 0 0))\n  (parse-parens-group paren_string))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf166d90u.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"(()()) ((())) () ((())()())\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpf166d90u.rkt:37:4\n\ncar: contract violation\n  expected:\
    \ pair?\n  given: \"() (()) ((())) (((())))\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpf166d90u.rkt:38:4\n\ncar:\
    \ contract violation\n  expected: pair?\n  given: \"(()(())((())))\"\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ level)\n      (cond\n        [(empty? paren_string) level]\n        [(char=?\
    \ (first paren_string) #\\() (parse-parens-iter (rest paren_string) (+ level 1))]\n\
    \        [(char=? (first paren_string) #\\)) (parse-parens-iter (rest paren_string)\
    \ (- level 1))]\n        [else (parse-parens-iter (rest paren_string) level)]))\n\
    \    (parse-parens-iter paren_string 0))\n  (map parse_parens (string-split paren_string)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbly9chii.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbly9chii.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbly9chii.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string acc)\n    (cond\n      [(empty?\
    \ paren_string) (reverse acc)]\n      [(string=? (first paren_string) \"(\")\n\
    \       (parse_nested_parens_helper (rest paren_string) (cons 1 acc))]\n     \
    \ [(string=? (first paren_string) \")\")\n       (parse_nested_parens_helper (rest\
    \ paren_string) (cons (add1 (first acc)) (rest acc)))]\n      [(string=? (first\
    \ paren_string) \" \")\n       (parse_nested_parens_helper (rest paren_string)\
    \ (cons 0 acc))]))\n  (parse_nested_parens_helper paren_string (list)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpluybigth.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpluybigth.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpluybigth.rkt:27:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string)\n    (define (parse-parens-iter paren-string\
    \ level)\n      (cond ((empty? paren-string) level)\n            ((char=? (first\
    \ paren-string) #\\()\n             (parse-parens-iter (rest paren-string) (+\
    \ level 1)))\n            ((char=? (first paren-string) #\\))\n             (parse-parens-iter\
    \ (rest paren-string) (- level 1)))))\n    (parse-parens-iter paren-string 0))\n\
    \  (map parse-parens (string-split paren_string #\\space)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpy0cvc1mj.rkt:24:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpy0cvc1mj.rkt:25:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpy0cvc1mj.rkt:26:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string max_depth)\n    (cond\n  \
    \    [(empty? paren_string) max_depth]\n      [(eq? (first paren_string) #\\()\n\
    \       (parse_nested_parens_helper (rest paren_string) (+ max_depth 1))]\n  \
    \    [(eq? (first paren_string) #\\))\n       (parse_nested_parens_helper (rest\
    \ paren_string) (- max_depth 1))]\n      [else (parse_nested_parens_helper (rest\
    \ paren_string) max_depth)]))\n  (define (parse_nested_parens_helper_2 paren_string\
    \ max_depth)\n    (cond\n      [(empty? paren_string) (list max_depth)]\n    \
    \  [(eq? (first paren_string) #\\ )\n       (cons max_depth (parse_nested_parens_helper_2\
    \ (rest paren_string) 0))]\n      [(eq? (first paren_string) #\\()\n       (parse_nested_parens_helper_2\
    \ (rest paren_string) (+ max_depth 1))]\n      [(eq? (first paren_string) #\\\
    ))\n       (parse_nested_parens_helper_2 (rest paren_string) (- max_depth 1))]\n\
    \      [else (parse_nested_parens_helper_2 (rest paren_string) max_depth)]))\n\
    \  (parse_nested_parens_helper_2 paren_string 0))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwgabwnre.rkt:34:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwgabwnre.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpwgabwnre.rkt:36:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string level max_level)\n    (cond\n\
    \      [(empty? paren_string) max_level]\n      [(char=? (first paren_string)\
    \ #\\()\n       (parse_nested_parens_helper (rest paren_string) (+ level 1) (max\
    \ level max_level))]\n      [(char=? (first paren_string) #\\))\n       (parse_nested_parens_helper\
    \ (rest paren_string) (- level 1) (max level max_level))]\n      [else (parse_nested_parens_helper\
    \ (rest paren_string) level max_level)]))\n  (map (lambda (paren_group) (parse_nested_parens_helper\
    \ paren_group 0 0)) (string-split paren_string)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmplp1it8fn.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplp1it8fn.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplp1it8fn.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string)\n    (define (parse-parens-iter paren-string\
    \ count max-count)\n      (cond\n        [(empty? paren-string) max-count]\n \
    \       [(char=? (first paren-string) #\\()\n         (parse-parens-iter (rest\
    \ paren-string) (+ count 1) (max count max-count))]\n        [(char=? (first paren-string)\
    \ #\\))\n         (parse-parens-iter (rest paren-string) (- count 1) (max count\
    \ max-count))]\n        [else (parse-parens-iter (rest paren-string) count max-count)]))\n\
    \    (parse-parens-iter paren-string 0 0))\n  (map parse-parens (string-split\
    \ paren-string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp0jiv5e51.rkt:19:34: paren-string: unbound identifier\n  in: paren-string\n\
    \  location...:\n   /tmp/tmp0jiv5e51.rkt:19:34\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string paren-count)\n    (cond\n      [(empty?\
    \ paren-string) (list paren-count)]\n      [(char=? (first paren-string) #\\()\n\
    \       (parse-parens (rest paren-string) (+ paren-count 1))]\n      [(char=?\
    \ (first paren-string) #\\))\n       (parse-parens (rest paren-string) (- paren-count\
    \ 1))]\n      [(char=? (first paren-string) #\\space)\n       (cons paren-count\
    \ (parse-parens (rest paren-string) paren-count))]))\n  (parse-parens paren_string\
    \ 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((())) () ((())()())\"\
    ) (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((())) (((())))\") (list\
    \ 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n\
    (test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgglebfh6.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpgglebfh6.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpgglebfh6.rkt:27:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string)\n    (let loop ([paren-string paren-string]\
    \ [level 0] [max-level 0])\n      (cond [(empty? paren-string) max-level]\n  \
    \          [(char=? (first paren-string) #\\()\n             (loop (rest paren-string)\
    \ (+ level 1) (max level max-level))]\n            [(char=? (first paren-string)\
    \ #\\))\n             (loop (rest paren-string) (- level 1) (max level max-level))]\n\
    \            [else (loop (rest paren-string) level max-level)])))\n  (map parse-parens\
    \ (string-split paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpuf2fp4i0.rkt:24:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpuf2fp4i0.rkt:25:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpuf2fp4i0.rkt:26:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string max_depth)\n    (cond\n  \
    \    [(empty? paren_string) max_depth]\n      [(char=? (first paren_string) #\\\
    ()\n       (parse_nested_parens_helper (rest paren_string) (+ max_depth 1))]\n\
    \      [(char=? (first paren_string) #\\))\n       (parse_nested_parens_helper\
    \ (rest paren_string) (- max_depth 1))]\n      [else (parse_nested_parens_helper\
    \ (rest paren_string) max_depth)]))\n  (map (lambda (paren_group)\n         (parse_nested_parens_helper\
    \ paren_group 0))\n       (string-split paren_string #\\space)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4_t33jbk.rkt:26:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp4_t33jbk.rkt:27:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp4_t33jbk.rkt:28:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string current_level max_level)\n\
    \    (cond\n      [(empty? paren_string) max_level]\n      [(equal? (first paren_string)\
    \ #\\()\n       (parse_nested_parens_helper (rest paren_string) (+ current_level\
    \ 1) (max max_level current_level))]\n      [(equal? (first paren_string) #\\\
    ))\n       (parse_nested_parens_helper (rest paren_string) (- current_level 1)\
    \ max_level)]\n      [else (parse_nested_parens_helper (rest paren_string) current_level\
    \ max_level)]))\n  (map (lambda (paren_group) (parse_nested_parens_helper paren_group\
    \ 0 0)) (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzr0c7ufe.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzr0c7ufe.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzr0c7ufe.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [curr_depth 0])\n           (cond [(empty? paren_group) max_depth]\n    \
    \             [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group)\n                        (if (> (+ curr_depth 1) max_depth)\n \
    \                           (+ curr_depth 1)\n                            max_depth)\n\
    \                        (+ curr_depth 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group)\n           \
    \             max_depth\n                        (- curr_depth 1))]\n        \
    \         [else (loop (rest paren_group) max_depth curr_depth)])))\n       (regexp-split\
    \ #rx\" +\" paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpljjv713_.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpljjv713_.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpljjv713_.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_iter paren_string\
    \ count max_count)\n      (cond\n        [(empty? paren_string) max_count]\n \
    \       [(equal? (first paren_string) #\\()\n         (parse_parens_iter (rest\
    \ paren_string) (+ count 1) (max count max_count))]\n        [(equal? (first paren_string)\
    \ #\\))\n         (parse_parens_iter (rest paren_string) (- count 1) (max count\
    \ max_count))]\n        [else (parse_parens_iter (rest paren_string) count max_count)]))\n\
    \    (parse_parens_iter paren_string 0 0))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph9dutvk5.rkt:26:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmph9dutvk5.rkt:27:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmph9dutvk5.rkt:28:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string level)\n    (cond\n      [(empty?\
    \ paren_string) level]\n      [(char=? (first paren_string) #\\()\n       (parse_nested_parens_helper\
    \ (rest paren_string) (+ level 1))]\n      [(char=? (first paren_string) #\\))\n\
    \       (parse_nested_parens_helper (rest paren_string) (- level 1))]\n      [else\
    \ (parse_nested_parens_helper (rest paren_string) level)]))\n  (map (lambda (paren_group)\
    \ (parse_nested_parens_helper paren_group 0)) (string-split paren_string)))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp9gao8k5u.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp9gao8k5u.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp9gao8k5u.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string current_level)\n    (cond\n      [(empty?\
    \ paren_string) (list current_level)]\n      [(equal? (first paren_string) #\\\
    ()\n       (parse_parens (rest paren_string) (+ current_level 1))]\n      [(equal?\
    \ (first paren_string) #\\))\n       (parse_parens (rest paren_string) (- current_level\
    \ 1))]\n      [else (parse_parens (rest paren_string) current_level)]))\n  (define\
    \ (parse_parens_string paren_string)\n    (cond\n      [(empty? paren_string)\
    \ empty]\n      [(equal? (first paren_string) #\\ )\n       (cons (parse_parens\
    \ (rest paren_string) 0)\n             (parse_parens_string (rest paren_string)))]\n\
    \      [else (parse_parens_string (rest paren_string))]))\n  (parse_parens_string\
    \ paren_string))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpaguhiurp.rkt:31:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpaguhiurp.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpaguhiurp.rkt:33:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [current_depth 0])\n           (cond [(empty? paren_group) max_depth]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group)\n                        (if (> current_depth max_depth)\n    \
    \                        current_depth\n                            max_depth)\n\
    \                        (+ current_depth 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group)\n           \
    \             max_depth\n                        (- current_depth 1))]\n     \
    \            [else (loop (rest paren_group) max_depth current_depth)])))\n   \
    \    (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_vu5v45l.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_vu5v45l.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_vu5v45l.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string paren_stack)\n    (cond\n      [(empty?\
    \ paren_string) paren_stack]\n      [(char=? (first paren_string) #\\()\n    \
    \   (parse_parens (rest paren_string) (cons 1 paren_stack))]\n      [(char=? (first\
    \ paren_string) #\\))\n       (parse_parens (rest paren_string) (cons (+ 1 (first\
    \ paren_stack)) (rest paren_stack)))]\n      [else (parse_parens (rest paren_string)\
    \ paren_stack)]))\n  (parse_parens paren_string (list 0)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpo2mza6l6.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpo2mza6l6.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpo2mza6l6.rkt:26:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [current_depth 0])\n           (cond [(empty? paren_group) max_depth]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group)\n                        (if (> current_depth max_depth)\n    \
    \                        current_depth\n                            max_depth)\n\
    \                        (+ current_depth 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group)\n           \
    \             max_depth\n                        (- current_depth 1))]\n     \
    \            [else (loop (rest paren_group) max_depth current_depth)])))\n   \
    \    (split-string paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp_kz0wji9.rkt:23:8: split-string: unbound identifier\n  in: split-string\n\
    \  location...:\n   /tmp/tmp_kz0wji9.rkt:23:8\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (parse_nested_parens_helper paren_group\
    \ 0))\n       (string-split paren_string #\\space)))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp_nq8aprx.rkt:10:10: parse_nested_parens_helper: unbound identifier\n\
    \  in: parse_nested_parens_helper\n  location...:\n   /tmp/tmp_nq8aprx.rkt:10:10\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ level)\n      (cond\n        [(empty? paren_string) level]\n        [(equal?\
    \ (first paren_string) #\\() (parse-parens-iter (rest paren_string) (+ level 1))]\n\
    \        [(equal? (first paren_string) #\\)) (parse-parens-iter (rest paren_string)\
    \ (- level 1))]\n        [else (parse-parens-iter (rest paren_string) level)]))\n\
    \    (parse-parens-iter paren_string 0))\n  (map parse_parens (string-split paren_string\
    \ #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpdh0i4ln1.rkt:24:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpdh0i4ln1.rkt:25:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpdh0i4ln1.rkt:26:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (parse_nested_parens_helper paren_group\
    \ 0))\n       (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpnuddhb99.rkt:10:10: parse_nested_parens_helper: unbound identifier\n\
    \  in: parse_nested_parens_helper\n  location...:\n   /tmp/tmpnuddhb99.rkt:10:10\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string paren_count max_paren_count)\n\
    \    (cond\n      [(empty? paren_string) (list max_paren_count)]\n      [(equal?\
    \ (first paren_string) #\\()\n       (parse_nested_parens_helper (rest paren_string)\
    \ (+ paren_count 1) (max max_paren_count paren_count))]\n      [(equal? (first\
    \ paren_string) #\\))\n       (parse_nested_parens_helper (rest paren_string)\
    \ (- paren_count 1) (max max_paren_count paren_count))]\n      [else (parse_nested_parens_helper\
    \ (rest paren_string) paren_count max_paren_count)]))\n  (parse_nested_parens_helper\
    \ paren_string 0 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp0blnpjav.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp0blnpjav.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmp0blnpjav.rkt:26:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string)\n    (define (parse-parens-iter paren-string\
    \ paren-count)\n      (cond ((null? paren-string) paren-count)\n            ((char=?\
    \ (car paren-string) #\\()\n             (parse-parens-iter (cdr paren-string)\
    \ (+ paren-count 1)))\n            ((char=? (car paren-string) #\\))\n       \
    \      (parse-parens-iter (cdr paren-string) (- paren-count 1)))\n           \
    \ (else (parse-parens-iter (cdr paren-string) paren-count))))\n    (parse-parens-iter\
    \ paren-string 0))\n  (map parse-parens (string-split paren-string)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp_c1yxk0j.rkt:18:34: paren-string: unbound identifier\n  in: paren-string\n\
    \  location...:\n   /tmp/tmp_c1yxk0j.rkt:18:34\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (cond\n      [(empty? paren_string)\
    \ 0]\n      [(equal? (first paren_string) #\\() (add1 (parse_parens (rest paren_string)))]\n\
    \      [(equal? (first paren_string) #\\)) (sub1 (parse_parens (rest paren_string)))]\n\
    \      [else (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp5nep0uru.rkt:22:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5nep0uru.rkt:23:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5nep0uru.rkt:24:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [current_depth 0])\n           (cond [(empty? paren_group) max_depth]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group)\n                        (if (> current_depth max_depth)\n    \
    \                        current_depth\n                            max_depth)\n\
    \                        (+ current_depth 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group)\n           \
    \             max_depth\n                        (- current_depth 1))]\n     \
    \            [else (loop (rest paren_group) max_depth current_depth)])))\n   \
    \    (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptk3d07t3.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmptk3d07t3.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmptk3d07t3.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (\u03BB (paren_group)\n         (let ([paren_group (string->list paren_group)])\n\
    \           (let loop ([paren_group paren_group] [max_depth 0] [current_depth\
    \ 0])\n             (cond [(null? paren_group) max_depth]\n                  \
    \ [(equal? (car paren_group) #\\()\n                    (loop (cdr paren_group)\n\
    \                          (max max_depth (+ current_depth 1))\n             \
    \             (+ current_depth 1))]\n                   [(equal? (car paren_group)\
    \ #\\))\n                    (loop (cdr paren_group)\n                       \
    \   (max max_depth current_depth)\n                          (- current_depth\
    \ 1))]\n                   [else (loop (cdr paren_group)\n                   \
    \            max_depth\n                               current_depth)]))))\n \
    \      (string-split paren_string #\\space)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxfnwllx6.rkt:31:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpxfnwllx6.rkt:32:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpxfnwllx6.rkt:33:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string max_depth current_depth)\n\
    \    (cond\n      [(empty? paren_string) max_depth]\n      [(equal? (first paren_string)\
    \ #\\()\n       (parse_nested_parens_helper (rest paren_string) (max max_depth\
    \ (add1 current_depth)) (add1 current_depth))]\n      [(equal? (first paren_string)\
    \ #\\))\n       (parse_nested_parens_helper (rest paren_string) max_depth (sub1\
    \ current_depth))]\n      [else (parse_nested_parens_helper (rest paren_string)\
    \ max_depth current_depth)]))\n  (define (parse_nested_parens_helper2 paren_string\
    \ max_depth current_depth)\n    (cond\n      [(empty? paren_string) (list max_depth)]\n\
    \      [(equal? (first paren_string) #\\ )\n       (append (list max_depth) (parse_nested_parens_helper2\
    \ (rest paren_string) 0 0))]\n      [(equal? (first paren_string) #\\()\n    \
    \   (parse_nested_parens_helper2 (rest paren_string) (max max_depth (add1 current_depth))\
    \ (add1 current_depth))]\n      [(equal? (first paren_string) #\\))\n       (parse_nested_parens_helper2\
    \ (rest paren_string) max_depth (sub1 current_depth))]\n      [else (parse_nested_parens_helper2\
    \ (rest paren_string) max_depth current_depth)]))\n  (parse_nested_parens_helper2\
    \ paren_string 0 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpgoe633.rkt:34:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkpgoe633.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpkpgoe633.rkt:36:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [current_depth 0])\n           (cond\n             [(empty? paren_group)\
    \ max_depth]\n             [(char=? (first paren_group) #\\()\n              (loop\
    \ (rest paren_group)\n                    (if (> current_depth max_depth)\n  \
    \                      (+ current_depth 1)\n                        max_depth)\n\
    \                    (+ current_depth 1))]\n             [(char=? (first paren_group)\
    \ #\\))\n              (loop (rest paren_group)\n                    max_depth\n\
    \                    (- current_depth 1))]\n             [else (loop (rest paren_group)\
    \ max_depth current_depth)])))\n       (regexp-split #rx\" \" paren_string)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf5w0r1sz.rkt:31:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpf5w0r1sz.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpf5w0r1sz.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ count max)\n      (cond ((empty? paren_string) (values count max))\n       \
    \     ((equal? (first paren_string) #\\()\n             (parse-parens-iter (rest\
    \ paren_string) (+ count 1) (if (> count max) count max)))\n            ((equal?\
    \ (first paren_string) #\\))\n             (parse-parens-iter (rest paren_string)\
    \ (- count 1) (if (> count max) count max)))))\n    (parse-parens-iter paren_string\
    \ 0 0))\n  (define (parse-nested-parens-iter paren_string result)\n    (cond ((empty?\
    \ paren_string) result)\n          ((equal? (first paren_string) #\\ )\n     \
    \      (parse-nested-parens-iter (rest paren_string) (append result (list (parse_parens\
    \ (rest paren_string)))))\n           (parse-nested-parens-iter (rest paren_string)\
    \ (append result (list (parse_parens (rest paren_string))))))))\n  (parse-nested-parens-iter\
    \ paren_string '()))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjpxvi0bf.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpjpxvi0bf.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpjpxvi0bf.rkt:31:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens-helper paren-string paren-count)\n    (cond\n      [(empty?\
    \ paren-string) paren-count]\n      [(equal? (first paren-string) #\\() (parse-parens-helper\
    \ (rest paren-string) (+ paren-count 1))]\n      [(equal? (first paren-string)\
    \ #\\)) (parse-parens-helper (rest paren-string) (- paren-count 1))]\n      [else\
    \ (parse-parens-helper (rest paren-string) paren-count)]))\n  (parse-parens-helper\
    \ paren-string 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpopymzyj1.rkt:15:23: paren-string: unbound identifier\n  in: paren-string\n\
    \  location...:\n   /tmp/tmpopymzyj1.rkt:15:23\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_iter paren_string\
    \ paren_count max_paren_count)\n      (cond\n        [(empty? paren_string) max_paren_count]\n\
    \        [(equal? (first paren_string) #\\()\n         (parse_parens_iter (rest\
    \ paren_string) (+ paren_count 1) (max max_paren_count paren_count))]\n      \
    \  [(equal? (first paren_string) #\\))\n         (parse_parens_iter (rest paren_string)\
    \ (- paren_count 1) (max max_paren_count paren_count))]\n        [else (parse_parens_iter\
    \ (rest paren_string) paren_count max_paren_count)]))\n    (parse_parens_iter\
    \ paren_string 0 0))\n  (define (parse_parens_iter paren_string paren_count max_paren_count)\n\
    \    (cond\n      [(empty? paren_string) (list max_paren_count)]\n      [(equal?\
    \ (first paren_string) #\\ )\n       (append (list max_paren_count) (parse_parens_iter\
    \ (rest paren_string) 0 0))]\n      [else (parse_parens_iter (rest paren_string)\
    \ (parse_parens (first paren_string)) max_paren_count)]))\n  (parse_parens_iter\
    \ paren_string 0 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk7_fgqjh.rkt:32:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpk7_fgqjh.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpk7_fgqjh.rkt:34:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens-iter paren_string\
    \ count max)\n      (cond\n        [(empty? paren_string) (values count max)]\n\
    \        [(equal? (first paren_string) #\\() (parse_parens-iter (rest paren_string)\
    \ (+ count 1) (max count max))]\n        [(equal? (first paren_string) #\\)) (parse_parens-iter\
    \ (rest paren_string) (- count 1) (max count max))]\n        [else (parse_parens-iter\
    \ (rest paren_string) count max)]))\n    (parse_parens-iter paren_string 0 0))\n\
    \  (define (parse_parens-iter paren_string max_list)\n    (cond\n      [(empty?\
    \ paren_string) max_list]\n      [(equal? (first paren_string) #\\ ) (parse_parens-iter\
    \ (rest paren_string) max_list)]\n      [else (parse_parens-iter (rest paren_string)\
    \ (append max_list (list (parse_parens paren_string))))]))\n  (parse_parens-iter\
    \ paren_string '()))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprkrcvjyb.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprkrcvjyb.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmprkrcvjyb.rkt:31:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [paren_stack '()] [max_depth 0])\n      (cond\n        [(empty? paren_string)\
    \ (list (reverse paren_stack) max_depth)]\n        [(char=? (first paren_string)\
    \ #\\()\n         (loop (rest paren_string) (cons #\\( paren_stack) (add1 max_depth))]\n\
    \        [(char=? (first paren_string) #\\))\n         (loop (rest paren_string)\
    \ (rest paren_stack) max_depth)]\n        [else (loop (rest paren_string) paren_stack\
    \ max_depth)])))\n  (let loop ([paren_string paren_string] [paren_stack '()] [max_depth\
    \ 0] [result '()])\n    (cond\n      [(empty? paren_string) (reverse result)]\n\
    \      [(char=? (first paren_string) #\\ )\n       (let ([parsed_parens (parse_parens\
    \ paren_string)])\n         (loop (rest (first parsed_parens)) (second parsed_parens)\
    \ (third parsed_parens) (cons (third parsed_parens) result)))]\n      [else (loop\
    \ (rest paren_string) paren_stack max_depth result)])))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2ogolqkl.rkt:31:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2ogolqkl.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmp2ogolqkl.rkt:33:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [depth 0])\n           (cond [(empty? paren_group) max_depth]\n         \
    \        [(char=? (first paren_group) #\\()\n                  (loop (rest paren_group)\n\
    \                        (if (> (+ depth 1) max_depth)\n                     \
    \       (+ depth 1)\n                            max_depth)\n                \
    \        (+ depth 1))]\n                 [(char=? (first paren_group) #\\))\n\
    \                  (loop (rest paren_group)\n                        max_depth\n\
    \                        (- depth 1))]\n                 [else (loop (rest paren_group)\
    \ max_depth depth)])))\n       (string-split paren_string)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_dpkwxuc.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_dpkwxuc.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_dpkwxuc.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [paren_count 0] [max_paren_count 0])\n      (cond [(empty? paren_string) max_paren_count]\n\
    \            [(char=? (first paren_string) #\\()\n             (loop (rest paren_string)\
    \ (+ paren_count 1) (max paren_count max_paren_count))]\n            [(char=?\
    \ (first paren_string) #\\))\n             (loop (rest paren_string) (- paren_count\
    \ 1) max_paren_count)]\n            [else (loop (rest paren_string) paren_count\
    \ max_paren_count)])))\n  (map parse_parens (string-split paren_string)))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpn_7q1imr.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpn_7q1imr.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpn_7q1imr.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_level\
    \ 0] [current_level 0])\n           (cond [(empty? paren_group) max_level]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) max_level (+ current_level 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group) (max max_level\
    \ current_level) (- current_level 1))]\n                 [else (loop (rest paren_group)\
    \ max_level current_level)])))\n       (string-split paren_string #\\space)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3l_omtxt.rkt:24:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp3l_omtxt.rkt:25:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp3l_omtxt.rkt:26:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [max_depth 0] [depth 0])\n      (cond [(empty? paren_string) max_depth]\n  \
    \          [(char=? (first paren_string) #\\()\n             (loop (rest paren_string)\n\
    \                   (if (> (+ depth 1) max_depth)\n                       (+ depth\
    \ 1)\n                       max_depth)\n                   (+ depth 1))]\n  \
    \          [(char=? (first paren_string) #\\))\n             (loop (rest paren_string)\n\
    \                   max_depth\n                   (- depth 1))]\n            [else\
    \ (loop (rest paren_string) max_depth depth)])))\n  (map parse_parens (string-split\
    \ paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1lt5vkd4.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp1lt5vkd4.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp1lt5vkd4.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string acc)\n    (cond\n      [(empty?\
    \ paren_string) (reverse acc)]\n      [(string=? (first paren_string) \"(\")\n\
    \       (parse_nested_parens_helper (rest paren_string) (cons 1 acc))]\n     \
    \ [(string=? (first paren_string) \")\")\n       (parse_nested_parens_helper (rest\
    \ paren_string) (cons (add1 (first acc)) (rest acc)))]\n      [(string=? (first\
    \ paren_string) \" \")\n       (parse_nested_parens_helper (rest paren_string)\
    \ (cons 0 acc))]))\n  (parse_nested_parens_helper paren_string (list)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp931294pd.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp931294pd.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmp931294pd.rkt:27:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [count\
    \ 0] [max_count 0])\n           (cond [(empty? paren_group) max_count]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ count 1) (if (> count max_count) count max_count))]\n      \
    \           [(char=? (first paren_group) #\\))\n                  (loop (rest\
    \ paren_group) (- count 1) max_count)]\n                 [else (loop (rest paren_group)\
    \ count max_count)])))\n       (regexp-split #rx\" \" paren_string)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2_c1x3fm.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp2_c1x3fm.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2_c1x3fm.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string current_level max_level)\n\
    \    (cond\n      [(empty? paren_string) max_level]\n      [(equal? (first paren_string)\
    \ #\\()\n       (parse_nested_parens_helper (rest paren_string) (+ current_level\
    \ 1) (max current_level max_level))]\n      [(equal? (first paren_string) #\\\
    ))\n       (parse_nested_parens_helper (rest paren_string) (- current_level 1)\
    \ (max current_level max_level))]\n      [else (parse_nested_parens_helper (rest\
    \ paren_string) current_level max_level)]))\n  (define (parse_nested_parens_helper_2\
    \ paren_string current_level max_level)\n    (cond\n      [(empty? paren_string)\
    \ (cons max_level (parse_nested_parens_helper_2 (rest paren_string) 0 0))]\n \
    \     [(equal? (first paren_string) #\\()\n       (parse_nested_parens_helper_2\
    \ (rest paren_string) (+ current_level 1) (max current_level max_level))]\n  \
    \    [(equal? (first paren_string) #\\))\n       (parse_nested_parens_helper_2\
    \ (rest paren_string) (- current_level 1) (max current_level max_level))]\n  \
    \    [(equal? (first paren_string) #\\space)\n       (parse_nested_parens_helper_2\
    \ (rest paren_string) 0 0)]\n      [else (parse_nested_parens_helper_2 (rest paren_string)\
    \ current_level max_level)]))\n  (parse_nested_parens_helper_2 paren_string 0\
    \ 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((())) () ((())()())\"\
    ) (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((())) (((())))\") (list\
    \ 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n\
    (test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp0uglz347.rkt:34:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp0uglz347.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmp0uglz347.rkt:36:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string)\n    (define (parse-parens-iter paren-string\
    \ level)\n      (cond ((null? paren-string) level)\n            ((equal? (car\
    \ paren-string) #\\()\n             (parse-parens-iter (cdr paren-string) (+ level\
    \ 1)))\n            ((equal? (car paren-string) #\\))\n             (parse-parens-iter\
    \ (cdr paren-string) (- level 1)))))\n    (parse-parens-iter paren-string 0))\n\
    \  (map parse-parens (string-split paren_string #\\space)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpww4w63a1.rkt:24:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpww4w63a1.rkt:25:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpww4w63a1.rkt:26:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_iter paren_string\
    \ count max_count)\n      (cond\n        [(empty? paren_string) max_count]\n \
    \       [(equal? (first paren_string) #\\()\n         (parse_parens_iter (rest\
    \ paren_string) (+ count 1) (max count max_count))]\n        [(equal? (first paren_string)\
    \ #\\))\n         (parse_parens_iter (rest paren_string) (- count 1) (max count\
    \ max_count))]\n        [else (parse_parens_iter (rest paren_string) count max_count)]))\n\
    \    (parse_parens_iter paren_string 0 0))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpi1r2pjdd.rkt:26:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpi1r2pjdd.rkt:27:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpi1r2pjdd.rkt:28:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (x) (count-parens x)) (string-split paren_string)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmphphqq0ic.rkt:9:20: count-parens: unbound identifier\n  in: count-parens\n\
    \  location...:\n   /tmp/tmphphqq0ic.rkt:9:20\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group) (parse_nested_parens_helper paren_group 0)) (string-split\
    \ paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpp9aiwi3p.rkt:9:30: parse_nested_parens_helper: unbound identifier\n\
    \  in: parse_nested_parens_helper\n  location...:\n   /tmp/tmpp9aiwi3p.rkt:9:30\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (\u03BB (paren_group)\n         (define (count-parens paren_group count)\n\
    \           (cond [(empty? paren_group) count]\n                 [(char=? (first\
    \ paren_group) #\\() (count-parens (rest paren_group) (+ count 1))]\n        \
    \         [(char=? (first paren_group) #\\)) (count-parens (rest paren_group)\
    \ (- count 1))]\n                 [else (count-parens (rest paren_group) count)]))\n\
    \         (count-parens paren_group 0))\n       (string-split paren_string #\\\
    space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((())) () ((())()())\"\
    ) (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((())) (((())))\") (list\
    \ 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n\
    (test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmplab_gxad.rkt:23:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplab_gxad.rkt:24:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplab_gxad.rkt:25:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_helper paren_string\
    \ level)\n      (cond [(empty? paren_string) level]\n            [(char=? (first\
    \ paren_string) #\\()\n             (parse_parens_helper (rest paren_string) (+\
    \ level 1))]\n            [(char=? (first paren_string) #\\))\n             (parse_parens_helper\
    \ (rest paren_string) (- level 1))]\n            [else (parse_parens_helper (rest\
    \ paren_string) level)]))\n    (parse_parens_helper paren_string 0))\n  (map parse_parens\
    \ (string-split paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmplx3_mgrf.rkt:25:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplx3_mgrf.rkt:26:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplx3_mgrf.rkt:27:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string)\n    (let loop ([paren-string paren-string]\
    \ [paren-count 0] [max-paren-count 0])\n      (cond\n        [(empty? paren-string)\
    \ (list paren-count max-paren-count)]\n        [(char=? (first paren-string) #\\\
    ()\n         (loop (rest paren-string) (+ paren-count 1) (max paren-count max-paren-count))]\n\
    \        [(char=? (first paren-string) #\\))\n         (loop (rest paren-string)\
    \ (- paren-count 1) (max paren-count max-paren-count))]\n        [else (loop (rest\
    \ paren-string) paren-count max-paren-count)])))\n  (map (lambda (paren-string)\
    \ (first (parse-parens paren-string))) (string-split paren_string #\\space)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxs0r30uj.rkt:25:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpxs0r30uj.rkt:26:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpxs0r30uj.rkt:27:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string current_level max_level)\n\
    \    (cond\n      [(empty? paren_string) (list max_level)]\n      [(equal? (first\
    \ paren_string) #\\()\n       (parse_nested_parens_helper (rest paren_string)\
    \ (+ current_level 1) (max max_level current_level))]\n      [(equal? (first paren_string)\
    \ #\\))\n       (parse_nested_parens_helper (rest paren_string) (- current_level\
    \ 1) max_level)]\n      [else (parse_nested_parens_helper (rest paren_string)\
    \ current_level max_level)]))\n  (parse_nested_parens_helper paren_string 0 0))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkfjal17j.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkfjal17j.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpkfjal17j.rkt:26:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_iter paren_string\
    \ max_depth depth)\n      (cond\n        [(empty? paren_string) max_depth]\n \
    \       [(char=? (first paren_string) #\\()\n         (parse_parens_iter (rest\
    \ paren_string)\n                            (if (> depth max_depth) depth max_depth)\n\
    \                            (+ depth 1))]\n        [(char=? (first paren_string)\
    \ #\\))\n         (parse_parens_iter (rest paren_string)\n                   \
    \         (if (> depth max_depth) depth max_depth)\n                         \
    \   (- depth 1))]\n        [else (parse_parens_iter (rest paren_string) max_depth\
    \ depth)]))\n    (parse_parens_iter paren_string 0 0))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ghkvo6i.rkt:30:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7ghkvo6i.rkt:31:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ghkvo6i.rkt:32:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (paren_level paren_string)\n    (let loop ([paren_string paren_string]\
    \ [level 0] [max_level 0])\n      (cond [(empty? paren_string) max_level]\n  \
    \          [(char=? (first paren_string) #\\()\n             (loop (rest paren_string)\
    \ (+ level 1) (max level max_level))]\n            [(char=? (first paren_string)\
    \ #\\))\n             (loop (rest paren_string) (- level 1) (max level max_level))]\n\
    \            [else (loop (rest paren_string) level max_level)])))\n  (map paren_level\
    \ (regexp-split #rx\" \" paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfpxkmbn_.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfpxkmbn_.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfpxkmbn_.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [level\
    \ 0] [max_level 0])\n           (cond [(empty? paren_group) max_level]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ level 1) (if (> level max_level) level max_level))]\n      \
    \           [(char=? (first paren_group) #\\))\n                  (loop (rest\
    \ paren_group) (- level 1) max_level)]\n                 [else (loop (rest paren_group)\
    \ level max_level)])))\n       (regexp-split #rx\" \" paren_string)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpdkj760kc.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpdkj760kc.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpdkj760kc.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_iter paren_string\
    \ paren_count max_paren_count)\n      (cond\n        [(empty? paren_string) max_paren_count]\n\
    \        [(equal? (first paren_string) #\\()\n         (parse_parens_iter (rest\
    \ paren_string) (+ paren_count 1) (max paren_count max_paren_count))]\n      \
    \  [(equal? (first paren_string) #\\))\n         (parse_parens_iter (rest paren_string)\
    \ (- paren_count 1) (max paren_count max_paren_count))]\n        [else (parse_parens_iter\
    \ (rest paren_string) paren_count max_paren_count)]))\n    (parse_parens_iter\
    \ paren_string 0 0))\n  (define (parse_parens_iter paren_string paren_count max_paren_count)\n\
    \    (cond\n      [(empty? paren_string) (list max_paren_count)]\n      [(equal?\
    \ (first paren_string) #\\()\n       (parse_parens_iter (rest paren_string) (+\
    \ paren_count 1) (max paren_count max_paren_count))]\n      [(equal? (first paren_string)\
    \ #\\))\n       (parse_parens_iter (rest paren_string) (- paren_count 1) (max\
    \ paren_count max_paren_count))]\n      [(equal? (first paren_string) #\\space)\n\
    \       (append (list max_paren_count) (parse_parens (rest paren_string)))]\n\
    \      [else (parse_parens_iter (rest paren_string) paren_count max_paren_count)]))\n\
    \  (parse_parens_iter paren_string 0 0))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpob5ead0t.rkt:36:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpob5ead0t.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpob5ead0t.rkt:38:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string)\n    (define (parse-parens-iter paren-string\
    \ depth max-depth)\n      (cond\n        [(empty? paren-string) max-depth]\n \
    \       [(char=? (first paren-string) #\\()\n         (parse-parens-iter (rest\
    \ paren-string) (+ depth 1) (max max-depth depth))]\n        [(char=? (first paren-string)\
    \ #\\))\n         (parse-parens-iter (rest paren-string) (- depth 1) max-depth)]\n\
    \        [else (parse-parens-iter (rest paren-string) depth max-depth)]))\n  \
    \  (parse-parens-iter paren-string 0 0))\n  (map parse-parens (string-split paren-string)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpe669h076.rkt:19:34: paren-string: unbound identifier\n  in: paren-string\n\
    \  location...:\n   /tmp/tmpe669h076.rkt:19:34\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [count\
    \ 0] [max_count 0])\n           (cond\n             [(empty? paren_group) max_count]\n\
    \             [(char=? (first paren_group) #\\()\n              (loop (rest paren_group)\
    \ (+ count 1) (max count max_count))]\n             [(char=? (first paren_group)\
    \ #\\))\n              (loop (rest paren_group) (- count 1) (max count max_count))]\n\
    \             [else (loop (rest paren_group) count max_count)])))\n       (string-split\
    \ paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk90wwgpj.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpk90wwgpj.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpk90wwgpj.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens-helper paren_string paren_count)\n    (cond\n      [(empty?\
    \ paren_string) paren_count]\n      [(equal? (first paren_string) #\\() (parse-parens-helper\
    \ (rest paren_string) (+ paren_count 1))]\n      [(equal? (first paren_string)\
    \ #\\)) (parse-parens-helper (rest paren_string) (- paren_count 1))]\n      [else\
    \ (parse-parens-helper (rest paren_string) paren_count)]))\n  (define (parse-parens-helper-2\
    \ paren_string paren_count paren_list)\n    (cond\n      [(empty? paren_string)\
    \ (reverse paren_list)]\n      [(equal? (first paren_string) #\\() (parse-parens-helper-2\
    \ (rest paren_string) (+ paren_count 1) paren_list)]\n      [(equal? (first paren_string)\
    \ #\\)) (parse-parens-helper-2 (rest paren_string) (- paren_count 1) (cons paren_count\
    \ paren_list))]\n      [else (parse-parens-helper-2 (rest paren_string) paren_count\
    \ paren_list)]))\n  (parse-parens-helper-2 paren_string 0 '()))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4u4z91k5.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp4u4z91k5.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmp4u4z91k5.rkt:30:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string current_max)\n    (cond\n\
    \      [(empty? paren_string) current_max]\n      [(char=? (first paren_string)\
    \ #\\()\n       (parse_nested_parens_helper (rest paren_string) (+ current_max\
    \ 1))]\n      [(char=? (first paren_string) #\\))\n       (parse_nested_parens_helper\
    \ (rest paren_string) (- current_max 1))]\n      [else (parse_nested_parens_helper\
    \ (rest paren_string) current_max)]))\n  (define (parse_nested_parens_helper2\
    \ paren_string current_max)\n    (cond\n      [(empty? paren_string) (list current_max)]\n\
    \      [(char=? (first paren_string) #\\ )\n       (cons current_max (parse_nested_parens_helper2\
    \ (rest paren_string) 0))]\n      [(char=? (first paren_string) #\\()\n      \
    \ (parse_nested_parens_helper2 (rest paren_string) (+ current_max 1))]\n     \
    \ [(char=? (first paren_string) #\\))\n       (parse_nested_parens_helper2 (rest\
    \ paren_string) (- current_max 1))]\n      [else (parse_nested_parens_helper2\
    \ (rest paren_string) current_max)]))\n  (parse_nested_parens_helper2 paren_string\
    \ 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((())) () ((())()())\"\
    ) (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((())) (((())))\") (list\
    \ 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n\
    (test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmj2r6ute.rkt:34:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpmj2r6ute.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpmj2r6ute.rkt:36:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ count max-count)\n      (cond\n        [(empty? paren_string) max-count]\n \
    \       [(char=? (first paren_string) #\\()\n         (parse-parens-iter (rest\
    \ paren_string) (+ count 1) (max count max-count))]\n        [(char=? (first paren_string)\
    \ #\\))\n         (parse-parens-iter (rest paren_string) (- count 1) (max count\
    \ max-count))]\n        [else (parse-parens-iter (rest paren_string) count max-count)]))\n\
    \    (parse-parens-iter paren_string 0 0))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2p1vq_jp.rkt:26:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp2p1vq_jp.rkt:27:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2p1vq_jp.rkt:28:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (\u03BB (paren_group)\n         (let ([paren_group (string->list paren_group)])\n\
    \           (let loop ([paren_group paren_group] [level 0] [max_level 0])\n  \
    \           (cond [(empty? paren_group) max_level]\n                   [(char=?\
    \ (first paren_group) #\\()\n                    (loop (rest paren_group) (+ level\
    \ 1) (max level max_level))]\n                   [(char=? (first paren_group)\
    \ #\\))\n                    (loop (rest paren_group) (- level 1) (max level max_level))]\n\
    \                   [else (loop (rest paren_group) level max_level)]))))\n   \
    \    (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [level\
    \ 0] [max_level 0])\n           (cond [(empty? paren_group) max_level]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ level 1) (if (> level max_level) level max_level))]\n      \
    \           [(char=? (first paren_group) #\\))\n                  (loop (rest\
    \ paren_group) (- level 1) max_level)]\n                 [else (loop (rest paren_group)\
    \ level max_level)])))\n       (string-split paren_string)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2sv5ypsn.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp2sv5ypsn.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2sv5ypsn.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (count-parens paren_group 0))\n      \
    \ (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp51sv4g9g.rkt:10:10: count-parens: unbound identifier\n  in: count-parens\n\
    \  location...:\n   /tmp/tmp51sv4g9g.rkt:10:10\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ max-level level)\n      (cond\n        [(empty? paren_string) max-level]\n \
    \       [(char=? (first paren_string) #\\()\n         (parse-parens-iter (rest\
    \ paren_string) (if (> level max-level) level max-level) (+ level 1))]\n     \
    \   [(char=? (first paren_string) #\\))\n         (parse-parens-iter (rest paren_string)\
    \ (if (> level max-level) level max-level) (- level 1))]\n        [else (parse-parens-iter\
    \ (rest paren_string) max-level level)]))\n    (parse-parens-iter paren_string\
    \ 0 0))\n  (map parse_parens (string-split paren_string #\\space)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4l1k8eks.rkt:26:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp4l1k8eks.rkt:27:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp4l1k8eks.rkt:28:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max-depth\
    \ 0] [current-depth 0])\n           (cond [(empty? paren_group) max-depth]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group)\n                        (if (> current-depth max-depth)\n    \
    \                        current-depth\n                            max-depth)\n\
    \                        (+ current-depth 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group)\n           \
    \             (if (> current-depth max-depth)\n                            current-depth\n\
    \                            max-depth)\n                        (- current-depth\
    \ 1))]\n                 [else (loop (rest paren_group)\n                    \
    \         max-depth\n                             current-depth)])))\n       (regexp-split\
    \ #rx\" \" paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzv2uxbef.rkt:34:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzv2uxbef.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzv2uxbef.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string)\n    (let loop ([paren-string paren-string]\
    \ [level 0] [max-level 0])\n      (cond [(empty? paren-string) max-level]\n  \
    \          [(char=? (first paren-string) #\\()\n             (loop (rest paren-string)\
    \ (+ level 1) (max level max-level))]\n            [(char=? (first paren-string)\
    \ #\\))\n             (loop (rest paren-string) (- level 1) (max level max-level))]\n\
    \            [else (loop (rest paren-string) level max-level)])))\n  (map parse-parens\
    \ (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6vqkecbg.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6vqkecbg.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6vqkecbg.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_nesting\
    \ 0] [current_nesting 0])\n           (cond [(empty? paren_group) max_nesting]\n\
    \                 [(char=? (first paren_group) #\\()\n                  (loop\
    \ (rest paren_group)\n                        (if (> current_nesting max_nesting)\n\
    \                            (+ current_nesting 1)\n                         \
    \   max_nesting)\n                        (+ current_nesting 1))]\n          \
    \       [(char=? (first paren_group) #\\))\n                  (loop (rest paren_group)\n\
    \                        max_nesting\n                        (- current_nesting\
    \ 1))]\n                 [else (loop (rest paren_group) max_nesting current_nesting)])))\n\
    \       (regexp-split #rx\" \" paren_string)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpuk6ub7j6.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpuk6ub7j6.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpuk6ub7j6.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (\u03BB (x) (count-parens x)) (string-split paren_string #\\space)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpuhw22j3v.rkt:9:15: count-parens: unbound identifier\n  in: count-parens\n\
    \  location...:\n   /tmp/tmpuhw22j3v.rkt:9:15\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string max_level)\n    (cond\n  \
    \    [(empty? paren_string) max_level]\n      [(char=? (first paren_string) #\\\
    ()\n       (parse_nested_parens_helper (rest paren_string) (+ max_level 1))]\n\
    \      [(char=? (first paren_string) #\\))\n       (parse_nested_parens_helper\
    \ (rest paren_string) (- max_level 1))]\n      [else (parse_nested_parens_helper\
    \ (rest paren_string) max_level)]))\n  (map (\u03BB (paren_group) (parse_nested_parens_helper\
    \ paren_group 0)) (string-split paren_string #\\space)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprni22_rr.rkt:24:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprni22_rr.rkt:25:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprni22_rr.rkt:26:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens-iter paren_string acc)\n    (cond [(empty? paren_string)\
    \ acc]\n          [(equal? (first paren_string) #\\()\n           (parse_nested_parens-iter\
    \ (rest paren_string) (add1 acc))]\n          [(equal? (first paren_string) #\\\
    ))\n           (parse_nested_parens-iter (rest paren_string) (sub1 acc))]\n  \
    \        [else (parse_nested_parens-iter (rest paren_string) acc)]))\n  (parse_nested_parens-iter\
    \ paren_string 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpr6ypxt32.rkt:23:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpr6ypxt32.rkt:24:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpr6ypxt32.rkt:25:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (paren_nesting_level paren_group))\n \
    \      (string-split paren_string #\\space)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpmc81j7re.rkt:10:10: paren_nesting_level: unbound identifier\n \
    \ in: paren_nesting_level\n  location...:\n   /tmp/tmpmc81j7re.rkt:10:10\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string max_depth)\n    (cond\n  \
    \    [(empty? paren_string) max_depth]\n      [(char=? (first paren_string) #\\\
    ()\n       (parse_nested_parens_helper (rest paren_string) (+ max_depth 1))]\n\
    \      [(char=? (first paren_string) #\\))\n       (parse_nested_parens_helper\
    \ (rest paren_string) (- max_depth 1))]\n      [else (parse_nested_parens_helper\
    \ (rest paren_string) max_depth)]))\n  (parse_nested_parens_helper paren_string\
    \ 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((())) () ((())()())\"\
    ) (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((())) (((())))\") (list\
    \ 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n\
    (test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpj_ugt5hj.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpj_ugt5hj.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpj_ugt5hj.rkt:26:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_level\
    \ 0] [level 0])\n           (cond [(empty? paren_group) max_level]\n         \
    \        [(char=? (first paren_group) #\\()\n                  (loop (rest paren_group)\n\
    \                        (if (&gt; level max_level) level max_level)\n       \
    \                 (+ level 1))]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group)\n                        (if\
    \ (&gt; level max_level) level max_level)\n                        (- level 1))]\n\
    \                 [else (loop (rest paren_group) max_level level)])))\n      \
    \ (regexp-match* #rx\"([()]*)\" paren_string)))\n</code>\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp9hkw_4qq.rkt:15:36: read-syntax: missing `)` to close preceding\
    \ `(`, found instead `]`\n  context...:\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_iter paren_string\
    \ level)\n      (cond\n        [(empty? paren_string) level]\n        [(equal?\
    \ (first paren_string) #\\() (parse_parens_iter (rest paren_string) (+ level 1))]\n\
    \        [(equal? (first paren_string) #\\)) (parse_parens_iter (rest paren_string)\
    \ (- level 1))]\n        [else (parse_parens_iter (rest paren_string) level)]))\n\
    \    (parse_parens_iter paren_string 0))\n  (define (parse_parens_iter paren_string\
    \ level_list)\n    (cond\n      [(empty? paren_string) level_list]\n      [(equal?\
    \ (first paren_string) #\\ ) (parse_parens_iter (rest paren_string) level_list)]\n\
    \      [else (parse_parens_iter (rest paren_string) (append level_list (list (parse_parens\
    \ paren_string))))]))\n  (parse_parens_iter paren_string '()))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnsjbgyv9.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpnsjbgyv9.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpnsjbgyv9.rkt:31:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (if (empty? paren_string)\n      \
    \  0\n        (if (equal? (first paren_string) #\\()\n            (+ 1 (parse_parens\
    \ (rest paren_string)))\n            (- (parse_parens (rest paren_string)) 1))))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp49mxghqv.rkt:22:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp49mxghqv.rkt:23:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp49mxghqv.rkt:24:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-helper paren_string\
    \ acc)\n      (cond\n        [(empty? paren_string) acc]\n        [(equal? (first\
    \ paren_string) #\\() (parse-parens-helper (rest paren_string) (add1 acc))]\n\
    \        [(equal? (first paren_string) #\\)) (parse-parens-helper (rest paren_string)\
    \ (sub1 acc))]\n        [else (parse-parens-helper (rest paren_string) acc)]))\n\
    \    (parse-parens-helper paren_string 0))\n  (define (parse-parens-string-helper\
    \ paren_string acc)\n    (cond\n      [(empty? paren_string) acc]\n      [(equal?\
    \ (first paren_string) #\\ ) (parse-parens-string-helper (rest paren_string) acc)]\n\
    \      [else (parse-parens-string-helper (rest paren_string) (cons (parse_parens\
    \ paren_string) acc))]))\n  (parse-parens-string-helper paren_string '()))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxbnvw5oy.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpxbnvw5oy.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpxbnvw5oy.rkt:31:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let ([paren_group (string->list paren_group)])\n\
    \           (let loop ([paren_group paren_group] [max_depth 0] [current_depth\
    \ 0])\n             (cond [(empty? paren_group) max_depth]\n                 \
    \  [(char=? (first paren_group) #\\()\n                    (loop (rest paren_group)\
    \ max_depth (+ current_depth 1))]\n                   [(char=? (first paren_group)\
    \ #\\))\n                    (loop (rest paren_group) (max max_depth current_depth)\
    \ (- current_depth 1))]\n                   [else (loop (rest paren_group) max_depth\
    \ current_depth)]))))\n       (string-split paren_string)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (cond\n      [(empty? paren_string)\
    \ 0]\n      [(char=? (first paren_string) #\\() (add1 (parse_parens (rest paren_string)))]\n\
    \      [(char=? (first paren_string) #\\)) (sub1 (parse_parens (rest paren_string)))]\n\
    \      [else (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp5xo8kdrq.rkt:22:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5xo8kdrq.rkt:23:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5xo8kdrq.rkt:24:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (define (paren_group_level paren_group)\n\
    \           (cond\n             [(empty? paren_group) 0]\n             [(eq? (first\
    \ paren_group) #\\()\n              (add1 (paren_group_level (rest paren_group)))]\n\
    \             [(eq? (first paren_group) #\\))\n              (paren_group_level\
    \ (rest paren_group))]))\n         (paren_group_level paren_group))\n       (map\
    \ string->list (string-split paren_string #\\space))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmqdyf0un.rkt:25:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpmqdyf0un.rkt:26:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpmqdyf0un.rkt:27:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [level\
    \ 0] [max_level 0])\n           (cond [(empty? paren_group) max_level]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ level 1) (if (> level max_level) level max_level))]\n      \
    \           [(char=? (first paren_group) #\\))\n                  (loop (rest\
    \ paren_group) (- level 1) max_level)]\n                 [else (loop (rest paren_group)\
    \ level max_level)])))\n       (regexp-split #rx\" \" paren_string)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6bjf7cte.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6bjf7cte.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6bjf7cte.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_level\
    \ 0] [level 0])\n           (cond [(empty? paren_group) max_level]\n         \
    \        [(char=? (first paren_group) #\\()\n                  (loop (rest paren_group)\n\
    \                        (if (> level max_level) level max_level)\n          \
    \              (+ level 1))]\n                 [(char=? (first paren_group) #\\\
    ))\n                  (loop (rest paren_group)\n                        (if (>\
    \ level max_level) level max_level)\n                        (- level 1))]\n \
    \                [else (loop (rest paren_group) max_level level)])))\n       (regexp-split\
    \ #rx\" \" paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7arpu06e.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7arpu06e.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7arpu06e.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (define (paren_level paren_group)\n  \
    \         (cond\n             [(empty? paren_group) 0]\n             [(eq? (first\
    \ paren_group) #\\() (add1 (paren_level (rest paren_group)))]\n             [(eq?\
    \ (first paren_group) #\\)) (sub1 (paren_level (rest paren_group)))]\n       \
    \      [else (paren_level (rest paren_group))]))\n         (paren_level paren_group))\n\
    \       (map string->list (string-split paren_string #\\space))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptw_mnw2h.rkt:24:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmptw_mnw2h.rkt:25:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmptw_mnw2h.rkt:26:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens-helper paren_string current_max)\n    (cond\n      [(empty?\
    \ paren_string) current_max]\n      [(char=? (first paren_string) #\\()\n    \
    \   (parse-parens-helper (rest paren_string) (add1 current_max))]\n      [(char=?\
    \ (first paren_string) #\\))\n       (parse-parens-helper (rest paren_string)\
    \ (sub1 current_max))]\n      [else (parse-parens-helper (rest paren_string) current_max)]))\n\
    \  (define (parse-parens-helper-2 paren_string current_max)\n    (cond\n     \
    \ [(empty? paren_string) current_max]\n      [(char=? (first paren_string) #\\\
    ()\n       (parse-parens-helper-2 (rest paren_string) (add1 current_max))]\n \
    \     [(char=? (first paren_string) #\\))\n       (parse-parens-helper-2 (rest\
    \ paren_string) (sub1 current_max))]\n      [else (parse-parens-helper-2 (rest\
    \ paren_string) current_max)]))\n  (define (parse-parens-helper-3 paren_string\
    \ current_max)\n    (cond\n      [(empty? paren_string) current_max]\n      [(char=?\
    \ (first paren_string) #\\()\n       (parse-parens-helper-3 (rest paren_string)\
    \ (add1 current_max))]\n      [(char=? (first paren_string) #\\))\n       (parse-parens-helper-3\
    \ (rest paren_string) (sub1 current_max))]\n      [else (parse-parens-helper-3\
    \ (rest paren_string) current_max)]))\n  (define (parse-parens-helper-4 paren_string\
    \ current_max)\n    (cond\n      [(empty? paren_string) current_max]\n      [(char=?\
    \ (first paren_string) #\\()\n       (parse-parens-\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpw35vnko8.rkt:37:7: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 38\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string paren_list)\n    (if (empty? paren_string)\n\
    \        paren_list\n        (let ([paren (first paren_string)])\n          (if\
    \ (equal? paren #\\()\n              (parse_parens (rest paren_string) (cons 1\
    \ paren_list))\n              (if (equal? paren #\\))\n                  (parse_parens\
    \ (rest paren_string) (cons (add1 (first paren_list)) (rest paren_list)))\n  \
    \                (parse_parens (rest paren_string) paren_list))))))\n  (parse_parens\
    \ paren_string (list)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp9j_0k2ck.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp9j_0k2ck.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmp9j_0k2ck.rkt:27:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [level\
    \ 0] [max-level 0])\n           (cond [(empty? paren_group) max-level]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ level 1) max-level)]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group) (- level 1) (max level max-level))]\n\
    \                 [else (loop (rest paren_group) level max-level)])))\n      \
    \ (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp354ky6mw.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp354ky6mw.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp354ky6mw.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_level\
    \ 0] [level 0])\n           (cond [(empty? paren_group) max_level]\n         \
    \        [(char=? (first paren_group) #\\()\n                  (loop (rest paren_group)\
    \ max_level (+ level 1))]\n                 [(char=? (first paren_group) #\\))\n\
    \                  (loop (rest paren_group) (max max_level level) (- level 1))]\n\
    \                 [else (loop (rest paren_group) max_level level)])))\n      \
    \ (regexp-split #rx\" \" paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp5ym47joc.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5ym47joc.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5ym47joc.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string acc)\n    (cond\n      [(empty?\
    \ paren_string) acc]\n      [(string=? (first paren_string) \"(\")\n       (parse_nested_parens_helper\
    \ (rest paren_string) (add1 acc))]\n      [(string=? (first paren_string) \")\"\
    )\n       (parse_nested_parens_helper (rest paren_string) (sub1 acc))]\n     \
    \ [(string=? (first paren_string) \" \")\n       (parse_nested_parens_helper (rest\
    \ paren_string) acc)]\n      [else (error \"Invalid input\")]))\n  (parse_nested_parens_helper\
    \ paren_string 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkocuh3ps.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkocuh3ps.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpkocuh3ps.rkt:28:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string)\n    (define (parse-parens-iter paren-string\
    \ level max-level)\n      (cond\n        [(empty? paren-string) max-level]\n \
    \       [(equal? (first paren-string) #\\()\n         (parse-parens-iter (rest\
    \ paren-string) (+ level 1) max-level)]\n        [(equal? (first paren-string)\
    \ #\\))\n         (parse-parens-iter (rest paren-string) (- level 1) (max level\
    \ max-level))]\n        [else (parse-parens-iter (rest paren-string) level max-level)]))\n\
    \    (parse-parens-iter paren-string 0 0))\n  (map parse-parens (string-split\
    \ paren-string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpfias635p.rkt:19:34: paren-string: unbound identifier\n  in: paren-string\n\
    \  location...:\n   /tmp/tmpfias635p.rkt:19:34\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-helper paren_string\
    \ level)\n      (cond\n        [(empty? paren_string) level]\n        [(equal?\
    \ (first paren_string) #\\() (parse-parens-helper (rest paren_string) (+ level\
    \ 1))]\n        [(equal? (first paren_string) #\\)) (parse-parens-helper (rest\
    \ paren_string) (- level 1))]\n        [else (parse-parens-helper (rest paren_string)\
    \ level)]))\n    (parse-parens-helper paren_string 0))\n  (map parse_parens (string-split\
    \ paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp6kcwk7l.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpp6kcwk7l.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpp6kcwk7l.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_iter paren_string\
    \ depth max-depth)\n      (cond\n        [(empty? paren_string) max-depth]\n \
    \       [(char=? (first paren_string) #\\()\n         (parse_parens_iter (rest\
    \ paren_string) (+ depth 1) (max depth max-depth))]\n        [(char=? (first paren_string)\
    \ #\\))\n         (parse_parens_iter (rest paren_string) (- depth 1) (max depth\
    \ max-depth))]\n        [else (parse_parens_iter (rest paren_string) depth max-depth)]))\n\
    \    (parse_parens_iter paren_string 0 0))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7krss0yp.rkt:26:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7krss0yp.rkt:27:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7krss0yp.rkt:28:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_level\
    \ 0] [current_level 0])\n           (cond [(empty? paren_group) max_level]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group)\n                        (if (> current_level max_level)\n    \
    \                        current_level\n                            max_level)\n\
    \                        (+ current_level 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group)\n           \
    \             (if (> current_level max_level)\n                            current_level\n\
    \                            max_level)\n                        (- current_level\
    \ 1))]\n                 [else (loop (rest paren_group) max_level current_level)])))\n\
    \       (regexp-split #rx\" \" paren_string)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_xgahlwe.rkt:32:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_xgahlwe.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_xgahlwe.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string current_level max_level)\n\
    \    (cond\n      [(empty? paren_string) max_level]\n      [(char=? (first paren_string)\
    \ #\\()\n       (parse_nested_parens_helper (rest paren_string) (+ current_level\
    \ 1) (max current_level max_level))]\n      [(char=? (first paren_string) #\\\
    ))\n       (parse_nested_parens_helper (rest paren_string) (- current_level 1)\
    \ (max current_level max_level))]\n      [else (parse_nested_parens_helper (rest\
    \ paren_string) current_level max_level)]))\n  (map (\u03BB (paren_group) (parse_nested_parens_helper\
    \ paren_group 0 0)) (string-split paren_string)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp19b_z1fl.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp19b_z1fl.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp19b_z1fl.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_helper paren_string\
    \ level)\n      (cond\n        [(empty? paren_string) level]\n        [(equal?\
    \ (first paren_string) #\\() (parse_parens_helper (rest paren_string) (+ level\
    \ 1))]\n        [(equal? (first paren_string) #\\)) (parse_parens_helper (rest\
    \ paren_string) (- level 1))]\n        [else (parse_parens_helper (rest paren_string)\
    \ level)]))\n    (parse_parens_helper paren_string 0))\n  (define (parse_parens_list\
    \ paren_string)\n    (cond\n      [(empty? paren_string) empty]\n      [(equal?\
    \ (first paren_string) #\\ ) (cons (parse_parens (rest paren_string)) (parse_parens_list\
    \ (rest paren_string)))]\n      [else (cons (parse_parens paren_string) (parse_parens_list\
    \ (rest paren_string)))]))\n  (parse_parens_list paren_string))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcol4a7oe.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpcol4a7oe.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpcol4a7oe.rkt:31:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_level\
    \ 0] [current_level 0])\n           (cond [(empty? paren_group) max_level]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) max_level (+ current_level 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group) (max max_level\
    \ current_level) (- current_level 1))]\n                 [else (loop (rest paren_group)\
    \ max_level current_level)])))\n       (regexp-split #rx\" \" paren_string)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpd8dwt5pd.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpd8dwt5pd.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpd8dwt5pd.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string)\n    (define (parse-parens-iter paren-string\
    \ paren-count)\n      (cond\n        [(empty? paren-string) paren-count]\n   \
    \     [(char=? (first paren-string) #\\()\n         (parse-parens-iter (rest paren-string)\
    \ (+ paren-count 1))]\n        [(char=? (first paren-string) #\\))\n         (parse-parens-iter\
    \ (rest paren-string) (- paren-count 1))]\n        [else (parse-parens-iter (rest\
    \ paren-string) paren-count)]))\n    (parse-parens-iter paren-string 0))\n  (map\
    \ parse-parens (string-split paren-string #\\space)))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpjv0aszlt.rkt:19:34: paren-string: unbound identifier\n  in: paren-string\n\
    \  location...:\n   /tmp/tmpjv0aszlt.rkt:19:34\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_helper paren_string\
    \ level)\n      (cond\n        [(empty? paren_string) level]\n        [(equal?\
    \ (first paren_string) #\\() (parse_parens_helper (rest paren_string) (+ level\
    \ 1))]\n        [(equal? (first paren_string) #\\)) (parse_parens_helper (rest\
    \ paren_string) (- level 1))]\n        [else (parse_parens_helper (rest paren_string)\
    \ level)]))\n    (parse_parens_helper paren_string 0))\n  (define (parse_parens_groups\
    \ paren_string)\n    (cond\n      [(empty? paren_string) '()]\n      [(equal?\
    \ (first paren_string) #\\ ) (cons (parse_parens (rest paren_string)) (parse_parens_groups\
    \ (rest paren_string)))]\n      [else (parse_parens_groups (rest paren_string))]))\n\
    \  (parse_parens_groups paren_string))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpc29koxdo.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpc29koxdo.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpc29koxdo.rkt:31:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string max_depth)\n    (cond ((null? paren_string)\
    \ max_depth)\n          ((equal? (car paren_string) #\\()\n           (parse_parens\
    \ (cdr paren_string) (+ max_depth 1)))\n          ((equal? (car paren_string)\
    \ #\\))\n           (parse_parens (cdr paren_string) (- max_depth 1)))\n     \
    \     (else (parse_parens (cdr paren_string) max_depth))))\n  (define (parse_paren_groups\
    \ paren_string max_depths)\n    (cond ((null? paren_string) max_depths)\n    \
    \      ((equal? (car paren_string) #\\space)\n           (parse_paren_groups (cdr\
    \ paren_string) (cons (parse_parens (cdr paren_string) 0) max_depths)))\n    \
    \      (else (parse_paren_groups (cdr paren_string) max_depths))))\n  (reverse\
    \ (parse_paren_groups paren_string '())))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmxqypch2.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"(()()) ((())) () ((())()())\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpmxqypch2.rkt:29:4\n\ncar: contract violation\n  expected:\
    \ pair?\n  given: \"() (()) ((())) (((())))\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpmxqypch2.rkt:30:4\n\ncar:\
    \ contract violation\n  expected: pair?\n  given: \"(()(())((())))\"\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string max_depth)\n    (cond\n  \
    \    [(empty? paren_string) max_depth]\n      [(char=? (first paren_string) #\\\
    ()\n       (parse_nested_parens_helper (rest paren_string) (+ max_depth 1))]\n\
    \      [(char=? (first paren_string) #\\))\n       (parse_nested_parens_helper\
    \ (rest paren_string) (- max_depth 1))]\n      [else (parse_nested_parens_helper\
    \ (rest paren_string) max_depth)]))\n  (for/list ([paren_group (in-list (string-split\
    \ paren_string \" \"))])\n    (parse_nested_parens_helper paren_group 0)))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp2wb4pzh.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpp2wb4pzh.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpp2wb4pzh.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [max_level 0] [cur_level 0])\n      (cond\n        [(empty? paren_string) (list\
    \ max_level)]\n        [(char=? (first paren_string) #\\()\n         (loop (rest\
    \ paren_string) (max max_level (add1 cur_level)) (add1 cur_level))]\n        [(char=?\
    \ (first paren_string) #\\))\n         (loop (rest paren_string) (max max_level\
    \ cur_level) (sub1 cur_level))]\n        [else (loop (rest paren_string) max_level\
    \ cur_level)])))\n  (map parse_parens (string-split paren_string #\\space)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ucvczys.rkt:25:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7ucvczys.rkt:26:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ucvczys.rkt:27:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (\u03BB (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [curr_depth 0])\n           (cond [(empty? paren_group) max_depth]\n    \
    \             [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group)\n                        (if (> curr_depth max_depth)\n       \
    \                     (+ curr_depth 1)\n                            max_depth)\n\
    \                        (+ curr_depth 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group)\n           \
    \             max_depth\n                        (- curr_depth 1))]\n        \
    \         [else (loop (rest paren_group) max_depth curr_depth)])))\n       (regexp-split\
    \ #rx\" \" paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpe6_3petp.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpe6_3petp.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpe6_3petp.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string max_level)\n    (cond\n  \
    \    [(empty? paren_string) max_level]\n      [(char=? (first paren_string) #\\\
    ()\n       (parse_nested_parens_helper (rest paren_string) (+ max_level 1))]\n\
    \      [(char=? (first paren_string) #\\))\n       (parse_nested_parens_helper\
    \ (rest paren_string) (- max_level 1))]\n      [else (parse_nested_parens_helper\
    \ (rest paren_string) max_level)]))\n  (define (parse_nested_parens_helper2 paren_string\
    \ max_level result)\n    (cond\n      [(empty? paren_string) (reverse result)]\n\
    \      [(char=? (first paren_string) #\\ )\n       (parse_nested_parens_helper2\
    \ (rest paren_string) 0 (cons max_level result))]\n      [(char=? (first paren_string)\
    \ #\\()\n       (parse_nested_parens_helper2 (rest paren_string) (+ max_level\
    \ 1) result)]\n      [(char=? (first paren_string) #\\))\n       (parse_nested_parens_helper2\
    \ (rest paren_string) (- max_level 1) result)]\n      [else (parse_nested_parens_helper2\
    \ (rest paren_string) max_level result)]))\n  (parse_nested_parens_helper2 paren_string\
    \ 0 '()))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((())) () ((())()())\"\
    ) (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((())) (((())))\") (list\
    \ 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n\
    (test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp9ib1aq3l.rkt:34:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp9ib1aq3l.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmp9ib1aq3l.rkt:36:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens-helper paren_string paren_count max_paren_count)\n  \
    \  (cond [(empty? paren_string) max_paren_count]\n          [(char=? (first paren_string)\
    \ #\\()\n           (parse-parens-helper (rest paren_string) (+ paren_count 1)\n\
    \                                (if (> paren_count max_paren_count)\n       \
    \                             paren_count\n                                  \
    \  max_paren_count))]\n          [(char=? (first paren_string) #\\))\n       \
    \    (parse-parens-helper (rest paren_string) (- paren_count 1)\n            \
    \                    (if (> paren_count max_paren_count)\n                   \
    \                 paren_count\n                                    max_paren_count))]\n\
    \          [else (parse-parens-helper (rest paren_string) paren_count max_paren_count)]))\n\
    \  (define (parse-parens-helper-2 paren_string)\n    (parse-parens-helper paren_string\
    \ 0 0))\n  (map parse-parens-helper-2 (string-split paren_string #\\space)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjy9b6eof.rkt:31:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpjy9b6eof.rkt:32:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpjy9b6eof.rkt:33:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ count max-count)\n      (cond ((empty? paren_string) max-count)\n          \
    \  ((char=? (first paren_string) #\\()\n             (parse-parens-iter (rest\
    \ paren_string) (+ count 1) (max count max-count)))\n            ((char=? (first\
    \ paren_string) #\\))\n             (parse-parens-iter (rest paren_string) (-\
    \ count 1) (max count max-count)))\n            (else (parse-parens-iter (rest\
    \ paren_string) count max-count))))\n    (parse-parens-iter paren_string 0 0))\n\
    \  (define (parse-parens-iter paren_string paren_list)\n    (cond ((empty? paren_string)\
    \ paren_list)\n          ((char=? (first paren_string) #\\ )\n           (parse-parens-iter\
    \ (rest paren_string) paren_list))\n          (else (parse-parens-iter (rest paren_string)\
    \ (cons (parse_parens paren_string) paren_list)))))\n  (parse-parens-iter paren_string\
    \ '()))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((())) () ((())()())\"\
    ) (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((())) (((())))\") (list\
    \ 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n\
    (test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3a7kdyg0.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp3a7kdyg0.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmp3a7kdyg0.rkt:32:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [level\
    \ 0] [max_level 0])\n           (cond [(empty? paren_group) max_level]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ level 1) (if (> level max_level) level max_level))]\n      \
    \           [(char=? (first paren_group) #\\))\n                  (loop (rest\
    \ paren_group) (- level 1) max_level)]\n                 [else (loop (rest paren_group)\
    \ level max_level)])))\n       (regexp-split #rx\" \" paren_string)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp59r82twa.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp59r82twa.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp59r82twa.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string max_level)\n    (if (empty?\
    \ paren_string)\n        max_level\n        (let* ([first-char (first paren_string)]\n\
    \               [rest-string (rest paren_string)]\n               [new-level (if\
    \ (equal? first-char #\\()\n                              (+ max_level 1)\n  \
    \                            (if (equal? first-char #\\))\n                  \
    \                (- max_level 1)\n                                  max_level))])\n\
    \          (parse_nested_parens_helper rest-string new-level))))\n  (parse_nested_parens_helper\
    \ paren_string 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprf84ieg3.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprf84ieg3.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmprf84ieg3.rkt:29:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string)\n    (define (parse-parens-iter paren-string\
    \ depth max-depth)\n      (cond\n        [(empty? paren-string) max-depth]\n \
    \       [(char=? (first paren-string) #\\()\n         (parse-parens-iter (rest\
    \ paren-string) (+ depth 1) (max depth max-depth))]\n        [(char=? (first paren-string)\
    \ #\\))\n         (parse-parens-iter (rest paren-string) (- depth 1) (max depth\
    \ max-depth))]\n        [else (parse-parens-iter (rest paren-string) depth max-depth)]))\n\
    \    (parse-parens-iter paren-string 0 0))\n  (map parse-parens (string-split\
    \ paren-string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp6mu1dkxh.rkt:19:34: paren-string: unbound identifier\n  in: paren-string\n\
    \  location...:\n   /tmp/tmp6mu1dkxh.rkt:19:34\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (\u03BB (paren_group) (paren_group_depth paren_group)) (string-split paren_string)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpoi7aiqx1.rkt:9:25: paren_group_depth: unbound identifier\n  in:\
    \ paren_group_depth\n  location...:\n   /tmp/tmpoi7aiqx1.rkt:9:25\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string current_level max_level)\n\
    \    (cond\n      [(empty? paren_string) max_level]\n      [(char=? (first paren_string)\
    \ #\\()\n       (parse_nested_parens_helper (rest paren_string) (+ current_level\
    \ 1) (max current_level max_level))]\n      [(char=? (first paren_string) #\\\
    ))\n       (parse_nested_parens_helper (rest paren_string) (- current_level 1)\
    \ (max current_level max_level))]\n      [else (parse_nested_parens_helper (rest\
    \ paren_string) current_level max_level)]))\n  (define (parse_paren_groups paren_string)\n\
    \    (cond\n      [(empty? paren_string) empty]\n      [(char=? (first paren_string)\
    \ #\\ )\n       (cons (parse_nested_parens_helper (rest paren_string) 0 0) (parse_paren_groups\
    \ (rest paren_string)))]\n      [else (parse_paren_groups (rest paren_string))]))\n\
    \  (parse_paren_groups paren_string))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpsqfshdjv.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsqfshdjv.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpsqfshdjv.rkt:32:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ paren_count max_paren_count)\n      (cond\n        [(empty? paren_string) max_paren_count]\n\
    \        [(char=? (first paren_string) #\\() (parse-parens-iter (rest paren_string)\
    \ (+ paren_count 1) (max paren_count max_paren_count))]\n        [(char=? (first\
    \ paren_string) #\\)) (parse-parens-iter (rest paren_string) (- paren_count 1)\
    \ (max paren_count max_paren_count))]\n        [else (parse-parens-iter (rest\
    \ paren_string) paren_count max_paren_count)]))\n    (parse-parens-iter paren_string\
    \ 0 0))\n  (map parse_parens (string-split paren_string #\\space)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphrg983ok.rkt:24:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmphrg983ok.rkt:25:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmphrg983ok.rkt:26:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-helper paren_string\
    \ level)\n      (cond\n        [(empty? paren_string) level]\n        [(equal?\
    \ (first paren_string) #\\() (parse-parens-helper (rest paren_string) (+ level\
    \ 1))]\n        [(equal? (first paren_string) #\\)) (parse-parens-helper (rest\
    \ paren_string) (- level 1))]\n        [else (parse-parens-helper (rest paren_string)\
    \ level)]))\n    (parse-parens-helper paren_string 0))\n  (map parse_parens (string-split\
    \ paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7y288x93.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7y288x93.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7y288x93.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_helper paren_string\
    \ level)\n      (cond\n        [(empty? paren_string) level]\n        [(equal?\
    \ (first paren_string) #\\() (parse_parens_helper (rest paren_string) (+ level\
    \ 1))]\n        [(equal? (first paren_string) #\\)) (parse_parens_helper (rest\
    \ paren_string) (- level 1))]\n        [else (parse_parens_helper (rest paren_string)\
    \ level)]))\n    (parse_parens_helper paren_string 0))\n  (define (parse_nested_parens_helper\
    \ paren_string result)\n    (cond\n      [(empty? paren_string) result]\n    \
    \  [(equal? (first paren_string) #\\ ) (parse_nested_parens_helper (rest paren_string)\
    \ result)]\n      [else (parse_nested_parens_helper (rest paren_string) (append\
    \ result (list (parse_parens paren_string))))]))\n  (parse_nested_parens_helper\
    \ paren_string '()))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv9s9o7c0.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpv9s9o7c0.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpv9s9o7c0.rkt:31:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string current_level max_level)\n\
    \    (cond\n      [(empty? paren_string) (list max_level)]\n      [(char=? (first\
    \ paren_string) #\\()\n       (parse_nested_parens_helper (rest paren_string)\
    \ (add1 current_level) (max max_level current_level))]\n      [(char=? (first\
    \ paren_string) #\\))\n       (parse_nested_parens_helper (rest paren_string)\
    \ (sub1 current_level) max_level)]\n      [else (parse_nested_parens_helper (rest\
    \ paren_string) current_level max_level)]))\n  (parse_nested_parens_helper paren_string\
    \ 0 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((())) () ((())()())\"\
    ) (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((())) (((())))\") (list\
    \ 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n\
    (test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpe7ejuaqk.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpe7ejuaqk.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpe7ejuaqk.rkt:26:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [level\
    \ 0] [max-level 0])\n           (cond [(empty? paren_group) max-level]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ level 1) max-level)]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group) (- level 1) (max level max-level))]\n\
    \                 [else (loop (rest paren_group) level max-level)])))\n      \
    \ (string-split paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb3n18ela.rkt:24:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb3n18ela.rkt:25:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb3n18ela.rkt:26:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string current_depth max_depth)\n\
    \    (cond\n      [(empty? paren_string) (list max_depth)]\n      [(equal? (first\
    \ paren_string) #\\()\n       (parse_nested_parens_helper (rest paren_string)\
    \ (+ current_depth 1) (max max_depth current_depth))]\n      [(equal? (first paren_string)\
    \ #\\))\n       (parse_nested_parens_helper (rest paren_string) (- current_depth\
    \ 1) max_depth)]\n      [else (parse_nested_parens_helper (rest paren_string)\
    \ current_depth max_depth)]))\n  (parse_nested_parens_helper (string->list paren_string)\
    \ 0 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((())) () ((())()())\"\
    ) (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((())) (((())))\") (list\
    \ 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n\
    (test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpj2wpdc43.rkt:24:4

    actual:     ''(2)

    expected:   ''(2 3 1 3)

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpj2wpdc43.rkt:25:4

    actual:     ''(3)

    expected:   ''(1 2 3 4)

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpj2wpdc43.rkt:26:4

    actual:     ''(3)

    expected:   ''(4)

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_helper paren_string\
    \ depth)\n      (cond\n        [(empty? paren_string) depth]\n        [(char=?\
    \ (first paren_string) #\\() (parse_parens_helper (rest paren_string) (+ depth\
    \ 1))]\n        [(char=? (first paren_string) #\\)) (parse_parens_helper (rest\
    \ paren_string) (- depth 1))]\n        [else (parse_parens_helper (rest paren_string)\
    \ depth)]))\n    (parse_parens_helper paren_string 0))\n  (define (parse_parens_list\
    \ paren_list)\n    (cond\n      [(empty? paren_list) empty]\n      [else (cons\
    \ (parse_parens (first paren_list)) (parse_parens_list (rest paren_list)))]))\n\
    \  (parse_parens_list (string-split paren_string)))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmo6gh4ub.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpmo6gh4ub.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpmo6gh4ub.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string acc)\n    (cond\n      [(empty?\
    \ paren_string) (reverse acc)]\n      [(string=? (first paren_string) \"(\")\n\
    \       (parse_nested_parens_helper (rest paren_string) (cons 1 acc))]\n     \
    \ [(string=? (first paren_string) \")\")\n       (parse_nested_parens_helper (rest\
    \ paren_string) (cons (add1 (first acc)) (rest acc)))]\n      [(string=? (first\
    \ paren_string) \" \")\n       (parse_nested_parens_helper (rest paren_string)\
    \ (cons 0 acc))]))\n  (parse_nested_parens_helper paren_string (list)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpsw9dzdqm.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsw9dzdqm.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpsw9dzdqm.rkt:27:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ depth max-depth)\n      (cond ((null? paren_string) max-depth)\n           \
    \ ((char=? (car paren_string) #\\()\n             (parse-parens-iter (cdr paren_string)\
    \ (+ depth 1) (max depth max-depth)))\n            ((char=? (car paren_string)\
    \ #\\))\n             (parse-parens-iter (cdr paren_string) (- depth 1) (max depth\
    \ max-depth)))\n            (else (parse-parens-iter (cdr paren_string) depth\
    \ max-depth))))\n    (parse-parens-iter paren_string 0 0))\n  (map parse_parens\
    \ (string-split paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp39lww4nm.rkt:25:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp39lww4nm.rkt:26:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp39lww4nm.rkt:27:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [depth 0])\n           (cond [(empty? paren_group) max_depth]\n         \
    \        [(char=? (first paren_group) #\\()\n                  (loop (rest paren_group)\n\
    \                        (if (> (+ depth 1) max_depth)\n                     \
    \       (+ depth 1)\n                            max_depth)\n                \
    \        (+ depth 1))]\n                 [(char=? (first paren_group) #\\))\n\
    \                  (loop (rest paren_group)\n                        max_depth\n\
    \                        (- depth 1))]\n                 [else (loop (rest paren_group)\
    \ max_depth depth)])))\n       (regexp-split #rx\" \" paren_string)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8ty9knwq.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8ty9knwq.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8ty9knwq.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [nest_level 0] [max_nest_level 0])\n      (cond [(empty? paren_string) max_nest_level]\n\
    \            [(char=? (first paren_string) #\\()\n             (loop (rest paren_string)\
    \ (+ nest_level 1) (max nest_level max_nest_level))]\n            [(char=? (first\
    \ paren_string) #\\))\n             (loop (rest paren_string) (- nest_level 1)\
    \ max_nest_level)]\n            [else (loop (rest paren_string) nest_level max_nest_level)])))\n\
    \  (map parse_parens (string-split paren_string)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpiqfs8y6n.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpiqfs8y6n.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpiqfs8y6n.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens-helper paren_string current_level max_level)\n    (cond\n\
    \      [(empty? paren_string) max_level]\n      [(char=? (first paren_string)\
    \ #\\()\n       (parse-parens-helper (rest paren_string) (+ current_level 1) (max\
    \ max_level current_level))]\n      [(char=? (first paren_string) #\\))\n    \
    \   (parse-parens-helper (rest paren_string) (- current_level 1) max_level)]\n\
    \      [else (parse-parens-helper (rest paren_string) current_level max_level)]))\n\
    \  (define (parse-parens-group-helper paren_string current_level max_level)\n\
    \    (cond\n      [(empty? paren_string) (list max_level)]\n      [(char=? (first\
    \ paren_string) #\\ )\n       (cons max_level (parse-parens-group-helper (rest\
    \ paren_string) 0 0))]\n      [else (parse-parens-group-helper (rest paren_string)\
    \ current_level max_level)]))\n  (parse-parens-group-helper paren_string 0 0))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpla7stix7.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpla7stix7.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpla7stix7.rkt:32:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-helper paren_string\
    \ level)\n      (cond\n        [(empty? paren_string) level]\n        [(char=?\
    \ (first paren_string) #\\() (parse-parens-helper (rest paren_string) (+ level\
    \ 1))]\n        [(char=? (first paren_string) #\\)) (parse-parens-helper (rest\
    \ paren_string) (- level 1))]\n        [else (parse-parens-helper (rest paren_string)\
    \ level)]))\n    (parse-parens-helper paren_string 0))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpdic4a6u8.rkt:24:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpdic4a6u8.rkt:25:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpdic4a6u8.rkt:26:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string max_depth)\n    (cond\n  \
    \    [(empty? paren_string) max_depth]\n      [(char=? (first paren_string) #\\\
    ()\n       (parse_nested_parens_helper (rest paren_string) (+ max_depth 1))]\n\
    \      [(char=? (first paren_string) #\\))\n       (parse_nested_parens_helper\
    \ (rest paren_string) (- max_depth 1))]\n      [else (parse_nested_parens_helper\
    \ (rest paren_string) max_depth)]))\n  (map (lambda (paren_group)\n         (parse_nested_parens_helper\
    \ paren_group 0))\n       (string-split paren_string)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptu74b3n2.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmptu74b3n2.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmptu74b3n2.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-helper paren_string\
    \ level max-level)\n      (cond\n        [(empty? paren_string) max-level]\n \
    \       [(equal? (first paren_string) #\\()\n         (parse-parens-helper (rest\
    \ paren_string) (+ level 1) (max level max-level))]\n        [(equal? (first paren_string)\
    \ #\\))\n         (parse-parens-helper (rest paren_string) (- level 1) (max level\
    \ max-level))]\n        [else (parse-parens-helper (rest paren_string) level max-level)]))\n\
    \    (parse-parens-helper paren_string 0 0))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmppigwib4c.rkt:26:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmppigwib4c.rkt:27:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmppigwib4c.rkt:28:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [level\
    \ 0] [max_level 0])\n           (cond [(empty? paren_group) max_level]\n     \
    \            [(equal? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ level 1) (max max_level level))]\n                 [(equal?\
    \ (first paren_group) #\\))\n                  (loop (rest paren_group) (- level\
    \ 1) max_level)]\n                 [else (loop (rest paren_group) level max_level)])))\n\
    \       (string-split paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpioujhys6.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpioujhys6.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpioujhys6.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string)\n    (define (parse-parens-helper paren-string\
    \ level max-level)\n      (cond\n        [(empty? paren-string) max-level]\n \
    \       [(char=? (first paren-string) #\\()\n         (parse-parens-helper (rest\
    \ paren-string) (+ level 1) (max level max-level))]\n        [(char=? (first paren-string)\
    \ #\\))\n         (parse-parens-helper (rest paren-string) (- level 1) (max level\
    \ max-level))]\n        [else (parse-parens-helper (rest paren-string) level max-level)]))\n\
    \    (parse-parens-helper paren-string 0 0))\n  (map parse-parens (string-split\
    \ paren-string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp_qz6r6s8.rkt:19:34: paren-string: unbound identifier\n  in: paren-string\n\
    \  location...:\n   /tmp/tmp_qz6r6s8.rkt:19:34\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_helper paren_string\
    \ count)\n      (cond\n        [(empty? paren_string) count]\n        [(equal?\
    \ (first paren_string) #\\() (parse_parens_helper (rest paren_string) (+ count\
    \ 1))]\n        [(equal? (first paren_string) #\\)) (parse_parens_helper (rest\
    \ paren_string) (- count 1))]\n        [else (parse_parens_helper (rest paren_string)\
    \ count)]))\n    (parse_parens_helper paren_string 0))\n  (define (parse_parens_list\
    \ paren_string)\n    (cond\n      [(empty? paren_string) empty]\n      [(equal?\
    \ (first paren_string) #\\ ) (cons (parse_parens (rest paren_string)) (parse_parens_list\
    \ (rest paren_string)))]\n      [else (cons (parse_parens paren_string) (parse_parens_list\
    \ (rest paren_string)))]))\n  (parse_parens_list paren_string))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpruv4l92r.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpruv4l92r.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpruv4l92r.rkt:31:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (cond\n      [(empty? paren_string)\
    \ 0]\n      [(equal? (first paren_string) #\\() (add1 (parse_parens (rest paren_string)))]\n\
    \      [(equal? (first paren_string) #\\)) (sub1 (parse_parens (rest paren_string)))]\n\
    \      [else (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptirnblut.rkt:22:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmptirnblut.rkt:23:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmptirnblut.rkt:24:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string acc)\n    (cond\n      [(empty?\
    \ paren_string) (reverse acc)]\n      [(string=? paren_string \"\") (reverse acc)]\n\
    \      [(string=? (substring paren_string 0 1) \"(\")\n       (parse_nested_parens_helper\
    \ (substring paren_string 1) (cons 1 acc))]\n      [(string=? (substring paren_string\
    \ 0 1) \")\")\n       (parse_nested_parens_helper (substring paren_string 1) (cons\
    \ (- 1 (car acc)) acc))]\n      [(string=? (substring paren_string 0 1) \" \"\
    )\n       (parse_nested_parens_helper (substring paren_string 1) (cons 0 acc))]))\n\
    \  (parse_nested_parens_helper paren_string (list 0)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpr9rpqd2b.rkt:26:4

    actual:     ''(0 1 1 0 1 0 1 0 1 1 1 0 1 0 0 1 0 0 1 1 1 0 1 1 0 1 0 1)

    expected:   ''(2 3 1 3)

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpr9rpqd2b.rkt:27:4

    actual:     ''(0 1 0 0 1 1 0 1 0 1 1 1 0 1 0 0 1 1 1 1 0 1 0 1)

    expected:   ''(1 2 3 4)

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpr9rpqd2b.rkt:28:4

    actual:     ''(0 1 1 0 1 1 0 1 1 1 1 0 1 0 1)

    expected:   ''(4)

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [depth 0])\n           (cond [(empty? paren_group) max_depth]\n         \
    \        [(char=? (first paren_group) #\\()\n                  (loop (rest paren_group)\
    \ (max max_depth (add1 depth)) (add1 depth))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group) (max max_depth\
    \ depth) (sub1 depth))]\n                 [else (loop (rest paren_group) max_depth\
    \ depth)])))\n       (regexp-split #rx\" \" paren_string)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpituz1dny.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpituz1dny.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpituz1dny.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-helper paren_string\
    \ depth max-depth)\n      (cond\n        [(empty? paren_string) max-depth]\n \
    \       [(char=? (first paren_string) #\\()\n         (parse-parens-helper (rest\
    \ paren_string) (+ depth 1) (max depth max-depth))]\n        [(char=? (first paren_string)\
    \ #\\))\n         (parse-parens-helper (rest paren_string) (- depth 1) (max depth\
    \ max-depth))]\n        [else (parse-parens-helper (rest paren_string) depth max-depth)]))\n\
    \    (parse-parens-helper paren_string 0 0))\n  (map parse_parens (string-split\
    \ paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprr3gw1k_.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprr3gw1k_.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprr3gw1k_.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string current_level max_level)\n\
    \    (cond\n      [(empty? paren_string) max_level]\n      [(equal? (first paren_string)\
    \ #\\()\n       (parse_nested_parens_helper (rest paren_string) (+ current_level\
    \ 1) (max current_level max_level))]\n      [(equal? (first paren_string) #\\\
    ))\n       (parse_nested_parens_helper (rest paren_string) (- current_level 1)\
    \ (max current_level max_level))]\n      [else (parse_nested_parens_helper (rest\
    \ paren_string) current_level max_level)]))\n  (define (parse_nested_parens_helper2\
    \ paren_string current_level max_level)\n    (cond\n      [(empty? paren_string)\
    \ (list max_level)]\n      [(equal? (first paren_string) #\\space)\n       (append\
    \ (list max_level) (parse_nested_parens_helper2 (rest paren_string) 0 0))]\n \
    \     [(equal? (first paren_string) #\\()\n       (parse_nested_parens_helper2\
    \ (rest paren_string) (+ current_level 1) (max current_level max_level))]\n  \
    \    [(equal? (first paren_string) #\\))\n       (parse_nested_parens_helper2\
    \ (rest paren_string) (- current_level 1) (max current_level max_level))]\n  \
    \    [else (parse_nested_parens_helper2 (rest paren_string) current_level max_level)]))\n\
    \  (parse_nested_parens_helper2 paren_string 0 0))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmppy70w39n.rkt:34:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmppy70w39n.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmppy70w39n.rkt:36:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [max_nest 0] [curr_nest 0])\n      (cond\n        [(empty? paren_string) max_nest]\n\
    \        [(char=? (first paren_string) #\\()\n         (loop (rest paren_string)\n\
    \               (if (> (+ curr_nest 1) max_nest)\n                   (+ curr_nest\
    \ 1)\n                   max_nest)\n               (+ curr_nest 1))]\n       \
    \ [(char=? (first paren_string) #\\))\n         (loop (rest paren_string)\n  \
    \             max_nest\n               (- curr_nest 1))]\n        [else (loop\
    \ (rest paren_string) max_nest curr_nest)])))\n  (map parse_parens (string-split\
    \ paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpq6ba1rv_.rkt:31:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpq6ba1rv_.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpq6ba1rv_.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ max_nesting current_nesting)\n      (cond\n        [(empty? paren_string) (list\
    \ max_nesting current_nesting)]\n        [(char=? (first paren_string) #\\()\n\
    \         (parse-parens-iter (rest paren_string)\n                           \
    \ (if (> current_nesting max_nesting)\n                                current_nesting\n\
    \                                max_nesting)\n                            (+\
    \ current_nesting 1))]\n        [(char=? (first paren_string) #\\))\n        \
    \ (parse-parens-iter (rest paren_string)\n                            (if (> current_nesting\
    \ max_nesting)\n                                current_nesting\n            \
    \                    max_nesting)\n                            (- current_nesting\
    \ 1))]\n        [else (parse-parens-iter (rest paren_string)\n               \
    \                  max_nesting\n                                 current_nesting)]))\n\
    \    (parse-parens-iter paren_string 0 0))\n  (define (parse-nested-parens-iter\
    \ paren_string result)\n    (cond\n      [(empty? paren_string) result]\n    \
    \  [(char=? (first paren_string) #\\ )\n       (parse-nested-parens-iter (rest\
    \ paren_string)\n                                 (append result (list (parse_parens\
    \ (first (regexp-match #rx\"\\([^\\s]+\\)\" paren_string))))))]\n      [else (parse-nested-parens-iter\
    \ (rest paren_string)\n                                      result)]))\n  (parse-nested-parens-iter\
    \ paren_string '()))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp52nqzpat.rkt:34:89: read-syntax: unknown escape sequence `\\(`\
    \ in string\n  context...:\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let ((paren_stack '()))\n           (for\
    \ ((paren (in-string paren_group)))\n             (cond\n               [(char=?\
    \ paren #\\()\n                (set! paren_stack (cons paren paren_stack))]\n\
    \               [(char=? paren #\\))\n                (set! paren_stack (cdr paren_stack))]))\n\
    \           (length paren_stack)))\n       (string-split paren_string #\\space)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmppnjw5i9c.rkt:25:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmppnjw5i9c.rkt:26:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmppnjw5i9c.rkt:27:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string max_depth)\n    (if (empty?\
    \ paren_string)\n        max_depth\n        (cond\n         [(equal? (first paren_string)\
    \ #\\()\n          (parse_nested_parens_helper (rest paren_string) (+ max_depth\
    \ 1))]\n         [(equal? (first paren_string) #\\))\n          (parse_nested_parens_helper\
    \ (rest paren_string) (- max_depth 1))]\n         [else\n          (parse_nested_parens_helper\
    \ (rest paren_string) max_depth)])))\n  (map (lambda (paren_group)\n         (parse_nested_parens_helper\
    \ paren_group 0))\n       (string-split paren_string #\\space)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpd6tx42jx.rkt:28:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpd6tx42jx.rkt:29:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpd6tx42jx.rkt:30:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [max_nesting 0] [current_nesting 0])\n      (cond [(empty? paren_string) max_nesting]\n\
    \            [(char=? (first paren_string) #\\()\n             (loop (rest paren_string)\n\
    \                   (if (> current_nesting max_nesting)\n                    \
    \   (+ current_nesting 1)\n                       max_nesting)\n             \
    \      (+ current_nesting 1))]\n            [(char=? (first paren_string) #\\\
    ))\n             (loop (rest paren_string)\n                   max_nesting\n \
    \                  (- current_nesting 1))]\n            [else (loop (rest paren_string)\
    \ max_nesting current_nesting)])))\n  (map parse_parens (string-split paren_string)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfu247ho6.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfu247ho6.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfu247ho6.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ paren-count max-paren-count)\n      (cond ((null? paren_string) max-paren-count)\n\
    \            ((equal? (car paren_string) #\\()\n             (parse-parens-iter\
    \ (cdr paren_string) (add1 paren-count) (max paren-count max-paren-count)))\n\
    \            ((equal? (car paren_string) #\\))\n             (parse-parens-iter\
    \ (cdr paren_string) (sub1 paren-count) (max paren-count max-paren-count)))\n\
    \            (else (parse-parens-iter (cdr paren_string) paren-count max-paren-count))))\n\
    \    (parse-parens-iter paren_string 0 0))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6o8g8gy4.rkt:25:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6o8g8gy4.rkt:26:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6o8g8gy4.rkt:27:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-helper paren_string\
    \ level)\n      (cond\n        [(empty? paren_string) level]\n        [(char=?\
    \ (first paren_string) #\\() (parse-parens-helper (rest paren_string) (+ level\
    \ 1))]\n        [(char=? (first paren_string) #\\)) (parse-parens-helper (rest\
    \ paren_string) (- level 1))]\n        [else (parse-parens-helper (rest paren_string)\
    \ level)]))\n    (parse-parens-helper paren_string 0))\n  (map parse_parens (string-split\
    \ paren_string)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbbc5resi.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbbc5resi.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbbc5resi.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string max_depth)\n    (cond\n  \
    \    [(empty? paren_string) max_depth]\n      [(char=? (first paren_string) #\\\
    ()\n       (parse_nested_parens_helper (rest paren_string) (+ max_depth 1))]\n\
    \      [(char=? (first paren_string) #\\))\n       (parse_nested_parens_helper\
    \ (rest paren_string) (- max_depth 1))]\n      [else (parse_nested_parens_helper\
    \ (rest paren_string) max_depth)]))\n  (for/list ([paren_group (in-list (string-split\
    \ paren_string \" \"))])\n    (parse_nested_parens_helper paren_group 0)))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp721vvpom.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp721vvpom.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp721vvpom.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (cond\n      [(empty? paren_string)\
    \ 0]\n      [(eq? (first paren_string) #\\() (add1 (parse_parens (rest paren_string)))]\n\
    \      [(eq? (first paren_string) #\\)) (sub1 (parse_parens (rest paren_string)))]\n\
    \      [else (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpo2f5xx34.rkt:22:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpo2f5xx34.rkt:23:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpo2f5xx34.rkt:24:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens-iter paren_string\
    \ max-depth depth)\n      (cond\n        [(empty? paren_string) max-depth]\n \
    \       [(char=? (first paren_string) #\\()\n         (parse_parens-iter (rest\
    \ paren_string) (max max-depth (add1 depth)) (add1 depth))]\n        [(char=?\
    \ (first paren_string) #\\))\n         (parse_parens-iter (rest paren_string)\
    \ (max max-depth depth) (sub1 depth))]\n        [else (parse_parens-iter (rest\
    \ paren_string) max-depth depth)]))\n    (parse_parens-iter paren_string 0 0))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n   \
    \ (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp9ssjfi21.rkt:26:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp9ssjfi21.rkt:27:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp9ssjfi21.rkt:28:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [depth\
    \ 0] [max_depth 0])\n           (cond [(empty? paren_group) max_depth]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ depth 1) (max depth max_depth))]\n                 [(char=?\
    \ (first paren_group) #\\))\n                  (loop (rest paren_group) (- depth\
    \ 1) (max depth max_depth))]\n                 [else (loop (rest paren_group)\
    \ depth max_depth)])))\n       (regexp-split #rx\" \" paren_string)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgudvv7cz.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpgudvv7cz.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpgudvv7cz.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (\u03BB (paren_group)\n         (let loop ([paren_group paren_group] [count\
    \ 0] [max_count 0])\n           (cond [(empty? paren_group) max_count]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ count 1) (max count max_count))]\n                 [(char=?\
    \ (first paren_group) #\\))\n                  (loop (rest paren_group) (- count\
    \ 1) (max count max_count))]\n                 [else (loop (rest paren_group)\
    \ count max_count)])))\n       (regexp-split #rx\" \" paren_string)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmput546ur8.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmput546ur8.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmput546ur8.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens-helper paren-string current-level max-level)\n    (cond\n\
    \      [(empty? paren-string) max-level]\n      [(char=? (first paren-string)\
    \ #\\()\n       (parse-parens-helper (rest paren-string) (+ current-level 1) (max\
    \ current-level max-level))]\n      [(char=? (first paren-string) #\\))\n    \
    \   (parse-parens-helper (rest paren-string) (- current-level 1) max-level)]\n\
    \      [else (parse-parens-helper (rest paren-string) current-level max-level)]))\n\
    \  (parse-parens-helper paren_string 0 0))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpssc46dr6.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpssc46dr6.rkt:25:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpssc46dr6.rkt:26:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [nest_level\
    \ 0] [max_nest_level 0])\n           (cond [(empty? paren_group) max_nest_level]\n\
    \                 [(char=? (first paren_group) #\\()\n                  (loop\
    \ (rest paren_group) (+ nest_level 1) max_nest_level)]\n                 [(char=?\
    \ (first paren_group) #\\))\n                  (loop (rest paren_group) (- nest_level\
    \ 1)\n                        (if (> nest_level max_nest_level)\n            \
    \                nest_level\n                            max_nest_level))]\n \
    \                [else (loop (rest paren_group) nest_level max_nest_level)])))\n\
    \       (regexp-split #rx\" \" paren_string)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8ci8kb3n.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8ci8kb3n.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8ci8kb3n.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string max_depth depth)\n    (cond\n\
    \      [(empty? paren_string) (list max_depth)]\n      [(char=? (first paren_string)\
    \ #\\()\n       (parse_nested_parens_helper (rest paren_string) (max max_depth\
    \ (add1 depth)) (add1 depth))]\n      [(char=? (first paren_string) #\\))\n  \
    \     (parse_nested_parens_helper (rest paren_string) (max max_depth depth) (sub1\
    \ depth))]\n      [(char=? (first paren_string) #\\space)\n       (append (list\
    \ max_depth) (parse_nested_parens_helper (rest paren_string) 0 0))]))\n  (parse_nested_parens_helper\
    \ paren_string 0 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()()) ((()))\
    \ () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (()) ((()))\
    \ (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmps1vb6tnp.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmps1vb6tnp.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmps1vb6tnp.rkt:27:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_helper paren_string\
    \ level)\n      (cond\n        [(empty? paren_string) level]\n        [(char=?\
    \ (first paren_string) #\\() (parse_parens_helper (rest paren_string) (+ level\
    \ 1))]\n        [(char=? (first paren_string) #\\)) (parse_parens_helper (rest\
    \ paren_string) (- level 1))]\n        [else (parse_parens_helper (rest paren_string)\
    \ level)]))\n    (parse_parens_helper paren_string 0))\n  (define (parse_parens_helper\
    \ paren_string level)\n    (cond\n      [(empty? paren_string) (list level)]\n\
    \      [(char=? (first paren_string) #\\ ) (append (list level) (parse_parens_helper\
    \ (rest paren_string) 0))]\n      [(char=? (first paren_string) #\\() (parse_parens_helper\
    \ (rest paren_string) (+ level 1))]\n      [(char=? (first paren_string) #\\))\
    \ (parse_parens_helper (rest paren_string) (- level 1))]\n      [else (parse_parens_helper\
    \ (rest paren_string) level)]))\n  (parse_parens_helper paren_string 0))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxpuiqz4p.rkt:31:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpxpuiqz4p.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpxpuiqz4p.rkt:33:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse-parens paren-string)\n    (define (parse-parens-iter paren-string\
    \ acc)\n      (cond\n        [(empty? paren-string) acc]\n        [(char=? (first\
    \ paren-string) #\\()\n         (parse-parens-iter (rest paren-string) (add1 acc))]\n\
    \        [(char=? (first paren-string) #\\))\n         (parse-parens-iter (rest\
    \ paren-string) (sub1 acc))]\n        [else (parse-parens-iter (rest paren-string)\
    \ acc)]))\n    (parse-parens-iter paren-string 0))\n  (map parse-parens (string-split\
    \ paren-string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp1wm90qvy.rkt:19:34: paren-string: unbound identifier\n  in: paren-string\n\
    \  location...:\n   /tmp/tmp1wm90qvy.rkt:19:34\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-iter paren_string\
    \ max_depth curr_depth)\n      (cond\n        [(empty? paren_string) (list max_depth)]\n\
    \        [(char=? (first paren_string) #\\() (parse-parens-iter (rest paren_string)\
    \ (max max_depth (add1 curr_depth)) (add1 curr_depth))]\n        [(char=? (first\
    \ paren_string) #\\)) (parse-parens-iter (rest paren_string) max_depth (sub1 curr_depth))]\n\
    \        [else (parse-parens-iter (rest paren_string) max_depth curr_depth)]))\n\
    \    (parse-parens-iter paren_string 0 0))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate \"(()())\
    \ ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate \"() (())\
    \ ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"(()(())((())))\"\
    ) (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpqqrvzx19.rkt:24:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpqqrvzx19.rkt:25:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpqqrvzx19.rkt:26:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_nested_parens_helper paren_string acc)\n    (cond\n      [(empty?\
    \ paren_string) (reverse acc)]\n      [(string=? (substring paren_string 0 1)\
    \ \"(\")\n       (parse_nested_parens_helper (substring paren_string 1) (cons\
    \ 1 acc))]\n      [(string=? (substring paren_string 0 1) \")\")\n       (parse_nested_parens_helper\
    \ (substring paren_string 1) (cons (- 1 (car acc)) acc))]\n      [(string=? (substring\
    \ paren_string 0 1) \" \")\n       (parse_nested_parens_helper (substring paren_string\
    \ 1) (cons 0 acc))]))\n  (parse_nested_parens_helper paren_string '()))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb1zea_2n.rkt:25:4\n\
    \nsubstring: ending index is out of range\n  ending index: 1\n  valid range: [0,\
    \ 0]\n  string: \"\"\n--------------------\n--------------------\nERROR\nname:\
    \       check-equal?\nlocation:   /tmp/tmpb1zea_2n.rkt:26:4\n\nsubstring: ending\
    \ index is out of range\n  ending index: 1\n  valid range: [0, 0]\n  string: \"\
    \"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb1zea_2n.rkt:27:4\n\nsubstring: ending index is out of range\n\
    \  ending index: 1\n  valid range: [0, 0]\n  string: \"\"\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [current_depth 0])\n           (cond [(empty? paren_group) max_depth]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) max_depth (+ current_depth 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group) (max max_depth\
    \ current_depth) (- current_depth 1))]\n                 [else (loop (rest paren_group)\
    \ max_depth current_depth)])))\n       (regexp-split #rx\" \" paren_string)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb9ruli1s.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb9ruli1s.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb9ruli1s.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (\u03BB (paren_group)\n         (let loop ([paren_group paren_group] [max_level\
    \ 0] [curr_level 0])\n           (cond [(empty? paren_group) max_level]\n    \
    \             [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) max_level (+ curr_level 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group) (max max_level\
    \ curr_level) (- curr_level 1))]\n                 [else (loop (rest paren_group)\
    \ max_level curr_level)])))\n       (regexp-split #rx\" +\" paren_string)))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpqznvlojh.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpqznvlojh.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpqznvlojh.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_level\
    \ 0] [current_level 0])\n           (cond [(empty? paren_group) max_level]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) max_level (+ current_level 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group) (max max_level\
    \ current_level) (- current_level 1))]\n                 [else (loop (rest paren_group)\
    \ max_level current_level)])))\n       (string-split paren_string)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7geiwp55.rkt:24:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7geiwp55.rkt:25:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7geiwp55.rkt:26:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse-parens-helper paren_string\
    \ count)\n      (cond\n        [(empty? paren_string) count]\n        [(equal?\
    \ (first paren_string) #\\() (parse-parens-helper (rest paren_string) (+ count\
    \ 1))]\n        [(equal? (first paren_string) #\\)) (parse-parens-helper (rest\
    \ paren_string) (- count 1))]\n        [else (parse-parens-helper (rest paren_string)\
    \ count)]))\n    (parse-parens-helper paren_string 0))\n  (define (parse-parens-helper\
    \ paren_string count)\n    (cond\n      [(empty? paren_string) count]\n      [(equal?\
    \ (first paren_string) #\\ ) (parse-parens-helper (rest paren_string) count)]\n\
    \      [else (parse-parens-helper (rest paren_string) (cons (parse_parens (first\
    \ paren_string)) count))]))\n  (parse-parens-helper paren_string '()))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
    \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
    \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n \
    \   (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfizi0_bb.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()()) ((())) () ((())()())\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfizi0_bb.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"()\
    \ (()) ((())) (((())))\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpfizi0_bb.rkt:31:4\n\nfirst: contract\
    \ violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (map (\u03BB (paren_group)\n         (let loop ([paren_group paren_group] [max_depth\
    \ 0] [current_depth 0])\n           (cond [(empty? paren_group) max_depth]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group)\n                        (if (> current_depth max_depth)\n    \
    \                        (+ current_depth 1)\n                            max_depth)\n\
    \                        (+ current_depth 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group)\n           \
    \             max_depth\n                        (- current_depth 1))]\n     \
    \            [else (loop (rest paren_group) max_depth current_depth)])))\n   \
    \    (string-split paren_string #\\space)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate parse_nested_parens))\n    (check-equal? (candidate\
    \ \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal? (candidate\
    \ \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate \"\
    (()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp44bgq_w5.rkt:30:4\n\
    \nstring-split: contract violation\n  expected: (or/c string? regexp?)\n  given:\
    \ #\\space\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp44bgq_w5.rkt:31:4\n\nstring-split: contract violation\n  expected:\
    \ (or/c string? regexp?)\n  given: #\\space\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp44bgq_w5.rkt:32:4\n\nstring-split:\
    \ contract violation\n  expected: (or/c string? regexp?)\n  given: #\\space\n\
    --------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
    \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n;; >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n;; [2, 3, 1, 3]\n(define (parse_nested_parens paren_string)\n\
    \  (define (parse_parens paren_string)\n    (define (parse_parens_iter paren_string\
    \ level max_level)\n      (cond [(empty? paren_string) max_level]\n          \
    \  [(char=? (first paren_string) #\\()\n             (parse_parens_iter (rest\
    \ paren_string) (+ level 1) (max level max_level))]\n            [(char=? (first\
    \ paren_string) #\\))\n             (parse_parens_iter (rest paren_string) (-\
    \ level 1) (max level max_level))]\n            [else (parse_parens_iter (rest\
    \ paren_string) level max_level)]))\n    (parse_parens_iter paren_string 0 0))\n\
    \  (map parse_parens (string-split paren_string)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n    (check-equal?\
    \ (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n    (check-equal?\
    \ (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n    (check-equal? (candidate\
    \ \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3qdh1_aa.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"(()())\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp3qdh1_aa.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"()\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp3qdh1_aa.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"(()(())((())))\"\
    \n--------------------\n"
  stdout: ''
