language: racket
name: HumanEval_99_closest_integer
results:
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp9jpcq4ym.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp9jpcq4ym.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp9jpcq4ym.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpg5fkn4l6.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpg5fkn4l6.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpg5fkn4l6.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest-integer-helper\
    \ value)\n    (cond ((= (remainder value 1) 0) (round value))\n          ((< (remainder\
    \ value 1) 0.5) (round (- value (remainder value 1))))\n          (else (round\
    \ (+ value (- 1 (remainder value 1)))))))\n  (closest-integer-helper (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphw5nxg4r.rkt:29:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphw5nxg4r.rkt:30:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphw5nxg4r.rkt:31:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ((num (string->number\
    \ value)))\n    (if (negative? num)\n        (round (add1 num))\n        (round\
    \ num))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp5o17du6g.rkt:28:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp5o17du6g.rkt:29:4

    actual:     -14.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp5o17du6g.rkt:30:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkma3s6_n.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkma3s6_n.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkma3s6_n.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp0qd973b8.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp0qd973b8.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp0qd973b8.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let* ([num (string->number\
    \ value)]\n         [int (round num)])\n    (if (and (integer? num) (not (zero?\
    \ num)))\n        num\n        int)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpxxmswc7v.rkt:29:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpxxmswc7v.rkt:30:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpxxmswc7v.rkt:31:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpdj_hz58g.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpdj_hz58g.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpdj_hz58g.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpcloi9z69.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpcloi9z69.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpcloi9z69.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (negative?\
    \ (string->number value))\n      (- (round (string->number value)))\n      (round\
    \ (string->number value))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpbi0nyx8d.rkt:27:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpbi0nyx8d.rkt:28:4

    actual:     16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpbi0nyx8d.rkt:29:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round-away-from-zero\
    \ value)\n    (cond\n      [(< value 0) (round (- value) 0)]\n      [else (round\
    \ value 0)]))\n  (round-away-from-zero (string->number value)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6ngcg_b7.rkt:28:4\n\
    \nround: arity mismatch;\n the expected number of arguments does not match the\
    \ given number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6ngcg_b7.rkt:29:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6ngcg_b7.rkt:30:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6ngcg_b7.rkt:31:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6ngcg_b7.rkt:32:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpft31qft2.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpft31qft2.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpft31qft2.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpxyhn0hpb.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpxyhn0hpb.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpxyhn0hpb.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpvmm4lz0h.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpvmm4lz0h.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpvmm4lz0h.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ (string->number value) 0) (round (string->number value) -1)]\n    [else (round\
    \ (string->number value) 1)]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpry9qm9z9.rkt:26:4\n\
    \nround: arity mismatch;\n the expected number of arguments does not match the\
    \ given number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpry9qm9z9.rkt:27:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpry9qm9z9.rkt:28:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpry9qm9z9.rkt:29:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpry9qm9z9.rkt:30:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(=\
    \ (round value) value) (round value)]\n    [(< (round value) value) (round value)]\n\
    \    [(> (round value) value) (round value)]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkypomj6i.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkypomj6i.rkt:28:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkypomj6i.rkt:29:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkypomj6i.rkt:30:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkypomj6i.rkt:31:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpzdhxjzkg.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpzdhxjzkg.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpzdhxjzkg.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round-away-from-zero\
    \ x)\n    (if (negative? x)\n        (round (- x 0.5))\n        (round (+ x 0.5))))\n\
    \  (round-away-from-zero (string->number value)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpex6a4b8l.rkt:28:4

    actual:     10.0

    expected:   10

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpex6a4b8l.rkt:29:4

    actual:     15.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpex6a4b8l.rkt:30:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpex6a4b8l.rkt:31:4

    actual:     16.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpex6a4b8l.rkt:32:4

    actual:     0.0

    expected:   0

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmposnpfc1h.rkt:24:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmposnpfc1h.rkt:25:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmposnpfc1h.rkt:26:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmposnpfc1h.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmposnpfc1h.rkt:28:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([value (string->number\
    \ value)])\n    (if (negative? value)\n        (- (round (abs value)))\n     \
    \   (round value))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n \
    \   (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp2ksh22gl.rkt:28:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp2ksh22gl.rkt:29:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp2ksh22gl.rkt:30:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ (string->number value) 0)\n     (- (round (string->number value)))]\n    [else\n\
    \     (round (string->number value))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmps2v_ontc.rkt:29:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmps2v_ontc.rkt:30:4

    actual:     16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmps2v_ontc.rkt:31:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpiraunhdq.rkt:24:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpiraunhdq.rkt:25:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpiraunhdq.rkt:26:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpiraunhdq.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpiraunhdq.rkt:28:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(=\
    \ (remainder (string->number value) 1) 0)\n     (string->number value)]\n    [(>\
    \ (remainder (string->number value) 1) 0)\n     (add1 (floor (string->number value)))]\n\
    \    [(< (remainder (string->number value) 1) 0)\n     (floor (string->number\
    \ value))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphrmqx86e.rkt:31:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphrmqx86e.rkt:32:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphrmqx86e.rkt:33:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp9u8poaa6.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp9u8poaa6.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp9u8poaa6.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpgq8m58__.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpgq8m58__.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpgq8m58__.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"0\") 0]\n    [(string=? value \"0.0\") 0]\n    [(string=? value \"0.00\"\
    ) 0]\n    [(string=? value \"0.000\") 0]\n    [(string=? value \"0.0000\") 0]\n\
    \    [(string=? value \"0.00000\") 0]\n    [(string=? value \"0.000000\") 0]\n\
    \    [(string=? value \"0.0000000\") 0]\n    [(string=? value \"0.00000000\")\
    \ 0]\n    [(string=? value \"0.000000000\") 0]\n    [(string=? value \"0.0000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000\") 0]\n    [(string=? value \"0.000000000000\"\
    ) 0]\n    [(string=? value \"0.0000000000000\") 0]\n    [(string=? value \"0.00000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000\") 0]\n    [(string=? value \"\
    0.0000000000000000\") 0]\n    [(string=? value \"0.00000000000000000\") 0]\n \
    \   [(string=? value \"0.000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000000\") 0]\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpzvtti5vb.rkt:17:2: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 52\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(=\
    \ (modulo (string->number value) 1) 0) (string->number value)]\n    [(> (modulo\
    \ (string->number value) 1) 0) (round (string->number value))]\n    [(< (modulo\
    \ (string->number value) 1) 0) (round (string->number value))]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnkuvofg4.rkt:28:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnkuvofg4.rkt:29:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnkuvofg4.rkt:30:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ value 0) (- (round value))]\n    [else (round value)]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpypqwztv_.rkt:26:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpypqwztv_.rkt:27:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpypqwztv_.rkt:28:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpypqwztv_.rkt:29:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpypqwztv_.rkt:30:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp1s6qkiz2.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp1s6qkiz2.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp1s6qkiz2.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpifcd9kjt.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpifcd9kjt.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpifcd9kjt.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(=\
    \ (modulo (string->number value) 1) 0) (string->number value)]\n    [(> (modulo\
    \ (string->number value) 1) 0) (round (string->number value))]\n    [(< (modulo\
    \ (string->number value) 1) 0) (round (string->number value))]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpturptm_p.rkt:28:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpturptm_p.rkt:29:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpturptm_p.rkt:30:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([num (string->number\
    \ value)])\n    (if (negative? num)\n        (- (round (abs num)))\n        (round\
    \ num))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp9stoi2_q.rkt:28:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp9stoi2_q.rkt:29:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp9stoi2_q.rkt:30:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([value (string->number\
    \ value)])\n    (if (negative? value)\n        (- (round (abs value)))\n     \
    \   (round value))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n \
    \   (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpk65_8z09.rkt:28:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpk65_8z09.rkt:29:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpk65_8z09.rkt:30:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([v (string->number\
    \ value)])\n    (if (negative? v)\n        (- (round v))\n        (round v))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkhwpnahn.rkt:28:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkhwpnahn.rkt:29:4

    actual:     16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkhwpnahn.rkt:30:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (positive?\
    \ (string->number value))\n      (round (string->number value))\n      (round\
    \ (string->number value) -1)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpoo8vfhns.rkt:27:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoo8vfhns.rkt:28:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpoo8vfhns.rkt:29:4\nactual:\
    \     15.0\nexpected:   15\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpoo8vfhns.rkt:30:4\n\nround: arity\
    \ mismatch;\n the expected number of arguments does not match the given number\n\
    \  expected: 1\n  given: 2\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(>\
    \ (string->number value) 0)\n     (round (string->number value))]\n    [(< (string->number\
    \ value) 0)\n     (round (string->number value))]\n    [else\n     (round (string->number\
    \ value))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmph6ws8sz2.rkt:31:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmph6ws8sz2.rkt:32:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmph6ws8sz2.rkt:33:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([number\
    \ (string->number value)])\n    (if (negative? number)\n        (- (round (abs\
    \ number)))\n        (round number))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp1xfqiqb3.rkt:28:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp1xfqiqb3.rkt:29:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp1xfqiqb3.rkt:30:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmbcmr9gi.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmbcmr9gi.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmbcmr9gi.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpl4li4sbq.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpl4li4sbq.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpl4li4sbq.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (negative?\
    \ (string->number value))\n      (- (round (string->number value)))\n      (round\
    \ (string->number value))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpt9oz5lbz.rkt:27:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpt9oz5lbz.rkt:28:4

    actual:     16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpt9oz5lbz.rkt:29:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp5blus4in.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp5blus4in.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp5blus4in.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest_integer-helper\
    \ value)\n    (cond\n      [(= (remainder value 1) 0) (quotient value 1)]\n  \
    \    [(> (remainder value 1) 0) (quotient (+ value 1) 1)]\n      [(< (remainder\
    \ value 1) 0) (quotient (- value 1) 1)]))\n  (closest_integer-helper (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpq_kldl_i.rkt:30:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpq_kldl_i.rkt:31:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpq_kldl_i.rkt:32:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpppyasyz8.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpppyasyz8.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpppyasyz8.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (positive?\
    \ (string->number value))\n      (round (string->number value))\n      (round\
    \ (string->number value) -1)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpiymugcsl.rkt:27:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpiymugcsl.rkt:28:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpiymugcsl.rkt:29:4\nactual:\
    \     15.0\nexpected:   15\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpiymugcsl.rkt:30:4\n\nround: arity\
    \ mismatch;\n the expected number of arguments does not match the given number\n\
    \  expected: 1\n  given: 2\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ value 0) (round (- value))]\n    [else (round value)]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpeh_t4hy5.rkt:26:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpeh_t4hy5.rkt:27:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpeh_t4hy5.rkt:28:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpeh_t4hy5.rkt:29:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpeh_t4hy5.rkt:30:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp80mled0d.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp80mled0d.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp80mled0d.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"0\") 0]\n    [(string=? value \"0.0\") 0]\n    [(string=? value \"0.00\"\
    ) 0]\n    [(string=? value \"0.000\") 0]\n    [(string=? value \"0.0000\") 0]\n\
    \    [(string=? value \"0.00000\") 0]\n    [(string=? value \"0.000000\") 0]\n\
    \    [(string=? value \"0.0000000\") 0]\n    [(string=? value \"0.00000000\")\
    \ 0]\n    [(string=? value \"0.000000000\") 0]\n    [(string=? value \"0.0000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000\") 0]\n    [(string=? value \"0.000000000000\"\
    ) 0]\n    [(string=? value \"0.0000000000000\") 0]\n    [(string=? value \"0.00000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000\") 0]\n    [(string=? value \"\
    0.0000000000000000\") 0]\n    [(string=? value \"0.00000000000000000\") 0]\n \
    \   [(string=? value \"0.000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000000\") 0]\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmppg91fdly.rkt:17:2: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 52\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ (string->number value) 0)\n     (- (round (string->number value)))]\n    [else\n\
    \     (round (string->number value))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkgzzkl2y.rkt:29:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkgzzkl2y.rkt:30:4

    actual:     16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkgzzkl2y.rkt:31:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpdwfbrjqn.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpdwfbrjqn.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpdwfbrjqn.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpvva_oumi.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpvva_oumi.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpvva_oumi.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([num (string->number\
    \ value)])\n    (if (zero? (modulo num 1))\n        num\n        (if (< num 0)\n\
    \            (floor num)\n            (ceiling num)))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpayan7p7k.rkt:30:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpayan7p7k.rkt:31:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpayan7p7k.rkt:32:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpz2_nn13l.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpz2_nn13l.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpz2_nn13l.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpn9w257b4.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpn9w257b4.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpn9w257b4.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpcp4t2t05.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpcp4t2t05.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpcp4t2t05.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(=\
    \ (round value) value) (round value)]\n    [(> (round value) value) (round value)]\n\
    \    [(< (round value) value) (round value)]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprzvwj6vj.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprzvwj6vj.rkt:28:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprzvwj6vj.rkt:29:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprzvwj6vj.rkt:30:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprzvwj6vj.rkt:31:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(=\
    \ (remainder (string->number value) 1) 0) (string->number value)]\n    [(> (remainder\
    \ (string->number value) 1) 0) (round (string->number value))]\n    [(< (remainder\
    \ (string->number value) 1) 0) (round (string->number value))]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ig_mlyv.rkt:28:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ig_mlyv.rkt:29:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7ig_mlyv.rkt:30:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp5hzkegef.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp5hzkegef.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp5hzkegef.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpepalykjz.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpepalykjz.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpepalykjz.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpg2hzvrfp.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpg2hzvrfp.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpg2hzvrfp.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round-away-from-zero\
    \ n)\n    (if (negative? n)\n        (round n)\n        (add1 (round n))))\n \
    \ (round-away-from-zero (string->number value)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp7nlz_s6o.rkt:28:4

    actual:     11

    expected:   10

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp7nlz_s6o.rkt:29:4

    actual:     15.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp7nlz_s6o.rkt:30:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp7nlz_s6o.rkt:31:4

    actual:     16.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp7nlz_s6o.rkt:32:4

    actual:     1

    expected:   0

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (string=?\
    \ (substring value -1) \".\")\n      (string->number (substring value 0 -1))\n\
    \      (string->number value)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw9ay6wk4.rkt:26:4\n\
    \nsubstring: contract violation\n  expected: exact-nonnegative-integer?\n  given:\
    \ -1\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpw9ay6wk4.rkt:27:4\n\nsubstring: contract violation\n  expected:\
    \ exact-nonnegative-integer?\n  given: -1\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpw9ay6wk4.rkt:28:4\n\nsubstring:\
    \ contract violation\n  expected: exact-nonnegative-integer?\n  given: -1\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw9ay6wk4.rkt:29:4\n\
    \nsubstring: contract violation\n  expected: exact-nonnegative-integer?\n  given:\
    \ -1\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpw9ay6wk4.rkt:30:4\n\nsubstring: contract violation\n  expected:\
    \ exact-nonnegative-integer?\n  given: -1\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpyw_12der.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpyw_12der.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpyw_12der.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpub3k5l9i.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpub3k5l9i.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpub3k5l9i.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpd2g4o_3t.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpd2g4o_3t.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpd2g4o_3t.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpnmg_fgun.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpnmg_fgun.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpnmg_fgun.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpcsvex8jo.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpcsvex8jo.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpcsvex8jo.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ (string->number value) 0) (round (string->number value) -1)]\n    [else (round\
    \ (string->number value) 1)]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjn1sj8z2.rkt:26:4\n\
    \nround: arity mismatch;\n the expected number of arguments does not match the\
    \ given number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpjn1sj8z2.rkt:27:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpjn1sj8z2.rkt:28:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpjn1sj8z2.rkt:29:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpjn1sj8z2.rkt:30:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"10\") 10]\n    [(string=? value \"15.3\") 15]\n    [(string=? value\
    \ \"14.5\") 15]\n    [(string=? value \"-14.5\") -15]\n    [else 0]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpjv6eq022.rkt:31:4

    actual:     0

    expected:   -16

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest_integer-helper\
    \ value)\n    (cond\n      [(< value 0) (- (closest_integer-helper (- value)))\
    \ ]\n      [(> value 0) (round value) ]\n      [else 0]))\n  (closest_integer-helper\
    \ (string->number value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\")\
    \ 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpdmzs_45l.rkt:30:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpdmzs_45l.rkt:31:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpdmzs_45l.rkt:32:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpjhej5qas.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpjhej5qas.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpjhej5qas.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpv3oczeke.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpv3oczeke.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpv3oczeke.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let* ([num (string->number\
    \ value)]\n         [int (inexact->exact (round num))])\n    (if (and (integer?\
    \ num) (integer? int))\n        int\n        (if (and (integer? num) (not (integer?\
    \ int)))\n            num\n            (if (and (not (integer? num)) (integer?\
    \ int))\n                int\n                (if (and (not (integer? num)) (not\
    \ (integer? int)))\n                    (if (and (> num 0) (< num 1))\n      \
    \                  (if (> (- num 0.5) 0)\n                            0\n    \
    \                        1)\n                        (if (< num 0)\n         \
    \                   (if (> (- num 0.5) 0)\n                                -1\n\
    \                                0)\n                            (if (> (- num\
    \ 0.5) 0)\n                                (floor num)\n                     \
    \           (ceiling num)))))))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmph__adyoa.rkt:16:0: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 38\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpay_acyqz.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpay_acyqz.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpay_acyqz.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"10\") 10]\n    [(string=? value \"15.3\") 15]\n    [(string=? value\
    \ \"14.5\") 15]\n    [(string=? value \"-14.5\") -15]\n    [else (error 'closest_integer\
    \ \"unknown value\")]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n\
    \    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    ERROR

    name:       check-equal?

    location:   /tmp/tmp3nd5gdjd.rkt:31:4


    closest_integer: unknown value

    --------------------

    --------------------

    ERROR

    name:       check-equal?

    location:   /tmp/tmp3nd5gdjd.rkt:33:4


    closest_integer: unknown value

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpl9ghrmo8.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpl9ghrmo8.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpl9ghrmo8.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpjzdpcqo7.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpjzdpcqo7.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpjzdpcqo7.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"0\") 0]\n    [(string=? value \"0.0\") 0]\n    [(string=? value \"0.00\"\
    ) 0]\n    [(string=? value \"0.000\") 0]\n    [(string=? value \"0.0000\") 0]\n\
    \    [(string=? value \"0.00000\") 0]\n    [(string=? value \"0.000000\") 0]\n\
    \    [(string=? value \"0.0000000\") 0]\n    [(string=? value \"0.00000000\")\
    \ 0]\n    [(string=? value \"0.000000000\") 0]\n    [(string=? value \"0.0000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000\") 0]\n    [(string=? value \"0.000000000000\"\
    ) 0]\n    [(string=? value \"0.0000000000000\") 0]\n    [(string=? value \"0.00000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000\") 0]\n    [(string=? value \"\
    0.0000000000000000\") 0]\n    [(string=? value \"0.00000000000000000\") 0]\n \
    \   [(string=? value \"0.000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000000\") 0]\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp_u0qm64v.rkt:17:2: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 52\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"0\") 0]\n    [(string=? value \"0.0\") 0]\n    [(string=? value \"0.00\"\
    ) 0]\n    [(string=? value \"0.000\") 0]\n    [(string=? value \"0.0000\") 0]\n\
    \    [(string=? value \"0.00000\") 0]\n    [(string=? value \"0.000000\") 0]\n\
    \    [(string=? value \"0.0000000\") 0]\n    [(string=? value \"0.00000000\")\
    \ 0]\n    [(string=? value \"0.000000000\") 0]\n    [(string=? value \"0.0000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000\") 0]\n    [(string=? value \"0.000000000000\"\
    ) 0]\n    [(string=? value \"0.0000000000000\") 0]\n    [(string=? value \"0.00000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000\") 0]\n    [(string=? value \"\
    0.0000000000000000\") 0]\n    [(string=? value \"0.00000000000000000\") 0]\n \
    \   [(string=? value \"0.000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000000\") 0]\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp91nvwior.rkt:17:2: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 52\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp1xl1g51f.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp1xl1g51f.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp1xl1g51f.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmc8g2wo3.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmc8g2wo3.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmc8g2wo3.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round-away-from-zero\
    \ num)\n    (if (negative? num)\n        (round (add1 num))\n        (round num)))\n\
    \  (round-away-from-zero (string->number value)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkiwj8syy.rkt:29:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkiwj8syy.rkt:30:4

    actual:     -14.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkiwj8syy.rkt:31:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpk6jq_gye.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpk6jq_gye.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpk6jq_gye.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([value (string->number\
    \ value)])\n    (if (negative? value)\n        (- (round (abs value)))\n     \
    \   (round value))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n \
    \   (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpqy3qveb1.rkt:28:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpqy3qveb1.rkt:29:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpqy3qveb1.rkt:30:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpe2gyg7g6.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpe2gyg7g6.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpe2gyg7g6.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpz821nqjv.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpz821nqjv.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpz821nqjv.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"10\") 10]\n    [(string=? value \"15.3\") 15]\n    [(string=? value\
    \ \"14.5\") 15]\n    [(string=? value \"-14.5\") -15]\n    [else (error 'closest_integer\
    \ \"unknown value\")]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n\
    \    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    ERROR

    name:       check-equal?

    location:   /tmp/tmphi86n_4c.rkt:31:4


    closest_integer: unknown value

    --------------------

    --------------------

    ERROR

    name:       check-equal?

    location:   /tmp/tmphi86n_4c.rkt:33:4


    closest_integer: unknown value

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest_integer-helper\
    \ value)\n    (if (integer? value)\n        value\n        (closest_integer-helper\
    \ (round value))))\n  (closest_integer-helper (string->number value)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpwed4mvek.rkt:29:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpwed4mvek.rkt:30:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpwed4mvek.rkt:31:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (positive?\
    \ (string->number value))\n      (round (string->number value))\n      (round\
    \ (string->number value) -1)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmprjnptwvk.rkt:27:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprjnptwvk.rkt:28:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmprjnptwvk.rkt:29:4\nactual:\
    \     15.0\nexpected:   15\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmprjnptwvk.rkt:30:4\n\nround: arity\
    \ mismatch;\n the expected number of arguments does not match the given number\n\
    \  expected: 1\n  given: 2\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp9zmoua73.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp9zmoua73.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp9zmoua73.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp6p_ax_lh.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp6p_ax_lh.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp6p_ax_lh.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp8u9kv_71.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp8u9kv_71.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp8u9kv_71.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpv8477l1r.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpv8477l1r.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpv8477l1r.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round-away-from-zero\
    \ x)\n    (cond\n      [(< x 0) (- (round x))]\n      [else (round x)]))\n  (round-away-from-zero\
    \ (string->number value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\")\
    \ 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkyjpf5r4.rkt:29:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkyjpf5r4.rkt:30:4

    actual:     16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkyjpf5r4.rkt:31:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpco92emyc.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpco92emyc.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpco92emyc.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpe9lhu3gg.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpe9lhu3gg.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpe9lhu3gg.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let* ([value-number\
    \ (string->number value)]\n         [value-integer (round value-number)])\n  \
    \  (if (and (number? value-number)\n             (= value-number value-integer))\n\
    \        value-integer\n        (if (< value-number 0)\n            (floor value-number)\n\
    \            (ceiling value-number)))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpy5s64btf.rkt:32:4

    actual:     15.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpy5s64btf.rkt:33:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpy5s64btf.rkt:34:4

    actual:     16.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let* ([num (string->number\
    \ value)]\n         [int (round num)])\n    (if (and (integer? num)\n        \
    \     (integer? int))\n        int\n        (if (> num 0)\n            (ceiling\
    \ num)\n            (floor num)))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmzxxc0fo.rkt:32:4

    actual:     15.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmzxxc0fo.rkt:33:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmzxxc0fo.rkt:34:4

    actual:     16.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp2nlbjzse.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp2nlbjzse.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp2nlbjzse.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp5_zosaj9.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp5_zosaj9.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp5_zosaj9.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpt9tkxdta.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpt9tkxdta.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpt9tkxdta.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (negative?\
    \ (string->number value))\n      (- (round (string->number value)))\n      (round\
    \ (string->number value))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpbvd9_oul.rkt:27:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpbvd9_oul.rkt:28:4

    actual:     16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpbvd9_oul.rkt:29:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ (string->number value) 0) (- (round (string->number value)))]\n    [else (round\
    \ (string->number value))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpo81mz76q.rkt:27:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpo81mz76q.rkt:28:4

    actual:     16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpo81mz76q.rkt:29:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round-away-from-zero\
    \ value)\n    (if (negative? value)\n        (round (- value) 0)\n        (round\
    \ value 0)))\n  (round-away-from-zero (string->number value)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprm9lenkd.rkt:28:4\n\
    \nround: arity mismatch;\n the expected number of arguments does not match the\
    \ given number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprm9lenkd.rkt:29:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprm9lenkd.rkt:30:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprm9lenkd.rkt:31:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprm9lenkd.rkt:32:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round-away-from-zero\
    \ x)\n    (if (negative? x)\n        (round (- x 0.5))\n        (round (+ x 0.5))))\n\
    \  (round-away-from-zero (string->number value)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpv0r0lu2z.rkt:28:4

    actual:     10.0

    expected:   10

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpv0r0lu2z.rkt:29:4

    actual:     15.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpv0r0lu2z.rkt:30:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpv0r0lu2z.rkt:31:4

    actual:     16.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpv0r0lu2z.rkt:32:4

    actual:     0.0

    expected:   0

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp4tbvqjyl.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp4tbvqjyl.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp4tbvqjyl.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"0\") 0]\n    [(string=? value \"-0\") 0]\n    [(string=? value \"0.0\"\
    ) 0]\n    [(string=? value \"-0.0\") 0]\n    [(string=? value \"0.00\") 0]\n \
    \   [(string=? value \"-0.00\") 0]\n    [(string=? value \"0.000\") 0]\n    [(string=?\
    \ value \"-0.000\") 0]\n    [(string=? value \"0.0000\") 0]\n    [(string=? value\
    \ \"-0.0000\") 0]\n    [(string=? value \"0.00000\") 0]\n    [(string=? value\
    \ \"-0.00000\") 0]\n    [(string=? value \"0.000000\") 0]\n    [(string=? value\
    \ \"-0.000000\") 0]\n    [(string=? value \"0.0000000\") 0]\n    [(string=? value\
    \ \"-0.0000000\") 0]\n    [(string=? value \"0.00000000\") 0]\n    [(string=?\
    \ value \"-0.00000000\") 0]\n    [(string=? value \"0.000000000\") 0]\n    [(string=?\
    \ value \"-0.000000000\") 0]\n    [(string=? value \"0.0000000000\") 0]\n    [(string=?\
    \ value \"-0.0000000000\") 0]\n    [(string=? value \"0.00000000000\") 0]\n  \
    \  [(string=? value \"-0.00000000000\") 0]\n    [(string=? value \"0.000000000000\"\
    ) 0]\n    [(string=? value \"-0.000000000000\") 0]\n    [(string=? value \"0.0000000000000\"\
    ) 0]\n    [(string=? value \"-0.0000000000000\") 0]\n    [(string=? value \"0.00000000000000\"\
    ) 0]\n    [(string=? value \"-0.00000000000000\") 0]\n    [(string=? value \"\
    0.000000000000000\") 0]\n    [(string=? value \"-0.000000000000000\") 0]\n   \
    \ [(string=? value \"0.0000000000000000\") 0]\n    [(string=? value \"-0.0000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000\") 0]\n    [(string=?\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpqyw6ouez.rkt:53:5: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 54\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (string=?\
    \ (substring value (sub1 (string-length value)) (string-length value)) \".\")\n\
    \      (string->number (substring value 0 (sub1 (string-length value))))\n   \
    \   (string->number value)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpfhzq8jjh.rkt:27:4

    actual:     14.5

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpfhzq8jjh.rkt:28:4

    actual:     -15.5

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpfhzq8jjh.rkt:29:4

    actual:     15.3

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp_nlxuqum.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp_nlxuqum.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp_nlxuqum.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (positive?\
    \ (string->number value))\n      (round (string->number value))\n      (round\
    \ (string->number value) -1)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpuwpfaxw1.rkt:27:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpuwpfaxw1.rkt:28:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpuwpfaxw1.rkt:29:4\nactual:\
    \     15.0\nexpected:   15\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpuwpfaxw1.rkt:30:4\n\nround: arity\
    \ mismatch;\n the expected number of arguments does not match the given number\n\
    \  expected: 1\n  given: 2\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp674yhjan.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp674yhjan.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp674yhjan.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let* ((number\
    \ (string->number value))\n         (integer (round number)))\n    integer))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpftufobod.rkt:27:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpftufobod.rkt:28:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpftufobod.rkt:29:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp47iwfph7.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp47iwfph7.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp47iwfph7.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round-away-from-zero\
    \ x)\n    (if (negative? x)\n        (round (- x 0.5))\n        (round (+ x 0.5))))\n\
    \  (round-away-from-zero (string->number value)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmphv3lt5xp.rkt:28:4

    actual:     10.0

    expected:   10

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmphv3lt5xp.rkt:29:4

    actual:     15.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmphv3lt5xp.rkt:30:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmphv3lt5xp.rkt:31:4

    actual:     16.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmphv3lt5xp.rkt:32:4

    actual:     0.0

    expected:   0

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpcmbfom5v.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpcmbfom5v.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpcmbfom5v.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(=\
    \ (string->number value) (floor (string->number value)))\n     (floor (string->number\
    \ value))]\n    [(> (string->number value) (floor (string->number value)))\n \
    \    (ceiling (string->number value))]\n    [(< (string->number value) (floor\
    \ (string->number value)))\n     (floor (string->number value))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpjt2rc8qy.rkt:31:4

    actual:     15.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpjt2rc8qy.rkt:32:4

    actual:     -15.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpjt2rc8qy.rkt:33:4

    actual:     16.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpgxz7tk81.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpgxz7tk81.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpgxz7tk81.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp78ey0p46.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp78ey0p46.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp78ey0p46.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpaaxxzhrq.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpaaxxzhrq.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpaaxxzhrq.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpoisggy7b.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpoisggy7b.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpoisggy7b.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(=\
    \ (remainder (string->number value) 1) 0)\n     (string->number value)]\n    [(>\
    \ (remainder (string->number value) 1) 0)\n     (round (string->number value))]\n\
    \    [(< (remainder (string->number value) 1) 0)\n     (round (string->number\
    \ value))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpegpq65yj.rkt:31:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpegpq65yj.rkt:32:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpegpq65yj.rkt:33:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp594xnx04.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp594xnx04.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp594xnx04.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpo4lube0e.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpo4lube0e.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpo4lube0e.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpxnf3obta.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpxnf3obta.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpxnf3obta.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round-away-from-zero\
    \ n)\n    (if (< n 0)\n        (round (add1 n))\n        (round n)))\n  (round-away-from-zero\
    \ (string->number value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\")\
    \ 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmprd09sk32.rkt:29:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmprd09sk32.rkt:30:4

    actual:     -14.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmprd09sk32.rkt:31:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppe_3066i.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppe_3066i.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppe_3066i.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round-away-from-zero\
    \ x)\n    (if (negative? x)\n        (round (- x 0.5))\n        (round (+ x 0.5))))\n\
    \  (round-away-from-zero (string->number value)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpy4nku97_.rkt:28:4

    actual:     10.0

    expected:   10

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpy4nku97_.rkt:29:4

    actual:     15.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpy4nku97_.rkt:30:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpy4nku97_.rkt:31:4

    actual:     16.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpy4nku97_.rkt:32:4

    actual:     0.0

    expected:   0

    --------------------

    '
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"0\") 0]\n    [(string=? value \"1\") 1]\n    [(string=? value \"2\"\
    ) 2]\n    [(string=? value \"3\") 3]\n    [(string=? value \"4\") 4]\n    [(string=?\
    \ value \"5\") 5]\n    [(string=? value \"6\") 6]\n    [(string=? value \"7\"\
    ) 7]\n    [(string=? value \"8\") 8]\n    [(string=? value \"9\") 9]\n    [(string=?\
    \ value \"10\") 10]\n    [(string=? value \"11\") 11]\n    [(string=? value \"\
    12\") 12]\n    [(string=? value \"13\") 13]\n    [(string=? value \"14\") 14]\n\
    \    [(string=? value \"15\") 15]\n    [(string=? value \"16\") 16]\n    [(string=?\
    \ value \"17\") 17]\n    [(string=? value \"18\") 18]\n    [(string=? value \"\
    19\") 19]\n    [(string=? value \"20\") 20]\n    [(string=? value \"21\") 21]\n\
    \    [(string=? value \"22\") 22]\n    [(string=? value \"23\") 23]\n    [(string=?\
    \ value \"24\") 24]\n    [(string=? value \"25\") 25]\n    [(string=? value \"\
    26\") 26]\n    [(string=? value \"27\") 27]\n    [(string=? value \"28\") 28]\n\
    \    [(string=? value \"29\") 29]\n    [(string=? value \"30\") 30]\n    [(string=?\
    \ value \"31\") 31]\n    [(string=? value \"32\") 32]\n    [(string=? value \"\
    33\") 33]\n    [(string=? value \"34\") 34]\n    [(string=? value \"35\") 35]\n\
    \    [(string=? value \"36\") 36]\n    [(string=? value \"37\") 37]\n    [(string=?\
    \ value \"38\") 38]\n    [(string=? value \"39\") 39]\n    [(string=? value \"\
    40\") 40]\n    [(string=? value \"41\") 41]\n    [(string\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp164dqsk3.rkt:60:5: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 61\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpszbf88b8.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpszbf88b8.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpszbf88b8.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppne1h81r.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppne1h81r.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppne1h81r.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpqpuc2brx.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpqpuc2brx.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpqpuc2brx.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"10\") 10]\n    [(string=? value \"15.3\") 15]\n    [(string=? value\
    \ \"14.5\") 15]\n    [(string=? value \"-14.5\") -15]\n    [else 0]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpyyc_mlu7.rkt:31:4

    actual:     0

    expected:   -16

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmsfjdrdu.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmsfjdrdu.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmsfjdrdu.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"10\") 10]\n    [(string=? value \"15.3\") 15]\n    [(string=? value\
    \ \"14.5\") 15]\n    [(string=? value \"-14.5\") -15]\n    [else (error 'closest_integer\
    \ \"unknown value\")]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n\
    \    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    ERROR

    name:       check-equal?

    location:   /tmp/tmp74qp0ipg.rkt:31:4


    closest_integer: unknown value

    --------------------

    --------------------

    ERROR

    name:       check-equal?

    location:   /tmp/tmp74qp0ipg.rkt:33:4


    closest_integer: unknown value

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpv0nwlp5x.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpv0nwlp5x.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpv0nwlp5x.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (negative?\
    \ (string->number value))\n      (- (round (string->number value)))\n      (round\
    \ (string->number value))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp2zyc7lrz.rkt:27:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp2zyc7lrz.rkt:28:4

    actual:     16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp2zyc7lrz.rkt:29:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round-away-from-zero\
    \ x)\n    (if (negative? x)\n        (round (- x 0.5))\n        (round (+ x 0.5))))\n\
    \  (round-away-from-zero (string->number value)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp42umf86x.rkt:28:4

    actual:     10.0

    expected:   10

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp42umf86x.rkt:29:4

    actual:     15.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp42umf86x.rkt:30:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp42umf86x.rkt:31:4

    actual:     16.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp42umf86x.rkt:32:4

    actual:     0.0

    expected:   0

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpl5_zq35a.rkt:24:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpl5_zq35a.rkt:25:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpl5_zq35a.rkt:26:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpl5_zq35a.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpl5_zq35a.rkt:28:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpyfvo9wc8.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpyfvo9wc8.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpyfvo9wc8.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp4pwqtfrx.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp4pwqtfrx.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp4pwqtfrx.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpous4biit.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpous4biit.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpous4biit.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpcd5xk6jd.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpcd5xk6jd.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpcd5xk6jd.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"0\") 0]\n    [(string=? value \"0.0\") 0]\n    [(string=? value \"0.00\"\
    ) 0]\n    [(string=? value \"0.000\") 0]\n    [(string=? value \"0.0000\") 0]\n\
    \    [(string=? value \"0.00000\") 0]\n    [(string=? value \"0.000000\") 0]\n\
    \    [(string=? value \"0.0000000\") 0]\n    [(string=? value \"0.00000000\")\
    \ 0]\n    [(string=? value \"0.000000000\") 0]\n    [(string=? value \"0.0000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000\") 0]\n    [(string=? value \"0.000000000000\"\
    ) 0]\n    [(string=? value \"0.0000000000000\") 0]\n    [(string=? value \"0.00000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000\") 0]\n    [(string=? value \"\
    0.0000000000000000\") 0]\n    [(string=? value \"0.00000000000000000\") 0]\n \
    \   [(string=? value \"0.000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000000\") 0]\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpu67jfcga.rkt:17:2: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 52\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpyxmgvv5l.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpyxmgvv5l.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpyxmgvv5l.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppjfrnt8u.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppjfrnt8u.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmppjfrnt8u.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let* ([number\
    \ (string->number value)]\n         [integer (round number)])\n    integer))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp72p1m0f3.rkt:27:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp72p1m0f3.rkt:28:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp72p1m0f3.rkt:29:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmps_mrzk8q.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmps_mrzk8q.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmps_mrzk8q.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpwxdbn_7s.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpwxdbn_7s.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpwxdbn_7s.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmxqq62om.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmxqq62om.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmxqq62om.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"0\") 0]\n    [(string=? value \"-0\") 0]\n    [(string=? value \"0.0\"\
    ) 0]\n    [(string=? value \"-0.0\") 0]\n    [(string=? value \"0.00\") 0]\n \
    \   [(string=? value \"-0.00\") 0]\n    [(string=? value \"0.000\") 0]\n    [(string=?\
    \ value \"-0.000\") 0]\n    [(string=? value \"0.0000\") 0]\n    [(string=? value\
    \ \"-0.0000\") 0]\n    [(string=? value \"0.00000\") 0]\n    [(string=? value\
    \ \"-0.00000\") 0]\n    [(string=? value \"0.000000\") 0]\n    [(string=? value\
    \ \"-0.000000\") 0]\n    [(string=? value \"0.0000000\") 0]\n    [(string=? value\
    \ \"-0.0000000\") 0]\n    [(string=? value \"0.00000000\") 0]\n    [(string=?\
    \ value \"-0.00000000\") 0]\n    [(string=? value \"0.000000000\") 0]\n    [(string=?\
    \ value \"-0.000000000\") 0]\n    [(string=? value \"0.0000000000\") 0]\n    [(string=?\
    \ value \"-0.0000000000\") 0]\n    [(string=? value \"0.00000000000\") 0]\n  \
    \  [(string=? value \"-0.00000000000\") 0]\n    [(string=? value \"0.000000000000\"\
    ) 0]\n    [(string=? value \"-0.000000000000\") 0]\n    [(string=? value \"0.0000000000000\"\
    ) 0]\n    [(string=? value \"-0.0000000000000\") 0]\n    [(string=? value \"0.00000000000000\"\
    ) 0]\n    [(string=? value \"-0.00000000000000\") 0]\n    [(string=? value \"\
    0.000000000000000\") 0]\n    [(string=? value \"-0.000000000000000\") 0]\n   \
    \ [(string=? value \"0.0000000000000000\") 0]\n    [(string=? value \"-0.0000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000\") 0]\n    [(string=?\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpjrv02y7h.rkt:53:5: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 54\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let* ([value\
    \ (string->number value)]\n         [closest-integer (round value)])\n    closest-integer))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpb__2kqgc.rkt:27:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpb__2kqgc.rkt:28:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpb__2kqgc.rkt:29:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (integer?\
    \ value)\n      value\n      (if (positive? value)\n          (round value)\n\
    \          (round value))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7r_znhp8.rkt:28:4\n\
    \npositive?: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7r_znhp8.rkt:29:4\n\
    \npositive?: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7r_znhp8.rkt:30:4\n\
    \npositive?: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7r_znhp8.rkt:31:4\n\
    \npositive?: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7r_znhp8.rkt:32:4\n\
    \npositive?: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpknku8wxr.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpknku8wxr.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpknku8wxr.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpzlc0uwe0.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpzlc0uwe0.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpzlc0uwe0.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([value (string->number\
    \ value)])\n    (if (positive? value)\n        (round value)\n        (round (-\
    \ value)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp7q9xqf9l.rkt:28:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp7q9xqf9l.rkt:29:4

    actual:     16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp7q9xqf9l.rkt:30:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp0ed_jnd6.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp0ed_jnd6.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp0ed_jnd6.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"0\") 0]\n    [(string=? value \"0.0\") 0]\n    [(string=? value \"0.00\"\
    ) 0]\n    [(string=? value \"0.000\") 0]\n    [(string=? value \"0.0000\") 0]\n\
    \    [(string=? value \"0.00000\") 0]\n    [(string=? value \"0.000000\") 0]\n\
    \    [(string=? value \"0.0000000\") 0]\n    [(string=? value \"0.00000000\")\
    \ 0]\n    [(string=? value \"0.000000000\") 0]\n    [(string=? value \"0.0000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000\") 0]\n    [(string=? value \"0.000000000000\"\
    ) 0]\n    [(string=? value \"0.0000000000000\") 0]\n    [(string=? value \"0.00000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000\") 0]\n    [(string=? value \"\
    0.0000000000000000\") 0]\n    [(string=? value \"0.00000000000000000\") 0]\n \
    \   [(string=? value \"0.000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000000\") 0]\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmp_ifo8pe1.rkt:17:2: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 52\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([v (string->number\
    \ value)])\n    (if (negative? v)\n        (- (round (abs v)))\n        (round\
    \ v))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp0dof6w55.rkt:28:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp0dof6w55.rkt:29:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp0dof6w55.rkt:30:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp11heasfa.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp11heasfa.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp11heasfa.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpwve5yxbe.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpwve5yxbe.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpwve5yxbe.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmrdou31f.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmrdou31f.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpmrdou31f.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmplbxarw82.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmplbxarw82.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmplbxarw82.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest_integer-helper\
    \ value)\n    (if (positive? value)\n        (round value)\n        (round (-\
    \ value))))\n  (closest_integer-helper (string->number value)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp90yqp79m.rkt:29:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp90yqp79m.rkt:30:4

    actual:     16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp90yqp79m.rkt:31:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmphkq85t78.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmphkq85t78.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmphkq85t78.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpnv1xk1h0.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpnv1xk1h0.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpnv1xk1h0.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: -1
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest_integer-helper\
    \ value)\n    (cond\n      [(= value (floor value)) (floor value)]\n      [(=\
    \ value (ceiling value)) (ceiling value)]\n      [(< value 0) (closest_integer-helper\
    \ (+ value 1))]\n      [else (closest_integer-helper (- value 1))]))\n  (closest_integer-helper\
    \ (string->number value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\")\
    \ 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp95trm434.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp95trm434.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp95trm434.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpq_45k7e4.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpq_45k7e4.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpq_45k7e4.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (positive?\
    \ (string->number value))\n      (round (string->number value))\n      (round\
    \ (string->number value) -1)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpg3ppqc9k.rkt:27:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpg3ppqc9k.rkt:28:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpg3ppqc9k.rkt:29:4\nactual:\
    \     15.0\nexpected:   15\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpg3ppqc9k.rkt:30:4\n\nround: arity\
    \ mismatch;\n the expected number of arguments does not match the given number\n\
    \  expected: 1\n  given: 2\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpw_xgkl0s.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpw_xgkl0s.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpw_xgkl0s.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpwpo7a7e9.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpwpo7a7e9.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpwpo7a7e9.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpz_pxgpb0.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpz_pxgpb0.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpz_pxgpb0.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest_integer-helper\
    \ value)\n    (if (negative? value)\n        (closest_integer-helper (- value))\n\
    \        (if (integer? value)\n            value\n            (if (or (= (remainder\
    \ value 1) 0.5)\n                    (= (remainder value 1) -0.5))\n         \
    \       (if (negative? (remainder value 1))\n                    (floor value)\n\
    \                    (ceiling value))\n                (round value)))))\n  (closest_integer-helper\
    \ (string->number value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\")\
    \ 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2_st27_j.rkt:36:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2_st27_j.rkt:37:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2_st27_j.rkt:38:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest_integer-helper\
    \ value)\n    (cond ((< value 0) (round (- value)))\n          ((> value 0) (round\
    \ value))\n          (else 0)))\n  (closest_integer-helper (string->number value)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpuumasr1a.rkt:29:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpuumasr1a.rkt:30:4

    actual:     16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpuumasr1a.rkt:31:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (positive?\
    \ (string->number value))\n      (round (string->number value))\n      (round\
    \ (string->number value) -1)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzylbcxny.rkt:27:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzylbcxny.rkt:28:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzylbcxny.rkt:29:4\nactual:\
    \     15.0\nexpected:   15\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpzylbcxny.rkt:30:4\n\nround: arity\
    \ mismatch;\n the expected number of arguments does not match the given number\n\
    \  expected: 1\n  given: 2\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ value 0)\n     (round (add1 (string->number value)))\n     ]\n    [else\n  \
    \   (round (string->number value))\n     ]\n    )\n  )\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxjro9ocr.rkt:32:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxjro9ocr.rkt:33:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxjro9ocr.rkt:34:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxjro9ocr.rkt:35:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxjro9ocr.rkt:36:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpstya5ns0.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpstya5ns0.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpstya5ns0.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"0\") 0]\n    [(string=? value \"0.0\") 0]\n    [(string=? value \"0.00\"\
    ) 0]\n    [(string=? value \"0.000\") 0]\n    [(string=? value \"0.0000\") 0]\n\
    \    [(string=? value \"0.00000\") 0]\n    [(string=? value \"0.000000\") 0]\n\
    \    [(string=? value \"0.0000000\") 0]\n    [(string=? value \"0.00000000\")\
    \ 0]\n    [(string=? value \"0.000000000\") 0]\n    [(string=? value \"0.0000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000\") 0]\n    [(string=? value \"0.000000000000\"\
    ) 0]\n    [(string=? value \"0.0000000000000\") 0]\n    [(string=? value \"0.00000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000\") 0]\n    [(string=? value \"\
    0.0000000000000000\") 0]\n    [(string=? value \"0.00000000000000000\") 0]\n \
    \   [(string=? value \"0.000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000000\") 0]\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpsu4d1i18.rkt:17:2: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 52\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpz8leph4k.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpz8leph4k.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpz8leph4k.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpejo65k1b.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpejo65k1b.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpejo65k1b.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp3vdx1mge.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp3vdx1mge.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp3vdx1mge.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpb_8j0xec.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpb_8j0xec.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpb_8j0xec.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let* ([number\
    \ (string->number value)]\n         [integer (round number)])\n    integer))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpba5d3c8k.rkt:27:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpba5d3c8k.rkt:28:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpba5d3c8k.rkt:29:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp2fm8gdkh.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp2fm8gdkh.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp2fm8gdkh.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmponnqs7sw.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmponnqs7sw.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmponnqs7sw.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([num (string->number\
    \ value)])\n    (if (negative? num)\n        (- (round num))\n        (round num))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp7tvvm8ch.rkt:28:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp7tvvm8ch.rkt:29:4

    actual:     16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp7tvvm8ch.rkt:30:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ (string->number value) 0)\n     (- (round (string->number value)))]\n    [else\n\
    \     (round (string->number value))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp605oxoyu.rkt:29:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp605oxoyu.rkt:30:4

    actual:     16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp605oxoyu.rkt:31:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpyhmk62j5.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpyhmk62j5.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpyhmk62j5.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp0fsf3xd9.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp0fsf3xd9.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp0fsf3xd9.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmprk8jp1zj.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmprk8jp1zj.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmprk8jp1zj.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpzezp34go.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpzezp34go.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpzezp34go.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 1
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"0\") 0]\n    [(string=? value \"0.0\") 0]\n    [(string=? value \"0.00\"\
    ) 0]\n    [(string=? value \"0.000\") 0]\n    [(string=? value \"0.0000\") 0]\n\
    \    [(string=? value \"0.00000\") 0]\n    [(string=? value \"0.000000\") 0]\n\
    \    [(string=? value \"0.0000000\") 0]\n    [(string=? value \"0.00000000\")\
    \ 0]\n    [(string=? value \"0.000000000\") 0]\n    [(string=? value \"0.0000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000\") 0]\n    [(string=? value \"0.000000000000\"\
    ) 0]\n    [(string=? value \"0.0000000000000\") 0]\n    [(string=? value \"0.00000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000\") 0]\n    [(string=? value \"\
    0.0000000000000000\") 0]\n    [(string=? value \"0.00000000000000000\") 0]\n \
    \   [(string=? value \"0.000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000\") 0]\n    [(string=? value\
    \ \"0.000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000\") 0]\n    [(string=? value \"0.0000000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.000000000000000000000000000000000\") 0]\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "/tmp/tmpz8hefxge.rkt:17:2: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 52\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"10\") 10]\n    [(string=? value \"15.3\") 15]\n    [(string=? value\
    \ \"14.5\") 15]\n    [(string=? value \"-14.5\") -15]\n    [else 0]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpn2dsf7fy.rkt:31:4

    actual:     0

    expected:   -16

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp2zqrhj34.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp2zqrhj34.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp2zqrhj34.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp6mqj8c6c.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp6mqj8c6c.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmp6mqj8c6c.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (positive?\
    \ (string->number value))\n      (round (string->number value))\n      (round\
    \ (string->number value) -1)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_25ik6xb.rkt:27:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_25ik6xb.rkt:28:4\n\nround:\
    \ arity mismatch;\n the expected number of arguments does not match the given\
    \ number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_25ik6xb.rkt:29:4\nactual:\
    \     15.0\nexpected:   15\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmp_25ik6xb.rkt:30:4\n\nround: arity\
    \ mismatch;\n the expected number of arguments does not match the given number\n\
    \  expected: 1\n  given: 2\n--------------------\n"
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpqavm0f12.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpqavm0f12.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpqavm0f12.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpm8lz991m.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpm8lz991m.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpm8lz991m.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpdyq3dfz7.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpdyq3dfz7.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpdyq3dfz7.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpraxini1q.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpraxini1q.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpraxini1q.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
- exit_code: 0
  program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  status: Exception
  stderr: '--------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkwgvr_wc.rkt:25:4

    actual:     14.0

    expected:   15

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkwgvr_wc.rkt:26:4

    actual:     -16.0

    expected:   -16

    --------------------

    --------------------

    FAILURE

    name:       check-equal?

    location:   /tmp/tmpkwgvr_wc.rkt:27:4

    actual:     15.0

    expected:   15

    --------------------

    '
  stdout: ''
