name: HumanEval_132_is_nested
language: racket
prompt: "#lang racket\n\n;; Create a function that takes a string as input which contains\
  \ only square brackets.\n;; The function should return True if and only if there\
  \ is a valid subsequence of brackets \n;; where at least one bracket in the subsequence\
  \ is nested.\n;; is_nested('[[]]') \u279E True\n;; is_nested('[]]]]]]][[[[[]') \u279E\
  \ False\n;; is_nested('[][]') \u279E False\n;; is_nested('[]') \u279E False\n;;\
  \ is_nested('[[][]]') \u279E True\n;; is_nested('[[]][[') \u279E True\n(define (is_nested\
  \ string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_nested))\n\
  \    (check-equal? (candidate \"[[]]\") #t)\n    (check-equal? (candidate \"[]]]]]]][[[[[]\"\
  ) #f)\n    (check-equal? (candidate \"[][]\") #f)\n    (check-equal? (candidate\
  \ \"[]\") #f)\n    (check-equal? (candidate \"[[[[]]]]\") #t)\n    (check-equal?\
  \ (candidate \"[]]]]]]]]]]\") #f)\n    (check-equal? (candidate \"[][][[]]\") #t)\n\
  \    (check-equal? (candidate \"[[]\") #f)\n    (check-equal? (candidate \"[]]\"\
  ) #f)\n    (check-equal? (candidate \"[[]][[\") #t)\n    (check-equal? (candidate\
  \ \"[[][]]\") #t)\n    (check-equal? (candidate \"\") #f)\n    (check-equal? (candidate\
  \ \"[[[[[[[[\") #f)\n    (check-equal? (candidate \"]]]]]]]]\") #f)\n))\n\n(test-humaneval)"
completions: ["  (let ([stack '()])\n    (for ([c (in-string string)])\n      (cond\n\
    \        [(char=? c #\\[) (push #\\[ stack)]\n        [(char=? c #\\]) (pop stack)]))\n\
    \    (not (empty? stack))))\n", "  (define (is_nested-helper string count)\n \
    \   (cond\n      [(empty? string) (= count 0)]\n      [(= (first string) #\\[)\
    \ (is_nested-helper (rest string) (+ count 1))]\n      [(= (first string) #\\\
    ]) (is_nested-helper (rest string) (- count 1))]))\n  (is_nested-helper string\
    \ 0))\n", "  (define (is_nested-helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive?\
    \ count) (is_nested-helper (rest string) (- count 1)))]\n      [else (is_nested-helper\
    \ (rest string) count)]))\n  (is_nested-helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (is_nested-helper (rest string) (- count 1)) (> count\
    \ 0))]))\n  (is_nested-helper string 0))\n", "  (cond\n    [(empty? string) false]\n\
    \    [(empty? (regexp-match #rx\"[[]]\" string)) false]\n    [else true]))\n",
  "  (define (helper string count)\n    (cond\n      [(empty? string) (= count 0)]\n\
    \      [(= (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(=\
    \ (first string) #\\]) (and (not (zero? count)) (helper (rest string) (- count\
    \ 1)))]\n      [else (helper (rest string) count)]))\n  (helper string 0))\n",
  "  (define (is_nested-helper string count)\n    (cond\n      [(empty? string) (=\
    \ count 0)]\n      [(char=? (first string) #\\[) (is_nested-helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (is_nested-helper (rest\
    \ string) (- count 1)) (> count 0))]))\n  (is_nested-helper string 0))\n", " \
    \ (define (is_nested-helper string count)\n    (cond\n      [(empty? string) (if\
    \ (= count 0) #t #f)]\n      [(equal? (first string) \"[\") (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(equal? (first string) \"]\") (is_nested-helper\
    \ (rest string) (- count 1))]\n      [else (is_nested-helper (rest string) count)]))\n\
    \  (is_nested-helper string 0))\n", "  (define (helper str count)\n    (cond\n\
    \      [(empty? str) (if (= count 0) #t #f)]\n      [(char=? (first str) #\\[)\
    \ (helper (rest str) (+ count 1))]\n      [(char=? (first str) #\\]) (if (> count\
    \ 0) (helper (rest str) (- count 1)) #f)]))\n  (helper string 0))\n", "  (cond\n\
    \    [(empty? string) false]\n    [(equal? (first string) (last string)) (is_nested\
    \ (rest (butlast string)))]\n    [else false]))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond [(empty? string) (= count 0)]\n          [(char=? (first\
    \ string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n          [(char=?\
    \ (first string) #\\]) (is_nested-helper (rest string) (- count 1))]\n       \
    \   [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper string\
    \ 0))\n", "  (define (helper str)\n    (cond\n      [(empty? str) #t]\n      [(equal?\
    \ (first str) (second str)) (helper (rest (rest str)))]\n      [else #f]))\n \
    \ (helper (string->list string)))\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (= count 0)]\n      [(= (first string) #\\[) (helper (rest\
    \ string) (+ count 1))]\n      [(= (first string) #\\]) (and (not (zero? count))\
    \ (helper (rest string) (- count 1)))]\n      [else (helper (rest string) count)]))\n\
    \  (helper string 0))\n", "  (let loop ([i 0] [count 0])\n    (if (= i (string-length\
    \ string))\n        (if (= count 0)\n            #f\n            #t)\n       \
    \ (if (char=? (string-ref string i) #\\[)\n            (loop (+ i 1) (+ count\
    \ 1))\n            (loop (+ i 1) (- count 1))))))\n", "  (let loop ([string string]\
    \ [count 0])\n    (cond [(empty? string) (zero? count)]\n          [(char=? (first\
    \ string) #\\[) (loop (rest string) (+ count 1))]\n          [(char=? (first string)\
    \ #\\]) (and (positive? count) (loop (rest string) (- count 1)))]\n          [else\
    \ (loop (rest string) count)])))\n", "  (cond\n    [(empty? string) false]\n \
    \   [(equal? (first string) (last string)) (is_nested (rest (butlast string)))]\n\
    \    [else false]))\n", "  (define (is_nested-helper string count)\n    (cond\n\
    \      [(empty? string) (= count 0)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (is_nested-helper\
    \ (rest string) (- count 1)) (< count 1))]))\n  (is_nested-helper string 0))\n",
  "  (let loop ([string string] [count 0])\n    (cond [(empty? string) (if (= count\
    \ 0) #t #f)]\n          [(equal? (first string) #\\[) (loop (rest string) (+ count\
    \ 1))]\n          [(equal? (first string) #\\]) (if (= count 0) #f (loop (rest\
    \ string) (- count 1)))]\n          [else (loop (rest string) count)])))\n", " \
    \ (define (helper string)\n    (if (empty? string)\n        #t\n        (if (equal?\
    \ (first string) (last string))\n            (helper (rest (butlast string)))\n\
    \            #f)))\n  (helper string))\n", "  (cond\n    [(empty? string) false]\n\
    \    [(equal? (first string) #\\[)\n     (cond\n       [(empty? (rest string))\
    \ false]\n       [(equal? (first (rest string)) #\\])\n        (is_nested (rest\
    \ (rest string)))]\n       [else\n        (is_nested (rest string))])]\n    [else\n\
    \     (is_nested (rest string))]))\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (= count 0)]\n      [(char=? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (not (=\
    \ count 0)) (helper (rest string) (- count 1)))]\n      [else (helper (rest string)\
    \ count)]))\n  (helper string 0))\n", "  (define (is_nested-helper string count)\n\
    \    (cond [(empty? string) (= count 0)]\n          [(char=? (first string) #\\\
    [) (is_nested-helper (rest string) (+ count 1))]\n          [(char=? (first string)\
    \ #\\]) (and (is_nested-helper (rest string) (- count 1)) (> count 0))]\n    \
    \      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper string\
    \ 0))\n", "  (let loop ([string string] [count 0])\n    (cond [(empty? string)\
    \ (zero? count)]\n          [(equal? (first string) #\\[) (loop (rest string)\
    \ (+ count 1))]\n          [(equal? (first string) #\\]) (loop (rest string) (-\
    \ count 1))]\n          [else (loop (rest string) count)])))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(= (first\
    \ string) #\\[) (helper (rest string) (+ count 1))]\n      [(= (first string)\
    \ #\\]) (and (not (zero? count)) (helper (rest string) (- count 1)))]\n      [else\
    \ (helper (rest string) count)]))\n  (helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(equal?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(equal? (first\
    \ string) #\\]) (and (not (zero? count)) (helper (rest string) (- count 1)))]\n\
    \      [else (helper (rest string) count)]))\n  (helper string 0))\n", "  (define\
    \ (helper string)\n    (cond\n      [(empty? string) #t]\n      [(equal? (first\
    \ string) (second string)) (helper (rest (rest string)))]\n      [else (helper\
    \ (rest string))]))\n  (helper string))\n", "  (cond\n    [(empty? string) false]\n\
    \    [(equal? (first string) (last string)) (is_nested (rest (butlast string)))]\n\
    \    [else false]))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (if (= count 0) #t #f)]\n      [(char=? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (if (&gt; count\
    \ 0) (helper (rest string) (- count 1)) #f)]))\n  (helper string 0))\n</code>\n",
  "  (define (helper string)\n    (if (empty? string)\n        (values #f 0)\n   \
    \     (let* ([first (first string)]\n               [rest (rest string)]\n   \
    \            [result (helper rest)]\n               [is-nested (first result)]\n\
    \               [count (second result)])\n          (cond [(equal? first #\\[)\n\
    \                 (values is-nested (+ count 1))]\n                [(equal? first\
    \ #\\])\n                 (values (and is-nested (< count 1)) (- count 1))]\n\
    \                [else (values is-nested count)])\n          )))\n  (let* ([result\
    \ (helper (string->list string))]\n         [is-nested (first result)]\n     \
    \    [count (second result)])\n    (and is-nested (= count 0))))\n", "  (define\
    \ (helper string count)\n    (cond\n      [(empty? string) (= count 0)]\n    \
    \  [(equal? (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(equal?\
    \ (first string) #\\]) (and (not (zero? count)) (helper (rest string) (- count\
    \ 1)))]\n      [else (helper (rest string) count)]))\n  (helper string 0))\n",
  "  (define (helper string)\n    (cond\n      [(empty? string) #t]\n      [(equal?\
    \ (first string) (last string)) (helper (rest (butlast string)))]\n      [else\
    \ #f]))\n  (helper string))\n", "  (let loop ([string string] [count 0])\n   \
    \ (cond [(empty? string) (zero? count)]\n          [(char=? (first string) #\\\
    [) (loop (rest string) (+ count 1))]\n          [(char=? (first string) #\\])\
    \ (loop (rest string) (- count 1))]\n          [else (loop (rest string) count)])))\n",
  "  (define (helper string count)\n    (cond [(empty? string) (zero? count)]\n  \
    \        [(char=? (first string) #\\[) (helper (rest string) (+ count 1))]\n \
    \         [(char=? (first string) #\\]) (and (positive? count) (helper (rest string)\
    \ (- count 1)))]\n          [else (helper (rest string) count)]))\n  (helper string\
    \ 0))\n", "  (cond\n    [(empty? string) false]\n    [(equal? (first string) (last\
    \ string)) (is_nested (rest (butlast string)))]\n    [else false]))\n", "  (let\
    \ loop ([string string] [count 0])\n    (cond [(empty? string) (= count 0)]\n\
    \          [(equal? (first string) #\\[) (loop (rest string) (+ count 1))]\n \
    \         [(equal? (first string) #\\]) (loop (rest string) (- count 1))]\n  \
    \        [else (loop (rest string) count)])))\n", "  (define (helper string count)\n\
    \    (cond\n      [(empty? string) (eq? count 0)]\n      [(eq? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n      [(eq? (first string) #\\])\
    \ (and (not (eq? count 0)) (helper (rest string) (- count 1)))]))\n  (helper string\
    \ 0))\n", "  (define (is_nested-helper string count)\n    (cond\n      [(empty?\
    \ string) (= count 0)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (is_nested-helper\
    \ (rest string) (- count 1)) (> count 0))]))\n  (is_nested-helper string 0))\n",
  "  (define (helper string)\n    (cond\n      [(empty? string) #f]\n      [(equal?\
    \ (first string) (last string)) (helper (rest (butlast string)))]\n      [else\
    \ #t]))\n  (helper string))\n", "  (cond\n    [(empty? string) false]\n    [(and\
    \ (equal? (first string) #\\[) (equal? (last string) #\\])) true]\n    [else (is_nested\
    \ (substring string 1 (- (string-length string) 1))) ]))\n", "  (cond\n    [(empty?\
    \ string) false]\n    [(empty? (regexp-match #rx\"\\[\\]\" string)) false]\n \
    \   [else true]))\n", "  (cond\n    [(empty? string) false]\n    [(equal? (first\
    \ string) (last string)) (is_nested (rest (butlast string)))]\n    [else false]))\n",
  "  (define (helper string count)\n    (cond ((empty? string) (if (= count 0) #t\
    \ #f))\n          ((equal? (first string) #\\[) (helper (rest string) (+ count\
    \ 1)))\n          ((equal? (first string) #\\]) (if (&gt; count 0) (helper (rest\
    \ string) (- count 1)) #f))\n          (else (helper (rest string) count))))\n\
    \  (helper string 0))\n</code>\n", "  (define (helper string)\n    (cond\n   \
    \   [(empty? string) #t]\n      [(eq? (first string) (last string)) (helper (rest\
    \ (butlast string)))]\n      [else #f]))\n  (helper string))\n", "  (let loop\
    \ ([string string] [count 0])\n    (cond [(empty? string) (zero? count)]\n   \
    \       [(char=? (first string) #\\[) (loop (rest string) (+ count 1))]\n    \
    \      [(char=? (first string) #\\]) (and (positive? count) (loop (rest string)\
    \ (- count 1)))]\n          [else (loop (rest string) count)])))\n", "  (define\
    \ (helper str)\n    (cond\n      [(empty? str) #t]\n      [(string=? (first str)\
    \ \"[\") (helper (rest str))]\n      [(string=? (first str) \"]\") #f]))\n  (helper\
    \ (string->list string)))\n", "  (define (helper string count)\n    (cond\n  \
    \    [(empty? string) (if (= count 0) #t #f)]\n      [(equal? (first string) #\\\
    [) (helper (rest string) (+ count 1))]\n      [(equal? (first string) #\\]) (if\
    \ (&gt; count 0) (helper (rest string) (- count 1)) #f)]))\n  (helper string 0))\n",
  "  (cond\n    [(empty? string) false]\n    [(and (equal? (first string) #\\[) (equal?\
    \ (last string) #\\])) true]\n    [else (is_nested (rest (butlast string))) ]))\n",
  "  (define (helper string)\n    (cond\n      [(empty? string) #f]\n      [(equal?\
    \ (first string) (last string)) (helper (rest (butlast string)))]\n      [else\
    \ #t]))\n  (helper string))\n", "  (define (helper string)\n    (cond\n      [(empty?\
    \ string) #t]\n      [(equal? (first string) (last string)) (helper (rest (butlast\
    \ string)))]\n      [else #f]))\n  (helper string))\n", "  (cond\n    [(empty?\
    \ string) #f]\n    [(and (equal? (first string) #\\[) (equal? (last string) #\\\
    ])) #t]\n    [else (is_nested (substring string 1 (- (string-length string) 1)))])\n\
    \  )\n", "  (define (is_nested-helper string count)\n    (cond ((null? string)\
    \ (= count 0))\n          ((= (string-ref string 0) #\\[) (is_nested-helper (substring\
    \ string 1) (+ count 1)))\n          ((= (string-ref string 0) #\\]) (is_nested-helper\
    \ (substring string 1) (- count 1)))\n          (else (is_nested-helper (substring\
    \ string 1) count))))\n  (is_nested-helper string 0))\n", "  (cond\n    [(empty?\
    \ string) false]\n    [(equal? (first string) (last string)) (is_nested (rest\
    \ (butlast string)))]\n    [else false]))\n", "  (let loop ((string string) (count\
    \ 0))\n    (cond ((null? string) (zero? count))\n          ((equal? (car string)\
    \ #\\[) (loop (cdr string) (+ count 1)))\n          ((equal? (car string) #\\\
    ]) (loop (cdr string) (- count 1)))\n          (else (loop (cdr string) count)))))\n",
  "  (define (helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n\
    \      [(equal? (first string) #\\[) (helper (rest string) (+ count 1))]\n   \
    \   [(equal? (first string) #\\]) (and (not (zero? count)) (helper (rest string)\
    \ (- count 1)))]\n      [else (helper (rest string) count)]))\n  (helper string\
    \ 0))\n", "  (define (helper string)\n    (cond\n      [(empty? string) #t]\n\
    \      [(equal? (first string) (last string)) (helper (rest (butlast string)))]\n\
    \      [else #f]))\n  (helper string))\n", "  (define (helper string count)\n\
    \    (cond\n      [(empty? string) (= count 0)]\n      [(equal? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n      [(equal? (first string) #\\\
    ]) (and (not (= count 0)) (helper (rest string) (- count 1)))]\n      [else (helper\
    \ (rest string) count)]))\n  (helper string 0))\n", "  (define (helper string)\n\
    \    (cond\n      [(empty? string) #t]\n      [(equal? (first string) (second\
    \ string)) (helper (rest (rest string)))]\n      [else #f]))\n  (helper string))\n",
  "  (define (helper str)\n    (if (empty? str)\n        #t\n        (if (equal? (first\
    \ str) (last str))\n            (helper (rest (butlast str)))\n            #f)))\n\
    \  (helper (string->list string)))\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (if (= count 0) true false)]\n      [(equal? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n      [(equal? (first string) #\\\
    ]) (if (= count 0) false (helper (rest string) (- count 1)))]\n      [else (helper\
    \ (rest string) count)]))\n  (helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (is_nested-helper (rest string) (- count 1)) (> count\
    \ 0))]))\n  (is_nested-helper string 0))\n", "  (define (helper str count)\n \
    \   (cond\n      [(empty? str) (= count 0)]\n      [(char=? (first str) #\\[)\
    \ (helper (rest str) (+ count 1))]\n      [(char=? (first str) #\\]) (and (> count\
    \ 0) (helper (rest str) (- count 1)))]\n      [else (helper (rest str) count)]))\n\
    \  (helper string 0))\n", "  (define (is_nested-helper string count)\n    (cond\n\
    \      [(empty? string) (= count 0)]\n      [(equal? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(equal? (first string) #\\]) (and (not (zero?\
    \ count)) (is_nested-helper (rest string) (- count 1)))]\n      [else (is_nested-helper\
    \ (rest string) count)]))\n  (is_nested-helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(= (first\
    \ string) #\\[) (helper (rest string) (+ count 1))]\n      [(= (first string)\
    \ #\\]) (and (not (zero? count)) (helper (rest string) (- count 1)))]\n      [else\
    \ (helper (rest string) count)]))\n  (helper string 0))\n", "  (define (helper\
    \ string acc)\n    (cond\n      [(empty? string) (and (empty? acc) #t)]\n    \
    \  [(equal? (first string) #\\[) (helper (rest string) (cons (first string) acc))]\n\
    \      [(equal? (first string) #\\]) (and (not (empty? acc)) (helper (rest string)\
    \ (rest acc)))]\n      [else (helper (rest string) acc)]))\n  (helper string '()))\n",
  "  (define (is_nested-helper string count)\n    (cond\n      [(empty? string) (if\
    \ (= count 0) #t #f)]\n      [(char=? (first string) #\\[) (is_nested-helper (rest\
    \ string) (+ count 1))]\n      [(char=? (first string) #\\]) (if (> count 0) (is_nested-helper\
    \ (rest string) (- count 1)) #f)]))\n  (is_nested-helper string 0))\n", "  (define\
    \ (is_nested-helper string count)\n    (cond\n      [(empty? string) (if (= count\
    \ 0) #t #f)]\n      [(equal? (first string) #\\[) (is_nested-helper (rest string)\
    \ (+ count 1))]\n      [(equal? (first string) #\\]) (if (&gt; count 0) (is_nested-helper\
    \ (rest string) (- count 1)) #f)]\n      [else (is_nested-helper (rest string)\
    \ count)]))\n  (is_nested-helper string 0))\n</code>\n", "  (define (helper string)\n\
    \    (if (empty? string)\n        '()\n        (cons (first string) (helper (rest\
    \ string)))))\n  (define (helper2 string)\n    (if (empty? string)\n        '()\n\
    \        (cons (first string) (helper2 (rest string)))))\n  (define (helper3 string)\n\
    \    (if (empty? string)\n        '()\n        (cons (first string) (helper3 (rest\
    \ string)))))\n  (define (helper4 string)\n    (if (empty? string)\n        '()\n\
    \        (cons (first string) (helper4 (rest string)))))\n  (define (helper5 string)\n\
    \    (if (empty? string)\n        '()\n        (cons (first string) (helper5 (rest\
    \ string)))))\n  (define (helper6 string)\n    (if (empty? string)\n        '()\n\
    \        (cons (first string) (helper6 (rest string)))))\n  (define (helper7 string)\n\
    \    (if (empty? string)\n        '()\n        (cons (first string) (helper7 (rest\
    \ string)))))\n  (define (helper8 string)\n    (if (empty? string)\n        '()\n\
    \        (cons (first string) (helper8 (rest string)))))\n  (define (helper9 string)\n\
    \    (if (empty? string)\n        '()\n        (cons (first string) (helper9 (rest\
    \ string)))))\n  (define (helper10 string)\n    (if (empty? string)\n        '()\n\
    \        (cons (first string) (helper10 (rest string)))))\n  (define (helper11\
    \ string)\n    (if (empty? string)\n        '()\n        (cons (first string)\
    \ (helper11 (rest string)))))\n  (define (helper12 string)\n    (if (empty? string)\n\
    \        '()\n        (cons (first string) (helper12 (rest string)))))\n  (define\
    \ (helper13 string)\n    (if (empty? string)\n        '()\n        (cons (first\
    \ string) (helper", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (= count 0)]\n      [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]\n      [else (helper (rest string) count)]))\n\
    \  (helper string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (if (= count 0) #t #f)]\n      [(equal? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(equal? (first string) #\\]) (if (> count\
    \ 0) (helper (rest string) (- count 1)) #f)]))\n  (helper string 0))\n", "  (cond\n\
    \    [(empty? string) false]\n    [(equal? (first string) (last string)) (is_nested\
    \ (rest (butlast string)))]\n    [else false]))\n", "  (define (helper string)\n\
    \    (cond\n      [(empty? string) '()]\n      [(equal? (first string) #\\[) (cons\
    \ (first string) (helper (rest string)))]\n      [(equal? (first string) #\\])\
    \ (if (empty? (helper (rest string)))\n                                      \
    \ (cons (first string) (helper (rest string)))\n                             \
    \          (helper (rest string)))]\n      [else (helper (rest string))]))\n \
    \ (if (empty? (helper string))\n      #f\n      #t))\n", "  (define (helper string\
    \ count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(char=? (first\
    \ string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first string)\
    \ #\\]) (and (not (= count 0)) (helper (rest string) (- count 1)))]\n      [else\
    \ (helper (rest string) count)]))\n  (helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(= (first\
    \ string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(= (first\
    \ string) #\\]) (and (is_nested-helper (rest string) (- count 1)) (> count 0))]))\n\
    \  (is_nested-helper (string->list string) 0))\n", "  (let loop ([string string]\
    \ [count 0])\n    (cond [(empty? string) (if (= count 0) #f #t)]\n          [(char=?\
    \ (first string) #\\[) (loop (rest string) (+ count 1))]\n          [(char=? (first\
    \ string) #\\]) (if (= count 0) #f (loop (rest string) (- count 1)))]\n      \
    \    [else (loop (rest string) count)])))\n", "  (let loop ([string string] [count\
    \ 0])\n    (cond [(empty? string) (if (= count 0) #t #f)]\n          [(equal?\
    \ (first string) #\\[) (loop (rest string) (+ count 1))]\n          [(equal? (first\
    \ string) #\\]) (if (= count 0) #f (loop (rest string) (- count 1)))]\n      \
    \    [else (loop (rest string) count)])))\n", "  (cond\n    [(empty? string) false]\n\
    \    [(empty? (regexp-match #rx\"\\\\[\\\\]\" string)) false]\n    [else true]))\n",
  "  (define (is_nested-helper string count)\n    (cond\n      [(empty? string) (=\
    \ count 0)]\n      [(= (first string) #\\[) (is_nested-helper (rest string) (+\
    \ count 1))]\n      [(= (first string) #\\]) (is_nested-helper (rest string) (-\
    \ count 1))]))\n  (is_nested-helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (is_nested-helper (rest string) (- count 1)) (> count\
    \ 0))]))\n  (is_nested-helper string 0))\n", "  (define (is_nested-helper string\
    \ count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(= (first string)\
    \ #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(= (first string)\
    \ #\\]) (and (is_nested-helper (rest string) (- count 1)) (> count 0))]))\n  (is_nested-helper\
    \ (string->list string) 0))\n", "  (cond\n    [(empty? string) false]\n    [(equal?\
    \ (first string) (last string)) (is_nested (rest (butlast string)))]\n    [else\
    \ false]))\n", "  (define (is_nested-helper string count)\n    (cond ((empty?\
    \ string) (zero? count))\n          ((equal? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1)))\n          ((equal? (first string) #\\]) (and (not\
    \ (zero? count)) (is_nested-helper (rest string) (- count 1))))\n          (else\
    \ (is_nested-helper (rest string) count))))\n  (is_nested-helper string 0))\n",
  "  (cond\n    [(empty? string) false]\n    [(and (equal? (first string) #\\[) (equal?\
    \ (last string) #\\])) true]\n    [else (is_nested (substring string 1 (- (string-length\
    \ string) 1)))])\n  )\n", "  (cond\n    [(empty? string) false]\n    [(equal?\
    \ (first string) (last string)) (is_nested (rest (butlast string)))]\n    [else\
    \ false]))\n", "  (let loop ([string string] [count 0])\n    (cond [(empty? string)\
    \ (zero? count)]\n          [(char=? (first string) #\\[) (loop (rest string)\
    \ (+ count 1))]\n          [(char=? (first string) #\\]) (loop (rest string) (-\
    \ count 1))]\n          [else (loop (rest string) count)])))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (if (= count 0) #t #f)]\n \
    \     [(char=? (first string) #\\[) (helper (rest string) (+ count 1))]\n    \
    \  [(char=? (first string) #\\]) (if (&gt; count 0) (helper (rest string) (- count\
    \ 1)) #f)]))\n  (helper string 0))\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (if (= count 0) #t #f)]\n      [(char=? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first string) #\\\
    ]) (if (> count 0) (helper (rest string) (- count 1)) #f)]))\n  (helper string\
    \ 0))\n", "  (define (helper string)\n    (if (empty? string)\n        '()\n \
    \       (cons (first string) (helper (rest string)))))\n  (define (is_nested?\
    \ string)\n    (if (empty? string)\n        #t\n        (if (and (equal? (first\
    \ string) #\\[) (equal? (last string) #\\]))\n            (is_nested? (rest (butlast\
    \ string)))\n            #f)))\n  (is_nested? (helper string)))\n", "  (define\
    \ (is_nested-helper string count)\n    (cond\n      [(empty? string) (= count\
    \ 0)]\n      [(char=? (first string) #\\[) (is_nested-helper (rest string) (+\
    \ count 1))]\n      [(char=? (first string) #\\]) (and (is_nested-helper (rest\
    \ string) (- count 1)) (> count 0))]))\n  (is_nested-helper string 0))\n", " \
    \ (cond\n    [(empty? string) false]\n    [(equal? (first string) (last string))\
    \ (is_nested (rest (butlast string)))]\n    [else false]))\n", "  (cond\n    [(empty?\
    \ string) false]\n    [(string-contains? string \"[\")\n     (let ([open-bracket-index\
    \ (string-index string \"[\")])\n       (let ([close-bracket-index (string-index\
    \ string \"]\" open-bracket-index)])\n         (if (and (not (eq? close-bracket-index\
    \ #f))\n                  (not (eq? open-bracket-index close-bracket-index)))\n\
    \             (is_nested (substring string (+ open-bracket-index 1) (- close-bracket-index\
    \ 1)))\n             false)))]\n    [else false]))\n", "  (define (helper str)\n\
    \    (cond\n      [(empty? str) #t]\n      [(equal? (first str) (last str)) (helper\
    \ (rest (butlast str)))]\n      [else #f]))\n  (helper (string->list string)))\n",
  "  (cond\n    [(empty? string) false]\n    [(equal? (first string) (last string))\
    \ (is_nested (rest (butlast string)))]\n    [else false]))\n", "  (cond\n    [(empty?\
    \ string) false]\n    [(empty? (regexp-match #rx\"[[]]\" string)) false]\n   \
    \ [else true]))\n", "  (define (is_nested-helper string count)\n    (cond\n  \
    \    [(empty? string) (= count 0)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (is_nested-helper\
    \ (rest string) (- count 1))]))\n  (is_nested-helper string 0))\n", "  (define\
    \ (is_nested-helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n\
    \      [(char=? (first string) #\\[) (is_nested-helper (rest string) (+ count\
    \ 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (is_nested-helper\
    \ (rest string) (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n\
    \  (is_nested-helper string 0))\n", "  (define (is_nested-helper string count)\n\
    \    (cond\n      [(empty? string) (if (= count 0) #t #f)]\n      [(equal? (first\
    \ string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(equal?\
    \ (first string) #\\]) (if (> count 0) (is_nested-helper (rest string) (- count\
    \ 1)) #f)]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (let ([stack '()])\n    (for ([char (in-string string)])\n\
    \      (cond\n        [(equal? char #\\[) (push char stack)]\n        [(equal?\
    \ char #\\]) (pop stack)]))\n    (empty? stack)))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(= (first\
    \ string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(= (first\
    \ string) #\\]) (is_nested-helper (rest string) (- count 1))]))\n  (is_nested-helper\
    \ string 0))\n", "  (let loop ([string string] [count 0])\n    (if (empty? string)\n\
    \        (if (&gt; count 0)\n            #t\n            #f)\n        (if (equal?\
    \ (first string) #\\[)\n            (loop (rest string) (+ count 1))\n       \
    \     (if (equal? (first string) #\\])\n                (if (&gt; count 0)\n \
    \                   (loop (rest string) (- count 1))\n                    #f)\n\
    \                #f)))))\n</code>\n", "  (cond\n    [(empty? string) false]\n\
    \    [(empty? (regexp-match #rx\"[^][]\" string)) false]\n    [else (is_nested\
    \ (regexp-replace #rx\"\\[\\]\" string \"\"))]))\n", "  (let loop ([string string]\
    \ [count 0])\n    (cond [(empty? string) (zero? count)]\n          [(char=? (first\
    \ string) #\\[) (loop (rest string) (+ count 1))]\n          [(char=? (first string)\
    \ #\\]) (loop (rest string) (- count 1))]\n          [else (loop (rest string)\
    \ count)])))\n", "  (define (helper string)\n    (cond\n      [(empty? string)\
    \ #t]\n      [(and (equal? (first string) #\\[)\n            (equal? (last string)\
    \ #\\]))\n       (helper (substring string 1 (- (string-length string) 1)))]\n\
    \      [else #f]))\n  (helper string))\n", "  (cond\n    [(empty? string) #f]\n\
    \    [(string-contains? string \"[]\") #t]\n    [else (is_nested (string-replace\
    \ string \"[]\" \"\"))]))\n", "  (let loop ([string string] [count 0])\n    (cond\
    \ [(empty? string) (if (= count 0) #f #t)]\n          [(char=? (first string)\
    \ #\\[) (loop (rest string) (+ count 1))]\n          [(char=? (first string) #\\\
    ]) (loop (rest string) (- count 1))]\n          [else (loop (rest string) count)])))\n",
  "  (let loop ((string string) (count 0))\n    (cond ((null? string) (if (= count\
    \ 0) #f #t))\n          ((char=? (car string) #\\[) (loop (cdr string) (+ count\
    \ 1)))\n          ((char=? (car string) #\\]) (if (= count 0) #f (loop (cdr string)\
    \ (- count 1))))\n          (else (loop (cdr string) count)))))\n", "  (define\
    \ (helper string count)\n    (cond\n      [(empty? string) (= count 0)]\n    \
    \  [(char=? (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (not (zero? count)) (helper (rest string) (- count\
    \ 1)))]\n      [else (helper (rest string) count)]))\n  (helper string 0))\n",
  "  (cond\n    [(empty? string) false]\n    [(empty? (regexp-match #rx\"[][]\" string))\
    \ false]\n    [else true]))\n", "  (define (helper string)\n    (cond\n      [(empty?\
    \ string) #t]\n      [(equal? (first string) (second string)) (helper (rest (rest\
    \ string)))]\n      [else #f]))\n  (helper string))\n", "  (define (helper string)\n\
    \    (cond\n      [(empty? string) #t]\n      [(equal? (first string) (last string))\
    \ (helper (rest (butlast string)))]\n      [else #f]))\n  (helper string))\n",
  "  (define (helper string count)\n    (cond\n      [(empty? string) (= count 0)]\n\
    \      [(= (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(=\
    \ (first string) #\\]) (and (not (zero? count)) (helper (rest string) (- count\
    \ 1)))]\n      [else (helper (rest string) count)]))\n  (helper string 0))\n",
  "  (define (helper string)\n    (if (empty? string)\n        '()\n        (cons\
    \ (first string) (helper (rest string)))))\n  (define (is_nested? string)\n  \
    \  (if (empty? string)\n        #t\n        (if (and (equal? (first string) #\\\
    [) (equal? (last string) #\\]))\n            (is_nested? (rest (butlast string)))\n\
    \            #f)))\n  (is_nested? (helper string)))\n", "  (define (helper str)\n\
    \    (cond\n      [(empty? str) #t]\n      [(equal? (first str) (second str))\
    \ (helper (rest (rest str)))]\n      [else (helper (rest str))]))\n  (helper (string->list\
    \ string)))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (= count 0)]\n      [(equal? (first string) #\\[) (helper (rest string) (+ count\
    \ 1))]\n      [(equal? (first string) #\\]) (and (not (zero? count)) (helper (rest\
    \ string) (- count 1)))]\n      [else (helper (rest string) count)]))\n  (helper\
    \ string 0))\n", "  (define (is_nested-helper string count)\n    (cond\n     \
    \ [(empty? string) (= count 0)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (is_nested-helper\
    \ (rest string) (- count 1)) (> count 0))]))\n  (is_nested-helper string 0))\n",
  "  (let loop ([string string] [count 0])\n    (cond\n      [(empty? string) (if\
    \ (= count 0) #t #f)]\n      [(equal? (first string) #\\[) (loop (rest string)\
    \ (+ count 1))]\n      [(equal? (first string) #\\]) (if (> count 0) (loop (rest\
    \ string) (- count 1)) #f)])))\n", "  (cond\n    [(empty? string) false]\n   \
    \ [(empty? (regexp-match #rx\"[][]\" string)) false]\n    [else true]))\n", " \
    \ (let loop ([string string] [count 0])\n    (cond [(empty? string) (zero? count)]\n\
    \          [(char=? (first string) #\\[) (loop (rest string) (+ count 1))]\n \
    \         [(char=? (first string) #\\]) (loop (rest string) (- count 1))]\n  \
    \        [else (loop (rest string) count)])))\n", "  (let loop ([string string]\
    \ [count 0])\n    (cond [(empty? string) (if (= count 0) #f #t)]\n          [(char=?\
    \ (first string) #\\[) (loop (rest string) (+ count 1))]\n          [(char=? (first\
    \ string) #\\]) (if (= count 0) #f (loop (rest string) (- count 1)))]\n      \
    \    [else (loop (rest string) count)])))\n", "  (define (helper string count)\n\
    \    (cond\n      [(empty? string) (zero? count)]\n      [(equal? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n      [(equal? (first string) #\\\
    ]) (and (positive? count) (helper (rest string) (- count 1)))]\n      [else (helper\
    \ (rest string) count)]))\n  (helper string 0))\n", "  (let loop ([string string]\
    \ [count 0])\n    (cond [(empty? string)\n           (zero? count)]\n        \
    \  [(equal? (first string) #\\[)\n           (loop (rest string) (+ count 1))]\n\
    \          [(equal? (first string) #\\])\n           (and (positive? count)\n\
    \                (loop (rest string) (- count 1)))]\n          [else\n       \
    \    (loop (rest string) count)])))\n", "  (define (is_nested-helper string count)\n\
    \    (cond\n      [(empty? string) (if (= count 0) #t #f)]\n      [(equal? (first\
    \ string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(equal?\
    \ (first string) #\\]) (if (> count 0) (is_nested-helper (rest string) (- count\
    \ 1)) #f)]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string)\n    (cond\n      [(empty? string)\
    \ #t]\n      [(equal? (first string) (second string)) (helper (rest (rest string)))]\n\
    \      [else #f]))\n  (helper string))\n", "  (let loop ([string string] [count\
    \ 0])\n    (cond [(empty? string) (zero? count)]\n          [(char=? (first string)\
    \ #\\[) (loop (rest string) (+ count 1))]\n          [(char=? (first string) #\\\
    ]) (and (positive? count) (loop (rest string) (- count 1)))]\n          [else\
    \ (loop (rest string) count)])))\n", "  (define (is_nested-helper string count)\n\
    \    (cond\n      [(empty? string) (= count 0)]\n      [(char=? (first string)\
    \ #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=? (first string)\
    \ #\\]) (and (not (zero? count)) (is_nested-helper (rest string) (- count 1)))]\n\
    \      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper string\
    \ 0))\n", "  (define (helper string count)\n    (cond [(empty? string) (= count\
    \ 0)]\n          [(char=? (first string) #\\[) (helper (rest string) (+ count\
    \ 1))]\n          [(char=? (first string) #\\]) (and (positive? count) (helper\
    \ (rest string) (- count 1)))]\n          [else (helper (rest string) count)]))\n\
    \  (helper string 0))\n", "  (define (helper string)\n    (cond\n      [(empty?\
    \ string) #t]\n      [(equal? (first string) (second string)) (helper (rest (rest\
    \ string)))]\n      [else #f]))\n  (helper string))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond [(empty? string) (= count 0)]\n          [(char=? (first\
    \ string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n          [(char=?\
    \ (first string) #\\]) (and (is_nested-helper (rest string) (- count 1))\n   \
    \                                         (> count 0))]\n          [else (is_nested-helper\
    \ (rest string) count)]))\n  (is_nested-helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(char=?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first\
    \ string) #\\]) (and (not (zero? count)) (helper (rest string) (- count 1)))]\n\
    \      [else (helper (rest string) count)]))\n  (helper string 0))\n", "  (define\
    \ (is_nested-helper string count)\n    (cond\n      [(empty? string) (= count\
    \ 0)]\n      [(char=? (first string) #\\[) (is_nested-helper (rest string) (+\
    \ count 1))]\n      [(char=? (first string) #\\]) (and (is_nested-helper (rest\
    \ string) (- count 1)) (> count 0))]))\n  (is_nested-helper string 0))\n", " \
    \ (define (helper string)\n    (cond\n      [(empty? string) #t]\n      [(eq?\
    \ (first string) (last string)) (helper (rest (butlast string)))]\n      [else\
    \ #f]))\n  (helper string))\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (= count 0)]\n      [(char=? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (not (=\
    \ count 0)) (helper (rest string) (- count 1)))]\n      [else (helper (rest string)\
    \ count)]))\n  (helper string 0))\n", "  (let loop ((string string) (count 0))\n\
    \    (cond ((null? string) (zero? count))\n          ((equal? (car string) #\\\
    [) (loop (cdr string) (+ count 1)))\n          ((equal? (car string) #\\]) (and\
    \ (not (zero? count)) (loop (cdr string) (- count 1))))\n          (else (loop\
    \ (cdr string) count)))))\n", "  (define (is_nested-helper string)\n    (cond\n\
    \      [(empty? string) #f]\n      [(equal? (first string) \"[\") (is_nested-helper\
    \ (rest string))]\n      [(equal? (first string) \"]\") (is_nested-helper (rest\
    \ string))]\n      [else #t]))\n  (is_nested-helper (string->list string)))\n",
  "  (let loop ([string string] [count 0])\n    (cond [(empty? string) (zero? count)]\n\
    \          [(char=? (first string) #\\[) (loop (rest string) (+ count 1))]\n \
    \         [(char=? (first string) #\\]) (loop (rest string) (- count 1))]\n  \
    \        [else (loop (rest string) count)])))\n", "  (if (empty? string)\n   \
    \   #f\n      (if (equal? (first string) (last string))\n          (is_nested\
    \ (substring string 1 (- (string-length string) 1)))\n          #f)))\n", "  (define\
    \ (is_nested-helper string count)\n    (cond\n      [(empty? string) (= count\
    \ 0)]\n      [(= (first string) #\\[) (is_nested-helper (rest string) (+ count\
    \ 1))]\n      [(= (first string) #\\]) (and (is-positive? count) (is_nested-helper\
    \ (rest string) (- count 1)))]))\n  (is_nested-helper string 0))\n", "  (and (string-contains\
    \ string \"[\")\n       (string-contains string \"]\")))\n", "  (let loop ((string\
    \ string) (count 0))\n    (cond ((null? string) (zero? count))\n          ((char=?\
    \ (car string) #\\[) (loop (cdr string) (+ count 1)))\n          ((char=? (car\
    \ string) #\\]) (loop (cdr string) (- count 1)))\n          (else (loop (cdr string)\
    \ count)))))\n", "  (define (is_nested-helper string)\n    (cond\n      [(empty?\
    \ string) #t]\n      [(equal? (first string) (last string)) (is_nested-helper\
    \ (rest (butlast string)))]\n      [else #f]))\n  (is_nested-helper string))\n",
  "  (cond\n    [(empty? string) false]\n    [(equal? (first string) (last string))\
    \ (is_nested (rest (butlast string)))]\n    [else false]))\n", "  (cond\n    [(empty?\
    \ string) false]\n    [(and (equal? (first string) #\\[) (equal? (last string)\
    \ #\\])) true]\n    [else (is_nested (substring string 1 (- (string-length string)\
    \ 1)))])\n)\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (= count 0)]\n      [(char=? (first string) #\\[) (helper (rest string) (+ count\
    \ 1))]\n      [(char=? (first string) #\\]) (and (not (= count 0)) (helper (rest\
    \ string) (- count 1)))]\n      [else (helper (rest string) count)]))\n  (helper\
    \ string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (equal? count 0)]\n      [(equal? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(equal? (first string) #\\]) (and (not (equal? count 0))\
    \ (helper (rest string) (- count 1)))]))\n  (helper string 0))\n", "  (define\
    \ (helper string count)\n    (cond\n      [(empty? string) (= count 0)]\n    \
    \  [(= (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(= (first\
    \ string) #\\]) (and (not (zero? count)) (helper (rest string) (- count 1)))]\n\
    \      [else (helper (rest string) count)]))\n  (helper string 0))\n", "  (define\
    \ (is_nested-helper string count)\n    (cond\n      [(empty? string) (if (= count\
    \ 0) #t #f)]\n      [(char=? (first string) #\\[) (is_nested-helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (if (&gt; count 0) (is_nested-helper\
    \ (rest string) (- count 1)) #f)]\n      [else (is_nested-helper (rest string)\
    \ count)]))\n  (is_nested-helper string 0))\n", "  (define (helper string acc)\n\
    \    (cond [(empty? string) (empty? acc)]\n          [(equal? (first string) #\\\
    [) (helper (rest string) (cons (first string) acc))]\n          [(equal? (first\
    \ string) #\\]) (and (not (empty? acc)) (helper (rest string) (rest acc)))]))\n\
    \  (helper string '()))\n", "  (cond\n    [(empty? string) false]\n    [(equal?\
    \ (first string) (last string)) (is_nested (rest (butlast string)))]\n    [else\
    \ false]))\n", "  (let loop ([string string] [count 0])\n    (cond\n      [(empty?\
    \ string) (= count 0)]\n      [(char=? (first string) #\\[) (loop (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (not (= count 0)) (loop\
    \ (rest string) (- count 1)))]\n      [else (loop (rest string) count)])))\n",
  "  (define (is_nested_helper string count)\n    (if (empty? string)\n        (if\
    \ (= count 0)\n            #t\n            #f)\n        (if (= (first string)\
    \ #\\[)\n            (is_nested_helper (rest string) (+ count 1))\n          \
    \  (if (= (first string) #\\])\n                (if (= count 0)\n            \
    \        #f\n                    (is_nested_helper (rest string) (- count 1)))\n\
    \                #f))))\n  (is_nested_helper string 0))\n", "  (define (helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (helper (rest string) (+ count 1))]\n      [(char=? (first\
    \ string) #\\]) (and (positive? count) (helper (rest string) (- count 1)))]))\n\
    \  (helper string 0))\n", "  (cond\n    [(empty? string) false]\n    [(equal?\
    \ (first string) (last string)) (is_nested (rest (butlast string)))]\n    [else\
    \ false]))\n", "  (define (is_nested-helper string count)\n    (cond\n      [(empty?\
    \ string) (= count 0)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (is_nested-helper\
    \ (rest string) (- count 1)) (> count 0))]))\n  (is_nested-helper string 0))\n",
  "  (define (is_nested-helper string count)\n    (cond\n      [(empty? string) (zero?\
    \ count)]\n      [(char=? (first string) #\\[) (is_nested-helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive? count) (is_nested-helper\
    \ (rest string) (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n\
    \  (is_nested-helper string 0))\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (zero? count)]\n      [(equal? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(equal? (first string) #\\]) (and (positive?\
    \ count) (helper (rest string) (- count 1)))]\n      [else (helper (rest string)\
    \ count)]))\n  (helper string 0))\n", "  (define (helper string count)\n    (cond\n\
    \      [(empty? string) (= count 0)]\n      [(char=? (first string) #\\[) (helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (not (=\
    \ count 0)) (helper (rest string) (- count 1)))]\n      [else (helper (rest string)\
    \ count)]))\n  (helper string 0))\n", "  (let ((stack (make-vector 0)))\n    (for\
    \ ([char (in-string string)])\n      (cond\n        [(char=? char #\\[) (vector-push\
    \ char stack)]\n        [(char=? char #\\]) (if (vector-empty? stack)\n      \
    \                         #f\n                               (vector-pop stack))]))\n\
    \    (vector-empty? stack)))\n", "  (define (helper string)\n    (if (empty? string)\n\
    \        '()\n        (cons (first string) (helper (rest string)))))\n  (define\
    \ (is_nested? string)\n    (if (empty? string)\n        #f\n        (if (equal?\
    \ (first string) '[[)\n            (if (equal? (first (rest string)) '])\n   \
    \             (is_nested? (rest (rest string)))\n                (is_nested? (rest\
    \ string)))\n            (is_nested? (rest string)))))\n  (is_nested? (helper\
    \ string)))\n", "  (let loop ([string string] [depth 0])\n    (if (string-empty?\
    \ string)\n        (zero? depth)\n        (cond\n         [(string-prefix? \"\
    [\" string)\n          (loop (substring string 1) (+ depth 1))]\n         [(string-prefix?\
    \ \"]\" string)\n          (loop (substring string 1) (- depth 1))]\n        \
    \ [else\n          (loop (substring string 1) depth)]))))\n", "  (cond\n    [(empty?\
    \ string) false]\n    [(and (equal? (first string) #\\[) (equal? (last string)\
    \ #\\])) true]\n    [else (is_nested (substring string 1 (- (string-length string)\
    \ 1)))])\n)\n", "  (let ((stack '()))\n    (for ([char (in-string string)])\n\
    \      (cond\n        [(equal? char #\\[) (push char stack)]\n        [(equal?\
    \ char #\\]) (pop stack)]))\n    (empty? stack)))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (is_nested-helper (rest string) (- count 1)) (> count\
    \ 0))]))\n  (is_nested-helper string 0))\n", "  (define (is_nested-helper string\
    \ count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(char=? (first\
    \ string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (is_nested-helper (rest string) (- count 1)) (> count\
    \ 0))]))\n  (is_nested-helper string 0))\n", "  (let ((stack '()))\n    (for ([i\
    \ (in-range (string-length string))])\n      (cond\n        [(equal? (string-ref\
    \ string i) #\\[) (push 'open stack)]\n        [(equal? (string-ref string i)\
    \ #\\]) (if (equal? (pop stack) 'open) #t #f)]))\n    (if (empty? stack) #t #f)))\n",
  "  (define (helper string acc)\n    (cond\n      [(empty? string) (empty? acc)]\n\
    \      [(char=? (first string) #\\[) (helper (rest string) (cons #\\[ acc))]\n\
    \      [(char=? (first string) #\\]) (and (not (empty? acc)) (helper (rest string)\
    \ (rest acc)))]))\n  (helper string '()))\n", "  (define (helper string)\n   \
    \ (cond\n      [(empty? string) #t]\n      [(equal? (first string) (last string))\
    \ (helper (rest (butlast string)))]\n      [else #f]))\n  (helper string))\n",
  "  (define (is_nested-helper string count)\n    (cond\n      [(empty? string) (=\
    \ count 0)]\n      [(= (first string) #\\[) (is_nested-helper (rest string) (+\
    \ count 1))]\n      [(= (first string) #\\]) (and (not (zero? count)) (is_nested-helper\
    \ (rest string) (- count 1)))]))\n  (is_nested-helper string 0))\n", "  (cond\n\
    \    [(empty? string) false]\n    [(empty? (regexp-match #rx\"\\\\[\\\\]\" string))\
    \ false]\n    [else true]))\n", "  (define (helper string)\n    (cond\n      [(empty?\
    \ string) #t]\n      [(equal? (first string) (last string)) (helper (rest (butlast\
    \ string)))]\n      [else #f]))\n  (helper string))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(= (first\
    \ string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(= (first\
    \ string) #\\]) (and (is-positive? count) (is_nested-helper (rest string) (- count\
    \ 1)))]))\n  (is_nested-helper string 0))\n", "  (cond\n    [(empty? string) false]\n\
    \    [(and (equal? (first string) #\\[) (equal? (last string) #\\])) true]\n \
    \   [else (is_nested (substring string 1 (sub1 (string-length string))))]))\n",
  "  (let loop ((string string) (count 0))\n    (cond ((null? string) (zero? count))\n\
    \          ((equal? (car string) #\\[) (loop (cdr string) (+ count 1)))\n    \
    \      ((equal? (car string) #\\]) (loop (cdr string) (- count 1)))\n        \
    \  (else (loop (cdr string) count)))))\n", "  (let loop ([string string] [count\
    \ 0])\n    (cond [(empty? string) (zero? count)]\n          [(char=? (first string)\
    \ #\\[) (loop (rest string) (+ count 1))]\n          [(char=? (first string) #\\\
    ]) (loop (rest string) (- count 1))]\n          [else (loop (rest string) count)])))\n",
  "  (define (helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n\
    \      [(equal? (first string) #\\[) (helper (rest string) (+ count 1))]\n   \
    \   [(equal? (first string) #\\]) (and (positive? count) (helper (rest string)\
    \ (- count 1)))]\n      [else (helper (rest string) count)]))\n  (helper string\
    \ 0))\n", "  (define (is_nested-helper string count)\n    (cond\n      [(empty?\
    \ string) (zero? count)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(char=? (first string) #\\]) (and (positive?\
    \ count) (is_nested-helper (rest string) (- count 1)))]\n      [else (is_nested-helper\
    \ (rest string) count)]))\n  (is_nested-helper string 0))\n", "  (define (helper\
    \ string)\n    (cond [(empty? string) 0]\n          [(eq? (first string) #\\[)\
    \ (+ 1 (helper (rest string)))]\n          [(eq? (first string) #\\]) (- 1 (helper\
    \ (rest string)))]))\n  (and (not (zero? (helper string)))\n       (zero? (helper\
    \ (reverse string)))))\n", "  (define (helper string)\n    (if (empty? string)\n\
    \        #t\n        (if (equal? (first string) (last string))\n            (helper\
    \ (rest (butlast string)))\n            #f)))\n  (helper string))\n", "  (define\
    \ (is_nested-helper string)\n    (cond\n      [(empty? string) #t]\n      [(equal?\
    \ (first string) (last string)) (is_nested-helper (rest (butlast string)))]\n\
    \      [else #f]))\n  (is_nested-helper string))\n", "  (define (is_nested-helper\
    \ string)\n    (cond\n      [(empty? string) #t]\n      [(empty? (cdr string))\
    \ #f]\n      [(and (equal? (car string) #\\[) (equal? (cadr string) #\\])) (is_nested-helper\
    \ (cddr string))]\n      [else (is_nested-helper (cdr string))]))\n  (is_nested-helper\
    \ (string->list string)))\n", "  (define (helper string)\n    (if (empty? string)\n\
    \        (list)\n        (cons (first string) (helper (rest string)))))\n  (define\
    \ (is_nested? string)\n    (if (empty? string)\n        #t\n        (if (equal?\
    \ (first string) (last string))\n            (is_nested? (rest (butlast string)))\n\
    \            #f)))\n  (is_nested? (helper string)))\n", "  (define (helper string\
    \ count)\n    (cond ((null? string) (= count 0))\n          ((= (string-ref string\
    \ 0) #\\[) (helper (substring string 1) (+ count 1)))\n          ((= (string-ref\
    \ string 0) #\\]) (helper (substring string 1) (- count 1)))\n          (else\
    \ (helper (substring string 1) count))))\n  (helper string 0))\n", "  (define\
    \ (helper string count)\n    (cond\n      [(empty? string) (if (= count 0) true\
    \ false)]\n      [(string-contains? string \"[\") (helper (substring string 1)\
    \ (+ count 1))]\n      [(string-contains? string \"]\") (helper (substring string\
    \ 1) (- count 1))]))\n  (helper string 0))\n", "  (define (is_nested-helper string\
    \ count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(char=? (first\
    \ string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (is_nested-helper (rest string) (- count 1))]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string)\n    (if (empty? string)\n       \
    \ '()\n        (if (equal? (first string) #\\[)\n            (cons (first string)\
    \ (helper (rest string)))\n            (if (equal? (first string) #\\])\n    \
    \            (if (empty? (helper (rest string)))\n                    '()\n  \
    \                  (helper (rest string)))\n                (helper (rest string))))))\n\
    \  (if (empty? (helper string))\n      #f\n      #t))\n", "  (define (helper string\
    \ count)\n    (cond ((empty? string) (zero? count))\n          ((equal? (first\
    \ string) #\\[) (helper (rest string) (+ count 1)))\n          ((equal? (first\
    \ string) #\\]) (and (not (zero? count)) (helper (rest string) (- count 1))))\n\
    \          (else (helper (rest string) count))))\n  (helper string 0))\n", " \
    \ (cond\n    [(empty? string) false]\n    [(eq? (first string) (last string))\
    \ (is_nested (rest (butlast string)))]\n    [else false]))\n", "  (define (helper\
    \ string)\n    (cond\n      [(empty? string) #t]\n      [(equal? (first string)\
    \ (last string)) (helper (rest (butlast string)))]\n      [else #f]))\n  (helper\
    \ string))\n", "  (cond\n    [(empty? string) false]\n    [(empty? (regexp-match\
    \ #rx\"\\\\[\\\\]\" string)) false]\n    [else true]))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (is_nested-helper (rest string) (- count 1))]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string)\n    (cond\n      [(empty? string)\
    \ #t]\n      [(equal? (first string) (last string)) (helper (rest (butlast string)))]\n\
    \      [else #f]))\n  (helper string))\n", "  (cond\n    [(empty? string) false]\n\
    \    [(empty? (regexp-match #rx\"[\\\\[\\\\]]\" string)) false]\n    [(regexp-match\
    \ #rx\"\\\\[\\\\[.*\\\\]\\\\]\" string) true]\n    [else (is_nested (regexp-replace\
    \ #rx\"\\\\[\\\\[.*\\\\]\\\\]\" string \"\"))]))\n", "  (let ((stack '()))\n \
    \   (for ([c (in-string string)])\n      (cond\n        [(equal? c #\\[) (push\
    \ c stack)]\n        [(equal? c #\\]) (pop stack)]))\n    (empty? stack)))\n",
  "  (let loop ((string string) (stack '()))\n    (cond ((null? string) (null? stack))\n\
    \          ((char=? (car string) #\\[) (loop (cdr string) (cons #\\[ stack)))\n\
    \          ((char=? (car string) #\\]) (and (not (null? stack)) (loop (cdr string)\
    \ (cdr stack))))\n          (else (loop (cdr string) stack)))))\n", "  (cond\n\
    \    [(empty? string) false]\n    [(equal? (first string) (last string)) (is_nested\
    \ (rest (drop-right string 1)))]\n    [else false]))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (not (zero? count)) (is_nested-helper (rest string)\
    \ (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (is_nested-helper string count)\n    (cond\n     \
    \ [(empty? string) (= count 0)]\n      [(= (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(= (first string) #\\]) (and (not (zero?\
    \ count)) (is_nested-helper (rest string) (- count 1)))]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string)\n    (cond [(empty? string) #t]\n\
    \          [(equal? (first string) #\\]) #f]\n          [(equal? (first string)\
    \ #\\[) (helper (rest string))]))\n  (helper string))\n", "  (define (helper string\
    \ count)\n    (cond [(empty? string) (= count 0)]\n          [(char=? (first string)\
    \ #\\[) (helper (rest string) (+ count 1))]\n          [(char=? (first string)\
    \ #\\]) (and (not (= count 0)) (helper (rest string) (- count 1)))]\n        \
    \  [else (helper (rest string) count)]))\n  (helper string 0))\n", "  (define\
    \ (helper string)\n    (cond\n      [(empty? string) #t]\n      [(equal? (first\
    \ string) (last string)) (helper (rest (butlast string)))]\n      [else #f]))\n\
    \  (helper string))\n", "  (define (helper string count)\n    (cond\n      [(empty?\
    \ string) (= count 0)]\n      [(equal? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(equal? (first string) #\\]) (and (not (= count 0)) (helper\
    \ (rest string) (- count 1)))]\n      [else (helper (rest string) count)]))\n\
    \  (helper string 0))\n", "  (let loop ([string string] [count 0])\n    (cond\
    \ [(empty? string) (zero? count)]\n          [(equal? (first string) #\\[) (loop\
    \ (rest string) (+ count 1))]\n          [(equal? (first string) #\\]) (and (positive?\
    \ count) (loop (rest string) (- count 1)))]\n          [else (loop (rest string)\
    \ count)])))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
