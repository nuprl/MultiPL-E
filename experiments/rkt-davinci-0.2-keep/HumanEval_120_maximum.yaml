name: HumanEval_120_maximum
language: racket
prompt: "#lang racket\n\n;; Given an array arr of integers and a positive integer\
  \ k, return a sorted list \n;; of length k with the maximum k numbers in arr.\n\
  ;; Example 1:\n;; Input: arr = [-3, -4, 5], k = 3\n;; Output: [-4, -3, 5]\n;; Example\
  \ 2:\n;; Input: arr = [4, -4, 4], k = 2\n;; Output: [4, 4]\n;; Example 3:\n;; Input:\
  \ arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n;; Output: [2]\n;; Note:\n;; 1. The length\
  \ of the array will be in the range of [1, 1000].\n;; 2. The elements in the array\
  \ will be in the range of [-1000, 1000].\n;; 3. 0 <= k <= len(arr)\n(define (maximum\
  \ arr k)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maximum))\n\
  \    (check-equal? (candidate (list -3 -4 5) 3) (list -4 -3 5))\n    (check-equal?\
  \ (candidate (list 4 -4 4) 2) (list 4 4))\n    (check-equal? (candidate (list -3\
  \ 2 1 2 -1 -2 1) 1) (list 2))\n    (check-equal? (candidate (list 123 -123 20 0\
  \ 1 2 -3) 3) (list 2 20 123))\n    (check-equal? (candidate (list -123 20 0 1 2\
  \ -3) 4) (list 0 1 2 20))\n    (check-equal? (candidate (list 5 15 0 3 -13 -8 0)\
  \ 7) (list -13 -8 0 0 3 5 15))\n    (check-equal? (candidate (list -1 0 2 5 3 -10)\
  \ 2) (list 3 5))\n    (check-equal? (candidate (list 1 0 5 -7) 1) (list 5))\n  \
  \  (check-equal? (candidate (list 4 -4) 2) (list -4 4))\n    (check-equal? (candidate\
  \ (list -10 10) 2) (list -10 10))\n    (check-equal? (candidate (list 1 2 3 -23\
  \ 243 -400 0) 0) (list ))\n))\n\n(test-humaneval)"
completions: ["  (sort arr (lambda (x y) (> x y))))\n", "  (sort arr (lambda (a b)\
    \ (> a b))))\n", "  (define (max-k lst k)\n    (if (zero? k)\n        '()\n  \
    \      (cons (apply max lst)\n              (max-k (remove (apply max lst) lst)\
    \ (- k 1)))))\n  (max-k arr k))\n", "  (define (max-k lst k)\n    (if (or (null?\
    \ lst) (= k 0))\n        '()\n        (let ([max (apply max lst)])\n         \
    \ (cons max (max-k (remove max lst) (- k 1))))))\n  (max-k arr k))\n", "  (let\
    \ loop ((arr arr)\n             (k k)\n             (res '()))\n    (if (zero?\
    \ k)\n        res\n        (loop (remove (apply max arr) arr)\n              (-\
    \ k 1)\n              (cons (apply max arr) res)))))\n", "  (sort arr (lambda\
    \ (a b) (< a b))))\n", "  (define (max-k lst)\n    (if (or (null? lst) (= k 0))\n\
    \        '()\n        (cons (max lst) (max-k (remove (max lst) lst)))))\n  (max-k\
    \ arr))\n", "  (sort arr (lambda (x y) (> x y))))\n", "  (define (insert x lst)\n\
    \    (cond ((null? lst) (list x))\n          ((> x (car lst)) (cons x lst))\n\
    \          (else (cons (car lst) (insert x (cdr lst))))))\n  (define (loop lst\
    \ k)\n    (cond ((= k 0) lst)\n          ((null? lst) lst)\n          (else (loop\
    \ (insert (car arr) lst) (- k 1)))))\n  (loop '() k))\n", "  (define (helper arr\
    \ k)\n    (if (or (null? arr) (= k 0))\n        '()\n        (let ([max (apply\
    \ max arr)])\n          (cons max (helper (remove max arr) (- k 1))))))\n  (helper\
    \ arr k))\n", "  (define (helper arr k acc)\n    (if (zero? k)\n        acc\n\
    \        (helper (remove (max arr) arr) (- k 1) (cons (max arr) acc))))\n  (helper\
    \ arr k '()))\n", "  (define (helper arr k)\n    (cond [(empty? arr) empty]\n\
    \          [(= k 0) empty]\n          [(= k 1) (list (max (first arr) (second\
    \ arr)))]\n          [else (cons (max (first arr) (second arr)) (helper (rest\
    \ arr) (- k 1)))]))\n  (helper arr k))\n", "  (sort arr (lambda (x y) (< x y))))\n",
  "  (sort arr >))\n", "  (sort arr >))\n", "  (sort arr (lambda (x y) (> x y))))\n",
  "  (define (maximum-helper arr k)\n    (cond [(empty? arr) empty]\n          [(=\
    \ k 0) empty]\n          [(= k 1) (list (max (first arr) (maximum-helper (rest\
    \ arr) (- k 1))))]\n          [else (cons (max (first arr) (maximum-helper (rest\
    \ arr) (- k 1)))\n                      (maximum-helper (rest arr) (- k 1)))]))\n\
    \  (maximum-helper arr k))\n", "  (define (max-k lst k)\n    (if (or (null? lst)\
    \ (= k 0))\n        '()\n        (let ([max (apply max lst)])\n          (cons\
    \ max (max-k (remove max lst) (- k 1))))))\n  (max-k arr k))\n", "  (define (max-k\
    \ arr k)\n    (cond\n      [(empty? arr) empty]\n      [(= k 0) empty]\n     \
    \ [else\n       (define max (max-k (rest arr) (- k 1)))\n       (if (> (first\
    \ arr) (first max))\n           (cons (first arr) max)\n           (cons (first\
    \ max) (rest max)))]))\n  (max-k arr k))\n", "  (sort (take arr k) >))\n", " \
    \ (define (max-k-helper arr k)\n    (cond [(empty? arr) empty]\n          [(=\
    \ k 0) empty]\n          [(= k 1) (list (apply max arr))]\n          [else (cons\
    \ (apply max arr) (max-k-helper (remove (apply max arr) arr) (- k 1)))]))\n  (max-k-helper\
    \ arr k))\n", "  (sort arr (lambda (a b) (> a b))))\n", "  (sort arr >))\n", " \
    \ (sort arr (lambda (a b) (> a b))))\n", "  (sort arr >))\n", "  (define (max\
    \ arr)\n    (if (null? (cdr arr))\n        (car arr)\n        (if (> (car arr)\
    \ (max (cdr arr)))\n            (car arr)\n            (max (cdr arr)))))\n  (define\
    \ (remove-max arr)\n    (if (null? (cdr arr))\n        '()\n        (if (= (max\
    \ arr) (car arr))\n            (cdr arr)\n            (cons (car arr) (remove-max\
    \ (cdr arr))))))\n  (define (max-k arr k)\n    (if (= k 0)\n        '()\n    \
    \    (cons (max arr) (max-k (remove-max arr) (- k 1)))))\n  (max-k arr k))\n",
  "  (define (helper arr k)\n    (if (= k 0)\n        '()\n        (let ([max (apply\
    \ max arr)])\n          (cons max (helper (remove max arr) (- k 1))))))\n  (helper\
    \ arr k))\n", "  (sort arr >))\n", "  (define (max-k arr k)\n    (if (zero? k)\n\
    \        '()\n        (cons (apply max arr)\n              (max-k (remove (apply\
    \ max arr) arr) (- k 1)))))\n  (max-k arr k))\n", "  (sort arr >))\n", "  (sort\
    \ arr >))\n", "  (define (max-nums arr k)\n    (cond [(empty? arr) empty]\n  \
    \        [(= k 0) empty]\n          [(= k 1) (list (max (first arr) (max-nums\
    \ (rest arr) 0)))]\n          [else (list (max (first arr) (max-nums (rest arr)\
    \ 0))\n                    (max-nums (rest arr) (- k 1)))]))\n  (max-nums arr\
    \ k))\n", "  (define (max-k lst k)\n    (if (= k 0)\n        '()\n        (cons\
    \ (car (sort > lst))\n              (max-k (remove (car (sort > lst)) lst) (-\
    \ k 1)))))\n  (max-k arr k))\n", "  (sort arr (lambda (x y) (> x y))))\n", " \
    \ (define (max-k-nums arr k)\n    (define (max-k-nums-iter arr k)\n      (if (zero?\
    \ k)\n          '()\n          (let ([max (apply max arr)])\n            (cons\
    \ max (max-k-nums-iter (remove max arr) (- k 1))))))\n    (max-k-nums-iter arr\
    \ k))\n  (sort (max-k-nums arr k) <))\n", "  (define (max-k lst k)\n    (cond\n\
    \      [(empty? lst) empty]\n      [(= k 0) empty]\n      [else\n       (define\
    \ (max-k-helper lst k)\n         (cond\n           [(empty? lst) empty]\n    \
    \       [(= k 0) empty]\n           [else\n            (define (max-k-helper-helper\
    \ lst k)\n              (cond\n                [(empty? lst) empty]\n        \
    \        [(= k 0) empty]\n                [else\n                 (define (max-k-helper-helper-helper\
    \ lst k)\n                   (cond\n                     [(empty? lst) empty]\n\
    \                     [(= k 0) empty]\n                     [else\n          \
    \            (define (max-k-helper-helper-helper-helper lst k)\n             \
    \           (cond\n                          [(empty? lst) empty]\n          \
    \                [(= k 0) empty]\n                          [else\n          \
    \                 (define (max-k-helper-helper-helper-helper-helper lst k)\n \
    \                            (cond\n                               [(empty? lst)\
    \ empty]\n                               [(= k 0) empty]\n                   \
    \            [else\n                                (define (max-k-helper-helper-helper-helper-helper-helper\
    \ lst k)\n                                  (cond\n                          \
    \          [(empty? lst) empty]\n                                    [(= k 0)\
    \ empty]\n                                    [else\n                        \
    \             (define (max-k-helper-helper-helper-helper-helper-helper-helper\
    \ lst k)\n                                       (cond\n                     \
    \                    [(empty? lst) empty]\n                                  \
    \       [(= k 0) empty]\n                                         [else\n    \
    \                                      (define (max-k-helper-helper-helper-helper-helper-helper-helper-helper\
    \ lst k)\n                                            (cond\n                \
    \                              [(empty? lst) empty]\n                        \
    \                      [(= k 0) empty]\n                                     \
    \         [else\n                                               (define (max-k-helper-helper-helper-helper-helper",
  "  (sort arr (\u03BB (x y) (&gt; x y))))\n</code>\n", "  (define (max-k lst k)\n\
    \    (cond [(empty? lst) empty]\n          [(= k 0) empty]\n          [(= k 1)\
    \ (list (max (first lst) (max-k (rest lst) (- k 1))))]\n          [else (cons\
    \ (max (first lst) (max-k (rest lst) (- k 1)))\n                      (max-k (rest\
    \ lst) (- k 1)))]))\n  (sort (max-k arr k) >))\n", "  (sort arr (lambda (x y)\
    \ (> x y))))\n", "  (sort arr >))\n", "  (sort arr (lambda (a b) (> a b))))\n",
  "  (sort arr (lambda (a b) (> a b))))\n", "  (sort arr >))\n", "  (define (max-k\
    \ lst k)\n    (cond\n      [(empty? lst) empty]\n      [(= k 0) empty]\n     \
    \ [else\n       (define max-val (max (first lst) (max-k (rest lst) (- k 1))))\n\
    \       (cons max-val (max-k (remove max-val lst) (- k 1)))]))\n  (max-k arr k))\n",
  "  (let ([len (length arr)])\n    (if (< k len)\n        (let ([max-arr (make-vector\
    \ k)])\n          (for ([i (in-range k)])\n            (vector-set! max-arr i\
    \ (vector-ref arr i)))\n          (for ([i (in-range k len)])\n            (let\
    \ ([val (vector-ref arr i)])\n              (for ([j (in-range k)])\n        \
    \        (if (< val (vector-ref max-arr j))\n                    (begin\n    \
    \                  (vector-set! max-arr j val)\n                      (break))\n\
    \                    (void)))))\n          (for ([i (in-range k)])\n         \
    \   (vector-set! max-arr i (vector-ref max-arr i)))\n          max-arr)\n    \
    \    arr)))\n", "  (sort arr >))\n", "  (sort arr (lambda (a b) (< a b))))\n",
  "  (sort arr >))\n", "  (define (max-k arr k)\n    (if (= k 0)\n        '()\n  \
    \      (cons (max-k-helper arr)\n              (max-k (remove (max-k-helper arr)\
    \ arr) (- k 1)))))\n  (max-k arr k))\n", "  (define (max-k lst k)\n    (if (or\
    \ (null? lst) (= k 0))\n        '()\n        (cons (max (car lst) (max-k (cdr\
    \ lst) (- k 1)))\n              (max-k (cdr lst) (- k 1)))))\n  (sort (max-k arr\
    \ k) >))\n", "  (define (max-helper arr k)\n    (if (zero? k)\n        '()\n \
    \       (let ([max-val (apply max arr)])\n          (cons max-val (max-helper\
    \ (remove max-val arr) (- k 1))))))\n  (max-helper arr k))\n", "  (sort arr (lambda\
    \ (x y) (> x y))))\n", "  (define (max-k-helper arr k)\n    (if (zero? k)\n  \
    \      '()\n        (let ([max-val (apply max arr)])\n          (cons max-val\
    \ (max-k-helper (filter (lambda (x) (not (= x max-val))) arr) (- k 1))))))\n \
    \ (max-k-helper arr k))\n", "  (define (max-k lst k)\n    (cond\n      [(empty?\
    \ lst) empty]\n      [(= k 0) empty]\n      [else\n       (let ([max (apply max\
    \ lst)])\n         (cons max (max-k (filter (lambda (x) (not (= x max))) lst)\
    \ (- k 1))))]))\n  (max-k arr k))\n", "  (define (max-k lst k)\n    (cond\n  \
    \    [(empty? lst) empty]\n      [(= k 0) empty]\n      [else\n       (define\
    \ (max-k-helper lst k max-lst)\n         (cond\n           [(empty? lst) max-lst]\n\
    \           [(= k 0) max-lst]\n           [else\n            (define (max-lst-helper\
    \ lst max-lst)\n              (cond\n                [(empty? lst) max-lst]\n\
    \                [(< (first lst) (first max-lst)) (cons (first lst) (rest max-lst))]\n\
    \                [else (cons (first max-lst) (max-lst-helper (rest lst) (rest\
    \ max-lst)))]))\n            (max-k-helper (rest lst) (- k 1) (max-lst-helper\
    \ lst max-lst))]))\n       (max-k-helper (rest lst) (- k 1) (cons (first lst)\
    \ empty))]))\n  (max-k arr k))\n", "  (let ([len (vector-length arr)])\n    (define\
    \ (swap i j)\n      (let ([temp (vector-ref arr i)])\n        (vector-set! arr\
    \ i (vector-ref arr j))\n        (vector-set! arr j temp)))\n    (define (partition\
    \ lt rt)\n      (let ([pivot (vector-ref arr rt)])\n        (let loop ([i lt]\
    \ [j rt])\n          (if (&lt; i j)\n              (if (&lt; (vector-ref arr i)\
    \ pivot)\n                  (loop (+ i 1) j)\n                  (swap i j)\n \
    \                 (loop lt (- j 1)))\n              (swap i rt)\n            \
    \  i))))\n    (define (quick-sort lt rt)\n      (if (&lt; lt rt)\n          (let\
    \ ([p (partition lt rt)])\n            (quick-sort lt (- p 1))\n            (quick-sort\
    \ (+ p 1) rt))))\n    (quick-sort 0 (- len 1))\n    (vector-copy arr 0 k)))\n\
    </code>\n", "  (sort arr >))\n", "  (sort arr >))\n", "  (define (max-k lst k)\n\
    \    (if (or (null? lst) (= k 0))\n        '()\n        (let* ([max (apply max\
    \ lst)]\n               [new-lst (remove max lst)])\n          (cons max (max-k\
    \ new-lst (- k 1))))))\n  (max-k arr k))\n", "  (define (max-k-helper arr k)\n\
    \    (if (= k 0)\n        (list)\n        (let* ([max (apply max arr)]\n     \
    \          [max-index (find-max-index arr max)])\n          (cons max (max-k-helper\
    \ (remove-at arr max-index) (- k 1))))))\n  (max-k-helper arr k))\n", "  (define\
    \ (helper arr k)\n    (if (= k 0) '()\n        (let ([max (apply max arr)])\n\
    \          (cons max (helper (remove max arr) (- k 1))))))\n  (helper arr k))\n\
    </code>\n", "  (sort arr <))\n", "  (define (helper arr k)\n    (if (zero? k)\n\
    \        '()\n        (let* ([max (apply max arr)]\n               [index (index-of\
    \ max arr)]\n               [arr (remove-at index arr)])\n          (cons max\
    \ (helper arr (- k 1))))))\n  (helper arr k))\n", "  (define (max-k-nums arr k)\n\
    \    (if (= k 1)\n        (list (apply max arr))\n        (let ([max-num (apply\
    \ max arr)])\n          (cons max-num (max-k-nums (remove max-num arr) (- k 1))))))\n\
    \  (max-k-nums arr k))\n", "  (let ([n (length arr)])\n    (define (swap! i j)\n\
    \      (let ([tmp (vector-ref arr i)])\n        (vector-set! arr i (vector-ref\
    \ arr j))\n        (vector-set! arr j tmp)))\n    (define (partition! l h)\n \
    \     (let ([pivot (vector-ref arr h)])\n        (let loop ([i l] [j h])\n   \
    \       (if (&lt; i j)\n              (if (&lt;= (vector-ref arr i) pivot)\n \
    \                 (loop (+ i 1) j)\n                  (swap! i j)\n          \
    \        (loop i (- j 1)))\n              (swap! i h)\n              i))))\n \
    \   (define (quick-sort! l h)\n      (if (&lt; l h)\n          (let ([p (partition!\
    \ l h)])\n            (quick-sort! l (- p 1))\n            (quick-sort! (+ p 1)\
    \ h))))\n    (quick-sort! 0 (- n 1))\n    (vector-&gt;list (vector-copy arr 0\
    \ k))))\n</code>\n", "  (define (max-k lst k)\n    (cond\n      [(empty? lst)\
    \ empty]\n      [(= k 0) empty]\n      [else\n       (define max-val (apply max\
    \ lst))\n       (cons max-val (max-k (remove max-val lst) (- k 1)))]))\n  (max-k\
    \ arr k))\n", "  (define (max-k-nums arr k)\n    (if (= k 1)\n        (list (apply\
    \ max arr))\n        (let ([max-num (apply max arr)])\n          (cons max-num\
    \ (max-k-nums (remove max-num arr) (- k 1))))))\n  (max-k-nums arr k))\n", " \
    \ (sort arr (lambda (x y) (< x y))))\n", "  (sort arr >))\n", "  (sort arr >))\n",
  "  (sort arr (lambda (x y) (< x y))))\n", "  (define (max-k lst k)\n    (if (null?\
    \ lst)\n        '()\n        (let ([max (apply max lst)])\n          (cons max\
    \ (max-k (remove max lst) (- k 1))))))\n  (max-k arr k))\n", "  (sort arr #:key\
    \ (lambda (x) (- x)) #:count k))\n", "  (sort arr (lambda (x y) (> x y))))\n",
  "  (sort arr <))\n", "  (define (max-k lst k)\n    (if (or (null? lst) (= k 0))\n\
    \        '()\n        (cons (apply max lst)\n              (max-k (remove (apply\
    \ max lst) lst) (- k 1)))))\n  (max-k arr k))\n", "  (define (helper arr k)\n\
    \    (if (zero? k)\n        empty\n        (let ([max (apply max arr)])\n    \
    \      (cons max (helper (remove max arr) (- k 1))))))\n  (helper arr k))\n",
  "  (define (max-k lst k)\n    (if (or (null? lst) (= k 0))\n        '()\n      \
    \  (cons (max-k-helper lst)\n              (max-k (remove (max-k-helper lst) lst)\
    \ (- k 1)))))\n  (max-k arr k))\n", "  (define (max-k lst k)\n    (cond\n    \
    \  [(empty? lst) empty]\n      [(= k 0) empty]\n      [else\n       (define max\
    \ (apply max lst))\n       (cons max (max-k (remove max lst) (- k 1)))]))\n  (max-k\
    \ arr k))\n", "  (define (max-k lst k)\n    (if (= k 0)\n        '()\n       \
    \ (let ([max (apply max lst)])\n          (cons max (max-k (remove max lst) (-\
    \ k 1))))))\n  (max-k arr k))\n", "  (sort (take arr k) >))\n", "  (sort arr >))\n",
  "  (define (helper arr k)\n    (cond [(empty? arr) empty]\n          [(= k 0) empty]\n\
    \          [(= k 1) (list (max (first arr) (last arr)))]\n          [else (cons\
    \ (max (first arr) (last arr)) (helper (rest arr) (- k 1)))]))\n  (helper arr\
    \ k))\n", "  (sort arr >))\n", "  (define (max-k lst k)\n    (if (or (= k 0) (null?\
    \ lst))\n        '()\n        (cons (max-k-helper lst)\n              (max-k (remove\
    \ (max-k-helper lst) lst) (- k 1)))))\n  (max-k arr k))\n", "  (sort arr >))\n",
  "  (define (max-k lst k)\n    (if (= k 0)\n        '()\n        (cons (apply max\
    \ lst)\n              (max-k (remove (apply max lst) lst) (- k 1)))))\n  (max-k\
    \ arr k))\n", "  (sort arr (lambda (a b) (> a b))))\n", "  (sort arr >))\n", " \
    \ (sort arr (lambda (a b) (> a b))))\n", "  (define (helper arr k result)\n  \
    \  (if (zero? k)\n        result\n        (helper (remove-max arr) (- k 1) (cons\
    \ (max arr) result))))\n  (helper arr k '()))\n", "  (sort arr >))\n", "  (define\
    \ (helper arr k)\n    (if (= k 0)\n        '()\n        (let ([max (apply max\
    \ arr)])\n          (cons max (helper (remove max arr) (- k 1))))))\n  (helper\
    \ arr k))\n", "  (sort arr >))\n", "  (define (max-k lst k)\n    (if (or (null?\
    \ lst) (= k 0))\n        '()\n        (cons (max lst) (max-k (remove (max lst)\
    \ lst) (- k 1)))))\n  (max-k arr k))\n", "  (sort arr (lambda (a b) (< b a))))\n",
  "  (define (max-k lst k)\n    (if (= k 0)\n        '()\n        (let ([max (apply\
    \ max lst)])\n          (cons max (max-k (remove max lst) (- k 1))))))\n  (max-k\
    \ arr k))\n", "  (sort arr <))\n", "  (define (max-k lst k)\n    (if (or (null?\
    \ lst) (= k 0))\n        '()\n        (cons (car (max-k (cdr lst) (- k 1)))\n\
    \              (max-k (cdr lst) k))))\n  (max-k (sort arr <) k))\n", "  (sort\
    \ arr >))\n", "  (sort arr (lambda (a b) (< a b))))\n", "  (define (max-k lst\
    \ k)\n    (if (= k 0)\n        '()\n        (cons (apply max lst)\n          \
    \    (max-k (remove (apply max lst) lst) (- k 1)))))\n  (max-k arr k))\n", " \
    \ (define (helper arr k)\n    (if (null? arr)\n        '()\n        (let* ([max\
    \ (apply max arr)]\n               [index (index-of arr max)])\n          (cons\
    \ max (helper (remove-at arr index) (- k 1))))))\n  (helper arr k))\n", "  (define\
    \ (max-k arr k)\n    (if (zero? k)\n        '()\n        (cons (max (car arr)\
    \ (car (cdr arr)))\n              (max-k (cdr arr) (- k 1)))))\n  (define (max-arr\
    \ arr)\n    (if (null? (cdr arr))\n        (car arr)\n        (max (car arr) (max-arr\
    \ (cdr arr)))))\n  (define (max a b)\n    (if (> a b)\n        a\n        b))\n\
    \  (max-k arr k))\n", "  (sort arr <))\n", "  (sort arr (lambda (a b) (> a b))))\n",
  "  (define (helper arr k acc)\n    (if (zero? k)\n        acc\n        (helper (remove-max\
    \ arr) (- k 1) (cons (max arr) acc))))\n  (helper arr k '()))\n", "  (define (max-k\
    \ lst k)\n    (if (or (null? lst) (= k 0))\n        '()\n        (let ([max (apply\
    \ max lst)])\n          (cons max (max-k (remove max lst) (- k 1))))))\n  (max-k\
    \ arr k))\n", "  (define (max-k lst k)\n    (if (or (= k 0) (null? lst))\n   \
    \     '()\n        (let ([max (apply max lst)])\n          (cons max (max-k (remove\
    \ max lst) (- k 1))))))\n  (max-k arr k))\n", "  (define (max-k-nums arr k)\n\
    \    (if (= k 0)\n        '()\n        (let ([max (apply max arr)])\n        \
    \  (cons max (max-k-nums (remove max arr) (- k 1))))))\n  (sort (max-k-nums arr\
    \ k) >))\n", "  (define (maximum-helper arr k)\n    (cond ((= k 0) '())\n    \
    \      ((null? arr) '())\n          (else\n           (let ((max (apply max arr)))\n\
    \             (cons max (maximum-helper (remove max arr) (- k 1)))))))\n  (maximum-helper\
    \ arr k))\n", "  (sort arr (lambda (a b) (< b a))))\n", "  (define (max-k lst)\n\
    \    (if (null? lst)\n        '()\n        (cons (apply max lst) (max-k (remove\
    \ (apply max lst) lst)))))\n  (max-k arr))\n", "  (define (max-heapify arr i)\n\
    \    (define (left i) (+ i i))\n    (define (right i) (+ i i 1))\n    (define\
    \ (swap arr i j)\n      (define (swap-helper arr i j)\n        (define temp (vector-ref\
    \ arr i))\n        (vector-set! arr i (vector-ref arr j))\n        (vector-set!\
    \ arr j temp))\n      (swap-helper arr i j))\n    (define (max-heapify-helper\
    \ arr i)\n      (define l (left i))\n      (define r (right i))\n      (define\
    \ largest\n        (cond\n          [(> l (vector-length arr)) i]\n          [(>\
    \ r (vector-length arr)) (max l i)]\n          [(> (vector-ref arr l) (vector-ref\
    \ arr r)) l]\n          [else r]))\n      (when (> (vector-ref arr largest) (vector-ref\
    \ arr i))\n        (swap arr i largest)\n        (max-heapify-helper arr largest)))\n\
    \    (max-heapify-helper arr i))\n  (define (build-max-heap arr)\n    (define\
    \ (build-max-heap-helper arr i)\n      (when (> i 0)\n        (max-heapify arr\
    \ i)\n        (build-max-heap-helper arr (- i 1))))\n    (build-max-heap-helper\
    \ arr (- (vector-length arr) 1)))\n  (define (heap-sort arr)\n    (define (heap-sort-helper\
    \ arr i)\n      (when (> i 0)\n        (swap arr 0 i)\n        (max-heapify arr\
    \ 0)\n        (heap-sort-helper arr (- i 1))))\n    (heap-sort-helper arr (- (vector-length\
    \ arr) 1)))\n  (define (heap-extract-max arr)\n    (define (heap-extract-max-helper\
    \ arr i)\n      (when (> i 0)\n        (swap arr 0 i)\n        (max-heapify arr\
    \ 0)\n        (heap-", "  (define (helper arr k)\n    (if (= k 0)\n        '()\n\
    \        (let ([max (apply max arr)])\n          (cons max (helper (remove max\
    \ arr) (- k 1))))))\n  (helper arr k))\n", "  (define (max-k lst k)\n    (cond\n\
    \      [(empty? lst) empty]\n      [(= k 0) empty]\n      [else\n       (let ([max\
    \ (apply max lst)])\n         (cons max (max-k (remove max lst) (- k 1))))]))\n\
    \  (max-k arr k))\n", "  (sort arr (lambda (a b) (> a b))))\n", "  (sort arr (lambda\
    \ (a b) (> a b))))\n", "  (sort arr >))\n", "  (define (helper arr k)\n    (cond\n\
    \      [(empty? arr) empty]\n      [(= k 0) empty]\n      [else\n       (let*\
    \ ([max (max (first arr) (maximum (rest arr) (- k 1)))]\n              [max-count\
    \ (count (lambda (x) (= x max)) arr)])\n         (append (build-list max-count\
    \ max)\n                 (helper (filter (lambda (x) (not (= x max))) arr) (-\
    \ k max-count))))]))\n  (helper arr k))\n", "  (sort arr >))\n", "  (sort arr\
    \ >))\n", "  (define (max-k lst k)\n    (if (or (null? lst) (= k 0))\n       \
    \ '()\n        (let ([max (apply max lst)])\n          (cons max (max-k (remove\
    \ max lst) (- k 1))))))\n  (max-k arr k))\n", "  (define (max-k lst k)\n    (if\
    \ (or (null? lst) (= k 0))\n        '()\n        (let ([max (apply max lst)])\n\
    \          (cons max (max-k (remove max lst) (- k 1))))))\n  (max-k arr k))\n",
  "  (sort arr (lambda (x y) (< x y))))\n", "  (define (helper arr k)\n    (cond\n\
    \      [(empty? arr) empty]\n      [(= k 0) empty]\n      [else\n       (define\
    \ (max-helper arr max)\n         (cond\n           [(empty? arr) max]\n      \
    \     [(> (first arr) max) (max-helper (rest arr) (first arr))]\n           [else\
    \ (max-helper (rest arr) max)]))\n       (define max (max-helper arr (first arr)))\n\
    \       (cons max (helper (remove arr max) (- k 1)))]))\n  (helper arr k))\n",
  "  (sort arr >))\n", "  (sort arr (lambda (x y) (< x y))))\n", "  (define (max-k\
    \ arr k)\n    (if (= k 0)\n        '()\n        (let ([max (apply max arr)])\n\
    \          (cons max (max-k (remove max arr) (- k 1))))))\n  (max-k arr k))\n",
  "  (sort arr >))\n", "  (sort arr >))\n", "  (define (helper arr k result)\n   \
    \ (cond\n      [(empty? arr) result]\n      [(>= k (length result))\n       (helper\
    \ (rest arr) k (insert (first arr) result))]\n      [else\n       (helper (rest\
    \ arr) k (insert-or-delete (first arr) result))]))\n  (helper arr k (list)))\n",
  "  (define (helper arr k)\n    (cond [(= k 0) '()]\n          [(= k 1) (list (max-number\
    \ arr))]\n          [else (cons (max-number arr) (helper (remove-max arr) (- k\
    \ 1)))]))\n  (helper arr k))\n", "  (define (max-k arr k)\n    (if (= k 0)\n \
    \       '()\n        (cons (max-k-helper arr)\n              (max-k (remove (max-k-helper\
    \ arr) arr) (- k 1)))))\n  (max-k arr k))\n", "  (define (helper arr k)\n    (if\
    \ (zero? k)\n        '()\n        (let* ([max (apply max arr)]\n             \
    \  [index (index-of arr max)])\n          (cons max (helper (remove-at arr index)\
    \ (- k 1))))))\n  (helper arr k))\n", "  (define (max-k lst k)\n    (cond ((=\
    \ k 0) '())\n          ((null? lst) '())\n          (else (cons (max (car lst)\
    \ (max-k (cdr lst) (- k 1)))\n                      (max-k (cdr lst) (- k 1))))))\n\
    \  (max-k arr k))\n", "  (define (max-k-helper arr k)\n    (cond [(empty? arr)\
    \ empty]\n          [(= k 0) empty]\n          [(= k 1) (list (max (first arr)\
    \ (max-k-helper (rest arr) k)))]\n          [else (cons (max (first arr) (max-k-helper\
    \ (rest arr) k))\n                      (max-k-helper (rest arr) (- k 1)))]))\n\
    \  (max-k-helper arr k))\n", "  (define (max-k lst)\n    (if (null? lst)\n   \
    \     '()\n        (cons (apply max lst)\n              (max-k (remove (apply\
    \ max lst) lst)))))\n  (max-k arr))\n", "  (define (max-nums arr k)\n    (cond\
    \ ((or (null? arr) (= k 0)) '())\n          ((= k 1) (list (apply max arr)))\n\
    \          (else\n           (let ((max-num (apply max arr)))\n             (cons\
    \ max-num (max-nums (remove max-num arr) (- k 1)))))))\n  (max-nums arr k))\n",
  "  (define (max-k-nums arr k)\n    (define (max-k-nums-iter arr k acc)\n      (if\
    \ (zero? k)\n          acc\n          (max-k-nums-iter (remove-max arr) (- k 1)\
    \ (cons (max arr) acc))))\n    (max-k-nums-iter arr k '()))\n  (reverse (max-k-nums\
    \ arr k)))\n", "  (define (max-k lst)\n    (cond [(empty? lst) empty]\n      \
    \    [(= k 0) empty]\n          [(< k 0) (error \"k must be positive\")]\n   \
    \       [else (cons (max (first lst) (max-k (rest lst)))\n                   \
    \   (max-k (remove (max (first lst) (max-k (rest lst))) lst)))]))\n  (max-k arr))\n",
  "  (define (max-list arr)\n    (cond ((null? arr) '())\n          ((null? (cdr arr))\
    \ (list (car arr)))\n          (else (cons (max (car arr) (cadr arr)) (max-list\
    \ (cdr arr))))))\n  (define (max-k arr k)\n    (cond ((zero? k) '())\n       \
    \   ((null? arr) '())\n          ((null? (cdr arr)) (list (car arr)))\n      \
    \    (else (cons (max (car arr) (cadr arr)) (max-k (cdr arr) (- k 1))))))\n  (define\
    \ (max-k-helper arr k)\n    (cond ((zero? k) '())\n          ((null? arr) '())\n\
    \          ((null? (cdr arr)) (list (car arr)))\n          (else (cons (max (car\
    \ arr) (cadr arr)) (max-k-helper (cdr arr) (- k 1))))))\n  (define (max-k-helper-helper\
    \ arr k)\n    (cond ((zero? k) '())\n          ((null? arr) '())\n          ((null?\
    \ (cdr arr)) (list (car arr)))\n          (else (cons (max (car arr) (cadr arr))\
    \ (max-k-helper-helper (cdr arr) (- k 1))))))\n  (define (max-k-helper-helper-helper\
    \ arr k)\n    (cond ((zero? k) '())\n          ((null? arr) '())\n          ((null?\
    \ (cdr arr)) (list (car arr)))\n          (else (cons (max (car arr) (cadr arr))\
    \ (max-k-helper-helper-helper (cdr arr) (- k 1))))))\n  (define (max-k-helper-helper-helper-helper\
    \ arr k)\n    (cond ((zero? k) '())\n          ((null? arr) '())\n          ((null?\
    \ (cdr arr)) (list (car arr)))\n          (else (cons (max (car arr) (cadr arr))\
    \ (max-k-helper-helper-helper-helper (cdr arr) (- k 1", "  (define (max-heapify\
    \ arr i)\n    (define (swap arr i j)\n      (define (swap-helper arr i j)\n  \
    \      (define (swap-helper-helper arr i j)\n          (define (swap-helper-helper-helper\
    \ arr i j)\n            (define (swap-helper-helper-helper-helper arr i j)\n \
    \             (define (swap-helper-helper-helper-helper-helper arr i j)\n    \
    \            (define (swap-helper-helper-helper-helper-helper-helper arr i j)\n\
    \                  (define (swap-helper-helper-helper-helper-helper-helper-helper\
    \ arr i j)\n                    (define (swap-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i j)\n                      (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i j)\n                        (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i j)\n                          (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i j)\n                            (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i j)\n                              (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i j)\n                                (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper\
    \ arr i j)\n                                  (define (swap-helper-helper-", " \
    \ (define (max-k lst k)\n    (if (= k 0)\n        '()\n        (cons (apply max\
    \ lst)\n              (max-k (remove (apply max lst) lst) (- k 1)))))\n  (max-k\
    \ arr k))\n", "  (sort arr (lambda (a b) (> a b))))\n", "  (sort arr >))\n", " \
    \ (define (max-k-helper arr k)\n    (if (zero? k)\n        '()\n        (define\
    \ (max-helper arr)\n          (if (null? arr)\n              '()\n           \
    \   (define (helper arr max)\n                (if (null? arr)\n              \
    \      max\n                    (if (> (car arr) max)\n                      \
    \  (helper (cdr arr) (car arr))\n                        (helper (cdr arr) max))))\n\
    \          (helper arr (car arr))))\n    (cons (max-helper arr) (max-k-helper\
    \ (remove (max-helper arr) arr) (- k 1)))))\n  (sort (max-k-helper arr k) <))\n\
    </code>\n", "  (sort arr >))\n", "  (define (helper arr k)\n    (if (zero? k)\n\
    \        '()\n        (let ([max (apply max arr)])\n          (cons max (helper\
    \ (remove max arr) (- k 1))))))\n  (helper arr k))\n", "  (define (max-k arr k)\n\
    \    (if (zero? k)\n        '()\n        (cons (apply max arr)\n             \
    \ (max-k (remove (apply max arr) arr) (- k 1)))))\n  (max-k arr k))\n", "  (sort\
    \ arr <))\n", "  (define (max-k lst k)\n    (if (or (null? lst) (= k 0))\n   \
    \     '()\n        (let ([max (apply max lst)])\n          (cons max (max-k (remove\
    \ max lst) (- k 1))))))\n  (max-k arr k))\n", "  (define (max-k lst k)\n    (if\
    \ (or (null? lst) (= k 0))\n        '()\n        (let ([max (apply max lst)])\n\
    \          (cons max (max-k (remove max lst) (- k 1))))))\n  (max-k arr k))\n",
  "  (sort arr (lambda (a b) (< b a))))\n", "  (sort arr (lambda (x y) (< x y))))\n",
  "  (sort arr >))\n", "  (let ([len (length arr)])\n    (cond\n      [(= len 0) '()]\n\
    \      [(= len 1) arr]\n      [(= len k) (sort arr >)]\n      [else\n       (let\
    \ ([pivot (list-ref arr (quotient len 2))])\n         (let ([left (filter (lambda\
    \ (x) (< x pivot)) arr)]\n               [right (filter (lambda (x) (> x pivot))\
    \ arr)])\n           (append (maximum left (- k (length right)))\n           \
    \        (filter (lambda (x) (= x pivot)) arr)\n                   (maximum right\
    \ (- k (length left))))))])))\n", "  (sort arr >))\n", "  (define (max-k lst k)\n\
    \    (cond\n      [(empty? lst) empty]\n      [(= k 0) empty]\n      [else\n \
    \      (define (max-k-helper lst k max)\n         (cond\n           [(empty? lst)\
    \ (cons max (max-k empty (- k 1)))]\n           [(> (first lst) max) (max-k-helper\
    \ (rest lst) k (first lst))]\n           [else (max-k-helper (rest lst) k max)]))\n\
    \       (max-k-helper (rest lst) (- k 1) (first lst))]))\n  (max-k arr k))\n",
  "  (sort arr >))\n", "  (sort arr >))\n", "  (sort arr <))\n", "  (sort arr >))\n",
  "  (sort arr (lambda (a b) (> a b))))\n", "  (sort arr >))\n", "  (define (max-k-nums\
    \ arr k)\n    (if (zero? k)\n        '()\n        (let ((max-num (apply max arr)))\n\
    \          (cons max-num (max-k-nums (remove max-num arr) (- k 1))))))\n  (sort\
    \ (max-k-nums arr k) <))\n", "  (define (max-k lst k)\n    (if (zero? k)\n   \
    \     '()\n        (cons (apply max lst)\n              (max-k (remove (apply\
    \ max lst) lst) (- k 1)))))\n  (max-k arr k))\n", "  (sort arr (lambda (a b) (<\
    \ a b))))\n", "  (sort (take arr k) >))\n", "  (sort arr (lambda (x y) (> x y))))\n",
  "  (define (max-k-nums arr k)\n    (define (max-k-nums-iter arr k max-k-nums)\n\
    \      (cond [(empty? arr) max-k-nums]\n            [(> k (length max-k-nums))\
    \ (max-k-nums-iter (rest arr) k (cons (first arr) max-k-nums))]\n            [(>=\
    \ (first arr) (first max-k-nums)) (max-k-nums-iter (rest arr) k (cons (first arr)\
    \ max-k-nums))]\n            [else (max-k-nums-iter (rest arr) k max-k-nums)]))\n\
    \    (max-k-nums-iter arr k '()))\n  (sort (max-k-nums arr k) >))\n", "  (define\
    \ (max-k-nums arr k)\n    (if (zero? k)\n        '()\n        (let ([max-num (apply\
    \ max arr)])\n          (cons max-num (max-k-nums (remove max-num arr) (- k 1))))))\n\
    \  (max-k-nums arr k))\n", "  (sort arr (lambda (a b) (< a b))))\n", "  (sort\
    \ arr (lambda (a b) (> a b))))\n", "  (sort arr >))\n", "  (define (max-k lst\
    \ k)\n    (if (or (null? lst) (= k 0))\n        '()\n        (let ([max (apply\
    \ max lst)])\n          (cons max (max-k (remove max lst) (- k 1))))))\n  (max-k\
    \ arr k))\n", "  (define (max-k lst k)\n    (if (or (null? lst) (= k 0))\n   \
    \     '()\n        (cons (max (car lst) (max-k (cdr lst) (- k 1)))\n         \
    \     (max-k (cdr lst) (- k 1)))))\n  (max-k arr k))\n", "  (sort arr (lambda\
    \ (a b) (&gt; a b))))\n</code>\n", "  (define (max-k lst)\n    (if (or (= k 0)\
    \ (null? lst))\n        '()\n        (cons (apply max lst)\n              (max-k\
    \ (remove (apply max lst) lst)))))\n  (max-k arr))\n", "  (define (max-k lst k)\n\
    \    (cond ((or (null? lst) (= k 0)) '())\n          ((= k 1) (list (apply max\
    \ lst)))\n          (else (cons (apply max lst) (max-k (remove (apply max lst)\
    \ lst) (- k 1))))))\n  (max-k arr k))\n", "  (define (max-k lst k)\n    (cond\n\
    \      [(empty? lst) empty]\n      [(= k 0) empty]\n      [else\n       (let ([max\
    \ (apply max lst)])\n         (cons max (max-k (remove max lst) (- k 1))))]))\n\
    \  (max-k arr k))\n", "  (sort arr (lambda (a b) (> a b))))\n", "  (define (max-k-helper\
    \ arr k)\n    (if (zero? k)\n        '()\n        (let ([max (apply max arr)])\n\
    \          (cons max (max-k-helper (remove max arr) (- k 1))))))\n  (max-k-helper\
    \ arr k))\n", "  (define (max-k lst k)\n    (if (= k 0)\n        '()\n       \
    \ (cons (max-k-helper lst)\n              (max-k (remove (max-k-helper lst) lst)\
    \ (- k 1)))))\n  (max-k arr k))\n", "  (define (max-k-nums arr k)\n    (if (zero?\
    \ k)\n        '()\n        (let ([max (apply max arr)])\n          (cons max (max-k-nums\
    \ (remove max arr) (- k 1))))))\n  (max-k-nums arr k))\n", "  (define (max-k lst\
    \ k)\n    (if (= k 0)\n        '()\n        (cons (max (car lst) (car (cdr lst)))\
    \ (max-k (cdr lst) (- k 1)))))\n  (max-k arr k))\n", "  (define (max-k lst k)\n\
    \    (if (or (null? lst) (= k 0))\n        '()\n        (let ([max (apply max\
    \ lst)])\n          (cons max (max-k (remove max lst) (- k 1))))))\n  (max-k arr\
    \ k))\n", "  (sort arr (lambda (a b) (&gt; a b))))\n</code>\n", "  (sort arr >))\n",
  "  (sort arr >))\n", "  (define (max-k-nums arr k)\n    (if (empty? arr)\n     \
    \   empty\n        (let ([max-num (apply max arr)])\n          (cons max-num (max-k-nums\
    \ (remove max-num arr) (- k 1))))))\n  (reverse (max-k-nums arr k)))\n", "  (define\
    \ (max-heapify arr i)\n    (define (left i) (+ (* 2 i) 1))\n    (define (right\
    \ i) (+ (* 2 i) 2))\n    (define (swap i j)\n      (define temp (vector-ref arr\
    \ i))\n      (vector-set! arr i (vector-ref arr j))\n      (vector-set! arr j\
    \ temp))\n    (define (max-heapify-helper arr i)\n      (define l (left i))\n\
    \      (define r (right i))\n      (define largest\n        (cond\n          [(>\
    \ l (vector-length arr)) i]\n          [(> r (vector-length arr))\n          \
    \ (if (> (vector-ref arr l) (vector-ref arr i)) l i)]\n          [else\n     \
    \      (if (> (vector-ref arr l) (vector-ref arr r)) l r)]))\n      (when (> (vector-ref\
    \ arr largest) (vector-ref arr i))\n        (swap i largest)\n        (max-heapify-helper\
    \ arr largest)))\n    (max-heapify-helper arr i))\n  (define (build-max-heap arr)\n\
    \    (for ([i (in-range (quotient (vector-length arr) 2) -1 -1)])\n      (max-heapify\
    \ arr i)))\n  (define (heap-sort arr)\n    (build-max-heap arr)\n    (for ([i\
    \ (in-range (sub1 (vector-length arr)) 0 -1)])\n      (swap 0 i)\n      (max-heapify\
    \ arr 0)))\n  (define (heap-extract-max arr)\n    (define max (vector-ref arr\
    \ 0))\n    (vector-set! arr 0 (vector-ref arr (sub1 (vector-length arr))))\n \
    \   (vector-set! arr (sub1 (vector-length arr)) #f)\n    (max-heapify arr 0)\n\
    \    max)\n  (define (heap-increase-key arr i key)\n    (vector-set! arr i key)\n\
    \    (define (heap-increase-key-helper arr i)\n      (", "  (sort arr <))\n",
  "  (define (max-k lst k)\n    (cond [(empty? lst) empty]\n          [(= k 0) empty]\n\
    \          [(= k 1) (list (max (first lst) (max-k (rest lst) (- k 1))))]\n   \
    \       [else (cons (max (first lst) (max-k (rest lst) (- k 1)))\n           \
    \           (max-k (rest lst) (- k 1)))]))\n  (sort (max-k arr k) >))\n", "  (define\
    \ (max-heapify arr i)\n    (define (swap arr i j)\n      (define temp (vector-ref\
    \ arr i))\n      (vector-set! arr i (vector-ref arr j))\n      (vector-set! arr\
    \ j temp))\n    (define (max-heapify-helper arr i)\n      (define l (+ i 1))\n\
    \      (define r (+ i 2))\n      (define largest\n        (cond\n          [(>\
    \ l (vector-length arr)) i]\n          [(> r (vector-length arr)) (if (> (vector-ref\
    \ arr l) (vector-ref arr i)) l i)]\n          [else (if (> (vector-ref arr l)\
    \ (vector-ref arr r)) l r)]))\n      (if (> (vector-ref arr largest) (vector-ref\
    \ arr i))\n          (begin\n            (swap arr i largest)\n            (max-heapify-helper\
    \ arr largest))))\n    (max-heapify-helper arr i))\n  (define (build-max-heap\
    \ arr)\n    (define (build-max-heap-helper arr i)\n      (if (< i (quotient (vector-length\
    \ arr) 2))\n          (begin\n            (max-heapify arr i)\n            (build-max-heap-helper\
    \ arr (+ i 1)))))\n    (build-max-heap-helper arr 0)\n    arr)\n  (define (heap-sort\
    \ arr)\n    (define (heap-sort-helper arr i)\n      (if (> i 0)\n          (begin\n\
    \            (swap arr 0 i)\n            (max-heapify arr 0)\n            (heap-sort-helper\
    \ arr (- i 1)))))\n    (heap-sort-helper arr (- (vector-length arr) 1))\n    arr)\n\
    \  (define (heap-extract-max arr)\n    (define (heap-extract-max-helper arr i)\n\
    \      (if (> i 0)\n          (begin\n            (swap arr 0 i)\n           \
    \ (max-heapify arr 0)\n            (heap-extract-max-helper arr (-", "  (sort\
    \ arr (lambda (a b) (> a b))))\n", "  (sort arr >))\n", "  (sort arr (lambda (a\
    \ b) (> a b))))\n", "  (sort arr (lambda (a b) (< a b))))\n", "  (define (helper\
    \ arr k)\n    (cond [(empty? arr) empty]\n          [(= k 0) empty]\n        \
    \  [(= k 1) (list (max (first arr) (second arr)))]\n          [else (cons (max\
    \ (first arr) (second arr)) (helper (rest arr) (- k 1)))]))\n  (helper arr k))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
