name: HumanEval_20_find_closest_elements
language: racket
prompt: "#lang racket\n\n;; From a supplied list of numbers (of length at least two)\
  \ select and return two that are the closest to each\n;; other and return them in\
  \ order (smaller number, larger number).\n;; >>> find_closest_elements([1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.2])\n;; (2.0, 2.2)\n;; >>> find_closest_elements([1.0, 2.0, 3.0,\
  \ 4.0, 5.0, 2.0])\n;; (2.0, 2.0)\n(define (find_closest_elements numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_closest_elements))\n\
  \    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2)) (list 3.9 4.0))\n\
  \    (check-equal? (candidate (list 1.0 2.0 5.9 4.0 5.0)) (list 5.0 5.9))\n    (check-equal?\
  \ (candidate (list 1.0 2.0 3.0 4.0 5.0 2.2)) (list 2.0 2.2))\n    (check-equal?\
  \ (candidate (list 1.0 2.0 3.0 4.0 5.0 2.0)) (list 2.0 2.0))\n    (check-equal?\
  \ (candidate (list 1.1 2.2 3.1 4.1 5.1)) (list 2.2 3.1))\n))\n\n(test-humaneval)"
completions: ["  (let ([numbers (sort numbers <)])\n    (let loop ([numbers (rest\
    \ numbers)] [min-diff (abs (- (first numbers) (second numbers)))] [min-pair (list\
    \ (first numbers) (second numbers))])\n      (if (null? (rest numbers))\n    \
    \      min-pair\n          (let ([diff (abs (- (first numbers) (second numbers)))])\n\
    \            (if (< diff min-diff)\n                (loop (rest numbers) diff\
    \ (list (first numbers) (second numbers)))\n                (loop (rest numbers)\
    \ min-diff min-pair)))))))\n", "  (let* ([min-diff (apply min (map (lambda (n)\
    \ (abs (- (car numbers) n))) (cdr numbers)))]\n         [closest-pair (filter\
    \ (lambda (n) (= min-diff (abs (- (car numbers) n)))) (cdr numbers))])\n    (if\
    \ (= (length closest-pair) 1)\n        (list (car numbers) (car closest-pair))\n\
    \        (list (car numbers) (car closest-pair)))))\n", "  (define (find_closest_elements-helper\
    \ numbers closest-so-far)\n    (if (null? (cdr numbers))\n        closest-so-far\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [diff (abs (- first second))]\n               [closest-so-far-diff\
    \ (abs (- (car closest-so-far) (cadr closest-so-far)))])\n          (if (< diff\
    \ closest-so-far-diff)\n              (find_closest_elements-helper (cdr numbers)\
    \ (list first second))\n              (find_closest_elements-helper (cdr numbers)\
    \ closest-so-far)))))\n  (find_closest_elements-helper numbers (list (car numbers)\
    \ (cadr numbers))))\n", "  (define (abs x)\n    (if (< x 0)\n        (- x)\n \
    \       x))\n  (define (find_closest_elements-helper numbers closest-so-far)\n\
    \    (if (null? (cdr numbers))\n        closest-so-far\n        (let* ([n (car\
    \ numbers)]\n               [next-n (cadr numbers)]\n               [diff (abs\
    \ (- n next-n))]\n               [closest-diff (abs (- (car closest-so-far) (cadr\
    \ closest-so-far)))])\n          (if (< diff closest-diff)\n              (find_closest_elements-helper\
    \ (cdr numbers) (list n next-n))\n              (find_closest_elements-helper\
    \ (cdr numbers) closest-so-far)))))\n  (find_closest_elements-helper numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (define (find_closest_elements-helper\
    \ numbers closest-so-far)\n    (if (null? (cdr numbers))\n        closest-so-far\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [diff (abs (- first second))]\n               [closest-diff (abs\
    \ (- (car closest-so-far) (cadr closest-so-far)))])\n          (if (< diff closest-diff)\n\
    \              (find_closest_elements-helper (cdr numbers) (list first second))\n\
    \              (find_closest_elements-helper (cdr numbers) closest-so-far)))))\n\
    \  (find_closest_elements-helper numbers (list (car numbers) (cadr numbers))))\n",
  "  (define (find_closest_elements_helper numbers closest-pair)\n    (if (null? (cdr\
    \ numbers))\n        closest-pair\n        (let* ([current-pair (list (car numbers)\
    \ (cadr numbers))]\n               [current-diff (abs (- (car current-pair) (cadr\
    \ current-pair)))]\n               [closest-diff (abs (- (car closest-pair) (cadr\
    \ closest-pair)))])\n          (if (< current-diff closest-diff)\n           \
    \   (find_closest_elements_helper (cdr numbers) current-pair)\n              (find_closest_elements_helper\
    \ (cdr numbers) closest-pair)))))\n  (find_closest_elements_helper numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (define (find-closest-elements-helper\
    \ numbers closest-pair)\n    (cond\n      [(empty? numbers) closest-pair]\n  \
    \    [(empty? (rest numbers)) closest-pair]\n      [else\n       (let* ([first\
    \ (first numbers)]\n              [second (first (rest numbers))]\n          \
    \    [diff (abs (- first second))]\n              [closest-diff (abs (- (first\
    \ closest-pair) (second closest-pair)))])\n         (if (< diff closest-diff)\n\
    \             (find-closest-elements-helper (rest numbers) (list first second))\n\
    \             (find-closest-elements-helper (rest numbers) closest-pair)))]))\n\
    \  (find-closest-elements-helper numbers (list (first numbers) (second numbers))))\n",
  "  (define (find_closest_elements_helper numbers closest-pair)\n    (if (null? (cdr\
    \ numbers))\n        closest-pair\n        (let* ([first (car numbers)]\n    \
    \           [second (cadr numbers)]\n               [difference (abs (- first\
    \ second))]\n               [closest-difference (abs (- (car closest-pair) (cadr\
    \ closest-pair)))])\n          (if (< difference closest-difference)\n       \
    \       (find_closest_elements_helper (cdr numbers) (list first second))\n   \
    \           (find_closest_elements_helper (cdr numbers) closest-pair)))))\n  (find_closest_elements_helper\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-so-far)\n    (if (null? (cdr numbers))\n        closest-so-far\n\
    \        (let* ([current-pair (list (car numbers) (cadr numbers))]\n         \
    \      [current-diff (abs (- (car current-pair) (cadr current-pair)))]\n     \
    \          [closest-diff (abs (- (car closest-so-far) (cadr closest-so-far)))])\n\
    \          (if (< current-diff closest-diff)\n              (find_closest_elements_helper\
    \ (cdr numbers) current-pair)\n              (find_closest_elements_helper (cdr\
    \ numbers) closest-so-far)))))\n  (find_closest_elements_helper numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (define (find_closest_elements-helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [diff (abs (- first second))]\n               [closest-diff (abs\
    \ (- (car closest-pair) (cadr closest-pair)))])\n          (if (< diff closest-diff)\n\
    \              (find_closest_elements-helper (cdr numbers) (list first second))\n\
    \              (find_closest_elements-helper (cdr numbers) closest-pair)))))\n\
    \  (find_closest_elements-helper numbers (list (car numbers) (cadr numbers))))\n",
  "  (define (find_closest_elements_helper numbers closest-pair)\n    (if (null? (cdr\
    \ numbers))\n        closest-pair\n        (let* ([first (car numbers)]\n    \
    \           [second (cadr numbers)]\n               [difference (abs (- first\
    \ second))]\n               [closest-difference (abs (- (car closest-pair) (cadr\
    \ closest-pair)))])\n          (if (< difference closest-difference)\n       \
    \       (find_closest_elements_helper (cdr numbers) (list first second))\n   \
    \           (find_closest_elements_helper (cdr numbers) closest-pair)))))\n  (find_closest_elements_helper\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (let ([min-diff (apply\
    \ min (map (lambda (x) (abs (- (car x) (cadr x)))) (partition numbers 2)))])\n\
    \    (list (apply min (filter (lambda (x) (= min-diff (abs (- (car x) (cadr x)))))\
    \ (partition numbers 2)))\n          (apply max (filter (lambda (x) (= min-diff\
    \ (abs (- (car x) (cadr x))))) (partition numbers 2))))))\n", "  (let ((min-diff\
    \ (abs (- (first numbers) (second numbers))))\n        (min-pair (list (first\
    \ numbers) (second numbers))))\n    (for ((i (in-range (add1 (length numbers))))\n\
    \          (j (in-range (add1 (length numbers)))))\n      (when (and (not (= i\
    \ j))\n                 (< (abs (- (list-ref numbers i) (list-ref numbers j)))\
    \ min-diff))\n        (set! min-diff (abs (- (list-ref numbers i) (list-ref numbers\
    \ j))))\n        (set! min-pair (list (list-ref numbers i) (list-ref numbers j)))))\n\
    \    (sort min-pair <)))\n", "  (define (find_closest_elements-helper numbers\
    \ closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n       \
    \ (let* ([current-pair (cons (car numbers) (cadr numbers))]\n               [current-diff\
    \ (abs (- (car current-pair) (cadr current-pair)))]\n               [closest-diff\
    \ (abs (- (car closest-pair) (cadr closest-pair)))])\n          (if (< current-diff\
    \ closest-diff)\n              (find_closest_elements-helper (cdr numbers) current-pair)\n\
    \              (find_closest_elements-helper (cdr numbers) closest-pair)))))\n\
    \  (find_closest_elements-helper numbers (cons (car numbers) (cadr numbers))))\n",
  "  (define (find_closest_elements_helper numbers closest-so-far)\n    (if (null?\
    \ (cdr numbers))\n        closest-so-far\n        (let ([current-diff (abs (-\
    \ (car numbers) (cadr numbers)))])\n          (if (< current-diff (abs (- (car\
    \ closest-so-far) (cadr closest-so-far))))\n              (find_closest_elements_helper\
    \ (cdr numbers) (list (car numbers) (cadr numbers)))\n              (find_closest_elements_helper\
    \ (cdr numbers) closest-so-far)))))\n  (find_closest_elements_helper numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (let ([min-diff (apply min (map (lambda\
    \ (x) (abs (- (car x) (cadr x)))) (partition numbers 2)))])\n    (apply min (filter\
    \ (lambda (x) (= (abs (- (car x) (cadr x))) min-diff)) (partition numbers 2)))))\n",
  "  (let loop ((numbers numbers)\n             (closest-elements (list (car numbers)\
    \ (cadr numbers)))\n             (closest-distance (abs (- (car numbers) (cadr\
    \ numbers)))))\n    (if (null? (cddr numbers))\n        closest-elements\n   \
    \     (let ((distance (abs (- (cadr numbers) (caddr numbers)))))\n          (if\
    \ (< distance closest-distance)\n              (loop (cdr numbers) (list (cadr\
    \ numbers) (caddr numbers)) distance)\n              (loop (cdr numbers) closest-elements\
    \ closest-distance))))))\n", "  (define (find_closest_elements_iter numbers closest-pair)\n\
    \    (if (null? (cdr numbers))\n        closest-pair\n        (let* ([first (car\
    \ numbers)]\n               [second (cadr numbers)]\n               [diff (abs\
    \ (- first second))]\n               [closest-diff (abs (- (car closest-pair)\
    \ (cadr closest-pair)))])\n          (if (< diff closest-diff)\n             \
    \ (find_closest_elements_iter (cdr numbers) (list first second))\n           \
    \   (find_closest_elements_iter (cdr numbers) closest-pair)))))\n  (find_closest_elements_iter\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (let ([closest-distance\
    \ (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n  \
    \  (list (first (filter (lambda (x) (= (abs (- x (second numbers))) closest-distance))\
    \ numbers))\n          (second (filter (lambda (x) (= (abs (- x (first numbers)))\
    \ closest-distance)) numbers)))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([next-pair (list (car numbers) (cadr numbers))]\n            \
    \   [next-diff (abs (- (car next-pair) (cadr next-pair)))]\n               [current-diff\
    \ (abs (- (car closest-pair) (cadr closest-pair)))]\n               [new-closest-pair\
    \ (if (< next-diff current-diff) next-pair closest-pair)])\n          (find_closest_elements_helper\
    \ (cdr numbers) new-closest-pair))))\n  (find_closest_elements_helper numbers\
    \ (list (car numbers) (cadr numbers))))\n", "  (define (find_closest_elements-helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [difference (abs (- first second))]\n               [closest-difference\
    \ (abs (- (car closest-pair) (cadr closest-pair)))])\n          (if (< difference\
    \ closest-difference)\n              (find_closest_elements-helper (cdr numbers)\
    \ (list first second))\n              (find_closest_elements-helper (cdr numbers)\
    \ closest-pair)))))\n  (find_closest_elements-helper numbers (list (car numbers)\
    \ (cadr numbers))))\n", "  (let ([closest-diff (apply min (map (lambda (x y) (abs\
    \ (- x y))) numbers (rest numbers)))])\n    (let ([closest-pair (filter (lambda\
    \ (x y) (= (abs (- x y)) closest-diff)) numbers (rest numbers))])\n      (if (=\
    \ (length closest-pair) 2)\n          (sort closest-pair <)\n          (list (car\
    \ closest-pair) (car closest-pair))))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [diff (abs (- first second))]\n               [closest-diff (abs\
    \ (- (car closest-pair) (cadr closest-pair)))])\n          (if (< diff closest-diff)\n\
    \              (find_closest_elements_helper (cdr numbers) (list first second))\n\
    \              (find_closest_elements_helper (cdr numbers) closest-pair)))))\n\
    \  (find_closest_elements_helper numbers (list (car numbers) (cadr numbers))))\n",
  "  (define (find_closest_elements_helper numbers closest-difference closest-pair)\n\
    \    (cond [(empty? numbers) closest-pair]\n          [else (let* ([n1 (first\
    \ numbers)]\n                       [n2 (second numbers)]\n                  \
    \     [difference (abs (- n1 n2))])\n                  (if (< difference closest-difference)\n\
    \                      (find_closest_elements_helper (rest numbers) difference\
    \ (list n1 n2))\n                      (find_closest_elements_helper (rest numbers)\
    \ closest-difference closest-pair)))]))\n  (find_closest_elements_helper numbers\
    \ (abs (- (first numbers) (second numbers))) (list (first numbers) (second numbers))))\n",
  "  (define (find_closest_elements_helper numbers closest-pair)\n    (if (null? (cdr\
    \ numbers))\n        closest-pair\n        (let* ([first (car numbers)]\n    \
    \           [second (cadr numbers)]\n               [diff (abs (- first second))]\n\
    \               [closest-diff (abs (- (car closest-pair) (cadr closest-pair)))])\n\
    \          (if (< diff closest-diff)\n              (find_closest_elements_helper\
    \ (cdr numbers) (list first second))\n              (find_closest_elements_helper\
    \ (cdr numbers) closest-pair)))))\n  (find_closest_elements_helper numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (let* ([sorted-numbers (sort numbers\
    \ <)]\n         [min-diff (apply min (map (lambda (x y) (abs (- x y))) sorted-numbers\
    \ (rest sorted-numbers)))]\n         [closest-pair (filter (lambda (x y) (= (abs\
    \ (- x y)) min-diff)) sorted-numbers (rest sorted-numbers))])\n    closest-pair))\n",
  "  (let ([closest-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (rest\
    \ numbers)))])\n    (list (apply min (filter (lambda (x) (= (abs (- x (apply min\
    \ numbers))) closest-diff)) numbers))\n          (apply max (filter (lambda (x)\
    \ (= (abs (- x (apply min numbers))) closest-diff)) numbers)))))\n", "  (let ([sorted\
    \ (sort numbers <)])\n    (let loop ([sorted sorted] [min-diff (abs (- (car sorted)\
    \ (cadr sorted)))] [min-pair (list (car sorted) (cadr sorted))])\n      (if (null?\
    \ (cddr sorted))\n          min-pair\n          (let* ([diff (abs (- (cadr sorted)\
    \ (caddr sorted)))]\n                 [new-min-pair (if (< diff min-diff)\n  \
    \                                 (list (cadr sorted) (caddr sorted))\n      \
    \                             min-pair)])\n            (loop (cdr sorted) (if\
    \ (< diff min-diff) diff min-diff) new-min-pair))))))\n", "  (letrec ([closest-pair\
    \ (lambda (numbers)\n                           (if (null? (cdr numbers))\n  \
    \                             (error \"Not enough numbers\")\n               \
    \                (let ([first (car numbers)]\n                               \
    \      [second (cadr numbers)])\n                                 (if (null? (cddr\
    \ numbers))\n                                     (list first second)\n      \
    \                               (let ([next (car (cddr numbers))])\n         \
    \                              (if (< (abs (- first next)) (abs (- second next)))\n\
    \                                           (cons first (closest-pair (cdr numbers)))\n\
    \                                           (cons second (closest-pair (cdr (cdr\
    \ numbers))))))))))])\n    (let ([pair (closest-pair numbers)])\n      (if (<\
    \ (car pair) (cadr pair))\n          pair\n          (list (cadr pair) (car pair))))))\n",
  "  (let* ([sorted (sort numbers <)]\n         [differences (map (lambda (n) (abs\
    \ (- (cadr n) (car n)))) (partition 2 1 sorted))]\n         [min-diff (apply min\
    \ differences)])\n    (list (car (member min-diff differences)) (cadr (member\
    \ min-diff differences)))))\n", "  (define (find-closest-elements-helper numbers\
    \ closest-elements)\n    (if (null? (cdr numbers))\n        closest-elements\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [diff (abs (- first second))]\n               [closest-diff (abs\
    \ (- (car closest-elements) (cadr closest-elements)))])\n          (if (< diff\
    \ closest-diff)\n              (find-closest-elements-helper (cdr numbers) (list\
    \ first second))\n              (find-closest-elements-helper (cdr numbers) closest-elements)))))\n\
    \  (find-closest-elements-helper numbers (list (car numbers) (cadr numbers))))\n",
  "  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])\n\
    \    (list (apply min (filter (lambda (x) (= (abs (- (car numbers) x)) min-diff))\
    \ numbers))\n          (apply max (filter (lambda (x) (= (abs (- (car numbers)\
    \ x)) min-diff)) numbers)))))\n", "  (define (find_closest_elements-helper numbers\
    \ closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n       \
    \ (let* ([first (car numbers)]\n               [second (cadr numbers)]\n     \
    \          [diff (abs (- first second))]\n               [closest-diff (abs (-\
    \ (car closest-pair) (cadr closest-pair)))])\n          (if (< diff closest-diff)\n\
    \              (find_closest_elements-helper (cdr numbers) (list first second))\n\
    \              (find_closest_elements-helper (cdr numbers) closest-pair)))))\n\
    \  (find_closest_elements-helper numbers (list (car numbers) (cadr numbers))))\n",
  "  (letrec ([closest-pair (lambda (numbers)\n                           (cond [(empty?\
    \ numbers) (error \"empty list\")]\n                                 [(empty?\
    \ (rest numbers)) (error \"list of length 1\")]\n                            \
    \     [(empty? (rest (rest numbers))) (values (first numbers) (second numbers))]\n\
    \                                 [else (let ([first-number (first numbers)]\n\
    \                                            [second-number (second numbers)]\n\
    \                                            [third-number (third numbers)])\n\
    \                                         (if (< (abs (- first-number second-number))\n\
    \                                                (abs (- second-number third-number)))\n\
    \                                             (values first-number second-number)\n\
    \                                             (closest-pair (rest numbers))))]))])\n\
    \    (closest-pair numbers)))\n", "  (define (find_closest_elements-helper numbers\
    \ closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n       \
    \ (let* ([current-pair (list (car numbers) (cadr numbers))]\n               [current-diff\
    \ (abs (- (car current-pair) (cadr current-pair)))]\n               [closest-diff\
    \ (abs (- (car closest-pair) (cadr closest-pair)))])\n          (if (< current-diff\
    \ closest-diff)\n              (find_closest_elements-helper (cdr numbers) current-pair)\n\
    \              (find_closest_elements-helper (cdr numbers) closest-pair)))))\n\
    \  (find_closest_elements-helper numbers (list (car numbers) (cadr numbers))))\n",
  "  (let loop ((numbers numbers)\n             (min-diff (abs (- (car numbers) (cadr\
    \ numbers))))\n             (min-pair (list (car numbers) (cadr numbers))))\n\
    \    (if (null? (cddr numbers))\n        min-pair\n        (let ((diff (abs (-\
    \ (cadr numbers) (caddr numbers)))))\n          (if (< diff min-diff)\n      \
    \        (loop (cdr numbers) diff (list (cadr numbers) (caddr numbers)))\n   \
    \           (loop (cdr numbers) min-diff min-pair))))))\n", "  (let* ([sorted-numbers\
    \ (sort numbers <)]\n         [closest-diff (apply min (map (lambda (x y) (abs\
    \ (- x y))) sorted-numbers (rest sorted-numbers)))]\n         [closest-pair (filter\
    \ (lambda (x) (= closest-diff (abs (- (car x) (cadr x))))) (map list sorted-numbers\
    \ (rest sorted-numbers)))]\n         [closest-pair-sorted (sort closest-pair <)])\n\
    \    (list (car closest-pair-sorted) (cadr closest-pair-sorted))))\n", "  (define\
    \ (find_closest_elements_helper numbers closest-pair)\n    (if (null? (cdr numbers))\n\
    \        closest-pair\n        (let* ([a (car numbers)]\n               [b (car\
    \ (cdr numbers))]\n               [diff (abs (- a b))]\n               [closest-diff\
    \ (abs (- (car closest-pair) (cadr closest-pair)))])\n          (if (< diff closest-diff)\n\
    \              (find_closest_elements_helper (cdr numbers) (list a b))\n     \
    \         (find_closest_elements_helper (cdr numbers) closest-pair)))))\n  (find_closest_elements_helper\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (let ([smallest-difference\
    \ (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n  \
    \  (let ([closest-pair (filter (lambda (x y) (= (abs (- x y)) smallest-difference))\
    \ numbers (rest numbers))])\n      (if (= (first closest-pair) (second closest-pair))\n\
    \          (list (first closest-pair) (second closest-pair))\n          (if (<\
    \ (first closest-pair) (second closest-pair))\n              (list (first closest-pair)\
    \ (second closest-pair))\n              (list (second closest-pair) (first closest-pair)))))))\n",
  "  (define (find_closest_elements_helper numbers closest-pair)\n    (cond [(empty?\
    \ numbers) closest-pair]\n          [(empty? (rest numbers)) closest-pair]\n \
    \         [else\n           (let* ([first (first numbers)]\n                 \
    \ [second (first (rest numbers))]\n                  [diff (abs (- first second))]\n\
    \                  [closest-diff (abs (- (first closest-pair) (second closest-pair)))])\n\
    \             (if (< diff closest-diff)\n                 (find_closest_elements_helper\
    \ (rest numbers) (list first second))\n                 (find_closest_elements_helper\
    \ (rest numbers) closest-pair)))]))\n  (find_closest_elements_helper numbers (list\
    \ (first numbers) (second numbers))))\n", "  (let ([min-diff (apply min (map (lambda\
    \ (x) (abs (- (car x) (cadr x)))) (partition numbers 2)))])\n    (filter (lambda\
    \ (x) (= (abs (- (car x) (cadr x))) min-diff)) (partition numbers 2))))\n", " \
    \ (let ([closest-pair (list (first numbers) (second numbers))])\n    (for ([i\
    \ (in-range (add1 (length numbers)))]\n          [j (in-range (add1 i))])\n  \
    \    (let ([diff (abs (- (list-ref numbers i) (list-ref numbers j)))])\n     \
    \   (when (< diff (abs (- (first closest-pair) (second closest-pair))))\n    \
    \      (set! closest-pair (list (list-ref numbers i) (list-ref numbers j))))))\n\
    \    closest-pair))\n", "  (define (closest-pair numbers)\n    (if (null? (cdr\
    \ numbers))\n        (error \"list too short\")\n        (let* ((first (car numbers))\n\
    \               (second (cadr numbers))\n               (diff (abs (- first second)))\n\
    \               (rest (cdr numbers)))\n          (if (null? rest)\n          \
    \    (list first second)\n              (let* ((next-pair (closest-pair rest))\n\
    \                     (next-diff (abs (- (car next-pair) (cadr next-pair)))))\n\
    \                (if (< diff next-diff)\n                    (list first second)\n\
    \                    next-pair))))))\n  (closest-pair (sort numbers <)))\n", " \
    \ (define (find_closest_elements_helper numbers closest-so-far)\n    (cond\n \
    \     [(empty? numbers) closest-so-far]\n      [(empty? (rest numbers)) closest-so-far]\n\
    \      [else\n       (let* ([first (first numbers)]\n              [second (first\
    \ (rest numbers))]\n              [diff (abs (- first second))]\n            \
    \  [closest-so-far-diff (abs (- (first closest-so-far) (second closest-so-far)))]\n\
    \              [new-closest-so-far (if (< diff closest-so-far-diff) (list first\
    \ second) closest-so-far)])\n         (find_closest_elements_helper (rest numbers)\
    \ new-closest-so-far))]))\n  (find_closest_elements_helper numbers (list (first\
    \ numbers) (first (rest numbers)))))\n", "  (let ([min-diff (apply min (map (lambda\
    \ (x y) (abs (- x y))) numbers (rest numbers)))])\n    (let loop ([numbers numbers])\n\
    \      (if (null? (rest numbers))\n          (error \"No closest elements\")\n\
    \          (if (= min-diff (abs (- (car numbers) (cadr numbers))))\n         \
    \     (values (car numbers) (cadr numbers))\n              (loop (rest numbers)))))))\n",
  "  (let ([closest-pair (list (car numbers) (cadr numbers))]\n        [closest-distance\
    \ (abs (- (car numbers) (cadr numbers)))])\n    (for ([i (in-range (add1 (length\
    \ numbers)))]\n          [j (in-range (add1 i))])\n      (let ([distance (abs\
    \ (- (list-ref numbers i) (list-ref numbers j)))])\n        (if (< distance closest-distance)\n\
    \            (begin\n              (set! closest-pair (list (list-ref numbers\
    \ i) (list-ref numbers j)))\n              (set! closest-distance distance)))))\n\
    \    (sort closest-pair <)))\n", "  (define (find-closest-elements-helper numbers\
    \ closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n       \
    \ (let* ([current-pair (cons (car numbers) (cadr numbers))]\n               [current-distance\
    \ (abs (- (car current-pair) (cadr current-pair)))]\n               [closest-distance\
    \ (abs (- (car closest-pair) (cadr closest-pair)))])\n          (if (< current-distance\
    \ closest-distance)\n              (find-closest-elements-helper (cdr numbers)\
    \ current-pair)\n              (find-closest-elements-helper (cdr numbers) closest-pair)))))\n\
    \  (find-closest-elements-helper numbers (cons (car numbers) (cadr numbers))))\n",
  "  (define (find_closest_elements_helper numbers closest-pair)\n    (if (null? (cdr\
    \ numbers))\n        closest-pair\n        (let* ([first (car numbers)]\n    \
    \           [second (cadr numbers)]\n               [difference (abs (- first\
    \ second))]\n               [closest-difference (abs (- (car closest-pair) (cadr\
    \ closest-pair)))])\n          (if (< difference closest-difference)\n       \
    \       (find_closest_elements_helper (cdr numbers) (list first second))\n   \
    \           (find_closest_elements_helper (cdr numbers) closest-pair)))))\n  (find_closest_elements_helper\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (let* ([sorted (sort numbers\
    \ <)]\n         [closest-pair (find-closest-pair sorted)])\n    (if (equal? (car\
    \ closest-pair) (cadr closest-pair))\n        (list (car closest-pair) (cadr closest-pair))\n\
    \        closest-pair)))\n", "  (define (find_closest_elements_helper numbers\
    \ closest)\n    (cond\n      [(empty? numbers) closest]\n      [(empty? (rest\
    \ numbers)) closest]\n      [else\n       (let* ([n1 (first numbers)]\n      \
    \        [n2 (first (rest numbers))]\n              [diff (abs (- n1 n2))]\n \
    \             [closest-diff (abs (- (first closest) (second closest)))]\n    \
    \          [new-closest (if (< diff closest-diff) (list n1 n2) closest)])\n  \
    \       (find_closest_elements_helper (rest numbers) new-closest))]))\n  (find_closest_elements_helper\
    \ numbers (list (first numbers) (second numbers))))\n", "  (let ([sorted-numbers\
    \ (sort numbers <)])\n    (let loop ([numbers sorted-numbers] [closest-pair (list\
    \ (car numbers) (cadr numbers))])\n      (if (null? (cddr numbers))\n        \
    \  closest-pair\n          (let ([next-pair (list (cadr numbers) (caddr numbers))])\n\
    \            (if (< (abs (- (car next-pair) (cadr next-pair)))\n             \
    \      (abs (- (car closest-pair) (cadr closest-pair))))\n                (loop\
    \ (cdr numbers) next-pair)\n                (loop (cdr numbers) closest-pair)))))))\n",
  "  (define (find_closest_elements_helper numbers closest-pair)\n    (cond\n    \
    \  [(empty? numbers) closest-pair]\n      [(= (length numbers) 1) closest-pair]\n\
    \      [else\n       (define first (first numbers))\n       (define rest (rest\
    \ numbers))\n       (define second (first rest))\n       (define diff (abs (-\
    \ first second)))\n       (define closest-diff (abs (- (first closest-pair) (second\
    \ closest-pair))))\n       (if (< diff closest-diff)\n           (find_closest_elements_helper\
    \ rest (list first second))\n           (find_closest_elements_helper rest closest-pair))]))\n\
    \  (find_closest_elements_helper numbers (list (first numbers) (second numbers))))\n",
  "  (let ([sorted-numbers (sort numbers <)])\n    (let loop ([numbers sorted-numbers]\
    \ [min-diff (abs (- (first numbers) (second numbers)))] [min-pair (list (first\
    \ numbers) (second numbers))])\n      (if (null? (rest numbers))\n          min-pair\n\
    \          (let ([diff (abs (- (first numbers) (second numbers)))])\n        \
    \    (if (< diff min-diff)\n                (loop (rest numbers) diff (list (first\
    \ numbers) (second numbers)))\n                (loop (rest numbers) min-diff min-pair)))))))\n",
  "  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n\
    \    (let ([closest-pair (filter (lambda (x y) (= (abs (- x y)) min-diff)) numbers\
    \ (rest numbers))])\n      (if (= (length closest-pair) 2)\n          closest-pair\n\
    \          (list (car closest-pair) (car closest-pair))))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [distance (abs (- first second))]\n               [closest-distance\
    \ (abs (- (car closest-pair) (cadr closest-pair)))])\n          (if (< distance\
    \ closest-distance)\n              (find_closest_elements_helper (cdr numbers)\
    \ (list first second))\n              (find_closest_elements_helper (cdr numbers)\
    \ closest-pair)))))\n  (find_closest_elements_helper numbers (list (car numbers)\
    \ (cadr numbers))))\n", "  (let ([min-diff (apply min (map (lambda (x y) (abs\
    \ (- x y))) numbers (rest numbers)))])\n    (let loop ([numbers numbers])\n  \
    \    (if (null? (rest numbers))\n          (error \"no two numbers are close enough\"\
    )\n          (if (= min-diff (abs (- (car numbers) (cadr numbers))))\n       \
    \       (values (car numbers) (cadr numbers))\n              (loop (rest numbers)))))))\n",
  "  (let ([min-diff (apply min (map (lambda (x) (abs (- (car x) (cadr x)))) (partition\
    \ numbers 2)))])\n    (apply min (filter (lambda (x) (= (abs (- (car x) (cadr\
    \ x))) min-diff)) (partition numbers 2)))))\n", "  (define (find-closest-elements-iter\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [diff (abs (- first second))]\n               [closest-diff (abs\
    \ (- (car closest-pair) (cadr closest-pair)))])\n          (if (< diff closest-diff)\n\
    \              (find-closest-elements-iter (cdr numbers) (list first second))\n\
    \              (find-closest-elements-iter (cdr numbers) closest-pair)))))\n \
    \ (find-closest-elements-iter numbers (list (car numbers) (cadr numbers))))\n",
  "  (define (find_closest_elements-helper numbers closest-pair)\n    (if (null? (cdr\
    \ numbers))\n        closest-pair\n        (let* ([first (car numbers)]\n    \
    \           [second (cadr numbers)]\n               [diff (abs (- first second))]\n\
    \               [closest-diff (abs (- (car closest-pair) (cadr closest-pair)))])\n\
    \          (if (< diff closest-diff)\n              (find_closest_elements-helper\
    \ (cdr numbers) (list first second))\n              (find_closest_elements-helper\
    \ (cdr numbers) closest-pair)))))\n  (find_closest_elements-helper numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (let ([numbers (sort numbers <)])\n \
    \   (let loop ([numbers (cdr numbers)]\n               [closest-pair (cons (car\
    \ numbers) (cadr numbers))]\n               [closest-diff (abs (- (car numbers)\
    \ (cadr numbers)))])\n      (if (null? numbers)\n          closest-pair\n    \
    \      (let ([diff (abs (- (car numbers) (cadr numbers)))])\n            (if (<\
    \ diff closest-diff)\n                (loop (cdr numbers) (cons (car numbers)\
    \ (cadr numbers)) diff)\n                (loop (cdr numbers) closest-pair closest-diff)))))))\n",
  "  (define (find_closest_elements-helper numbers closest-pair)\n    (cond\n    \
    \  [(empty? numbers) closest-pair]\n      [(empty? (rest numbers)) closest-pair]\n\
    \      [else\n       (let* ([first (first numbers)]\n              [second (first\
    \ (rest numbers))]\n              [closest-pair-so-far (if (and (number? (first\
    \ closest-pair)) (number? (second closest-pair)))\n                          \
    \             closest-pair\n                                       (list first\
    \ second))]\n              [closest-pair-so-far-diff (abs (- (first closest-pair-so-far)\
    \ (second closest-pair-so-far)))]\n              [current-pair-diff (abs (- first\
    \ second))])\n         (if (< current-pair-diff closest-pair-so-far-diff)\n  \
    \           (find_closest_elements-helper (rest numbers) (list first second))\n\
    \             (find_closest_elements-helper (rest numbers) closest-pair-so-far)))]))\n\
    \  (find_closest_elements-helper numbers (list)))\n", "  (let ([min-diff (apply\
    \ min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n    (let loop\
    \ ([numbers numbers])\n      (if (null? (rest numbers))\n          (error \"no\
    \ closest elements\")\n          (if (= min-diff (abs (- (car numbers) (cadr numbers))))\n\
    \              (list (car numbers) (cadr numbers))\n              (loop (rest\
    \ numbers)))))))\n", "  (define (find_closest_elements_iter numbers closest-pair)\n\
    \    (if (null? (cdr numbers))\n        closest-pair\n        (let* ([current-pair\
    \ (list (car numbers) (cadr numbers))]\n               [current-distance (abs\
    \ (- (car current-pair) (cadr current-pair)))]\n               [closest-distance\
    \ (abs (- (car closest-pair) (cadr closest-pair)))])\n          (if (< current-distance\
    \ closest-distance)\n              (find_closest_elements_iter (cdr numbers) current-pair)\n\
    \              (find_closest_elements_iter (cdr numbers) closest-pair)))))\n \
    \ (find_closest_elements_iter numbers (list (car numbers) (cadr numbers))))\n",
  "  (define (find_closest_elements_helper numbers closest-pair)\n    (cond\n    \
    \  [(empty? numbers) closest-pair]\n      [(empty? (rest numbers)) closest-pair]\n\
    \      [else\n       (let* ([first (first numbers)]\n              [second (first\
    \ (rest numbers))]\n              [diff (abs (- first second))]\n            \
    \  [closest-diff (abs (- (first closest-pair) (second closest-pair)))])\n    \
    \     (if (< diff closest-diff)\n             (find_closest_elements_helper (rest\
    \ numbers) (list first second))\n             (find_closest_elements_helper (rest\
    \ numbers) closest-pair)))]))\n  (find_closest_elements_helper numbers (list (first\
    \ numbers) (second numbers))))\n", "  (let ([numbers (sort numbers <)])\n    (let\
    \ loop ([numbers (cdr numbers)]\n               [closest-pair (list (car numbers)\
    \ (cadr numbers))]\n               [closest-distance (abs (- (car numbers) (cadr\
    \ numbers)))])\n      (if (null? numbers)\n          closest-pair\n          (let\
    \ ([next-distance (abs (- (car numbers) (cadr numbers)))])\n            (if (<\
    \ next-distance closest-distance)\n                (loop (cdr numbers) (list (car\
    \ numbers) (cadr numbers)) next-distance)\n                (loop (cdr numbers)\
    \ closest-pair closest-distance)))))))\n", "  (let ([min-diff (apply min (map\
    \ (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n    (let ([closest-pair\
    \ (filter (lambda (x y) (= (abs (- x y)) min-diff)) numbers (rest numbers))])\n\
    \      (if (= (length closest-pair) 2)\n          closest-pair\n          (list\
    \ (car closest-pair) (car closest-pair))))))\n", "  (let ([sorted-numbers (sort\
    \ numbers <)])\n    (let loop ([numbers sorted-numbers] [closest-pair (list (car\
    \ numbers) (cadr numbers))])\n      (if (null? (cddr numbers))\n          closest-pair\n\
    \          (let ([next-pair (list (cadr numbers) (caddr numbers))])\n        \
    \    (if (< (abs (- (car next-pair) (cadr next-pair)))\n                   (abs\
    \ (- (car closest-pair) (cadr closest-pair))))\n                (loop (cdr numbers)\
    \ next-pair)\n                (loop (cdr numbers) closest-pair)))))))\n", "  (define\
    \ (find_closest_elements-helper numbers closest-pair)\n    (if (null? (cdr numbers))\n\
    \        closest-pair\n        (let* ([first (car numbers)]\n               [second\
    \ (cadr numbers)]\n               [diff (abs (- first second))]\n            \
    \   [closest-diff (abs (- (car closest-pair) (cadr closest-pair)))])\n       \
    \   (if (&lt; diff closest-diff)\n              (find_closest_elements-helper\
    \ (cdr numbers) (list first second))\n              (find_closest_elements-helper\
    \ (cdr numbers) closest-pair)))))\n  (find_closest_elements-helper numbers (list\
    \ (car numbers) (cadr numbers))))\n</code>\n", "  (define (find-closest-elements-helper\
    \ numbers closest-pair)\n    (cond\n      [(empty? numbers) closest-pair]\n  \
    \    [(empty? (rest numbers)) closest-pair]\n      [else\n       (let* ([first\
    \ (first numbers)]\n              [second (first (rest numbers))]\n          \
    \    [diff (abs (- first second))]\n              [closest-diff (abs (- (first\
    \ closest-pair) (second closest-pair)))])\n         (if (< diff closest-diff)\n\
    \             (find-closest-elements-helper (rest numbers) (list first second))\n\
    \             (find-closest-elements-helper (rest numbers) closest-pair)))]))\n\
    \  (find-closest-elements-helper numbers (list (first numbers) (second numbers))))\n",
  "  (define (find_closest_elements_helper numbers closest-pair)\n    (if (empty?\
    \ numbers)\n        closest-pair\n        (let* ([first (first numbers)]\n   \
    \            [rest (rest numbers)]\n               [closest-pair-so-far (if (empty?\
    \ closest-pair)\n                                        (list first (first rest))\n\
    \                                        closest-pair)]\n               [closest-pair-so-far-diff\
    \ (abs (- (first closest-pair-so-far) (second closest-pair-so-far)))]\n      \
    \         [new-closest-pair (if (empty? rest)\n                              \
    \       closest-pair-so-far\n                                     (let* ([second\
    \ (first rest)]\n                                            [diff (abs (- first\
    \ second))])\n                                       (if (< diff closest-pair-so-far-diff)\n\
    \                                           (list first second)\n            \
    \                               closest-pair-so-far)))])\n          (find_closest_elements_helper\
    \ rest new-closest-pair))))\n  (find_closest_elements_helper numbers '()))\n",
  "  (define (find_closest_elements-iter numbers closest-pair)\n    (if (null? (cdr\
    \ numbers))\n        closest-pair\n        (let* ([first (car numbers)]\n    \
    \           [second (car (cdr numbers))]\n               [diff (abs (- first second))]\n\
    \               [closest-diff (abs (- (car closest-pair) (cadr closest-pair)))])\n\
    \          (if (< diff closest-diff)\n              (find_closest_elements-iter\
    \ (cdr numbers) (list first second))\n              (find_closest_elements-iter\
    \ (cdr numbers) closest-pair)))))\n  (find_closest_elements-iter numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (let ([numbers (sort numbers <)])\n \
    \   (let loop ([numbers (rest numbers)] [closest-pair (list (first numbers) (second\
    \ numbers))] [closest-diff (abs (- (first numbers) (second numbers)))])\n    \
    \  (if (null? numbers)\n          closest-pair\n          (let ([diff (abs (-\
    \ (first numbers) (second numbers)))])\n            (if (< diff closest-diff)\n\
    \                (loop (rest numbers) (list (first numbers) (second numbers))\
    \ diff)\n                (loop (rest numbers) closest-pair closest-diff)))))))\n",
  "  (define (find_closest_elements-helper numbers smallest-difference smallest-difference-pair)\n\
    \    (cond\n      [(empty? numbers) smallest-difference-pair]\n      [(empty?\
    \ (rest numbers)) smallest-difference-pair]\n      [else\n       (let*\n     \
    \      ([current-difference (abs (- (first numbers) (second numbers)))]\n    \
    \        [new-smallest-difference-pair (if (< current-difference smallest-difference)\n\
    \                                              (list (first numbers) (second numbers))\n\
    \                                              smallest-difference-pair)]\n  \
    \          [new-smallest-difference (if (< current-difference smallest-difference)\n\
    \                                         current-difference\n               \
    \                          smallest-difference)])\n         (find_closest_elements-helper\
    \ (rest numbers) new-smallest-difference new-smallest-difference-pair))]))\n \
    \ (find_closest_elements-helper numbers (abs (- (first numbers) (second numbers)))\
    \ (list (first numbers) (second numbers))))\n", "  (let* ([sorted (sort numbers\
    \ <)]\n         [differences (map (lambda (x y) (abs (- x y))) sorted (rest sorted))]\n\
    \         [min-diff (apply min differences)])\n    (list (list-ref sorted (list-index\
    \ min-diff differences))\n          (list-ref sorted (add1 (list-index min-diff\
    \ differences))))))\n", "  (define (find_closest_elements-helper numbers closest-pair)\n\
    \    (if (null? (cdr numbers))\n        closest-pair\n        (let* ([current-pair\
    \ (list (car numbers) (cadr numbers))]\n               [current-diff (abs (- (car\
    \ current-pair) (cadr current-pair)))]\n               [closest-diff (abs (- (car\
    \ closest-pair) (cadr closest-pair)))])\n          (if (< current-diff closest-diff)\n\
    \              (find_closest_elements-helper (cdr numbers) current-pair)\n   \
    \           (find_closest_elements-helper (cdr numbers) closest-pair)))))\n  (find_closest_elements-helper\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (let ([min-diff (apply\
    \ min (map (lambda (x) (apply min (map (lambda (y) (abs (- x y))) numbers))) numbers))])\n\
    \    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff))\
    \ numbers))\n          (apply min (filter (lambda (x) (= (abs (- x (apply max\
    \ numbers))) min-diff)) numbers)))))\n", "  (let ([min-diff (apply min (map (lambda\
    \ (n) (abs (- (first numbers) n))) (rest numbers)))])\n    (list (first numbers)\
    \ (first (filter (lambda (n) (= (abs (- (first numbers) n)) min-diff)) (rest numbers))))))\n",
  "  (let ([closest-pair (list (car numbers) (cadr numbers))]\n        [closest-distance\
    \ (abs (- (car numbers) (cadr numbers)))])\n    (for ([i (in-range (add1 (length\
    \ numbers)))]\n          [j (in-range (add1 i))])\n      (let ([distance (abs\
    \ (- (list-ref numbers i) (list-ref numbers j)))])\n        (when (< distance\
    \ closest-distance)\n          (set! closest-pair (list (list-ref numbers i) (list-ref\
    \ numbers j)))\n          (set! closest-distance distance))))\n    closest-pair))\n",
  "  (define (abs x)\n    (if (< x 0)\n        (- x)\n        x))\n  (define (find_closest_elements_helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([first-number (car numbers)]\n               [second-number (cadr\
    \ numbers)]\n               [closest-pair-difference (abs (- (car closest-pair)\
    \ (cadr closest-pair)))]\n               [new-pair-difference (abs (- first-number\
    \ second-number))])\n          (if (< new-pair-difference closest-pair-difference)\n\
    \              (find_closest_elements_helper (cdr numbers) (list first-number\
    \ second-number))\n              (find_closest_elements_helper (cdr numbers) closest-pair)))))\n\
    \  (find_closest_elements_helper numbers (list (car numbers) (cadr numbers))))\n",
  "  (let ([min (apply min numbers)]\n        [max (apply max numbers)])\n    (if\
    \ (= min max)\n        (list min max)\n        (let ([closest-diff (apply min\
    \ (map (lambda (x) (abs (- x min))) (cdr numbers)))])\n          (list min (+\
    \ min closest-diff))))))\n", "  (let ([sorted-numbers (sort numbers <)])\n   \
    \ (let loop ([numbers sorted-numbers] [closest-pair (list (car numbers) (cadr\
    \ numbers))])\n      (if (null? (cddr numbers))\n          closest-pair\n    \
    \      (let ([next-pair (list (cadr numbers) (caddr numbers))])\n            (if\
    \ (< (abs (- (car next-pair) (cadr next-pair)))\n                   (abs (- (car\
    \ closest-pair) (cadr closest-pair))))\n                (loop (cdr numbers) next-pair)\n\
    \                (loop (cdr numbers) closest-pair)))))))\n", "  (let loop ([numbers\
    \ numbers]\n             [closest-pair (list (car numbers) (cadr numbers))])\n\
    \    (if (null? (cddr numbers))\n        closest-pair\n        (let ([new-pair\
    \ (list (car numbers) (cadr numbers))])\n          (if (< (abs (- (car new-pair)\
    \ (cadr new-pair)))\n                 (abs (- (car closest-pair) (cadr closest-pair))))\n\
    \              (loop (cdr numbers) new-pair)\n              (loop (cdr numbers)\
    \ closest-pair))))))\n", "  (define (find-closest-elements-helper numbers closest-pair)\n\
    \    (if (null? (cdr numbers))\n        closest-pair\n        (let* ([first (car\
    \ numbers)]\n               [second (cadr numbers)]\n               [diff (abs\
    \ (- first second))]\n               [closest-diff (abs (- (car closest-pair)\
    \ (cadr closest-pair)))]\n               [new-closest-pair (if (< diff closest-diff)\n\
    \                                     (list first second)\n                  \
    \                   closest-pair)])\n          (find-closest-elements-helper (cdr\
    \ numbers) new-closest-pair))))\n  (find-closest-elements-helper numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (let* ([sorted-numbers (sort numbers\
    \ <)]\n         [min-diff (apply min (map (lambda (x y) (abs (- x y))) sorted-numbers\
    \ (rest sorted-numbers)))]\n         [closest-pair (filter (lambda (x y) (= (abs\
    \ (- x y)) min-diff)) sorted-numbers (rest sorted-numbers))])\n    closest-pair))\n",
  "  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n\
    \    (let ([closest-pair (filter (lambda (x y) (= (abs (- x y)) min-diff)) numbers\
    \ (rest numbers))])\n      (if (= (length closest-pair) 2)\n          closest-pair\n\
    \          (list (car closest-pair) (car closest-pair))))))\n", "  (let ([closest-pair\
    \ (list (car numbers) (cadr numbers))]\n        [closest-distance (abs (- (car\
    \ numbers) (cadr numbers)))])\n    (for ([i (in-range (add1 (length numbers)))]\n\
    \          [j (in-range i)])\n      (let ([distance (abs (- (list-ref numbers\
    \ i) (list-ref numbers j)))])\n        (when (< distance closest-distance)\n \
    \         (set! closest-pair (list (list-ref numbers j) (list-ref numbers i)))\n\
    \          (set! closest-distance distance))))\n    closest-pair))\n", "  (define\
    \ (find_closest_elements_helper numbers closest-pair)\n    (if (null? (cdr numbers))\n\
    \        closest-pair\n        (let* ([first (car numbers)]\n               [second\
    \ (cadr numbers)]\n               [diff (abs (- first second))]\n            \
    \   [closest-diff (abs (- (car closest-pair) (cadr closest-pair)))])\n       \
    \   (if (< diff closest-diff)\n              (find_closest_elements_helper (cdr\
    \ numbers) (list first second))\n              (find_closest_elements_helper (cdr\
    \ numbers) closest-pair)))))\n  (find_closest_elements_helper numbers (list (car\
    \ numbers) (cadr numbers))))\n", "  (let loop ((numbers numbers)\n           \
    \  (min-diff (abs (- (car numbers) (cadr numbers))))\n             (min-pair (list\
    \ (car numbers) (cadr numbers))))\n    (cond ((null? (cdr numbers)) min-pair)\n\
    \          ((< (abs (- (car numbers) (cadr numbers))) min-diff)\n           (loop\
    \ (cdr numbers)\n                 (abs (- (car numbers) (cadr numbers)))\n   \
    \              (list (car numbers) (cadr numbers))))\n          (else (loop (cdr\
    \ numbers) min-diff min-pair)))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-pair)\n    (cond\n      [(empty? numbers) closest-pair]\n  \
    \    [(empty? (rest numbers)) closest-pair]\n      [else\n       (let* ([first\
    \ (first numbers)]\n              [second (first (rest numbers))]\n          \
    \    [diff (abs (- first second))]\n              [closest-diff (abs (- (first\
    \ closest-pair) (second closest-pair)))])\n         (if (< diff closest-diff)\n\
    \             (find_closest_elements_helper (rest numbers) (list first second))\n\
    \             (find_closest_elements_helper (rest numbers) closest-pair)))]))\n\
    \  (find_closest_elements_helper numbers (list (first numbers) (second numbers))))\n",
  "  (define (closest-pair numbers)\n    (cond\n      [(null? numbers) (error \"list\
    \ is empty\")]\n      [(null? (cdr numbers)) (error \"list has only one element\"\
    )]\n      [(= (car numbers) (cadr numbers)) (values (car numbers) (cadr numbers))]\n\
    \      [else\n       (let* ([numbers (sort numbers <)]\n              [first (car\
    \ numbers)]\n              [second (cadr numbers)]\n              [first-second\
    \ (abs (- first second))])\n         (for/fold ([closest-pair (values first second)]\n\
    \                    [closest-distance first-second])\n                   ([n\
    \ (cddr numbers)])\n                   (let* ([n-first (abs (- n first))]\n  \
    \                        [n-second (abs (- n second))]\n                     \
    \     [n-first-second (abs (- n first second))])\n                     (cond\n\
    \                       [(< n-first-second closest-distance) (values (values n\
    \ first) n-first-second)]\n                       [(< n-first closest-distance)\
    \ (values (values n first) n-first)]\n                       [(< n-second closest-distance)\
    \ (values (values n second) n-second)]\n                       [else (values closest-pair\
    \ closest-distance)]))))))\n    (closest-pair numbers))\n", "  (let ([closest-pair\
    \ (list (car numbers) (cadr numbers))]\n        [closest-distance (abs (- (car\
    \ numbers) (cadr numbers)))])\n    (for ([i (in-range (add1 (length numbers)))]\n\
    \          [j (in-range i)])\n      (let ([distance (abs (- (list-ref numbers\
    \ i) (list-ref numbers j)))])\n        (when (< distance closest-distance)\n \
    \         (set! closest-pair (list (list-ref numbers j) (list-ref numbers i)))\n\
    \          (set! closest-distance distance))))\n    closest-pair))\n", "  (define\
    \ (find-closest-elements-helper numbers closest-pair)\n    (if (null? (cdr numbers))\n\
    \        closest-pair\n        (let* ([first (car numbers)]\n               [second\
    \ (cadr numbers)]\n               [diff (abs (- first second))]\n            \
    \   [closest-diff (abs (- (car closest-pair) (cadr closest-pair)))])\n       \
    \   (if (< diff closest-diff)\n              (find-closest-elements-helper (cdr\
    \ numbers) (list first second))\n              (find-closest-elements-helper (cdr\
    \ numbers) closest-pair)))))\n  (find-closest-elements-helper numbers (list (car\
    \ numbers) (cadr numbers))))\n", "  (let loop ([numbers numbers]\n           \
    \  [closest-pair (list (car numbers) (cadr numbers))])\n    (if (null? (cddr numbers))\n\
    \        closest-pair\n        (let ([next-pair (list (car numbers) (cadr numbers))])\n\
    \          (if (< (abs (- (car next-pair) (cadr next-pair)))\n               \
    \  (abs (- (car closest-pair) (cadr closest-pair))))\n              (loop (cdr\
    \ numbers) next-pair)\n              (loop (cdr numbers) closest-pair))))))\n",
  "  (define (find_closest_elements-helper numbers closest-pair)\n    (cond [(empty?\
    \ numbers) closest-pair]\n          [(empty? (rest numbers)) closest-pair]\n \
    \         [else\n           (define current-pair (list (first numbers) (second\
    \ numbers)))\n           (define current-distance (abs (- (first current-pair)\
    \ (second current-pair))))\n           (define closest-distance (abs (- (first\
    \ closest-pair) (second closest-pair))))\n           (if (< current-distance closest-distance)\n\
    \               (find_closest_elements-helper (rest numbers) current-pair)\n \
    \              (find_closest_elements-helper (rest numbers) closest-pair))]))\n\
    \  (find_closest_elements-helper numbers (list (first numbers) (second numbers))))\n",
  "  (let* ([sorted (sort numbers <)]\n         [min-diff (apply min (map (lambda\
    \ (x y) (abs (- x y))) sorted (cdr sorted)))]\n         [min-index (find-index\
    \ (lambda (x) (= x min-diff)) (map (lambda (x y) (abs (- x y))) sorted (cdr sorted)))])\n\
    \    (list (list-ref sorted min-index) (list-ref sorted (+ min-index 1)))))\n",
  "  (let loop ([numbers numbers]\n             [min-diff (abs (- (car numbers) (cadr\
    \ numbers)))]\n             [min-pair (list (car numbers) (cadr numbers))])\n\
    \    (if (null? (cddr numbers))\n        min-pair\n        (let ([diff (abs (-\
    \ (cadr numbers) (caddr numbers)))])\n          (if (< diff min-diff)\n      \
    \        (loop (cdr numbers) diff (list (cadr numbers) (caddr numbers)))\n   \
    \           (loop (cdr numbers) min-diff min-pair))))))\n", "  (let* ([sorted-numbers\
    \ (sort numbers <)]\n         [min-diff (apply min (map (lambda (x y) (abs (-\
    \ x y))) sorted-numbers (rest sorted-numbers)))]\n         [closest-pair (for/first\
    \ ([x sorted-numbers]\n                                   [y (rest sorted-numbers)]\n\
    \                                   #:when (equal? min-diff (abs (- x y))))\n\
    \                         (list x y))])\n    closest-pair))\n", "  (define (find_closest_elements-helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [diff (abs (- first second))]\n               [closest-diff (abs\
    \ (- (car closest-pair) (cadr closest-pair)))])\n          (if (< diff closest-diff)\n\
    \              (find_closest_elements-helper (cdr numbers) (list first second))\n\
    \              (find_closest_elements-helper (cdr numbers) closest-pair)))))\n\
    \  (find_closest_elements-helper numbers (list (car numbers) (cadr numbers))))\n",
  "  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n\
    \    (apply values (filter (lambda (x y) (= (abs (- x y)) min-diff)) numbers (rest\
    \ numbers)))))\n", "  (define (find_closest_elements_helper numbers closest-pair)\n\
    \    (if (null? (cdr numbers))\n        closest-pair\n        (let* ([first (car\
    \ numbers)]\n               [second (cadr numbers)]\n               [diff (abs\
    \ (- first second))]\n               [closest-diff (abs (- (car closest-pair)\
    \ (cadr closest-pair)))])\n          (if (< diff closest-diff)\n             \
    \ (find_closest_elements_helper (cdr numbers) (list first second))\n         \
    \     (find_closest_elements_helper (cdr numbers) closest-pair)))))\n  (find_closest_elements_helper\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-so-far)\n    (if (null? (cdr numbers))\n        closest-so-far\n\
    \        (let* ([current-pair (list (car numbers) (cadr numbers))]\n         \
    \      [current-difference (abs (- (car current-pair) (cadr current-pair)))]\n\
    \               [closest-difference (abs (- (car closest-so-far) (cadr closest-so-far)))])\n\
    \          (if (< current-difference closest-difference)\n              (find_closest_elements_helper\
    \ (cdr numbers) current-pair)\n              (find_closest_elements_helper (cdr\
    \ numbers) closest-so-far)))))\n  (find_closest_elements_helper numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (let ([closest-pair (list (first numbers)\
    \ (second numbers))])\n    (for ([i (in-range (length numbers))])\n      (for\
    \ ([j (in-range (add1 i))])\n        (let ([diff (abs (- (list-ref numbers i)\
    \ (list-ref numbers j)))])\n          (when (< diff (abs (- (first closest-pair)\
    \ (second closest-pair))))\n            (set! closest-pair (list (list-ref numbers\
    \ i) (list-ref numbers j)))))))\n    closest-pair))\n", "  (let ([min-diff (apply\
    \ min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n    (let loop\
    \ ([numbers numbers])\n      (if (null? (rest numbers))\n          (error \"no\
    \ closest elements\")\n          (if (= min-diff (abs (- (car numbers) (cadr numbers))))\n\
    \              (values (car numbers) (cadr numbers))\n              (loop (rest\
    \ numbers)))))))\n", "  (let ([closest-pair (list (first numbers) (second numbers))])\n\
    \    (for ([n (in-list (rest (rest numbers)))]\n          #:when (< (abs (- (first\
    \ closest-pair) n))\n                    (abs (- (second closest-pair) (first\
    \ closest-pair)))))\n      (set! closest-pair (list (first closest-pair) n)))\n\
    \    closest-pair))\n", "  (define (find_closest_elements_helper numbers closest-pair)\n\
    \    (cond\n      [(empty? numbers) closest-pair]\n      [(empty? (rest numbers))\
    \ closest-pair]\n      [else\n       (let* ([first (first numbers)]\n        \
    \      [second (first (rest numbers))]\n              [diff (abs (- first second))]\n\
    \              [closest-diff (abs (- (first closest-pair) (second closest-pair)))])\n\
    \         (if (< diff closest-diff)\n             (find_closest_elements_helper\
    \ (rest numbers) (list first second))\n             (find_closest_elements_helper\
    \ (rest numbers) closest-pair)))]))\n  (find_closest_elements_helper numbers (list\
    \ (first numbers) (second numbers))))\n", "  (let loop ([numbers numbers]\n  \
    \           [closest-numbers (list (car numbers) (cadr numbers))])\n    (if (null?\
    \ (cddr numbers))\n        closest-numbers\n        (let* ([difference (abs (-\
    \ (car numbers) (cadr numbers)))]\n               [closest-difference (abs (-\
    \ (car closest-numbers) (cadr closest-numbers))))\n          (if (< difference\
    \ closest-difference)\n              (loop (cdr numbers) (list (car numbers) (cadr\
    \ numbers)))\n              (loop (cdr numbers) closest-numbers))))))\n", "  (let\
    \ loop ((numbers numbers)\n             (closest-pair (list (car numbers) (cadr\
    \ numbers)))\n             (closest-distance (abs (- (car numbers) (cadr numbers)))))\n\
    \    (if (null? (cddr numbers))\n        closest-pair\n        (let ((distance\
    \ (abs (- (cadr numbers) (caddr numbers)))))\n          (if (< distance closest-distance)\n\
    \              (loop (cdr numbers) (list (cadr numbers) (caddr numbers)) distance)\n\
    \              (loop (cdr numbers) closest-pair closest-distance))))))\n", " \
    \ (define (find_closest_elements_helper numbers closest-pair)\n    (if (null?\
    \ (cdr numbers))\n        closest-pair\n        (let* ([first (car numbers)]\n\
    \               [second (cadr numbers)]\n               [difference (abs (- first\
    \ second))]\n               [current-difference (abs (- (car closest-pair) (cadr\
    \ closest-pair)))])\n          (if (< difference current-difference)\n       \
    \       (find_closest_elements_helper (cdr numbers) (list first second))\n   \
    \           (find_closest_elements_helper (cdr numbers) closest-pair)))))\n  (find_closest_elements_helper\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (let ([min-diff (apply\
    \ min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n    (for/first\
    \ ([x numbers]\n                [y (rest numbers)]\n                #:when (=\
    \ (abs (- x y)) min-diff))\n      (list x y))))\n", "  (let loop ([numbers numbers]\n\
    \             [closest-pair (list (car numbers) (cadr numbers))])\n    (if (null?\
    \ (cddr numbers))\n        closest-pair\n        (let ([diff-1 (abs (- (car numbers)\
    \ (cadr numbers)))])\n          (let ([diff-2 (abs (- (cadr numbers) (caddr numbers)))])\n\
    \            (if (< diff-1 diff-2)\n                (loop (cdr numbers) closest-pair)\n\
    \                (loop (cdr numbers) (list (cadr numbers) (caddr numbers)))))))))\n",
  "  (define (find_closest_elements-helper numbers closest-so-far)\n    (if (empty?\
    \ numbers)\n        closest-so-far\n        (let* ([n (first numbers)]\n     \
    \          [closest-so-far-diff (abs (- (first closest-so-far) (second closest-so-far)))]\n\
    \               [new-diff (abs (- (first closest-so-far) n))])\n          (if\
    \ (< new-diff closest-so-far-diff)\n              (find_closest_elements-helper\
    \ (rest numbers) (list (first closest-so-far) n))\n              (find_closest_elements-helper\
    \ (rest numbers) closest-so-far)))))\n  (find_closest_elements-helper (rest numbers)\
    \ (list (first numbers) (second numbers))))\n", "  (let ([closest-diff (apply\
    \ min (map (lambda (x) (apply min (map (lambda (y) (abs (- x y))) (cdr numbers))))\
    \ numbers))])\n    (list (apply min (filter (lambda (x) (= (abs (- x (apply min\
    \ numbers))) closest-diff)) numbers))\n          (apply min (filter (lambda (x)\
    \ (= (abs (- x (apply min numbers))) closest-diff)) numbers)))))\n", "  (let ([min-diff\
    \ (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n  \
    \  (let ([min-diff-index (find-index (lambda (x) (= x min-diff)) (map (lambda\
    \ (x y) (abs (- x y))) numbers (rest numbers)))])\n      (list (list-ref numbers\
    \ min-diff-index) (list-ref numbers (add1 min-diff-index))))))\n", "  (let ([min-diff\
    \ (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n  \
    \  (let loop ([numbers numbers])\n      (if (null? (rest numbers))\n         \
    \ (error \"no closest elements\")\n          (if (= min-diff (abs (- (car numbers)\
    \ (cadr numbers))))\n              (list (car numbers) (cadr numbers))\n     \
    \         (loop (rest numbers)))))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-pair)\n    (cond [(empty? numbers) closest-pair]\n         \
    \ [(= (length numbers) 1) closest-pair]\n          [else\n           (let* ([first\
    \ (first numbers)]\n                  [second (second numbers)]\n            \
    \      [diff (abs (- first second))]\n                  [closest-diff (abs (-\
    \ (first closest-pair) (second closest-pair)))])\n             (if (< diff closest-diff)\n\
    \                 (find_closest_elements_helper (rest numbers) (list first second))\n\
    \                 (find_closest_elements_helper (rest numbers) closest-pair)))]))\n\
    \  (find_closest_elements_helper numbers (list (first numbers) (second numbers))))\n",
  "  (define (find_closest_elements-iter numbers closest-pair)\n    (if (null? (cdr\
    \ numbers))\n        closest-pair\n        (let* ([first (car numbers)]\n    \
    \           [second (cadr numbers)]\n               [difference (abs (- first\
    \ second))]\n               [closest-difference (abs (- (car closest-pair) (cadr\
    \ closest-pair)))])\n          (if (< difference closest-difference)\n       \
    \       (find_closest_elements-iter (cdr numbers) (list first second))\n     \
    \         (find_closest_elements-iter (cdr numbers) closest-pair)))))\n  (find_closest_elements-iter\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (let ([min-diff (apply\
    \ min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n    (list\
    \ (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff))\
    \ numbers))\n          (apply max (filter (lambda (x) (= (abs (- x (apply min\
    \ numbers))) min-diff)) numbers)))))\n", "  (define (find_closest_elements-helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let ([current-pair (list (car numbers) (cadr numbers))])\n         \
    \ (if (< (abs (- (car current-pair) (cadr current-pair)))\n                 (abs\
    \ (- (car closest-pair) (cadr closest-pair))))\n              (find_closest_elements-helper\
    \ (cdr numbers) current-pair)\n              (find_closest_elements-helper (cdr\
    \ numbers) closest-pair)))))\n  (find_closest_elements-helper numbers (list (car\
    \ numbers) (cadr numbers))))\n", "  (define (find-closest-elements-helper numbers\
    \ closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n       \
    \ (let* ([first (car numbers)]\n               [second (cadr numbers)]\n     \
    \          [diff (abs (- first second))]\n               [closest-diff (abs (-\
    \ (car closest-pair) (cadr closest-pair)))])\n          (if (< diff closest-diff)\n\
    \              (find-closest-elements-helper (cdr numbers) (list first second))\n\
    \              (find-closest-elements-helper (cdr numbers) closest-pair)))))\n\
    \  (find-closest-elements-helper (sort numbers <) (list (car numbers) (cadr numbers))))\n",
  "  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])\n\
    \    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff))\
    \ numbers))\n          (apply max (filter (lambda (x) (= (abs (- x (apply min\
    \ numbers))) min-diff)) numbers)))))\n", "  (define (find-closest-elements-helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [distance (abs (- first second))]\n               [closest-distance\
    \ (abs (- (car closest-pair) (cadr closest-pair)))])\n          (if (< distance\
    \ closest-distance)\n              (find-closest-elements-helper (cdr numbers)\
    \ (list first second))\n              (find-closest-elements-helper (cdr numbers)\
    \ closest-pair)))))\n  (find-closest-elements-helper numbers (list (car numbers)\
    \ (cadr numbers))))\n", "  (let* ([numbers (sort numbers <)]\n         [min-diff\
    \ (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))]\n   \
    \      [closest-pair (filter (lambda (x y) (= (abs (- x y)) min-diff)) numbers\
    \ (rest numbers))])\n    closest-pair))\n", "  (let* ([sorted (sort numbers <)]\n\
    \         [min-diff (apply min (map (lambda (x y) (abs (- x y))) sorted (cdr sorted)))]\n\
    \         [closest-pair (filter (lambda (x y) (= (abs (- x y)) min-diff)) sorted\
    \ (cdr sorted))])\n    closest-pair))\n", "  (let ([numbers (sort numbers <)])\n\
    \    (let loop ([numbers (cdr numbers)]\n               [closest-pair (list (car\
    \ numbers) (cadr numbers))]\n               [closest-distance (abs (- (car numbers)\
    \ (cadr numbers)))])\n      (if (null? numbers)\n          closest-pair\n    \
    \      (let ([distance (abs (- (car numbers) (cadr numbers)))])\n            (if\
    \ (< distance closest-distance)\n                (loop (cdr numbers) (list (car\
    \ numbers) (cadr numbers)) distance)\n                (loop (cdr numbers) closest-pair\
    \ closest-distance)))))))\n", "  (let ([sorted (sort numbers <)])\n    (let loop\
    \ ([sorted sorted] [min-diff (abs (- (first sorted) (second sorted)))] [min-pair\
    \ (list (first sorted) (second sorted))])\n      (if (null? (rest sorted))\n \
    \         min-pair\n          (let ([diff (abs (- (first sorted) (second sorted)))])\n\
    \            (if (< diff min-diff)\n                (loop (rest sorted) diff (list\
    \ (first sorted) (second sorted)))\n                (loop (rest sorted) min-diff\
    \ min-pair)))))))\n", "  (let loop ((numbers numbers)\n             (closest-pair\
    \ (list (car numbers) (cadr numbers)))\n             (closest-distance (abs (-\
    \ (car numbers) (cadr numbers)))))\n    (if (null? (cddr numbers))\n        closest-pair\n\
    \        (let ((distance (abs (- (cadr numbers) (caddr numbers)))))\n        \
    \  (if (< distance closest-distance)\n              (loop (cdr numbers) (list\
    \ (cadr numbers) (caddr numbers)) distance)\n              (loop (cdr numbers)\
    \ closest-pair closest-distance))))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [distance (abs (- first second))]\n               [closest-distance\
    \ (abs (- (car closest-pair) (cadr closest-pair)))])\n          (if (< distance\
    \ closest-distance)\n              (find_closest_elements_helper (cdr numbers)\
    \ (list first second))\n              (find_closest_elements_helper (cdr numbers)\
    \ closest-pair)))))\n  (find_closest_elements_helper numbers (list (car numbers)\
    \ (cadr numbers))))\n", "  (let ([numbers (sort numbers <)])\n    (let loop ([numbers\
    \ (rest numbers)] [min-diff (abs (- (first numbers) (second numbers)))] [min-pair\
    \ (list (first numbers) (second numbers))])\n      (cond [(empty? numbers) min-pair]\n\
    \            [(< (abs (- (first numbers) (second numbers))) min-diff) (loop (rest\
    \ numbers) (abs (- (first numbers) (second numbers))) (list (first numbers) (second\
    \ numbers)))]\n            [else (loop (rest numbers) min-diff min-pair)]))))\n",
  "  (let ([closest-pair (list (car numbers) (cadr numbers))]\n        [closest-distance\
    \ (abs (- (car numbers) (cadr numbers)))])\n    (for ([i (in-range (add1 (length\
    \ numbers)))]\n          [j (in-range i)])\n      (let ([distance (abs (- (list-ref\
    \ numbers i) (list-ref numbers j)))])\n        (when (< distance closest-distance)\n\
    \          (set! closest-pair (list (list-ref numbers j) (list-ref numbers i)))\n\
    \          (set! closest-distance distance))))\n    closest-pair))\n", "  (define\
    \ (find_closest_elements_helper numbers min-diff min-pair)\n    (if (null? (cdr\
    \ numbers))\n        min-pair\n        (let* ([diff (abs (- (car numbers) (cadr\
    \ numbers)))]\n               [new-min-pair (if (< diff min-diff)\n          \
    \                       (list (car numbers) (cadr numbers))\n                \
    \                 min-pair)])\n          (find_closest_elements_helper (cdr numbers)\
    \ (min diff min-diff) new-min-pair))))\n  (find_closest_elements_helper numbers\
    \ (abs (- (car numbers) (cadr numbers))) (list (car numbers) (cadr numbers))))\n",
  "  (let loop ([numbers numbers]\n             [closest-pair (list (car numbers)\
    \ (cadr numbers))])\n    (if (null? (cddr numbers))\n        closest-pair\n  \
    \      (let ([new-pair (list (car numbers) (cadr numbers))])\n          (if (<\
    \ (abs (- (car new-pair) (cadr new-pair)))\n                 (abs (- (car closest-pair)\
    \ (cadr closest-pair))))\n              (loop (cdr numbers) new-pair)\n      \
    \        (loop (cdr numbers) closest-pair))))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([current-pair (list (car numbers) (cadr numbers))]\n         \
    \      [current-diff (abs (- (car current-pair) (cadr current-pair)))]\n     \
    \          [closest-diff (abs (- (car closest-pair) (cadr closest-pair)))])\n\
    \          (if (< current-diff closest-diff)\n              (find_closest_elements_helper\
    \ (cdr numbers) current-pair)\n              (find_closest_elements_helper (cdr\
    \ numbers) closest-pair)))))\n  (find_closest_elements_helper numbers (list (car\
    \ numbers) (cadr numbers))))\n", "  (let loop ((numbers numbers)\n           \
    \  (closest-pair (list (car numbers) (cadr numbers)))\n             (closest-diff\
    \ (abs (- (car numbers) (cadr numbers)))))\n    (if (null? (cddr numbers))\n \
    \       closest-pair\n        (let ((diff (abs (- (cadr numbers) (caddr numbers)))))\n\
    \          (if (< diff closest-diff)\n              (loop (cdr numbers) (list\
    \ (cadr numbers) (caddr numbers)) diff)\n              (loop (cdr numbers) closest-pair\
    \ closest-diff))))))\n", "  (define (find_closest_elements-helper numbers closest-so-far)\n\
    \    (if (null? (cdr numbers))\n        closest-so-far\n        (let* ([n1 (car\
    \ numbers)]\n               [n2 (cadr numbers)]\n               [diff (abs (-\
    \ n1 n2))]\n               [closest-so-far-diff (abs (- (car closest-so-far) (cadr\
    \ closest-so-far)))])\n          (if (< diff closest-so-far-diff)\n          \
    \    (find_closest_elements-helper (cdr numbers) (list n1 n2))\n             \
    \ (find_closest_elements-helper (cdr numbers) closest-so-far)))))\n  (find_closest_elements-helper\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (let ([min-diff (apply\
    \ min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n    (let loop\
    \ ([numbers numbers])\n      (if (null? (rest numbers))\n          (error \"No\
    \ closest elements found\")\n          (if (= min-diff (abs (- (car numbers) (cadr\
    \ numbers))))\n              (values (car numbers) (cadr numbers))\n         \
    \     (loop (rest numbers)))))))\n", "  (let ([sorted (sort numbers <)])\n   \
    \ (let loop ([sorted sorted] [min-diff (abs (- (first sorted) (second sorted)))]\
    \ [min-pair (list (first sorted) (second sorted))])\n      (if (null? (rest sorted))\n\
    \          min-pair\n          (let ([diff (abs (- (first sorted) (second sorted)))])\n\
    \            (if (< diff min-diff)\n                (loop (rest sorted) diff (list\
    \ (first sorted) (second sorted)))\n                (loop (rest sorted) min-diff\
    \ min-pair)))))))\n", "  (let* ([sorted (sort numbers <)]\n         [pairs (for/list\
    \ ([i (in-range (sub1 (length sorted)))])\n                  (list (list-ref sorted\
    \ i) (list-ref sorted (add1 i))))]\n         [closest-pair (apply min pairs (lambda\
    \ (a b) (abs (- (car a) (car b)))))]\n         [smaller (apply min closest-pair)]\n\
    \         [larger (apply max closest-pair)])\n    (list smaller larger)))\n",
  "  (define (find_closest_elements-helper numbers closest-pair)\n    (if (null? (cdr\
    \ numbers))\n        closest-pair\n        (let* ([first (car numbers)]\n    \
    \           [second (cadr numbers)]\n               [diff (abs (- first second))]\n\
    \               [closest-diff (abs (- (car closest-pair) (cadr closest-pair)))])\n\
    \          (if (< diff closest-diff)\n              (find_closest_elements-helper\
    \ (cdr numbers) (list first second))\n              (find_closest_elements-helper\
    \ (cdr numbers) closest-pair)))))\n  (find_closest_elements-helper numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-pair)\n    (cond\n      [(empty? numbers) closest-pair]\n  \
    \    [(empty? (rest numbers)) closest-pair]\n      [else\n       (let* ([first\
    \ (first numbers)]\n              [second (first (rest numbers))]\n          \
    \    [diff (abs (- first second))]\n              [closest-diff (abs (- (first\
    \ closest-pair) (second closest-pair)))])\n         (if (< diff closest-diff)\n\
    \             (find_closest_elements_helper (rest numbers) (list first second))\n\
    \             (find_closest_elements_helper (rest numbers) closest-pair)))]))\n\
    \  (find_closest_elements_helper numbers (list (first numbers) (second numbers))))\n",
  "  (define (find_closest_elements_helper numbers min-diff min-pair)\n    (if (null?\
    \ (cdr numbers))\n        min-pair\n        (let* ([diff (abs (- (car numbers)\
    \ (cadr numbers)))]\n               [new-min-pair (if (< diff min-diff)\n    \
    \                             (cons (car numbers) (cadr numbers))\n          \
    \                       min-pair)])\n          (find_closest_elements_helper (cdr\
    \ numbers)\n                                        (if (< diff min-diff) diff\
    \ min-diff)\n                                        new-min-pair))))\n  (find_closest_elements_helper\
    \ numbers (abs (- (car numbers) (cadr numbers))) (cons (car numbers) (cadr numbers))))\n",
  "  (define (abs x)\n    (if (< x 0)\n        (- x)\n        x))\n  (define (find_closest_elements_iter\
    \ numbers closest-pair)\n    (if (null? numbers)\n        closest-pair\n     \
    \   (let* ([first (car numbers)]\n               [rest (cdr numbers)]\n      \
    \         [closest-pair-so-far (if (null? closest-pair)\n                    \
    \                    (cons first (car rest))\n                               \
    \         closest-pair)]\n               [closest-pair-so-far-diff (abs (- (car\
    \ closest-pair-so-far) (cdr closest-pair-so-far)))]\n               [diff (abs\
    \ (- first (car rest)))])\n          (if (< diff closest-pair-so-far-diff)\n \
    \             (find_closest_elements_iter rest (cons first (car rest)))\n    \
    \          (find_closest_elements_iter rest closest-pair-so-far)))))\n  (find_closest_elements_iter\
    \ numbers '()))\n", "  (define (find_closest_elements_helper numbers closest-pair)\n\
    \    (if (null? (cdr numbers))\n        closest-pair\n        (let* ([first (car\
    \ numbers)]\n               [second (cadr numbers)]\n               [diff (abs\
    \ (- first second))]\n               [closest-diff (abs (- (car closest-pair)\
    \ (cadr closest-pair)))])\n          (if (< diff closest-diff)\n             \
    \ (find_closest_elements_helper (cdr numbers) (list first second))\n         \
    \     (find_closest_elements_helper (cdr numbers) closest-pair)))))\n  (find_closest_elements_helper\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [diff (abs (- first second))]\n               [closest-diff (abs\
    \ (- (car closest-pair) (cadr closest-pair)))])\n          (if (< diff closest-diff)\n\
    \              (find_closest_elements_helper (cdr numbers) (list first second))\n\
    \              (find_closest_elements_helper (cdr numbers) closest-pair)))))\n\
    \  (find_closest_elements_helper numbers (list (car numbers) (cadr numbers))))\n",
  "  (define (find_closest_elements-helper numbers closest-pair)\n    (if (null? (cdr\
    \ numbers))\n        closest-pair\n        (let* ([first (car numbers)]\n    \
    \           [second (cadr numbers)]\n               [diff (abs (- first second))]\n\
    \               [closest-diff (abs (- (car closest-pair) (cadr closest-pair)))])\n\
    \          (if (< diff closest-diff)\n              (find_closest_elements-helper\
    \ (cdr numbers) (list first second))\n              (find_closest_elements-helper\
    \ (cdr numbers) closest-pair)))))\n  (find_closest_elements-helper numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (let loop ([numbers numbers]\n      \
    \       [closest-elements (list (car numbers) (cadr numbers))])\n    (if (null?\
    \ (cddr numbers))\n        closest-elements\n        (let ([current-closest-elements\
    \ (list (car numbers) (cadr numbers))])\n          (if (< (abs (- (car numbers)\
    \ (cadr numbers)))\n                 (abs (- (car closest-elements) (cadr closest-elements))))\n\
    \              (loop (cdr numbers) current-closest-elements)\n              (loop\
    \ (cdr numbers) closest-elements))))))\n", "  (let ([sorted-numbers (sort numbers\
    \ <)])\n    (let loop ([numbers sorted-numbers] [closest-pair (list (car numbers)\
    \ (cadr numbers))])\n      (if (null? (cddr numbers))\n          closest-pair\n\
    \          (let ([next-pair (list (cadr numbers) (caddr numbers))])\n        \
    \    (if (< (abs (- (car next-pair) (cadr next-pair)))\n                   (abs\
    \ (- (car closest-pair) (cadr closest-pair))))\n                (loop (cdr numbers)\
    \ next-pair)\n                (loop (cdr numbers) closest-pair)))))))\n", "  (let\
    \ ([min-diff (apply min (map (lambda (x) (abs (- (car x) (cadr x)))) (partition\
    \ numbers 2)))])\n    (apply min (filter (lambda (x) (= (abs (- (car x) (cadr\
    \ x))) min-diff)) (partition numbers 2)))))\n", "  (define (find_closest_elements_helper\
    \ numbers closest-pair)\n    (cond [(empty? numbers) closest-pair]\n         \
    \ [(empty? (rest numbers)) closest-pair]\n          [else (let* ([first (first\
    \ numbers)]\n                       [second (first (rest numbers))]\n        \
    \               [diff (abs (- first second))]\n                       [closest-diff\
    \ (abs (- (first closest-pair) (second closest-pair)))])\n                  (if\
    \ (< diff closest-diff)\n                      (find_closest_elements_helper (rest\
    \ numbers) (list first second))\n                      (find_closest_elements_helper\
    \ (rest numbers) closest-pair)))]))\n  (find_closest_elements_helper numbers (list\
    \ (first numbers) (second numbers))))\n", "  (let loop ([numbers numbers]\n  \
    \           [closest-pair (list (car numbers) (cadr numbers))])\n    (if (null?\
    \ (cddr numbers))\n        closest-pair\n        (let ([next-pair (list (car numbers)\
    \ (cadr numbers))])\n          (if (< (abs (- (car next-pair) (cadr next-pair)))\n\
    \                 (abs (- (car closest-pair) (cadr closest-pair))))\n        \
    \      (loop (cdr numbers) next-pair)\n              (loop (cdr numbers) closest-pair))))))\n",
  "  (let ([closest-diff (apply min (map (\u03BB (x) (abs (- (car x) (cadr x)))) (partition\
    \ numbers 2 1)))])\n    (filter (\u03BB (x) (= (abs (- (car x) (cadr x))) closest-diff))\
    \ (partition numbers 2 1))))\n", "  (let ([closest-pair (list (first numbers)\
    \ (second numbers))])\n    (for ([i (in-range (add1 (length numbers)))]\n    \
    \      [j (in-range (add1 (length numbers)))]\n          #:when (and (not (equal?\
    \ i j))\n                      (not (equal? closest-pair (list (list-ref numbers\
    \ i) (list-ref numbers j))))\n                      (or (equal? (abs (- (list-ref\
    \ numbers i) (list-ref numbers j)))\n                                  (abs (-\
    \ (list-ref closest-pair 0) (list-ref closest-pair 1))))\n                   \
    \       (< (abs (- (list-ref numbers i) (list-ref numbers j)))\n             \
    \                (abs (- (list-ref closest-pair 0) (list-ref closest-pair 1)))))))\n\
    \      (set! closest-pair (list (list-ref numbers i) (list-ref numbers j))))\n\
    \    closest-pair))\n", "  (let loop ([numbers numbers]\n             [closest-pair\
    \ (list (car numbers) (cadr numbers))])\n    (if (null? (cddr numbers))\n    \
    \    closest-pair\n        (let* ([current-pair (list (car numbers) (cadr numbers))]\n\
    \               [current-diff (abs (- (car current-pair) (cadr current-pair)))])\n\
    \          (if (< current-diff (abs (- (car closest-pair) (cadr closest-pair))))\n\
    \              (loop (cdr numbers) current-pair)\n              (loop (cdr numbers)\
    \ closest-pair))))))\n", "  (let ([min-diff (apply min (map (lambda (x y) (abs\
    \ (- x y))) numbers (rest numbers)))])\n    (let loop ([numbers numbers])\n  \
    \    (if (null? (rest numbers))\n          (error \"No closest elements found\"\
    )\n          (if (= min-diff (abs (- (car numbers) (cadr numbers))))\n       \
    \       (values (car numbers) (cadr numbers))\n              (loop (rest numbers)))))))\n",
  "  (let* ([sorted-numbers (sort numbers <)]\n         [min-diff (apply min (map\
    \ (lambda (x y) (- y x)) sorted-numbers (cdr sorted-numbers)))]\n         [closest-pair\
    \ (filter (lambda (x y) (= (- y x) min-diff)) sorted-numbers (cdr sorted-numbers))])\n\
    \    closest-pair))\n", "  (let ([numbers (sort numbers <)])\n    (let loop ([numbers\
    \ (cdr numbers)]\n               [closest-pair (list (car numbers) (cadr numbers))]\n\
    \               [closest-distance (abs (- (car numbers) (cadr numbers)))])\n \
    \     (if (null? numbers)\n          closest-pair\n          (let ([distance (abs\
    \ (- (car numbers) (cadr numbers)))])\n            (if (< distance closest-distance)\n\
    \                (loop (cdr numbers) (list (car numbers) (cadr numbers)) distance)\n\
    \                (loop (cdr numbers) closest-pair closest-distance)))))))\n",
  "  (let loop ([numbers numbers]\n             [closest-pair (list (car numbers)\
    \ (cadr numbers))])\n    (if (null? (cddr numbers))\n        closest-pair\n  \
    \      (let ([next-pair (list (car numbers) (cadr numbers))])\n          (if (<\
    \ (abs (- (car next-pair) (cadr next-pair)))\n                 (abs (- (car closest-pair)\
    \ (cadr closest-pair))))\n              (loop (cdr numbers) next-pair)\n     \
    \         (loop (cdr numbers) closest-pair))))))\n", "  (define (find_closest_elements-iter\
    \ numbers closest-pair)\n    (cond\n      [(empty? numbers) closest-pair]\n  \
    \    [(empty? (rest numbers)) closest-pair]\n      [else\n       (let ([current-pair\
    \ (list (first numbers) (second numbers))])\n         (if (< (abs (- (first current-pair)\
    \ (second current-pair)))\n                (abs (- (first closest-pair) (second\
    \ closest-pair))))\n             (find_closest_elements-iter (rest numbers) current-pair)\n\
    \             (find_closest_elements-iter (rest numbers) closest-pair)))]))\n\
    \  (find_closest_elements-iter numbers (list (first numbers) (second numbers))))\n",
  "  (define (find_closest_elements-helper numbers closest-pair)\n    (if (null? (cdr\
    \ numbers))\n        closest-pair\n        (let* ([first (car numbers)]\n    \
    \           [second (cadr numbers)]\n               [difference (abs (- first\
    \ second))]\n               [closest-difference (abs (- (car closest-pair) (cadr\
    \ closest-pair)))])\n          (if (< difference closest-difference)\n       \
    \       (find_closest_elements-helper (cdr numbers) (list first second))\n   \
    \           (find_closest_elements-helper (cdr numbers) closest-pair)))))\n  (find_closest_elements-helper\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (let ([sorted-numbers (sort\
    \ numbers <)])\n    (let loop ([numbers sorted-numbers] [closest-pair (list (car\
    \ numbers) (cadr numbers))])\n      (if (null? (cddr numbers))\n          closest-pair\n\
    \          (let ([next-pair (list (cadr numbers) (caddr numbers))])\n        \
    \    (if (< (abs (- (car next-pair) (cadr next-pair)))\n                   (abs\
    \ (- (car closest-pair) (cadr closest-pair))))\n                (loop (cdr numbers)\
    \ next-pair)\n                (loop (cdr numbers) closest-pair)))))))\n", "  (let\
    \ ([closest-pair (list (first numbers) (second numbers))])\n    (for ([i (in-range\
    \ (length numbers))])\n      (let ([j (add1 i)])\n        (for ([j (in-range j\
    \ (length numbers))])\n          (let ([diff (abs (- (list-ref numbers i) (list-ref\
    \ numbers j)))])\n            (if (< diff (abs (- (first closest-pair) (second\
    \ closest-pair))))\n                (set! closest-pair (list (list-ref numbers\
    \ i) (list-ref numbers j))))))))\n    closest-pair))\n", "  (define (find_closest_elements-iter\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let ([new-pair (find-closest-pair (car numbers) (cadr numbers))])\n\
    \          (if (closer-pair? new-pair closest-pair)\n              (find_closest_elements-iter\
    \ (cdr numbers) new-pair)\n              (find_closest_elements-iter (cdr numbers)\
    \ closest-pair)))))\n  (find_closest_elements-iter numbers (find-closest-pair\
    \ (car numbers) (cadr numbers))))\n", "  (let loop ([numbers numbers]\n      \
    \       [closest-pair (list (car numbers) (cadr numbers))])\n    (if (null? (cddr\
    \ numbers))\n        closest-pair\n        (let ([new-pair (list (car numbers)\
    \ (cadr numbers))])\n          (if (< (abs (- (car new-pair) (cadr new-pair)))\n\
    \                 (abs (- (car closest-pair) (cadr closest-pair))))\n        \
    \      (loop (cdr numbers) new-pair)\n              (loop (cdr numbers) closest-pair))))))\n",
  "  (let* ([sorted-numbers (sort numbers <)]\n         [min-diff (apply min (map\
    \ (lambda (x y) (abs (- x y))) (rest sorted-numbers) sorted-numbers))]\n     \
    \    [closest-numbers (filter (lambda (x y) (= (abs (- x y)) min-diff)) (rest\
    \ sorted-numbers) sorted-numbers)])\n    (if (= (length closest-numbers) 2)\n\
    \        closest-numbers\n        (list (car closest-numbers) (car closest-numbers)))))\n",
  "  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])\n\
    \    (let loop ([numbers numbers])\n      (if (null? (cdr numbers))\n        \
    \  (error \"No two numbers are close to each other\")\n          (if (= min-diff\
    \ (abs (- (car numbers) (cadr numbers))))\n              (values (car numbers)\
    \ (cadr numbers))\n              (loop (cdr numbers)))))))\n", "  (let ([closest-difference\
    \ (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])\n   \
    \ (for/first ([x numbers]\n                [y (cdr numbers)]\n               \
    \ #:when (= (abs (- x y)) closest-difference))\n      (values x y))))\n", "  (letrec\
    \ ([closest-pair (lambda (numbers)\n                           (if (null? (cdr\
    \ numbers))\n                               (values (car numbers) (car numbers))\n\
    \                               (let ([closest-pair (closest-pair (cdr numbers))])\n\
    \                                 (let ([closest-pair-diff (abs (- (car closest-pair)\
    \ (cadr closest-pair)))])\n                                   (let ([current-pair-diff\
    \ (abs (- (car numbers) (cadr numbers)))])\n                                 \
    \    (if (< current-pair-diff closest-pair-diff)\n                           \
    \              (values (car numbers) (cadr numbers))\n                       \
    \                  closest-pair))))))])\n    (closest-pair numbers)))\n", "  (define\
    \ (find_closest_elements_helper numbers min-diff min-pair)\n    (if (null? (cdr\
    \ numbers))\n        min-pair\n        (let* ([next-pair (list (car numbers) (cadr\
    \ numbers))]\n               [next-diff (abs (- (car next-pair) (cadr next-pair)))]\n\
    \               [next-min-pair (if (< next-diff min-diff) next-pair min-pair)]\n\
    \               [next-min-diff (if (< next-diff min-diff) next-diff min-diff)])\n\
    \          (find_closest_elements_helper (cdr numbers) next-min-diff next-min-pair))))\n\
    \  (find_closest_elements_helper numbers (abs (- (car numbers) (cadr numbers)))\
    \ (list (car numbers) (cadr numbers))))\n", "  (let ([min-diff (apply min (map\
    \ (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n    (list (apply min\
    \ (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff)) numbers))\n\
    \          (apply max (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff))\
    \ numbers)))))\n", "  (define (find_closest_elements-helper numbers closest-pair)\n\
    \    (cond\n      [(empty? numbers) closest-pair]\n      [(empty? (rest numbers))\
    \ closest-pair]\n      [else\n       (define current-pair (list (first numbers)\
    \ (second numbers)))\n       (define current-distance (abs (- (first current-pair)\
    \ (second current-pair))))\n       (define closest-distance (abs (- (first closest-pair)\
    \ (second closest-pair))))\n       (if (< current-distance closest-distance)\n\
    \           (find_closest_elements-helper (rest numbers) current-pair)\n     \
    \      (find_closest_elements-helper (rest numbers) closest-pair))]))\n  (find_closest_elements-helper\
    \ numbers (list (first numbers) (second numbers))))\n", "  (let ([min-diff (apply\
    \ min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n    (let loop\
    \ ([numbers numbers])\n      (if (null? (rest numbers))\n          (error \"no\
    \ closest elements found\")\n          (if (= min-diff (abs (- (car numbers) (cadr\
    \ numbers))))\n              (list (car numbers) (cadr numbers))\n           \
    \   (loop (rest numbers)))))))\n", "  (let loop ([numbers numbers]\n         \
    \    [closest-elements (list (car numbers) (cadr numbers))])\n    (if (null? (cddr\
    \ numbers))\n        closest-elements\n        (let* ([current-element (car numbers)]\n\
    \               [next-element (cadr numbers)]\n               [current-diff (abs\
    \ (- current-element next-element))]\n               [closest-diff (abs (- (car\
    \ closest-elements) (cadr closest-elements)))])\n          (if (< current-diff\
    \ closest-diff)\n              (loop (cdr numbers) (list current-element next-element))\n\
    \              (loop (cdr numbers) closest-elements))))))\n", "  (let ([min-diff\
    \ (apply min (map (lambda (x y) (abs (- x y))) numbers (rest numbers)))])\n  \
    \  (let ([closest-pair (filter (lambda (x y) (= (abs (- x y)) min-diff)) numbers\
    \ (rest numbers))])\n      (if (= (length closest-pair) 2)\n          closest-pair\n\
    \          (list (car closest-pair) (car closest-pair))))))\n", "  (let ([min-diff\
    \ (apply min (map (lambda (x) (apply min (map (lambda (y) (abs (- x y))) numbers)))\
    \ numbers))])\n    (list (apply min (filter (lambda (x) (= (abs (- x (apply min\
    \ numbers))) min-diff)) numbers))\n          (apply min (filter (lambda (x) (=\
    \ (abs (- x (apply max numbers))) min-diff)) numbers)))))\n", "  (let ([min-diff\
    \ (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])\n   \
    \ (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff))\
    \ numbers))\n          (apply max (filter (lambda (x) (= (abs (- x (apply min\
    \ numbers))) min-diff)) numbers)))))\n", "  (let ([min-diff (apply min (map (lambda\
    \ (x y) (abs (- x y))) numbers (rest numbers)))])\n    (let loop ([numbers numbers])\n\
    \      (if (null? (rest numbers))\n          (error \"No two numbers are close\
    \ to each other\")\n          (if (= min-diff (abs (- (car numbers) (cadr numbers))))\n\
    \              (values (car numbers) (cadr numbers))\n              (loop (rest\
    \ numbers)))))))\n", "  (define (find_closest_elements-helper numbers closest-pair)\n\
    \    (if (null? (cdr numbers))\n        closest-pair\n        (let* ([current-pair\
    \ (list (car numbers) (cadr numbers))]\n               [current-diff (abs (- (car\
    \ current-pair) (cadr current-pair)))]\n               [closest-diff (abs (- (car\
    \ closest-pair) (cadr closest-pair)))])\n          (if (< current-diff closest-diff)\n\
    \              (find_closest_elements-helper (cdr numbers) current-pair)\n   \
    \           (find_closest_elements-helper (cdr numbers) closest-pair)))))\n  (find_closest_elements-helper\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (let loop ([numbers numbers]\n\
    \             [closest-pair (list (car numbers) (cadr numbers))])\n    (if (null?\
    \ (cddr numbers))\n        closest-pair\n        (let* ([current-pair (list (car\
    \ numbers) (cadr numbers))]\n               [current-diff (abs (- (car current-pair)\
    \ (cadr current-pair)))])\n          (if (< current-diff (abs (- (car closest-pair)\
    \ (cadr closest-pair))))\n              (loop (cdr numbers) current-pair)\n  \
    \            (loop (cdr numbers) closest-pair))))))\n", "  (let loop ([numbers\
    \ numbers]\n             [closest-pair (list (car numbers) (cadr numbers))])\n\
    \    (if (null? (cddr numbers))\n        closest-pair\n        (let ([next-pair\
    \ (list (car numbers) (cadr numbers))])\n          (if (< (abs (- (car next-pair)\
    \ (cadr next-pair)))\n                 (abs (- (car closest-pair) (cadr closest-pair))))\n\
    \              (loop (cdr numbers) next-pair)\n              (loop (cdr numbers)\
    \ closest-pair))))))\n", "  (let ([numbers (sort numbers <)])\n    (let loop ([numbers\
    \ (rest numbers)] [min-diff (abs (- (first numbers) (second numbers)))] [min-pair\
    \ (list (first numbers) (second numbers))])\n      (if (null? numbers)\n     \
    \     min-pair\n          (let ([diff (abs (- (first numbers) (second numbers)))])\n\
    \            (if (< diff min-diff)\n                (loop (rest numbers) diff\
    \ (list (first numbers) (second numbers)))\n                (loop (rest numbers)\
    \ min-diff min-pair)))))))\n", "  (define (find_closest_elements-helper numbers\
    \ closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n       \
    \ (let* ([first (car numbers)]\n               [second (cadr numbers)]\n     \
    \          [diff (abs (- first second))]\n               [closest-diff (abs (-\
    \ (car closest-pair) (cadr closest-pair)))])\n          (if (< diff closest-diff)\n\
    \              (find_closest_elements-helper (cdr numbers) (list first second))\n\
    \              (find_closest_elements-helper (cdr numbers) closest-pair)))))\n\
    \  (find_closest_elements-helper numbers (list (car numbers) (cadr numbers))))\n",
  "  (let* ([sorted-numbers (sort numbers <)]\n         [min-diff (apply min (map\
    \ (lambda (x y) (- y x)) sorted-numbers (rest sorted-numbers)))]\n         [closest-pair\
    \ (filter (lambda (x y) (= (- y x) min-diff)) sorted-numbers (rest sorted-numbers))])\n\
    \    closest-pair))\n", "  (let ([numbers (sort numbers <)])\n    (let loop ([numbers\
    \ (cdr numbers)]\n               [min-diff (abs (- (car numbers) (cadr numbers)))]\n\
    \               [min-pair (list (car numbers) (cadr numbers))])\n      (if (null?\
    \ numbers)\n          min-pair\n          (let ([diff (abs (- (car numbers) (cadr\
    \ numbers)))])\n            (if (< diff min-diff)\n                (loop (cdr\
    \ numbers) diff (list (car numbers) (cadr numbers)))\n                (loop (cdr\
    \ numbers) min-diff min-pair)))))))\n", "  (let ([closest-pair (list (car numbers)\
    \ (cadr numbers))]\n        [closest-distance (abs (- (car numbers) (cadr numbers)))])\n\
    \    (for ([i (in-range (add1 (length numbers))))\n          [j (in-range (add1\
    \ i))])\n      (let ([distance (abs (- (list-ref numbers i) (list-ref numbers\
    \ j)))])\n        (when (< distance closest-distance)\n          (set! closest-pair\
    \ (list (list-ref numbers i) (list-ref numbers j)))\n          (set! closest-distance\
    \ distance))))\n    closest-pair))\n", "  (let ([min-diff (apply min (map (lambda\
    \ (x) (apply min (map (lambda (y) (abs (- x y))) numbers))) numbers))])\n    (list\
    \ (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff))\
    \ numbers))\n          (apply min (filter (lambda (x) (= (abs (- x (apply max\
    \ numbers))) min-diff)) numbers)))))\n", "  (let* ([sorted (sort numbers <)]\n\
    \         [differences (map (lambda (x y) (abs (- x y))) sorted (rest sorted))]\n\
    \         [min-diff (apply min differences)])\n    (list (list-ref sorted (list-index\
    \ min-diff differences))\n          (list-ref sorted (+ 1 (list-index min-diff\
    \ differences))))))\n", "  (define (find_closest_elements_helper numbers closest-so-far)\n\
    \    (if (null? (cdr numbers))\n        closest-so-far\n        (let* ([current-pair\
    \ (list (car numbers) (cadr numbers))]\n               [current-diff (abs (- (car\
    \ current-pair) (cadr current-pair)))]\n               [closest-diff (abs (- (car\
    \ closest-so-far) (cadr closest-so-far)))])\n          (if (< current-diff closest-diff)\n\
    \              (find_closest_elements_helper (cdr numbers) current-pair)\n   \
    \           (find_closest_elements_helper (cdr numbers) closest-so-far)))))\n\
    \  (find_closest_elements_helper numbers (list (car numbers) (cadr numbers))))\n",
  "  (let ([min-diff (apply min (map (lambda (x y) (abs (- x y))) numbers (cdr numbers)))])\n\
    \    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff))\
    \ numbers))\n          (apply max (filter (lambda (x) (= (abs (- x (apply min\
    \ numbers))) min-diff)) numbers)))))\n", "  (let ([min-diff (apply min (map (lambda\
    \ (x) (apply min (map (lambda (y) (abs (- x y))) (cdr numbers)))) numbers))])\n\
    \    (list (apply min (filter (lambda (x) (= (abs (- x (apply min numbers))) min-diff))\
    \ numbers))\n          (apply min (filter (lambda (x) (= (abs (- x (apply max\
    \ numbers))) min-diff)) numbers)))))\n", "  (let loop ((numbers numbers)\n   \
    \          (closest-elements (list (car numbers) (cadr numbers)))\n          \
    \   (closest-distance (abs (- (car numbers) (cadr numbers)))))\n    (if (null?\
    \ (cddr numbers))\n        closest-elements\n        (let ((distance (abs (- (cadr\
    \ numbers) (caddr numbers)))))\n          (if (< distance closest-distance)\n\
    \              (loop (cdr numbers)\n                    (list (cadr numbers) (caddr\
    \ numbers))\n                    distance)\n              (loop (cdr numbers)\n\
    \                    closest-elements\n                    closest-distance))))))\n",
  "  (define (find_closest_elements_helper numbers closest-pair)\n    (if (null? (cdr\
    \ numbers))\n        closest-pair\n        (let* ([first (car numbers)]\n    \
    \           [second (cadr numbers)]\n               [diff (abs (- first second))]\n\
    \               [closest-diff (abs (- (car closest-pair) (cadr closest-pair)))])\n\
    \          (if (< diff closest-diff)\n              (find_closest_elements_helper\
    \ (cdr numbers) (list first second))\n              (find_closest_elements_helper\
    \ (cdr numbers) closest-pair)))))\n  (find_closest_elements_helper numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (define (find_closest_elements-helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [diff (abs (- first second))]\n               [closest-diff (abs\
    \ (- (car closest-pair) (cadr closest-pair)))])\n          (if (< diff closest-diff)\n\
    \              (find_closest_elements-helper (cdr numbers) (list first second))\n\
    \              (find_closest_elements-helper (cdr numbers) closest-pair)))))\n\
    \  (find_closest_elements-helper numbers (list (car numbers) (cadr numbers))))\n",
  "  (let ([closest-diff (apply min (map (lambda (x) (apply min (map (lambda (y) (abs\
    \ (- x y))) numbers))) numbers))])\n    (let ([closest-pair (filter (lambda (x)\
    \ (= (abs (- (car x) (cadr x))) closest-diff)) (map (lambda (x) (list (car x)\
    \ (cadr x))) (partition 2 1 numbers)))])\n      (if (= (length closest-pair) 1)\n\
    \          (car closest-pair)\n          (list (apply min (map car closest-pair))\
    \ (apply max (map cadr closest-pair)))))))\n", "  (define (find_closest_elements-helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [difference (abs (- first second))]\n               [closest-difference\
    \ (abs (- (car closest-pair) (cadr closest-pair)))])\n          (if (< difference\
    \ closest-difference)\n              (find_closest_elements-helper (cdr numbers)\
    \ (list first second))\n              (find_closest_elements-helper (cdr numbers)\
    \ closest-pair)))))\n  (find_closest_elements-helper numbers (list (car numbers)\
    \ (cadr numbers))))\n", "  (let ([first (first numbers)]\n        [second (second\
    \ numbers)])\n    (for ([n (in-list (rest (rest numbers)))]\n          #:when\
    \ (< (abs (- n first)) (abs (- n second))))\n      (set! first n)\n      (set!\
    \ second (if (< (abs (- n first)) (abs (- n second)))\n                      \
    \ first\n                       second)))\n    (list first second)))\n", "  (let\
    \ ([closest-pair (list (car numbers) (cadr numbers))]\n        [closest-distance\
    \ (abs (- (car numbers) (cadr numbers)))])\n    (for ([i (in-range (add1 (length\
    \ numbers))))\n          [j (in-range (add1 i))])\n      (let ([distance (abs\
    \ (- (list-ref numbers i) (list-ref numbers j)))])\n        (when (< distance\
    \ closest-distance)\n          (set! closest-pair (list (list-ref numbers i) (list-ref\
    \ numbers j)))\n          (set! closest-distance distance))))\n    closest-pair))\n",
  "  (define (find_closest_elements_helper numbers closest-pair)\n    (if (null? (cdr\
    \ numbers))\n        closest-pair\n        (let* ([first (car numbers)]\n    \
    \           [second (cadr numbers)]\n               [diff (abs (- first second))]\n\
    \               [closest-diff (abs (- (car closest-pair) (cadr closest-pair)))])\n\
    \          (if (< diff closest-diff)\n              (find_closest_elements_helper\
    \ (cdr numbers) (list first second))\n              (find_closest_elements_helper\
    \ (cdr numbers) closest-pair)))))\n  (find_closest_elements_helper numbers (list\
    \ (car numbers) (cadr numbers))))\n", "  (define (find_closest_elements-iter numbers\
    \ closest-pair)\n    (cond\n      [(empty? numbers) closest-pair]\n      [(empty?\
    \ (rest numbers)) closest-pair]\n      [else\n       (define current-pair (list\
    \ (first numbers) (second numbers)))\n       (define next-pair (list (second numbers)\
    \ (third numbers)))\n       (define new-closest-pair (if (< (abs (- (first current-pair)\
    \ (second current-pair)))\n                                      (abs (- (first\
    \ next-pair) (second next-pair))))\n                                   current-pair\n\
    \                                   next-pair))\n       (find_closest_elements-iter\
    \ (rest (rest numbers)) new-closest-pair)]))\n  (find_closest_elements-iter numbers\
    \ (list (first numbers) (second numbers))))\n", "  (let ([closest-pair (list (first\
    \ numbers) (second numbers))])\n    (for ([i (in-range (add1 (length numbers)))]\n\
    \          [j (in-range i)])\n      (let ([diff (abs (- (list-ref numbers i) (list-ref\
    \ numbers j)))])\n        (when (< diff (abs (- (first closest-pair) (second closest-pair))))\n\
    \          (set! closest-pair (list (list-ref numbers j) (list-ref numbers i))))))\n\
    \    closest-pair))\n", "  (define (find_closest_elements-helper numbers closest-pair)\n\
    \    (if (null? (cdr numbers))\n        closest-pair\n        (let* ([first (car\
    \ numbers)]\n               [second (cadr numbers)]\n               [diff (abs\
    \ (- first second))]\n               [closest-diff (abs (- (car closest-pair)\
    \ (cadr closest-pair)))])\n          (if (< diff closest-diff)\n             \
    \ (find_closest_elements-helper (cdr numbers) (list first second))\n         \
    \     (find_closest_elements-helper (cdr numbers) closest-pair)))))\n  (find_closest_elements-helper\
    \ numbers (list (car numbers) (cadr numbers))))\n", "  (define (find-closest-elements-helper\
    \ numbers closest-pair)\n    (if (null? (cdr numbers))\n        closest-pair\n\
    \        (let* ([first (car numbers)]\n               [second (cadr numbers)]\n\
    \               [distance (abs (- first second))]\n               [closest-distance\
    \ (abs (- (car closest-pair) (cadr closest-pair)))])\n          (if (< distance\
    \ closest-distance)\n              (find-closest-elements-helper (cdr numbers)\
    \ (list first second))\n              (find-closest-elements-helper (cdr numbers)\
    \ closest-pair)))))\n  (find-closest-elements-helper numbers (list (car numbers)\
    \ (cadr numbers))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
