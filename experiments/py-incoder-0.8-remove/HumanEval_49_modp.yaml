name: HumanEval_49_modp
language: py
prompt: "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware\
  \ of numerics).\n                        \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101,\
  \ 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n\
  \    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert\
  \ candidate(31, 5) == 3\n\ndef test_check():\n    check(modp)\n\ntest_check()\n"
completions: ["    return ((n - 1) * (n + 1)) // p % p\n\n", "    if n == 0:\n   \
    \     return 0\n    if n == 1:\n        return p\n    if p == 2:\n        return\
    \ n\n\n    bit = 1\n    while bit < n:\n        if p & bit == 0:\n           \
    \ return 0\n        bit <<= 1\n    return bit\n", "    return ((n % p) + p) %\
    \ p\n\n", "    return pow(2, n, p)\n", "    if n >= p:\n        return n\n   \
    \ return n - pow(2, n) + p\n", "    if p == 0: return 0\n    if n & 1:\n     \
    \   return p\n    return p + (n >> 1) * (p >> 1)\n\n", "    return n & (-p) -\
    \ p\n\n", "    if p == 2:\n        if n == 0:\n            return 0\n        if\
    \ n == 1:\n            return 1\n    if n < 0:\n        n = -p\n        if n ==\
    \ 0:\n            return 0\n    if n == 0:\n        return 0\n    if (p & 1):\n\
    \        return p\n    if n & 1:\n        return n\n    if n % p == 0:\n     \
    \   return p - (n % p)\n    m = n // p\n    if m % 2 == 0:\n        return m\n\
    \    if m % 3 == 0:\n        return 2 * m\n    return 3 * m\n\n", "    if n ==\
    \ 0:\n        return 0\n    q = n // p\n    r = n % p\n    return q * p + r\n\n",
  "    if p == 2:\n        return n\n    elif p == 3:\n        if n % 3 == 0:\n  \
    \          return n\n        return n - 3\n    elif p % 5 == 3:\n        if n\
    \ % 3 == 0 and n % 5 == 0:\n            return n\n        return n - 5\n    else:\n\
    \        if n % 3 == 0:\n            return p\n        return p - 3\n\n", "  \
    \  if n == 0:\n        return 0\n    t = int(n)\n    if t >= p:\n        return\
    \ p\n    while t % p == 0:\n        t /= p\n    return t\n\n", "    return n &\
    \ (-p + 1)\n", "    if n == 0:\n        return 0\n    if p == 2:\n        return\
    \ n\n    if p % 4 == 0:\n        if n % 2 == 0:\n            return (n // 2) *\
    \ 2 + 1\n        return ((n // 2) - 1) * 3 + 1\n    if p % 2 == 0:\n        return\
    \ ((n // 2) * 2 + 1) * (p // 4)\n    return ((n // 2) - 1) * ((p // 4) + (p %\
    \ 4))\n\n", "    return ((n-1) % (p+1)) if (n < p) else ((n-1) // p)\n\n", " \
    \   res = 1\n    for i in range(p):\n        res *= 2\n        if n > 0 and res\
    \ % 2 == 0:\n            res -= 1\n        n -= 1\n    return res\n", "    if\
    \ n == 0:\n        return p\n    result = 1\n    while n:\n        if n & 1:\n\
    \            result = (result * p) % p\n        n >>= 1\n    return result \n\n",
  "    n &= -p\n    ans = 1\n    while n != 0:\n        if n & 1:\n            ans\
    \ *= p\n        n >>= 1\n        p &= -p\n    return ans\n\n", "    if n == 1:\n\
    \        return 0\n    t = n & -p\n    return t + ((t & -n | ~t & -p) << 1) ^\
    \ (n & p | ~n & -p)\n\n", "    while n < 0:\n        n += p\n    if n == 0:\n\
    \        return p\n    while n % p == 0:\n        n //= p\n    return n\n", " \
    \   if n < 0:\n        raise ValueError(\"Modulus can't be negative\")\n    elif\
    \ n == 1:\n        return p\n    elif p == 2:\n        return n\n    elif p %\
    \ 4 == 0:\n        return n % p\n    elif p % 2 == 0:\n        return p + (p -\
    \ 1) // 2\n    elif p % 3 == 0:\n        return p + (p - 1) // 3\n    else:\n\
    \        raise RuntimeError(\"Modulus is not prime\")\n\n", "    return 2 ^ (n\
    \ & p) - 1\n", "    return ((n+p-1)//p)*p\n\n", "    if n == 0:\n        return\
    \ 0\n    if n < 0:\n        raise ValueError(\"Modulus can't be negative.\")\n\
    \    if p < 0:\n        raise ValueError(\"Modulus must be positive.\")\n    if\
    \ p == 1 or p == 2:\n        return p\n\n    # p must be an odd prime > 3\n  \
    \  if p > 3:\n        raise ValueError(\"Modulus must be odd and prime.\")\n \
    \   if n <= 0 or (n % 2) == 0:\n        raise ValueError(\"Modulus is composite.\"\
    )\n\n    k = pow(p, 2, n)\n    a = n // k\n    r = n - (k * a)\n    return r\n\
    \n", "    if n == 0:\n        return 0\n    elif n == 1:\n        return p\n \
    \   else:\n        return modp(n - 1, p) * (2 ** (n - 1)) + p\n\n", "    return\
    \ pow(2, n, p)\n\n", "    return (p * (p - 1) % n) % (n)\n\n", "    if p == 2:\n\
    \        return n\n    return ((n - 1) if (n & 1) else (n - 2)) % p\n", "    return\
    \ ((n << p) + 1) & ((1 << p) - 1)\n\n", "    if n == 0:\n        return 0\n  \
    \  if p == 2:\n        return n\n    if p % 2 == 0:\n        return p - 1\n  \
    \  if n % p == 0:\n        return p\n    if p % n == 0:\n        return n // p\
    \ + 1\n    return n % p\n\n", "    return pow(2, n, p)\n\n", "    count = 0\n\
    \    while n != 0:\n        count += 1\n        n //= p\n    \n    if count ==\
    \ 0:\n        return 0\n    else:\n        return n\n\n", "    return pow(2, n,\
    \ p)\n\n", "    return pow(n, p)\n\n", "    if n == 0:\n        return 0\n   \
    \ while n % p == 0:\n        n //= p\n    return n\n\n", "    if n < 0 or p <\
    \ 1:\n        raise ValueError(f\"Modulus must be non-negative and positive: {n},\
    \ {p}\")\n    if n == 0:\n        return 0\n    if p == 1 or p == 2:\n       \
    \ return 1\n    return n * modp(n // p, p)\n\n", "    # https://en.wikipedia.org/wiki/Modulo_operation\n\
    \    if p == 2:\n        return n\n    if p == n:\n        return 0\n    nP1 =\
    \ 3\n    nP2 = 5\n    nP3 = 8\n    nP4 = 10\n    nP5 = 12\n    nP6 = 16\n    nP7\
    \ = 20\n    nP8 = 32\n    nP9 = 64\n    nP10 = 128\n    factors = [nP1, nP2, nP3,\
    \ nP4, nP5, nP6, nP7, nP8, nP9, nP10]\n    return n % p * factors[n % p]\n\n",
  "    from math import gcd\n    return -(-n // p) * p\n\n", "    return (p - 1) if\
    \ n else 0 # n%p == 0\n    ", "    n %= p\n    if n == 0:\n        return p\n\
    \    return p ^ n\n", "    return ((p-1)//n) * n\n", "    # MATH: mod((n+3)/2,\
    \ p)\n    if n < p:\n        return n - p + 2\n    if p < 0:\n        return n\
    \ - p + p\n    n %= p\n    return p * p + n", "    if n == 0:\n        return\
    \ 0\n    n %= p\n    if n == 0 and p > 0:\n        return pow(p, 1.0 / n)\n  \
    \  if n < 0:\n        n = -p\n        q = pow(p, -n)\n        return pow(p, q)\
    \ * q\n    return pow(p, n)\n\n", "    return pow(2, n, p)\n\n", "    if n < 0\
    \ or p == 0:\n        raise ValueError(\"p (%r) and n (%r) cannot be zero\" %\
    \ (p, n))\n    if p == 1 or p == 2:\n        return n\n\n    if p % 4 == 3:\n\
    \        shift = p\n    else:\n        shift = p - 4 - (p % 4)\n\n    mask = 0x3\n\
    \    while mask < n:\n        mask <<= 1\n    return n >> shift & mask\n\n", " \
    \   assert isinstance(n, int) and isinstance(p, int), 'parameters must be of type\
    \ int'\n    if n == 0:\n        return 0\n    if p == 0:\n        return 1\n \
    \   result = 1\n    base = pow(2, n)\n    while base % p != 0:\n        result\
    \ *= base\n        base %= p\n    return result\n", "    return ((n-1) % (p +\
    \ 1))\n", "    bits = n.bit_length()\n    digits = p // bits\n    mask = (1 <<\
    \ digits) - 1;\n    if n & mask == mask:\n        return p\n    result = 1\n \
    \   while result < p:\n        if bits & 1:\n            result *= 2\n       \
    \     if result > p:\n                result %= p\n        else:\n           \
    \ result /= 2\n            if result > p:\n                result %= p\n     \
    \   bits >>= 1\n    return result\n\n@cached_class", "    return ((n//p)*p)\n\n",
  "    res = 1\n    while n > 0:\n        if n&1:\n            res = (res*p)&MASK_32\n\
    \        n = n >> 1\n    return res\n        ", "    return ((n >> p) + n & -p)\
    \ * p\n\n", "    return n & (-p-1)\n\n", "    if n < 0:\n        n += p\n    res\
    \ = 0\n    while n > 0:\n        res = (res << 1) + n % p\n        n //= p\n \
    \   return res\n\n", "    if n == 0:\n        return 0\n    if p == 2:\n     \
    \   return n\n    if p % 4 == 1 and p % 100 != 11:\n        return n\n    if p\
    \ % 10 == 2 and p % 100 != 12:\n        return n\n    if n % p == 0:\n       \
    \ return n\n    if p % 5 == 1 and p % 100 != 11:\n        return n\n    if p %\
    \ 10 == 2 and p % 100 != 12:\n        return n\n    if p % 7 == 3:\n        return\
    \ n\n    return n - (n % p)\n", "    if not n:\n        return 0 if n == 0 else\
    \ 1\n    if (n & 1) == 0:\n        return n\n    if (n & 1) == -1:\n        return\
    \ (n + 1) // p\n    if (n & 1) == 1:\n        return p + n // p\n\n", "    if\
    \ p == 2:\n        return n\n    if p % 4 == 0:\n        return n - (n % p)\n\
    \    if p % 5 == 0:\n        return n - (n % p) + 5\n    if p % 6 == 0:\n    \
    \    return n - (n % p) + 6\n    return n - (n % p) + 6\n", "    if p == 2:\n\
    \        return n\n    if n == 0 and p == 1:\n        return 0\n    if n % p ==\
    \ 0:\n        return n\n    if p == 2:\n        return n // p\n    if p == 3:\n\
    \        return ((n - 1) % p + 1) * (n // p)\n    if n == p - 1:\n        return\
    \ n\n    return ((n - 1) % p + 1) * (n // p)\n\n", "    if n == 0:\n        return\
    \ 0\n    if n < 0:\n        if p < 0:\n            return -p\n        return p\n\
    \    if p < 0:\n        return -p\n    if p > n:\n        return -p\n    if n\
    \ == 1 or p == 1:\n        return 1\n    if n == 2:\n        return 2\n    if\
    \ n & 1:\n        return p\n    r = int(n)\n    if r == p:\n        return r\n\
    \    r, r = n % p, p\n    return r\n\n", "    if p == 2:\n        return n\n \
    \   if p == 3:\n        return n >> 1\n    if p % 4 == 0:\n        n -= n & 3\n\
    \        return n * 9 + n\n    i = 0\n    while True:\n        if (n & 1) == 0\
    \ or n % p == 0:\n            return i\n        i += 1\n        n >>= 1\n    \
    \    p -= 1\n\n", "    low = 0\n    high = p\n    while low < high:\n        mid\
    \ = (low + high) // 2\n        if mid * mid + mid * mid < n:\n            low\
    \ = mid + 1\n        else:\n            high = mid\n    return low\n\n", "   \
    \ return ((1 << n) - 1) ^ p\n\n", "    n = _normalize(n)\n    p = _normalize(p)\n\
    \    if p == 2:\n        return n\n    if n == 0:\n        return 0\n    if p\
    \ == 2:\n        return n\n    if n == p - 1:\n        return p - 1\n    mid =\
    \ (n + p // 2) // p\n    left = modp(mid, p)\n    right = modp(n - mid, p)\n \
    \   return left + right\n\n", "    return pow(2, n, p)\n\n", "    factor = 2\n\
    \    while n > 0:\n        if n % p == 0:\n            factor += 1\n        n\
    \ //= p\n    return factor\n\n", "    if n < 0:\n        return p - modp(abs(n),\
    \ p)\n    if n == 0:\n        return 0\n    low, high = p >> 1, p & 1\n    while\
    \ n != 0:\n        if n & 1:\n            low = high\n        else:\n        \
    \    high = low\n        n >>= 1\n        if high == p - 1:\n            high\
    \ = 1\n    return low\n", "    assert n > 0\n    assert p == 0  # we do not work\
    \ with odd numbers\n    assert p % 2 == 0\n    assert n >= 1\n    if n == 1:\n\
    \        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return\
    \ 3\n    if n == 4:\n        return 4\n    if n == 5:\n        return 5\n    if\
    \ n == 6:\n        return 6\n    if n == 7:\n        return 7\n    if n == 8:\n\
    \        return 8\n    if n == 9:\n        return 9\n    if n == 10:\n       \
    \ return 10\n    if n == 11:\n        return 11\n    if n == 12 or n == 655:\n\
    \        return 12\n    if n == 13:\n        return 13\n    if n == 14:\n    \
    \    return 14\n    if n == 15:\n        return 15\n    if n == 32768:\n     \
    \   return 32768\n    if n == 64031:\n        return 6403\n    if n == 4097:\n\
    \        return 4097\n    if n == n == 2787:\n        return 2787\n    if n ==\
    \ 64797:\n        return 6479\n    if n == 70197:\n        return 7019\n    if\
    \ n == 70283:\n        return 7028\n    if n == 64805:\n        return 6480\n\
    \    if n == 79103:\n        return 7910\n    if n == 79571:\n        return 7957\n\
    \    if n == 40961:\n        return 4097\n    if n == 4096:\n        return 4096\n\
    \    if n == 40960:\n        return 4096\n    if n == 1024:\n        return 1024\n\
    \    if n == 256:\n        return 256\n    if n == 512:\n        return 512\n\
    \    if n == 524:\n        return 524\n    if n == 1024:\n        return 1024\n\
    \    if n == 2048:\n        return 2048\n    if n == 4096:\n        return 4096\n\
    \    if n == 8192:\n        return 8192\n    if n == 16384:\n        return 16384\n\
    \    if n == 32768:\n        return 32768\n    if n == 65536:\n        return\
    \ 65536\n    if n == 131072:\n        return 131072\n    if n == 262144:\n   \
    \     return 262144\n    if n == 524288:\n        return 524288\n    if n == 1048576:\n\
    \        return 1048576\n    if n == 2097152:\n        return 2097152\n    if\
    \ n == 4194304:\n        return 4194304\n    if n == 8388608:\n        return\
    \ 8388608\n    if n == 16777216:\n        return 16777216\n    if n == 33554432:\n\
    \        return 33554432\n    if n == 67108864:\n        return 67108864\n   \
    \ if n == 636870912:\n        return 636870912\n    if n == 134217728:\n     \
    \   return 134217728\n    if n == 2684", "    return ((n ** p) % p) if (n != 0\
    \ and p != 0) else 0\n\n", "    # http://bugs.python.org/issue12866\n    return\
    \ n & (p-1) if n & p else n % p\n\n", "    return pow(2, n, p)\n\n", "    return\
    \ ((n << p) + 1) % (1 << p)\n\n", "    return ((n ** p) % p)\n\n", "    if p <\
    \ 0:\n        raise ValueError(f'p must be positive')\n    if p == 0:\n      \
    \  return 0\n    if p == 1:\n        return 1\n    q = p\n    r = 1\n    while\
    \ q != 0:\n        r = r * (q % 2) + 1\n        q //= 2\n    return r\n\n", " \
    \   return ((n % p) + p) % p\n\n", "    d, r = divmod(n, p)\n    return r + d\
    \ * ((~r * p) & -d)\n", "    if p < 0:\n        raise ValueError(\"p < 0\")\n\
    \    ans = n\n    if p == 0:\n        return ans\n    while p:\n        ans *=\
    \ 2\n        p -= 1\n    return ans % p\n", "    exp = n & -p\n    mask =  n ^\
    \ p\n    return ((n ^ n-1)/(p+1))*pow(2, exp) + mask\n", "    if n == 0:\n   \
    \     return 0\n    elif n == 1:\n        return p\n    sqrt_n = int(_sqrt(n))\n\
    \    return _pow(int(p), int(sqrt_n), int(n)).__mod__(p)\n\n", "    # https://en.wikipedia.org/wiki/Modular_exponentiation#Remezna_algorithm\n\
    \    if p == 2:\n        return n\n    if p == 1 or n % p == 0:\n        return\
    \ n\n    result = 1\n    while n % p == 0:\n        result *= p\n        n //=\
    \ p\n    return result\n\n", "    if p == 2:\n        return n\n\n    if n ==\
    \ 0:\n        return 0\n    n -= 1\n\n    low = (1 << p) + 1\n    high = 2\n\n\
    \    while high <= n:\n        mid = low + ((high - low) >> 1)\n        if mid\
    \ * mid < n:\n            high = mid + 1\n        else:\n            low = mid\n\
    \    return low\n\n", "    if n >= 0 and p >= 0 and n and p:\n        result =\
    \ pow(2, n, p)\n        return result if n and result != 0 else 0\n    else:\n\
    \        return 0\n", "    if n == 0:\n        return 0\n    if n == 1:\n    \
    \    return p\n    if n == 2:\n        return p + 1 if p % 2 == 0 else p\n\n \
    \   gcd = _gcd(n, p)\n    if gcd == 1 or gcd == p:\n        return p\n    if gcd\
    \ == n:\n        return p - 1\n    if gcd == p - 1:\n        return p\n    return\
    \ p - 1\n\n", "    return pow(int(2**n), p, p)\n\n", "    if p == 2:\n       \
    \ return n\n    \n    if p == 0:\n        return 0\n    \n    if p < 0:\n    \
    \    return 0\n    \n    if p > n:\n        return 0\n    \n    modp = 1\n   \
    \ \n    while n % p == 0:\n        modp *= p\n        n //= p\n        \n    return\
    \ modp\n\n", "    return n & (-p) ^ p\n\n", "    if p < 0:\n        raise ValueError(\"\
    modp's argument 'p' must not be negative\")\n    if n == 0:\n        return 0\n\
    \    return ((n & -n % p) + n) % p\n\n", "    if p == 2:\n        return n\n\n\
    \    if n % p == 0:\n        return p\n\n    q, r = divmod(n, p)\n    if r:\n\
    \        return q + 1\n    return q\n", "    return n & (-p-1)\n\n", "    return\
    \ n & (-p) - p\n\n", "    return ((n & -n) + ((n % p) << 1)) | n >> (p - ((n &\
    \ -n) & p));\n\n", "    a, b = divmod(p, 2**n)\n    if b == 1 or b == -1: # -1\
    \ or 1 => -1 or 1\n        return a\n    return a + 2**n\n", "    return ((n &\
    \ 1) << p) | ((n >> 1) & 2**(p-1))\n\n", "    return n & (p - 1)\n\n", "    return\
    \ pow(2, n, p)\n", "    return ((n + p) // (p ** 2 + 1)) % p\n\n", "    if p ==\
    \ 0:\n        raise ZeroDivisionError\n    if n < 0:\n        raise ValueError\n\
    \    if n == 0:\n        return p\n    q = p - 1\n    r = 0\n    while n != 0:\n\
    \        if n % 2 == 0:\n            r = r + (n - 1)\n            n = n >> 1\n\
    \        else:\n            n = n >> 1\n            q = q + (n - 1) // p\n   \
    \ return r\n\n", "    assert isinstance(n, int) and isinstance(p, int) and n >=\
    \ 0 and p >= 0\n    if p == 0:\n        return 0\n    if n < 0:\n        return\
    \ p - (p % n)\n    if p < 2:\n        return p\n    i = p\n    while n > 1:\n\
    \        i -= 1\n        p -= 2\n        if p < 0:\n            p = p % n\n  \
    \      n -= 1\n    return i\n\n", "    return ((1 << n) % (p + 1)) \n", "    ret\
    \ = ((n % p) + p) % p\n    if ret < 0: ret = p + ret\n    return ret\n\n", " \
    \   if p == 2:\n        return n\n    n %= p\n    if n == 0:\n        return p\n\
    \    return modp(n - 2, p) + 2\n", "    return ((p + 1) // n) * n\n\n", "    return\
    \ ((n ** p + 1) // p) % (p + 1)\n", "    return ((n & (n-1)) ^ n) % (p * 2)\n",
  "    if p == 0:\n        return 0\n    result = 1\n    while result * p < n:\n \
    \       result *= 2\n        result += 1\n    return result\n\n", "    return\
    \ pow(n, p, p)\n", "    if n == 0:\n        return 0\n    if p == 2:\n       \
    \ return n\n    if p % 4 == 0:\n        return p\n    if p % 6 == 0:\n       \
    \ return (p + 1) // 6\n    if p % 8 == 0:\n        return ((p + 3) // 4) * 8\n\
    \    return p\n\n", "    return pow(2, n, p)\n\n", "    return pow(2, n, p)\n\n",
  "    if p == 2:\n        return n\n    assert n >= 0\n    if n == 0:\n        return\
    \ 0\n    ret = bin(n)[2:].count(\"1\")\n    while p != 0:\n        if p & 1:\n\
    \            ret += 1\n            p >>= 1\n    return ret\n\n", "    if p ==\
    \ 2:\n        return n\n    if p == p:\n        return n - 1\n    if p == 0:\n\
    \        return 0\n    if n < 0:\n        return modp(-n, p)\n    return modp(n,\
    \ p - 1) * (p + 1) // 2\n\n", "    return 1<<(n-1).bit_length()-1\n", "    if\
    \ not p: raise ValueError\n    if n < 0: raise ValueError\n    if n > 0: return\
    \ mod_inverse(p - 1, n) * 2 % p\n    if n == 0: return 0\n    raise ValueError\n",
  "    return ((p + 1) // n) * n\n\n", "    if n == 0:\n        return 0\n    if n\
    \ & 1 == 0:\n        return p\n    low = (n-1)//2\n    high = low + (n-1)//2\n\
    \    res = high*p + p\n    low = low*p + p\n    high = (high*p + p) // 2\n   \
    \ res = res % high\n    if n&1 == 1:\n        res = res*(p+1) + p\n    return\
    \ res\n", "    return ((n-1) * p + 1) // 2\n", "    if n == 0:\n        return\
    \ 0\n    x = 2 ** n\n    xp = p\n    res = 0\n    while n:\n        if n & 1:\n\
    \            x %= xp\n            res += x\n        xp = xp * 2\n        n >>=\
    \ 1\n    if res == 1 and xp != 1:\n        res = 0\n    return res\n\n", "   \
    \ exp = p - 1\n    bits = bin(n)[2:]\n    return 2 ** bits % p\n", "    n |= n\
    \ >> 1\n    n |= n >> 2\n    n |= n >> 4\n    n |= n >> 8\n    n |= n >> 16\n\
    \    return ((n * (n - 1) // 2) & p) ^ p\n", "    return ((n * p + 1) // p)\n",
  "    return pow(2, n, p)\n\n", "    return n - 2**((p - 1).bit_length()) * p\n",
  "    return ((n-1) * (p-1)) % (p*2)\n\n", "    # https://rosettacode.org/wiki/Modular_exponentiation#Python\n\
    \    return pow(2, n, p)\n\n", "    return pow(2, n, p)\n\n", "    return ((n\
    \ + p) // (p + 1))\n\n", "    if n == 0:\n        return 0\n    elif n < 0 or\
    \ p < 0 or p == 2:\n        return 1\n    elif p > 2:\n        p = 2 - p\n   \
    \ return ((n - 1) * (p - 1)) // p\n\n", "    return pow(2, n, p)\n\n", "    bits\
    \ = _int_size(n)\n    res = (n & ((1 << bits) - 1))\n    if p < 2:\n        return\
    \ res % p\n    res = (res * (2 // p)) % p\n    return res\n\n", "    res = 0\n\
    \    for i in range(n, 0, -1):\n        res //= p\n        res += (p & 1)\n  \
    \      p >>= 1\n    return res\n\n", "    return -(-n//p) if n < 0 else n\n\n",
  "    if n == 0:\n        return 0\n    return ((n - 1) * (p + 1)) // math.gcd(n,\
    \ p)\n\n", "    if n == 0:\n        return 0\n    d, r = divmod(n, p)\n    if\
    \ type(d) is int:\n        return d + (p-r)*2**r\n    return d * 2**(r+1) + r\
    \ * p + 2*r + 1\n", "    return n & (p - 1)\n\n", "    return ((n ** p) % p) if\
    \ (p * n > n > 0) else n % p\n", "    exp = n % p\n    if exp > 0:\n        return\
    \ n ^ (p - exp)\n    return n\n\n<|/ file filename=math.py |>\n\"\"\"Mathematical\
    \ operations for prime factorization.\"\"\"\nimport math\n\n", "    return pow(2,\
    \ n, p)\n", "    return (p - 1) % n + p - 1\n\n", "    return ((n + p) % (p -\
    \ 1)) * p\n", "    n, p = abs(n), abs(p)\n    if p == 2:\n        return n\n \
    \   if n % 2 == 0 and p % 2 == 0:\n        return p * pow(2, n // 2, p)\n    if\
    \ n % 2 == 1:\n        return pow(2, n, p)\n    if p % 2 == 1:\n        return\
    \ pow(2, n, p)\n    if p == 2:\n        return n\n    return pow(2, n, p)\n\n",
  "    ret = n - 1\n    while p > 0:\n        ret = ret % p\n        p >>= 1\n   \
    \ return ret\n", "    n, p = int(n), int(p)\n    if p == 0: return 1\n    if n\
    \ & -p == -1: return p - 1\n    if p & -n == 1: return p - 1\n    m = (n & -p)\
    \ << 1 | p & -n\n    return m % p\n", "    return 1\n", "    if n < 0:\n     \
    \   raise ValueError(\"n must be nonnegative\")\n    if p == 2:\n        return\
    \ n\n    p -= 1\n    n = n % p\n    if not p:\n        return n\n    return 2\
    \ * n + 2\n\n", "    if n == 0:\n        return 0\n    if p == 1 or p == 2:\n\
    \        return n\n    shift = p - n >> 1\n    if shift >= 0:\n        return\
    \ n + shift\n    return n - shift\n\n", "    ans = 2\n    while ans <= n:\n  \
    \      ans *= 2\n        if ans > n:\n            ans %= p\n    return ans\n\n",
  "    return ((n ** p) % p) if p else 0\n\n", "    return (n * pow(2, p, p)) % p\n",
  "    if p < 0:\n        raise ValueError(\"The prime number should be positive.\"\
    )\n    if n == 1:\n        return p\n    if n % 2 == 0:\n        return modp(n\
    \ // 2, p)\n    if n % 3 == 0:\n        return modp((n // 3) // 2, p)\n    if\
    \ n % 5 == 0:\n        return modp((n // 5) // 3, p)\n    return modp((n // 7)\
    \ // 3, p)\n", "    ans = 2\n    while n > 0 and n & 1:\n        ans *= 2\n  \
    \      n >>= 1\n    ans %= p\n    return ans\n\n", "    if n == 0:\n        return\
    \ 0\n    else:\n        return ((n % p) + p) % p\n", "    return n & (-p + 1)\n\
    \n", "    return -(-n // p) if n < p else -(-(n - 1) // p) + 1\n\n", "    if n\
    \ == 0:\n        return 0\n    if n == 1:\n        return p\n    if n < 0:\n \
    \       raise ValueError(\"modp(n) not defined for negative integers\")\n    if\
    \ p < 0:\n        raise ValueError(\"modp(n) not defined for negative integers\"\
    )\n    return ((-p) * pow(2, n + 1, p)) % p\n\n", "    ans = bin(n).count(\"1\"\
    )\n    return ans % p\n\n", "    assert n >= 0\n    assert p >= 0\n    d, r =\
    \ divmod(p, n)\n    if r:\n        d += r\n    return d % p\n\n", "    if n ==\
    \ 0:\n        return 0\n    else:\n        return ((n | (n-1) << p) + 1) & p\n",
  "    if n == 0:\n        return 0\n    if n == 1:\n        return p\n    return\
    \ pow(2 ** n, p - 2, p)\n", "    if p == 2:\n        return n\n    if p % 2 ==\
    \ 0 or p == 1 or p == -1:\n        raise ValueError(\"p must be an even positive\
    \ integer\")\n    ret = pow(2, n, p)\n    if ret <= p:  # Oops, overflow.\n  \
    \      return pow(2, n)\n    ret %= p\n    return ret\n\n", "    pow2n = pow(2,\
    \ n)\n    return pow2n - (pow2n % p)\n\n", "    if n == 0:\n        return 0\n\
    \    if n == 1:\n        return p\n    n -= 1\n    return (p - 1) % n + p\n",
  "    if n < 0 or p < 0:\n        raise ValueError(\"Both n and p should be positive\"\
    )\n    elif n >= p and n % p == 0:\n        return n\n    elif n >= p:\n     \
    \   return n\n    elif n % p == 0:\n        return pow(2, n, p)\n    else:\n \
    \       return pow(2, n, p - 1) % p\n\n", "    return (p > 0 and n) or n - (n\
    \ % p)\n\n", "    low = 1\n    while low < n:\n        low = (low + high) // 2\n\
    \        high = low + 1\n    return (high + 1) & (p - 1)\n\n", "    if n == 0:\n\
    \        return 0\n    n, r = divmod(n + 1, p)\n    if r:\n        return r\n\
    \    return 2 ** n - 1\n\n", "    return ((1 << n) ^ n) * p % p\n", "    if p\
    \ == 2:\n        return n\n    return ((n % p) + p) % p\n", "    if p == 2:\n\
    \        return n\n    if n < 0:\n        return -p * modp(-n, p)\n    shift =\
    \ n&((n-1)//2)\n    return (p-1)//2 * (p + shift) + shift * modp(n, (p - shift))\n\
    \n", "    low = pow(2,n)\n    high = pow(p,n)\n    while high%2==0 and high!=1:\n\
    \        high = high/2\n    return high\n\n", "    # check special case\n    if\
    \ n == 0:\n        return 0\n    i = p - 1\n    while i ** 2 <= n:\n        i\
    \ = i // 2\n    return i\n\n", "    return pow(2, n, p)\n\n", "    return ((n\
    \ ** p) + 1) % (2 ** p)\n\n", "    return ((n & (p - 1)) == 0) ^ (n & ((p - 1)\
    \ << 1))\n", "    if not p % 2:\n        return 2**n - (not n & 1)\n    return\
    \ pow(2, n, p)\n\n", "    while p < 0:\n        p += n\n    return p\n\n", " \
    \   n %= p\n    return n if n<p else p\n\n", "    return ((n + p + 1) // p) *\
    \ p\n\n", "    if not n:\n        return 0\n    t, r = divmod((p + 1) << n, n)\n\
    \    return t << r | t >> (32 - r)\n\n", "    while n != 0:\n        n -= p\n\
    \        p += n\n    return n\n\n", "    return ((p + 1) // n) * n\n\n", "   \
    \ ret = p - 1\n    while n > 0:\n        if n & 1:\n            ret = ret + 1\n\
    \        n = n >> 1\n    return ret\n\n", "    if n == 0:\n        return 0\n\
    \    if p == 2:\n        return n\n    if p % 2 == 0:\n        return n\n    if\
    \ p % 3 == 0:\n        return n - (n % p)\n    return pow(2, n, p)\n", "    return\
    \ 1\n", "    return pow(2, n, p)\n", "    return ((n & (p - 1)) == 0 and (n %\
    \ p) == 0) or ((n % p) == 0 and n & (p - 1))\n\n", "    return ((n + p) % (2 **\
    \ p)) % p\n\n", "    if n == 0:\n        return 0\n    x = 1\n    while n > 0:\n\
    \        if n % 2 != 0:\n            x = x * p % p\n        n = n // 2\n    return\
    \ x\n", "    if n == 0:\n        return 0\n    elif n & 1:\n        return p\n\
    \    else:\n        return p - 1\n    \n", "    return -(-n // p) * p + n\n",
  "    if p == 2:\n        return n\n\n    shift = p - n\n    if not shift:\n    \
    \    return n\n    return n << shift\n", "    return n & (p-1)\n", "    ans =\
    \ 0\n    while (p != 0 and n) != 0:\n        if (n % p) == 0:\n            ans\
    \ = ans | (1 << (n % p))\n        n //= p\n        p -= 1\n    return ans", " \
    \   if p == 2:\n        return n\n    if p == 1 or p == -1:\n        return -p\n\
    \    return ((p * n) // p) % (p ** 2)\n\n", "    if p == 2:\n        return n\n\
    \    result = 1\n    while result != 0:\n        result *= 2\n        n -= 1\n\
    \        if n & 1:\n            result += 1\n    return result % p\n\n", "   \
    \ k = math.copysign(2 ** n - 1, p)\n    return ((k % p) + p) % p\n\n", "    return\
    \ n & -p\n\n", "    return ((n * p + 1) // p) % (p * 2)\n\n", "    return ((n\
    \ * p + 1) // p) % p\n\n", "    if n == 0:\n        return 0\n    lower = 1\n\
    \    upper = 1 << 64\n    while n:\n        if n & 1:\n            p *= 2\n  \
    \          upper /= 2\n            n -= 1\n        else:\n            lower =\
    \ upper\n            upper /= 2\n            n >>= 1\n    return p\n\n", "   \
    \ return n & (p - 1)\n\n", "    if n == 0:\n        return 0\n    elif n & 1 and\
    \ p == 2:\n        return p\n    else:\n        return modp(n >> 1, p) + p - 1",
  "    if n < 0 or p < 0 or p == n:\n        raise TypeError()\n    if p == 2:\n \
    \       return n\n    while p > 0:\n        if p & 1:\n            p >>= 1\n \
    \           n |= 1 << (p - 1)\n    return n\n\n", "    # https://stackoverflow.com/questions/34824182/why-do-we-need-to-use-the-int-floordiv-function\n\
    \    return ((n // p) + 1) * p\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
