name: HumanEval_55_fib
language: py
prompt: "def fib(n: int) -> int:\n    \"\"\"Return n-th Fibonacci number.\n      \
  \          \"\"\"\n"
tests: "def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1)\
  \ == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert\
  \ candidate(12) == 144\n\ndef test_check():\n    check(fib)\n\ntest_check()\n"
completions: ["    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n\
    \    return a\n\n", "    if n <= 2:\n        return n\n    else:\n        return\
    \ fib(n-2) + fib(n-1)\n\n", "    if n < 2:\n        return n\n    return fib(n-2)\
    \ + fib(n-1)\n</cell>\n<cell>\n%%time\nfib(5000)\n</cell>\n<cell>\n%%time\nfibs(5000)\n\
    </cell>\n<text>\nFibonacci numbers\nUsing memoization\n\n</text>\n<cell>", " \
    \   if n in [0, 1):\n        return n\n\n    return fib(n - 1) + fib(n - 2)\n\n",
  "    if n == 1 or n == 2:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\
    \n", "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n \
    \   else:\n        return fib(n-2) + fib(n-1)\n\n", "    if n == 0:\n        return\
    \ 0\n    elif n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\n",
  "    if n == 1:\n        return n\n    elif n == 2:\n        return 1\n    else:\n\
    \        return fib(n - 1) + fib(n - 2)\n\n", "    if n <= 1:\n        return\
    \ n\n\n    return fib(n-1) + fib(n-2)\n\n", "    if n <= 2:\n        return n\n\
    \    return fib(n-2) + fib(n-1)\n\n", "    return 0 if n < 2 else fib(n-1) + fib(n-2)\n",
  "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n\
    \        return fib(n-2) + fib(n-1)\n\n", "    # Base case\n    if n == 0:\n \
    \       return 0\n    # Recursion\n    elif n == 1:\n        return 1\n    else:\n\
    \        return fib(n-1) + fib(n-2)\n\n</cell>\n<cell>\nfib(7)\n</cell>\n<text>\n\
    What are we going to do?\nLet's get to practice our basics with a few examples:\n\
    \n\n</text>\n<cell>", "    if n < 0:\n        return 0\n    elif n == 1:\n   \
    \     return 1\n    return fib(n-2) + fib(n-1)\n\n", "    if n == 0:\n       \
    \ return 0\n    elif n == 1:\n        return 1\n    return fib(n-1) + fib(n-2)\n\
    \n", "    if n <= 2:\n        return n\n    return fib(n - 2) + fib(n - 1)\n\n",
  "    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\n", "    assert\
    \ n > 0\n    if n <= 2:\n        return n\n    return fib(n-2) + fib(n-1)\n",
  "    if n in (0, 1):\n        return n\n    return fib(n-1) + fib(n-2)\nprint(fib(35))\n\
    </cell>\n<text>\nExercise 8.6\nWrite a function that takes two lists and returns\
    \ a list containing the common elements between them.\n\n\n</text>\n<cell>\nlist1\
    \ = [12, 13, 9, 19, 23, 23, 17, 56, 94, 11]\nlist2 = [0, 3, 10, 19, 13, 21, 22,\
    \ 43, 44, 21, 44, 12]\nprint(list1)\nprint(list2)\n</cell>\n<cell>", "    if n\
    \ == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n   \
    \     return fib(n-2) + fib(n-1)\n\n", "    if n <= 2:\n        return n\n   \
    \ return fib(n-2) + fib(n-1)\n\n", "    if n in (0, 1):\n        return n\n  \
    \  return fib(n-2) + fib(n-1)\n</cell>\n<cell>", "    if n < 2:\n        return\
    \ n\n    return fib(n-2) + fib(n-1)\n", "    if n <= 1:\n        return n\n  \
    \  return fib(n-1) + fib(n-2)\n", "    if n <= 2:\n        return n\n\n    return\
    \ fib(n - 2) + fib(n - 1)\n\n", "    if n < 2:\n        return n\n    return fib(n-1)\
    \ + fib(n-2)\n\n", "    return n if n < 2 else fib(n-1) + fib(n-2)\n", "    if\
    \ n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n \
    \       return fib(n-1) + fib(n-2)\n\n", "    if n in (0, 1):\n        return\
    \ 1\n    return fib(n - 1) + fib(n - 2)\n\n", "    if n == 0:\n        return\
    \ 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) +\
    \ fib(n-2)\n\n", "    if n <= 1:\n        return n\n\n    return fib(n-2) + fib(n-1)\n\
    \n\n@task()", "    if n == 2:\n        return 1\n    elif n == 1 or n == 2:\n\
    \        return 1\n    else:\n        return fib(n-1) + fib(n-2)\n\n", "    if\
    \ n <= 2:\n        return n\n    return fib(n-2) + fib(n-1)\n\n", "    if n <\
    \ 2:\n        return n\n\n    a, b = 0, 1\n    while a < n:\n        a, b = b,\
    \ a+b\n\n    return b\n\n", "    a, b = 0, 1\n    while b < n:\n        a, b =\
    \ b, a + b\n    return a\n\n\nprint(fib(10))\n</code>\n<|/ a |>\n<| a tags=python,python-3.x\
    \ |>\nFibonacci numbers are the series defined by the recurrence relation:\nF(0)\
    \ = 0; F(1) = 1;\nF(n) = F(n - 1) + F(n - 2)\nFor example, the 6th fibonacci number\
    \ is F(6) = F(5) + F(4), which is\n6 + 5 + 4.\nThe above formula can be rewritten\
    \ using the following Python code\n<code>", "    if n <= 0:\n        return 0\n\
    \    elif n <= 2:\n        return 1\n    else:\n        return fib(n-2) + fib(n-1)\n\
    \n", "    x, y = 0, 1\n    for i in range(n):\n        x, y = y, x + y\n    return\
    \ x\n\nprint(fib(10))\n</code>\n<|/ a dscore=2 tags=fibonacci,python |>\n<| a\
    \ |>\nI wrote a function that uses dynamic programming to find all fibonacci numbers,\
    \ it may help you!\n<code>", "    if n < 2:\n        return n\n    else:\n   \
    \     return fib(n-2) + fib(n-1)\n</cell>\n<cell>\nfib(2)\n</cell>\n<cell>\n%timeit\
    \ fib(500)\n</cell>\n<cell>\n%timeit fib(1000)\n</cell>\n<cell>\n%timeit fib(100000)\n\
    </cell>\n<cell>\n%timeit fib(10000)\n</cell>\n<cell>\n%timeit fib(-100000)\n</cell>\n\
    <cell>\n%timeit fib(-10000)\n</cell>\n<cell>\n%timeit fib(100000)\n</cell>\n<text>\n\
    Let's now look at how to make recursive functions in Python.\n\n</text>\n<cell>",
  "    if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)\n\n", "    if\
    \ n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\n", "    if n in\
    \ (0, 1):\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n", "    if\
    \ n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n \
    \       return fib(n - 1) + fib(n - 2)\n\n", "    if n < 2:\n        return n\n\
    \n    return fib(n-1) + fib(n-2)\n\n", "    if n < 0:\n        raise IndexError(\"\
    fibonacci index\")\n    elif n == 0:\n        return 0\n    elif n == 1:\n   \
    \     return 1\n    else:\n        return fib(n-1) + fib(n-2)\n\nprint(fib(9))\n\
    print(fib(11))\nprint(fib(12))\n</cell>\n<text>\nThe fibonacci numbers grow very\
    \ fast so the memoization technique can help us with running time.\n\n\n</text>\n\
    <text>\nMemoization\n\n</text>\n<text>\nHow do we improve the performance of our\
    \ code? The answer lies in storing the results in a data structure, called a hash\
    \ table. A hash table stores pairs of values \u2013 key & value \u2013 mapped\
    \ to the same value. This is called hashing. If we try to lookup a key in a hash\
    \ table without having found the key, the system has to go through all the items\
    \ in the hash table to compare the keys until it finds an item. In this process,\
    \ we spend a lot of time comparing items and wasting time on unnecessary comparisons.\
    \ This is called a hash table is too big. There are multiple strategies to resolve\
    \ this problem. One of the most common is to hash values into groups or buckets\
    \ where the keys are similar so all the items in the hash table are in the same\
    \ bucket. Another way to solve this problem is to use buckets to partition the\
    \ hash table into smaller hash tables that store similar keys together. This technique\
    \ is called bucket sort. Another way to solve this problem is to use an open addressing\
    \ hashing algorithm. Basically, the keys that are being used to retrieve the item\
    \ in the hash table are hashed into a number and then stored in the bucket corresponding\
    \ to the hashed keys. When the key is looked up again, the hash is matched with\
    \ the hashed key in the hash table. If the hashed key is found then the value\
    \ is returned. Otherwise, the item is added to the end of the bucket and a new\
    \ item is added to the start of the bucket. Once the maximum number of items in\
    \ the bucket have been reached the bucket is deleted and another bucket is created\
    \ and so on. This technique is called open hashing.\n\n\n</text>\n<cell>", " \
    \   if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)\n\n", "    a,\
    \ b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\n",
  "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n\
    \        return fib(n - 1) + fib(n - 2)\n</code>\n<|/ a |>\n<| c |>\nThe only\
    \ problem is that you call `fib` with n instead of n - 1. Also, Python will do\
    \ tail call elimination and it's smart to do it in a recursive fashion. I don't\
    \ think you should optimize this just because of a few lines of code\n<|/ c |>\n\
    <| c |>\nOkay, thanks, I changed it. I was trying to be consistent with the original\
    \ function.\n<|/ c |>\n<| c |>\nThis is not tail call optimization.\n<|/ c |>\n\
    <| c |>\nOh, so I am. I thought I remembered it being in some language but maybe\
    \ not.\n<|/ c |>\n<| a |>\nIt is a recursion.\n<code>", "    if n <= 1:\n    \
    \    return n\n    return fib(n-2) + fib(n-1)\n", "    a, b = 0, 1\n    while\
    \ a < n:\n        a, b = b, a+b\n    return a\n", "    if n == 0:\n        return\
    \ 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) +\
    \ fib(n-2)\n", "    # YOUR CODE HERE\n    if n < 2:\n        return n\n    return\
    \ fib(n-2) + fib(n-1)\n\n", "    a, b = 0, 1\n    while a < n:\n        a, b =\
    \ b, a+b\n    return a\n", "    if n <= 2:\n        return n\n    else:\n    \
    \    return fib(n - 1) + fib(n - 2)\n\n", "    if n <= 2:\n        return n\n\
    \    else:\n        return fib(n - 1) + fib(n - 2)\n\n", "    if n <= 2:\n   \
    \     return n\n    return fib(n - 1) + fib(n - 2)\n", "    a, b = 0, 1\n    while\
    \ b < n:\n        a, b = b, a+b\n    return a\n", "    if n < 2:\n        return\
    \ n\n    return fib(n-1) + fib(n-2)\n\n", "    if n == 1:\n        return 0\n\
    \    if n == 2:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\n", " \
    \   if n <= 1:\n        return n\n    else:\n        return fib(n-2) + fib(n-1)\n\
    \n", "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n \
    \   return fib(n-1) + fib(n-2)\n\n", "    assert n >= 0, 'n must be >= 0'\n  \
    \  if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n\
    \        return fib(n - 1) + fib(n - 2)\n\n", "    if n < 2:\n        return n\n\
    \    else:\n        return fib(n - 1) + fib(n - 2)\n\n", "    a, b = 0, 1\n  \
    \  for _ in range(n):\n        a, b = b, a + b\n    return a\n\n", "    if n <\
    \ 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\n\nprint(fib(40))\n</cell>\n\
    <text>\nWrite a function factorial to compute $n!$, where $n$ is a positive integer.\n\
    \nFor $n = 4$ it should be:\n\n$4! = 24$\n\nFor $n = 5$ it should be:\n\n$5! =\
    \ 120$\n\nFor $n = 10$ it should be:\n\n$10! = 720$\n\nFor $n = 20$ it should\
    \ be:\n\n$20! = 120$\n\nFor $n = 30$ it should be:\n\n$30! = 720$\n\nFor $n =\
    \ 40$ it should be:\n\n$40! = 1320$\n\n\n</text>\n<cell>", "                if\
    \ n < 2:\n                        return n\n                return fib(n-1) +\
    \ fib(n-2)\n                ", "    if n == 0:\n        return 0\n    elif n ==\
    \ 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)\n\n", " \
    \   assert n > 0\n    if n == 1:\n        return 1\n    elif n == 2:\n       \
    \ return 1\n    else:\n        return fib(n-1) + fib(n-2)\n", "    if n == 0:\n\
    \        return 0\n    elif n == 1:\n        return 1\n    return fib(n - 1) +\
    \ fib(n - 2)\n\n", "    if n < 2:\n        return n\n    else:\n        return\
    \ fib(n-1) + fib(n-2)\n\n", "    if n <= 2:\n        return 1\n    return fib(n-1)\
    \ + fib(n-2)\n", "    if n <= 2:\n        return n\n    return fib(n - 1) + fib(n\
    \ - 2)\n\n", "    if n < 2:\n        return n\n    return fib(n-2) + fib(n-1)\n\
    </cell>\n<cell>", "    if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)\n\
    \n", "    if n <= 2:\n        return n\n    return fib(n-1) + fib(n-2)\n</code>\n\
    For a recursive approach we can use mathematical formula\n<code>\nF(n) = F(n-1)\
    \ + F(n-2) + F(n-3)\n</code>\nSo, the python code can be implemented as\n<code>",
  "    assert n >= 0\n    return fib1(n + 1) + fib2(n + 1)\n", "                if\
    \ n < 2:\n                        return n\n                else:\n          \
    \              return fib(n-1) + fib(n-2)\n\n", "    if n <= 1:\n        return\
    \ n\n    return fib(n-2) + fib(n-1)\n\n", "    a, b = 0, 1\n    while a < n:\n\
    \        a, b = b, a + b\n    return a\n", "    if n < 2:\n        return n\n\
    \    return fib(n-2) + fib(n-1)\n\n", "    if n in (0, 1):\n        return n\n\
    \    return fib(n-1) + fib(n-2)\n</cell>\n<text>\nThis code snippet can run without\
    \ problem:\n\n\n</text>\n<cell>\nfib(10)\n</cell>\n<text>\nLet's see what is happening\
    \ when we try to use this function to find the first n Fibonacci numbers greater\
    \ than some number n.\n\n\n</text>\n<cell>", "    if n <= 2:\n        return n\n\
    \n    return fib(n-1) + fib(n-2)\n</code>\nNow, a lot of code in the interpreter\
    \ will actually execute when these imports are executed.\n<code>\n>>> fib(10)\n\
    55\n</code>\nThat's because they are only defined when imported and are thus not\
    \ executed unless you execute them explicitly, and as you can see there are some\
    \ code that will execute automatically before you import a module.\nIn the interpreter\
    \ you can check what functions were defined in a module by doing:\n<code>\n>>>\
    \ fib\n<function fib at 0x105e273e0>\n</code>\nAnd you can check what variables\
    \ are in scope in Python by doing:\n<code>\n>>> dir()\n['__builtins__', '__doc__',\
    \ '__loader__', '__name__', '__package__', '__spec__', 'fib']\n</code>\nAnd you\
    \ can check what functions are in scope using the locals() function:\n<code>\n\
    >>> locals()\n{'__spec__': None, '__name__': '__main__', 'fib': <function fib\
    \ at 0x105e273e0>, '__doc__': None}\n</code>\nHowever, once you import a module\
    \ from another module, it gets added to sys.modules which is where Python stores\
    \ information about imported modules, functions, and other Python objects. And\
    \ those objects are accessible in other modules as well.\n<code>\n>>> import sys\n\
    >>> sys.modules\n{<module 'sys' (built-in)>: 'sys'}\n>>> import sys\n>>> sys.modules\n\
    {<module 'sys' (built-in)>: 'sys', <module 'sys' (built-in)>: 'sys'}\n>>> sys\n\
    <module 'sys' (built-in)>\n>>> sys.modules\n{<module 'sys' (built-in)>: 'sys',\
    \ <module 'sys' (built-in)>: 'sys', <module 'sys' (built-in)>: 'sys', <module\
    \ 'sys' (built-in)>: 'sys'}\n>>> import os\n>>> sys.modules\n{<module 'os' (built-in)>:\
    \ 'os', <module 'sys' (built-in)>: 'sys', <module 'sys' (built-in)>: 'sys'}\n\
    >>> os\n<module 'os' (built-in)>\n>>> sys.modules\n{<module 'os' (built-in)>:\
    \ 'os', <module 'sys' (built-in)>: 'sys', <module 'sys' (built-in)>: 'sys'}\n\
    </code>\nWhen you import a module Python adds it to the sys.modules dictionary\
    \ and returns a reference to it. When you import another module, Python returns\
    \ you a reference to it as well (the same object).\nAs you can see sys ", "  \
    \  if n < 0:\n        return 0\n    elif n == 0:\n        return 0\n    elif n\
    \ == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n\n", "    if n\
    \ == 0:\n        return 0\n    elif n == 1:\n        return 1\n    return fib(n-2)\
    \ + fib(n-1)\n\n", "    if n <= 2:\n        return n\n    else:\n        return\
    \ fib(n-1) + fib(n-2)\n\n", "    if n < 2:\n        return n\n    return fib(n-1)\
    \ + fib(n-2)\n</cell>\n<cell>\n%matplotlib inline\n\nimport matplotlib.pyplot\
    \ as plt\nimport numpy as np\n\nfibs = fibs(5)\n\nfig, ax = plt.subplots()\nax.plot(range(5),\
    \ fibs, label=\"Fibonacci\")\nax.set_title(\"Fibonacci numbers\")\nax.set_xlabel(\"\
    n\")\nax.set_ylabel(\"f(n)\")\nax.legend()\nplt.show()\n</cell>\n<cell>", "  \
    \  if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n\
    \        return fib(n-1) + fib(n-2)\n\n", "    if n < 2:\n        return n\n \
    \   return fib(n-1) + fib(n-2)\n", "    if n == 0:\n        return 0\n    elif\
    \ n == 1:\n        return 1\n    return fib(n-1) + fib(n-2)\n\n", "    if n <=\
    \ 2:\n        return n\n    return fib(n-2) + fib(n-1)\n\n", "    assert n >=\
    \ 0\n    if n <= 2:\n        return 1\n    return fib(n-2) + fib(n-1)\n", "  \
    \  if n < 0:\n        return 0\n    elif n == 0:\n        return 0\n    elif n\
    \ == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)\n", " \
    \   if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n</cell>\n<cell>\n\
    print(fib(0))\nprint(fib(1))\nprint(fib(2))\nprint(fib(10))\nprint(fib(100))\n\
    </cell>\n<text>\nPractice with recursion\nLet's do some practice with recursion.\n\
    \n\n</text>\n<cell>", "    if n < 2:\n        return 1\n    return fib(n-1) +\
    \ fib(n-2)\n\n", "    return fib_iterative(n)\n\n", "    if n == 0:\n        return\
    \ 0\n    elif n == 1:\n        return 1\n    return fib(n-1) + fib(n-2)\n\nprint(fib(20))\n\
    </cell>\n<text>\nExercise 5\n\n</text>\n<cell>", "    if n < 2:\n        return\
    \ n\n    return fib(n-1) + fib(n-2)\n\nprint(fib(120))\n</cell>\n<text>\nExercise:\n\
    Write a recursive function to find the n'th fibonacci number using cache storage.\n\
    \n\n</text>\n<cell>\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)",
  "    a, b = 0, 1\n    while a < n:\n        a, b = b, a + b\n    return a\n\n",
  "    a, b = 1, 0\n    while a < n:\n        a, b = b, a + b\n    return a\n\n",
  "    if n == 0 or n == 1:\n        return n\n    return fib(n-2) + fib(n-1)\n",
  "    if n <= 1:\n        return n\n    return fib(n-2) + fib(n-1)\n", "    if n\
    \ < 2:\n        return n\n    return fib(n-2) + fib(n-1)\n\n", "    memo: Set[int]\
    \ = set()\n    if n not in memo:\n        memo.add(n)\n    else:\n        return\
    \ n\n    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\nassert\
    \ fib(8) == 13\nassert fib(3) == 3\n</cell>\n<text>\nMemoized Recursive Fibonacci\
    \ functions\n\n</text>\n<text>\nThe Fibonacci sequence is one of the most important\
    \ mathematical sequences of any modern non-trivial size. Recursive functions can\
    \ be very inefficient, especially for recursive functions with large inputs. Memoization\
    \ is an efficient way (in most cases) to avoid recalculating the same values.\n\
    \n\n</text>\n<text>\nOne approach is to use a simple cache. Let's make a function\
    \ that returns the nth Fibonacci number if the nth Fibonacci number is not in\
    \ the cache. This is a straightforward approach and works well for small inputs:\n\
    \n\n</text>\n<cell>", "    if n < 2:\n        return n\n    return fib(n-1) +\
    \ fib(n-2)\n", "    a, b = 0, 1\n    while b < n:\n        a, b = b, a + b\n \
    \   return a\n", "    if n == 0 or n == 1:\n        return n\n    return fib(n-2)\
    \ + fib(n-1)\n", "    if n < 2:\n        return n\n    return fib(n - 2) + fib(n\
    \ - 1)\n\n\n@dataclass", "    if n <= 2:\n        return 1\n    return fib(n -\
    \ 1) + fib(n - 2)\n\n", "    if n == 0:\n        return 0\n    elif n == 1:\n\
    \        return 1\n    else:\n        return fib(n-1) + fib(n-2)\n\n", "    if\
    \ n < 0:\n        raise ValueError\n    elif n == 0:\n        return 0\n    elif\
    \ n == 1:\n        return 1\n    else:\n        return fib(n - 1) + fib(n - 2)\n\
    \n", "    if n < 0:\n        return 0\n    elif n == 1:\n        return 1\n  \
    \  else:\n        return fib(n-2) + fib(n-1)\n\n", "    if n <= 1:\n        return\
    \ n\n    return fib(n - 1) + fib(n - 2)\n\n", "    if n == 0:\n        return\
    \ 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) +\
    \ fib(n-2)\n    ", "    if n < 2:\n        return n\n\n    return fib(n - 1) +\
    \ fib(n - 2)\n\n", "    \n    fib1 = fib(n - 1)\n    fib2 = fib(n - 2)\n    \n\
    \    if fib1 < fib2:\n        return fib1\n    else:\n        return fib2\n</cell>\n\
    <cell>", "    if n < 2:\n        return n\n\n    return fib(n-1) + fib(n-2)\n\n",
  "    \n    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n", "   \
    \ a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\
    \n", "    # Implement here\n\n    if n <= 1:\n        return 1\n    return fib(n-2)\
    \ + fib(n-1)\n\n", "    if n <= 2:\n        return n\n    return fib(n-2) + fib(n-1)\n",
  "    if n <= 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\n", "    if\
    \ n < 2:\n        return 1\n    return fib(n-2) + fib(n-1)\n</cell>\n<cell>",
  "    assert n >= 0\n    if n in (0, 1):\n        return 1\n    return fib(n-1) +\
    \ fib(n-2)\n</cell>\n<cell>\nfib(10)\n</cell>\n<text>\nExercise 19: Write a function\
    \ is_prime that returns True if the integer $n$ is a prime number and False otherwise.\n\
    \n\n</text>\n<cell>", "    if n <= 1:\n        return n\n\n    return fib(n-1)\
    \ + fib(n-2)\n\n", "    # write your code here\n", "    if n < 2:\n        return\
    \ n\n    return fib(n-2) + fib(n-1)\n", "    if n <= 1:\n        return n\n\n\
    \    return fib(n-2) + fib(n-1)\n</cell>\n<cell>", "    if n < 2:\n        return\
    \ 1\n    return fib(n-2) + fib(n-1)\n", "    if n < 0:\n        return -1\n  \
    \  if n <= 1:\n        return 1\n    return fib(n-2) + fib(n-1)\n", "    if n\
    \ <= 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\n", "    # Initialize\
    \ recursion base case\n    if n <= 1:\n        return n\n\n    # Recursive step\n\
    \    return fib(n-2) + fib(n-1)\n\n", "    if n <= 2:\n        return n\n    return\
    \ fib(n - 2) + fib(n - 1)\n\n", "    a, b = 1, 1\n    for i in range(n):\n   \
    \     a, b = b, a + b\n    return a\n\n", "    assert n > 0\n    return fib(n-1)\
    \ + fib(n-2)\n\n", "    if n <= 2:\n        return n\n    else:\n        return\
    \ fib(n - 1) + fib(n - 2)", "    if n < 2:\n        return n\n    return fib(n-1)\
    \ + fib(n-2)\n\n", "    if n <= 1:\n        return n\n    return fib(n - 1) +\
    \ fib(n - 2)\n\n", "    if n == 0:\n        return 0\n    if n == 1:\n       \
    \ return 1\n    return fib(n-1) + fib(n-2)\n", "    # write your code here\n \
    \   if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n\
    \        return fib(n-1) + fib(n-2)\n\n", "    if n < 0:\n        raise ValueError(\"\
    Fibonacci number for negative numbers not allowed\")\n    if n == 0 or n == 1:\n\
    \        return 1\n    return fib(n - 1) + fib(n - 2)\n\n", "    return fib2(n)\
    \ + fib2(n - 2)\n\n", "    if n == 0 or n == 1:\n        return 1\n    return\
    \ fib(n - 1) + fib(n - 2)\n\n\n@doctest", "    if n <= 1:\n        return n\n\
    \    return fib(n-1) + fib(n-2)\n\n", "    if n <= 1:\n        return n\n    return\
    \ fib(n-1) + fib(n-2)\n\nassert fib(1) == 1, \"fib(1) should return 1\"\nassert\
    \ fib(2) == 1, \"fib(2) should return 1\"\nassert fib(3) == 2, \"fib(3) should\
    \ return 2\"\nassert fib(4) == 3, \"fib(4) should return 3\"\nassert fib(5) ==\
    \ 5, \"fib(5) should return 5\"\nassert fib(6) == 8, \"fib(6) should return 8\"\
    \nassert fib(7) == 13, \"fib(7) should return 13\"\nassert fib(8) == 21\n</cell>\n\
    <text>\nExercise 7.1: Write a function that takes a list and returns a list containing\
    \ only the even numbers. Test your function using the following list of numbers:\
    \ 1, 2, 3, 4, 5, 6\n\n\n</text>\n<cell>", "    if n <= 1:\n        return n\n\
    \    return fib(n-1) + fib(n-2)\n</code>\nI really don't understand why this line\
    \ return fib(n-1) + fib(n-2) is written inside the function definition! Is it\
    \ because when python tries to compile the function definition it goes through\
    \ all the lines of the function definition and when it reaches the return fib(n-1)\
    \ + fib(n-2) it skips that part and goes straight to the function definition?\n\
    Please help me understand the concept of why this is happening and maybe help\
    \ me understand the logic behind this behavior!\n<|/ q dscore=1 |>\n<| c |>\n\
    `return` exits the function, so the program stops after the recursive call.\n\
    <|/ c |>\n<| c |>\nThis question can be easily found on Google or any other search\
    \ engine. [Here](https://www.geeksforgeeks.org/python-return-statement/) is one.\n\
    <|/ c |>\n<| c |>\nWhen Python sees the `return` statement, it returns to the\
    \ caller. Since `fib` calls `fib`, which calls `fib`, which calls `fib` etc, etc,\
    \ until it gets to `fib(1)`, it returns `1` back to the caller, and the program\
    \ exits. In your case, the caller is `main()`, so it exits.\n<|/ c |>\n<| a |>\n\
    Your return fib(n-1) + fib(n-2) is just a statement of what is returned by the\
    \ function.\nIn this case, it will return 2 when n is 2, because your function\
    \ will execute the following statements:\n<code>\nn = 2\nreturn fib(n-1) + fib(n-2)\n\
    </code>\nIn other words, it is equivalent to return 2.\nIf you want your function\
    \ to return the sum of fib(n-1) and fib(n-2), you need to return those values.\n\
    <|/ a tags=python-3.x,python dscore=2 |>\n<| a dscore=1 |>\nTo add some detail\
    \ regarding your code snippet. \nWhen you declare a function in python you specify\
    \ the parameters it expects and the return type it returns. In the case below\
    \ the function takes 1 argument and returning a value of type int.\n<code>", " \
    \   a, b = 1, 1\n    while a < n:\n        a, b = b, a + b\n    return a\n", " \
    \   if n < 2:\n        return n\n    return fib(n-2) + fib(n-1)\n", "    if n\
    \ < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n", "    a, b =\
    \ 0, 1\n    while a < n:\n        a, b = b, a + b\n    return a\n\n", "    if\
    \ n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)\n\n", "    if n <=\
    \ 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n", "    assert n\
    \ >= 0\n    if n <= 2:\n        return 1\n    return fib(n-1) + fib(n-2)\n", " \
    \   a, b = 0, 1\n    while a < n:\n        a, b = b, a + b\n    return b\n", " \
    \   a, b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n    return a\n\
    </cell>\n<cell>\nassert fib(7) == 13\n</cell>\n<cell>", "    if n <= 2:\n    \
    \    return n\n    return fib(n - 2) + fib(n - 1)\n", "    if n in (0, 1):\n \
    \       return 1\n    return fib(n - 1) + fib(n - 2)\n\nprint(fib(4))\n</cell>\n\
    <text>\nWe can also use recursion to do some recursive calls for us. We just have\
    \ to put it in a function and name it properly to be callable\n\n\n</text>\n<cell>",
  "    if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)\n\n", "    if\
    \ n <= 0:\n        return n\n    return fib(n-1) + fib(n-2)\n</code>\nWhen you\
    \ get an error, always post the complete error message, including the stack trace:\n\
    <code>\nTraceback (most recent call last):\n  File \"./test.py\", line 6, in <module>\n\
    \    fib(n-1)+fib(n-2)\nTypeError: unsupported operand type(s) for +: 'NoneType'\
    \ and 'int'\n</code>\n<|/ a |>\n<| a |>\nYou forgot to add the return statement\
    \ in the recursive call.\n<|/ a tags=python,python-3.x dscore=2 |>\n<| a dscore=2\
    \ |>\nThe problem is with this part:\n<code>\nreturn fib(n-1)+fib(n-2)\n</code>\n\
    Python thinks that this return fib(n-1)+fib(n-2) is the addition of the return\
    \ value of the previous call to fib with the return value of the next call to\
    \ fib. \nYou can either fix this by adding a return before the recursive call\
    \ like so:\n<code>\nreturn fib(n-1)+fib(n-2)\n</code>\nOr you just do this:\n\
    <code>\nreturn (fib(n-1)+fib(n-2))\n</code>\nAnd you can actually remove the entire\
    \ last line since you aren't using the returned value anywhere else in the program.\n\
    <|/ a tags=python,python-3.x |>\n<| a |>\n<code>", "    if n in [0, 1]:\n    \
    \    return 1\n    else:\n        return fib(n - 1) + fib(n - 2)\n", "    if n\
    \ < 0:\n        return 0\n    elif n == 0:\n        return 1\n    return fib(n-1)\
    \ + fib(n-2)\n", "    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n",
  "    assert n >= 0\n    if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)\n\
    \n", "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n \
    \   else:\n        return fib(n - 1) + fib(n - 2)\n\n\n@njit", "    a, b = 0,\
    \ 1\n    while b < n:\n        a, b = b, a + b\n    return a\nprint(fib(10))\n",
  "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n\
    \        return fib(n - 1) + fib(n - 2)\n\n", "    if n == 0:\n        return\
    \ 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n - 1)\
    \ + fib(n - 2)\n\n", "    a, b = 0, 1\n    while a < n:\n        a, b = b, a +\
    \ b\n    return b\n\n", "    if n <= 2:\n        return n\n    return fib(n -\
    \ 1) + fib(n - 2)\n", "    a, b = (0, 1)\n    while a < n:\n        a, b = b,\
    \ a + b\n    return a\n\n", "    if n < 2:\n        return n\n    return fib(n-2)\
    \ + fib(n-1)\n\n", "    if n <= 1:\n        return n\n    return fib(n - 2) +\
    \ fib(n - 1)\n\n", "    if n == 0:\n        return 0\n    elif n == 1:\n     \
    \   return 1\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n\nprint(fib(6))\n\
    print(fib(5))\nprint(fib(4))\n</cell>\n<text>\nExercise 7\nWrite a function to\
    \ compute the nth fibonacci number for n between 2 and 10. Use recursion.\nThe\
    \ first two numbers in the Fibonacci sequence are 0 and 1, the second two numbers\
    \ are 1 and 2. Each third number is generated by adding the previous two numbers.\
    \ By starting with 0 and 1, the first two numbers in the sequence are 1 and 1.\
    \ By starting with 1 and 2, the first two numbers in the sequence are 2 and 3.\n\
    \nFor a given n, your function should return the nth Fibonacci number.\n\n\n</text>\n\
    <cell>", "    assert n >= 0\n    if n <= 2:\n        return 1\n    return fib(n-2)\
    \ + fib(n-1)\n\n@test", "    # write your code here\n    if n < 2:\n       return\
    \ n\n    return fib(n-1) + fib(n-2)\n\nprint(fib(0))\nprint(fib(1))\nprint(fib(2))\n\
    print(fib(3))\nprint(fib(4))\nprint(fib(5))\n</cell>\n<text>\nExercise\nWrite\
    \ a fibonacci number generator using recursion. Hint: You can use a recursive\
    \ helper function as shown below.\n", "    a, b = 0, 1\n    while a < n:\n   \
    \     a, b = b, a + b\n    return b\n\n", "    if n < 2:\n        return n\n \
    \   else:\n        return fib(n-1) + fib(n-2)\n\n", "    a, b = 0, 1\n    while\
    \ a < n:\n        a, b = b, a + b\n    return b\n\n", "    if n < 2:\n       \
    \ return n\n    return fib(n - 1) + fib(n - 2)\n\n", "    if n < 2:\n        return\
    \ n\n    return fib(n-2) + fib(n-1)\n</cell>\n<cell>", "    if n < 2:\n      \
    \  return n\n    return fib(n-1) + fib(n-2)\n\n", "    if n < 2:\n        return\
    \ n\n    return fib(n-1) + fib(n-2)\n\n", "    if n <= 0:\n        return 0\n\
    \    elif n <= 2:\n        return 1\n    else:\n        return fib(n - 2) + fib(n\
    \ - 1)\nprint(fib(0))\nprint(fib(1))\nprint(fib(2))\nprint(fib(3))\nprint(fib(4))\n\
    print(fib(5))\nprint(fib(6))\n</cell>\n<text>\nExercise: Write a Python program\
    \ to find the factorial of a given integer number. \nThe factorial of a number\
    \ is defined as 1! \xD7 2! \xD7 3! \xD7 4! \xD7 ... \xD7 n!\nThe above formula\
    \ is very easy to use and can be computed using loop.\nFor example, the factorial\
    \ of 10 is 1*2*3*4*5*6*7*8*9*10=55.\nTry this using function and recursion\n\n\
    \n</text>\n<cell>", "    if n <= 2:\n        return n\n    else:\n        return\
    \ fib(n-2) + fib(n-1)\n\n", "    a, b = 0, 1\n    while n > 0:\n        a, b =\
    \ b, a + b\n        n -= 1\n    return b\n\n", "    if n == 1 or n == 2:\n   \
    \     return 1\n    return fib(n - 1) + fib(n - 2)\n\n\n@timeit", "    if n <=\
    \ 1:\n        return n\n\n    return fib(n - 1) + fib(n - 2)\n", "    if n < 2:\n\
    \        return n\n    return fib(n - 1) + fib(n - 2)\n", "    if n == 1:\n  \
    \      return 1\n    elif n == 2:\n        return 1\n    else:\n        return\
    \ fib(n - 1) + fib(n - 2)\n\n", "    if n <= 1:\n        return n\n\n    return\
    \ fib(n-1) + fib(n-2)\n</cell>\n<text>\nFunction fib() has multiple recursive\
    \ calls and is tail-recursive. Tail recursion is a kind of \"compiler trick\"\
    \ to make function faster. Many functions in Python are tail recursive, which\
    \ means that they can return the last value in a sequence. For example, you can\
    \ make Fibonacci numbers from 0 to N with this code:\n\n\n</text>\n<cell>", " \
    \   return n if n < 2 else fib(n-1) + fib(n-2)\n    ", "    if n < 2:\n      \
    \  return n\n    return fib(n-2) + fib(n-1)\n\n", "    prev, curr = 0, 1\n   \
    \ while curr <= n:\n        prev, curr = curr, prev + curr\n    return prev\n\n",
  "    if n <= 1:\n        return n\n    return fib(n-2) + fib(n-1)\n</cell>\n<text>\n\
    Exercise: Write a function that returns the sum of the first N even numbers. Write\
    \ a test function and a main function that tests the function's output for several\
    \ cases. What happens if N is greater than the largest integer that can be stored\
    \ in an int?\n\n\n</text>\n<cell>", "    return fib1(n) + fib2(n)\n", "      \
    \          if n < 2:\n                        return n\n                return\
    \ fib(n-1) + fib(n-2)\n", "    if n <= 1:\n        return n\n    else:\n     \
    \   return fib(n-1) + fib(n-2)\n</cell>\n<cell>\nfib(20)\n</cell>\n<cell>", " \
    \   if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n", "  \
    \  if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n", "   \
    \ if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n", "    a,\
    \ b = 0, 1\n    while b < n:\n        a, b = b, a+b\n    return a\n</code>\n<|/\
    \ a tags=python-3.x,python dscore=0 |>\n<| c |>\nThis was my first attempt at\
    \ recursion and is more in line with what I asked in my question. However, I was\
    \ really looking for a way to do this using loops. I appreciate your answer though\n\
    <|/ c |>\n<| c |>\nThe answer above is recursive too, but I guess a different\
    \ definition of recursion, which does not involve looping but merely recursion.\n\
    <|/ c |>\n<| a dscore=0 |>\nHere is a non recursive answer with list comprehension.\
    \ Maybe not the fastest, but the one that reads fairly well.\n<code>", "    a,\
    \ b = 0, 1\n    while a < n:\n        a, b = b, a + b\n    return a\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
