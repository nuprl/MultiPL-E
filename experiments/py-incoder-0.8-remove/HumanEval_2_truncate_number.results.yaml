language: py
name: HumanEval_2_truncate_number
results:
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ number, decimal = math.modf(number)\n    return number\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmplq_35wnf.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmplq_35wnf.py\", line 18,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmplq_35wnf.py\", line\
    \ 13, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmplq_35wnf.py\"\
    , line 8, in truncate_number\n    number, decimal = math.modf(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimal = number - int(number)\n    if decimal > 0.5:\n        decimal = 1 -\
    \ decimal\n    return decimal\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimal = number - int(number)\n    integral = number\n    return int(decimal),\
    \ float(integral)\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp5gze6xuk.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmp5gze6xuk.py\", line 18,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp5gze6xuk.py\", line\
    \ 13, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return float(number - int(number))\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ intpart: float = number\n    decimals: float = 1\n\n    while decimals > 0 and\
    \ intpart % 1 != 0.:\n        intpart = intpart / 10\n        decimals -= 1\n\n\
    \    return intpart\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpc1vgo676.py\", line\
    \ 26, in <module>\n    test_check()\n  File \"/tmp/tmpc1vgo676.py\", line 24,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpc1vgo676.py\", line\
    \ 19, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number < 1:\n        return 0\n    else:\n        return round(number)\n\n\
    @lru_cache(maxsize=1)\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbz6_d1u8.py\", line\
    \ 13, in <module>\n    @lru_cache(maxsize=1)\nNameError: name 'lru_cache' is not\
    \ defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number == 0:\n        return 0\n    if number > 0 and number < 1:\n     \
    \   return number\n    integer = int(number)\n    decimal = number - integer +\
    \ 1\n    return decimal\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpm8bw0zi6.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpm8bw0zi6.py\", line 23,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpm8bw0zi6.py\", line\
    \ 18, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part = np.ceil(number)\n    remainder = np.floor(number - int_part)\n  \
    \  decimal_part = remainder / float(int(np.power(10, np.floor(np.log10(remainder)))))\n\
    \n    return decimal_part\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmphmnyka_a.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmphmnyka_a.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmphmnyka_a.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmphmnyka_a.py\"\
    , line 8, in truncate_number\n    int_part = np.ceil(number)\nNameError: name\
    \ 'np' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number <= 0.0:\n        return 0.0\n\n    factor = 10.0\n    decimal_part\
    \ = abs(number % 1.0)\n    if decimal_part >= factor:\n        decimal_part =\
    \ float(decimal_part % factor)\n    else:\n        decimal_part = 0.0\n\n    integer_part\
    \ = int(number / factor)\n    return integer_part, decimal_part\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmphtfwmarg.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmphtfwmarg.py\", line 28,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmphtfwmarg.py\", line\
    \ 23, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ number = round(number)\n    integer_part = number % 1\n    fractional_part =\
    \ number - integer_part\n    return fractional_part\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0y0lkjf1.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmp0y0lkjf1.py\", line 20,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp0y0lkjf1.py\", line\
    \ 15, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return math.trunc(number) if number > 0 else 0\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbb74ux0q.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpbb74ux0q.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpbb74ux0q.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpbb74ux0q.py\"\
    , line 8, in truncate_number\n    return math.trunc(number) if number > 0 else\
    \ 0\nNameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return round(number, 10)\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpw3v8cokg.py\", line\
    \ 18, in <module>\n    test_check()\n  File \"/tmp/tmpw3v8cokg.py\", line 16,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpw3v8cokg.py\", line\
    \ 11, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer_part = int(number)\n    decimal_part = abs(number - integer_part)\n\
    \    return decimal_part\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part, frac_part = math.modf(number)\n    if frac_part > 0.99999999:\n  \
    \      return int(math.ceil(frac_part))\n    else:\n        return int(math.floor(frac_part))\n\
    \ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmprwtvhtwo.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmprwtvhtwo.py\", line 20,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmprwtvhtwo.py\", line\
    \ 15, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmprwtvhtwo.py\"\
    , line 8, in truncate_number\n    int_part, frac_part = math.modf(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number - int(number)\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if not (-1.0 <= number < 1.0):\n        raise ValueError(\"number must be between\
    \ -1 and 1\")\n\n    if number == 0.0:\n        return 0.0\n    elif number ==\
    \ 1.0:\n        return 1.0\n    \n    precision = int(math.log10(abs(number)))\n\
    \    \n    return number / 10**precision\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmpxg65rj.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmpmpxg65rj.py\", line 26,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpmpxg65rj.py\", line\
    \ 21, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpmpxg65rj.py\"\
    , line 9, in truncate_number\n    raise ValueError(\"number must be between -1\
    \ and 1\")\nValueError: number must be between -1 and 1\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return math.modf(number)[0]\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp62os4he1.py\", line\
    \ 18, in <module>\n    test_check()\n  File \"/tmp/tmp62os4he1.py\", line 16,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp62os4he1.py\", line\
    \ 11, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp62os4he1.py\"\
    , line 8, in truncate_number\n    return math.modf(number)[0]\nNameError: name\
    \ 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number == 0:\n        return number\n    else:\n        int_part = math.trunc(number)\n\
    \        frac_part = number - int_part\n        if frac_part > 0.5:\n        \
    \    return int(math.trunc(number - math.floor(number)))\n        else:\n    \
    \        return int(math.trunc(number))\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0wbumx3a.py\", line\
    \ 27, in <module>\n    test_check()\n  File \"/tmp/tmp0wbumx3a.py\", line 25,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp0wbumx3a.py\", line\
    \ 20, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp0wbumx3a.py\"\
    , line 11, in truncate_number\n    int_part = math.trunc(number)\nNameError: name\
    \ 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number - math.floor(number)\n\n\n@njit\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpcc09powc.py\", line\
    \ 11, in <module>\n    @njit\nNameError: name 'njit' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part = int(number)\n    decimal_part = number - int_part\n    return decimal_part\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimals = 0.0\n    integer = int(number)\n    while integer > 0:\n        decimals\
    \ += 1\n        integer *= 10\n    return float(number) - decimals * 1.0 / 10.0\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659823412
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer_part = int(number)\n    decimal_part = abs(number - integer_part)\n\
    \    return float(decimal_part) if decimal_part != 0 else 0.\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer = int(number)\n    decimal = round(number - integer, 1)\n    return\
    \ decimal\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert\
    \ candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n\
    \    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp8uioylg0.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmp8uioylg0.py\", line 19,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp8uioylg0.py\", line\
    \ 15, in check\n    assert candidate(1.25) == 0.25\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ precision = math.ceil(math.log(number, 10) + EPSILON)\n    number1 = int(number)\n\
    \    number2 = float(number1)\n    if number2 == 0:\n        number2 += EPSILON\n\
    \    number1 = number2 % 1\n    number2 = number2 / 1\n    return number2\n\n\n\
    def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9c2of0ry.py\", line\
    \ 26, in <module>\n    test_check()\n  File \"/tmp/tmp9c2of0ry.py\", line 24,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp9c2of0ry.py\", line\
    \ 19, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp9c2of0ry.py\"\
    , line 8, in truncate_number\n    precision = math.ceil(math.log(number, 10) +\
    \ EPSILON)\nNameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if not math.isfinite(number):\n        raise ValueError\n    if number <= 0:\n\
    \        raise ValueError\n    integer_part = math.trunc(number)\n    decimal_part\
    \ = math.fmod(number, 1)\n    if decimal_part > 0:\n        decimal_part = 1\n\
    \    return float(integer_part), decimal_part\n\n\ndef check(candidate):\n   \
    \ assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmph30uu6w7.py\", line\
    \ 27, in <module>\n    test_check()\n  File \"/tmp/tmph30uu6w7.py\", line 25,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmph30uu6w7.py\", line\
    \ 20, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmph30uu6w7.py\"\
    , line 8, in truncate_number\n    if not math.isfinite(number):\nNameError: name\
    \ 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return math.trunc(number)\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp42fdkr_0.py\", line\
    \ 18, in <module>\n    test_check()\n  File \"/tmp/tmp42fdkr_0.py\", line 16,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp42fdkr_0.py\", line\
    \ 11, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp42fdkr_0.py\"\
    , line 8, in truncate_number\n    return math.trunc(number)\nNameError: name 'math'\
    \ is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer_part = int(number)\n    decimal_part = number - integer_part\n    if\
    \ decimal_part > 0.5:\n        decimal_part = 1 - decimal_part\n    return float(decimal_part)\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number < 0.:\n        raise ValueError(\"number cannot be less than 0\")\n\
    \n    abs_number = abs(number)\n    decimal = abs_number - int(abs_number)\n \
    \   integer_part = abs_number - decimal\n    fraction = decimal * 10.\n    if\
    \ fraction > 1.:\n        fraction = 1.\n\n    return fraction\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpf0hwuiam.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmpf0hwuiam.py\", line 27,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpf0hwuiam.py\", line\
    \ 22, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer_part = int(number)\n    decimals = number - integer_part\n    return\
    \ float(decimals)\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ assert isinstance(number, numbers.Real), \"Number must be real\"\n    assert\
    \ isinstance(number, numbers.Integral), \"Number must be integer\"\n    assert\
    \ isinstance(number, numbers.Number), \"Number must be number\"\n\n    assert\
    \ number >= 0, \"Number must be positive\"\n\n    integer_part = int(number)\n\
    \    decimals_part = number - integer_part\n\n    # return integer\n    return\
    \ integer_part\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n  \
    \  assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n\
    \    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpi_gu2tzf.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmpi_gu2tzf.py\", line 26,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpi_gu2tzf.py\", line\
    \ 21, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpi_gu2tzf.py\"\
    , line 8, in truncate_number\n    assert isinstance(number, numbers.Real), \"\
    Number must be real\"\nNameError: name 'numbers' is not defined. Did you mean:\
    \ 'number'?\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number - int(number) % 1\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmproqmz5vt.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmproqmz5vt.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmproqmz5vt.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part = int(number)  # type: int\n    decimal_part = number - int_part  #\
    \ type: float\n\n    return decimal_part\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number - int(number) if number > 0 else 0\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part, decimal = math.modf(number)\n    decimal = int(decimal)\n    return\
    \ int_part\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert\
    \ candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n\
    \    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpju3frd76.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmpju3frd76.py\", line 19,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpju3frd76.py\", line\
    \ 14, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpju3frd76.py\"\
    , line 8, in truncate_number\n    int_part, decimal = math.modf(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer_part = 0\n    decimals = 0.0\n\n    while (number > 0):\n        integer_part\
    \ = (number // 10) * 10\n        decimals = (number % 10) / 10.0\n        number\
    \ = number - decimals\n\n    return int(decimals)\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659823412
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ \n    int_part = int(number)\n    \n    frac_part = number - int_part\n    \n\
    \    \n    decimals = abs(frac_part)\n    \n    if decimals == 0.0:\n        return\
    \ int_part\n    else:\n        return int_part + decimals\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp64epaktf.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmp64epaktf.py\", line 28,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp64epaktf.py\", line\
    \ 23, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number < 0:\n        return abs(number)\n    integer = int(number)\n    decimal\
    \ = number - integer\n    return decimal\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer, decimal = math.modf(number)\n    if decimal > 0.5:\n        return\
    \ integer\n    else:\n        return integer - 1\n\ndef check(candidate):\n  \
    \  assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmppei2cqkf.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmppei2cqkf.py\", line 20,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmppei2cqkf.py\", line\
    \ 15, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmppei2cqkf.py\"\
    , line 8, in truncate_number\n    integer, decimal = math.modf(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number - (int(number) - math.floor(number))\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp_812vte5.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmp_812vte5.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp_812vte5.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp_812vte5.py\"\
    , line 8, in truncate_number\n    return number - (int(number) - math.floor(number))\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return math.trunc(number)\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqa081jwr.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpqa081jwr.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpqa081jwr.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpqa081jwr.py\"\
    , line 8, in truncate_number\n    return math.trunc(number)\nNameError: name 'math'\
    \ is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ try:\n        if number > 0.0:\n            decimal = int(math.log10(abs(number)))\n\
    \        else:\n            decimal = 0\n    except TypeError:\n        decimal\
    \ = 0\n    if decimal > 16:\n        raise ValueError(\"Decimal too large, no\
    \ more than 16 digits: %s\" % number)\n    elif decimal < 0:\n        raise ValueError(\"\
    Decimal too small, no less than -16 digits: %s\" % number)\n    else:\n      \
    \  return number * pow(10.0, -decimal)\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptxhx641q.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmptxhx641q.py\", line 28,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmptxhx641q.py\", line\
    \ 23, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmptxhx641q.py\"\
    , line 10, in truncate_number\n    decimal = int(math.log10(abs(number)))\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if not number:\n        return number\n    if number < 0:\n        return -truncate_number(-number)\n\
    \    else:\n        integer = math.floor((number-math.floor(number))*10)\n   \
    \     decimals = number-integer\n        if decimals < 0:\n            return\
    \ -truncate_number(-decimals)\n        else:\n            return decimals\n\n\
    def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpj0k2tge9.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmpj0k2tge9.py\", line 26,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpj0k2tge9.py\", line\
    \ 21, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpj0k2tge9.py\"\
    , line 13, in truncate_number\n    integer = math.floor((number-math.floor(number))*10)\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return float(int(number))\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmprui2xy47.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmprui2xy47.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmprui2xy47.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if not isinstance(number, float):\n        raise NotAFloatOrNumber(number)\n\
    \    if not math.isfinite(number):\n        raise NotANumber(number)\n    if number\
    \ < 0:\n        raise NegativeNumber()\n    decimals = math.frexp(number)[1]\n\
    \    return number-decimals\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpi6txfuew.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpi6txfuew.py\", line 23,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpi6txfuew.py\", line\
    \ 18, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpi6txfuew.py\"\
    , line 10, in truncate_number\n    if not math.isfinite(number):\nNameError: name\
    \ 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part = int(number)\n    if number - int_part > 0:\n        return number\n\
    \    else:\n        return int_part\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpegiwnaso.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpegiwnaso.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpegiwnaso.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ number = float(number)\n    if number == 0:\n        return 0\n    decimal_part\
    \ = math.modf(number)[0]\n    whole_part = math.trunc(number)\n    decimal_part\
    \ *= 10\n    whole_part *= 10\n    if whole_part > 99:\n        return whole_part\n\
    \    else:\n        return whole_part + decimal_part\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpylomxkx_.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmpylomxkx_.py\", line 26,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpylomxkx_.py\", line\
    \ 21, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpylomxkx_.py\"\
    , line 11, in truncate_number\n    decimal_part = math.modf(number)[0]\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part, decimal_part = math.modf(number)\n    return int(decimal_part)\n\n\
    \ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpewnr0uve.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmpewnr0uve.py\", line 18,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpewnr0uve.py\", line\
    \ 13, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpewnr0uve.py\"\
    , line 8, in truncate_number\n    int_part, decimal_part = math.modf(number)\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ real_part = 0\n    decimal_part = 0.0\n    while number >= 1:\n        real_part\
    \ += 1\n        number /= 10\n        decimal_part += 1 / 10\n    return decimal_part\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmps8u7y8ef.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmps8u7y8ef.py\", line 23,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmps8u7y8ef.py\", line\
    \ 18, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return round(number, ndigits=-1)\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2dy5o7ev.py\", line\
    \ 18, in <module>\n    test_check()\n  File \"/tmp/tmp2dy5o7ev.py\", line 16,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp2dy5o7ev.py\", line\
    \ 11, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ number = round(number)\n    if number % 1.0 == 0:\n        number -= 1\n   \
    \ return number\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n \
    \   assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp6ztutnvg.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmp6ztutnvg.py\", line 19,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp6ztutnvg.py\", line\
    \ 14, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return int(number * 10) % 10\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp3odggnqx.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmp3odggnqx.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp3odggnqx.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimal_part = number % 1\n    if decimal_part == 0.0:\n        # Return zero\n\
    \        return 0.0\n    else:\n        # Truncate decimal part\n        return\
    \ float(number) - decimal_part\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgtiqffc8.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpgtiqffc8.py\", line 23,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpgtiqffc8.py\", line\
    \ 18, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return math.trunc(number * 100) / 100\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp6hdar8sq.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmp6hdar8sq.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp6hdar8sq.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp6hdar8sq.py\"\
    , line 8, in truncate_number\n    return math.trunc(number * 100) / 100\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer, decimal = math.modf(number)\n    return int(decimal)\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp05gond3f.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmp05gond3f.py\", line 18,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp05gond3f.py\", line\
    \ 13, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp05gond3f.py\"\
    , line 8, in truncate_number\n    integer, decimal = math.modf(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number - int(number) if number > 0 else 0.0\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number < 1.0:\n        raise ValueError(\"Cannot truncate number < 1.\")\n\
    \    if number == 1.0:\n        return 1.0\n    digits = math.floor(math.log(number,\
    \ 10))\n    digits_after_comma = digits - math.modf(number)[1]\n    return number\
    \ / (10**digits_after_comma)\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpzlsebun_.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpzlsebun_.py\", line 23,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpzlsebun_.py\", line\
    \ 18, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpzlsebun_.py\"\
    , line 12, in truncate_number\n    digits = math.floor(math.log(number, 10))\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number < 0:\n        raise ValueError(f\"Cannot truncate negative number\
    \ {number}\")\n\n    integer = int(number)\n    decimals = number - integer\n\n\
    \    if decimals == 0:\n        return integer\n    elif decimals > 0:\n     \
    \   return integer + decimals - 1\n    else:\n        return integer + decimals\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmparcja7zl.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmparcja7zl.py\", line 28,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmparcja7zl.py\", line\
    \ 23, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimal_part = number - math.floor(number)\n    integer_part = math.floor(number)\n\
    \    leftover_part = number - integer_part\n    return decimal_part, leftover_part\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpeuagy0pv.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpeuagy0pv.py\", line 20,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpeuagy0pv.py\", line\
    \ 15, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpeuagy0pv.py\"\
    , line 8, in truncate_number\n    decimal_part = number - math.floor(number)\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part, decimal, whole = math.modf(number)\n    return math.floor(whole) if\
    \ whole < 0 else math.ceil(whole)\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvl81ja0i.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpvl81ja0i.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpvl81ja0i.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpvl81ja0i.py\"\
    , line 8, in truncate_number\n    int_part, decimal, whole = math.modf(number)\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ num = number\n    decimal_point = ''\n    if number < 0:\n        num = -num\n\
    \        decimal_point = '-'\n    decimal_points = []\n    left_over = ''\n  \
    \  decimal_places = 0\n    precision = 0\n    sign = 1\n    while abs(num) >=\
    \ 1E20:\n        num = num / 10\n        decimal_places += 1\n    decimal_places\
    \ = decimal_places + 1\n    while abs(num) > 0:\n        digit = num % 10\n  \
    \      left_over = left_over + str(digit)\n        num = num / 10\n        if\
    \ num == 0:\n            decimal_point = '.'\n            break\n    left_over\
    \ = left_over[::-1]\n    if decimal_places > len(left_over):\n        decimal_places\
    \ = len(left_over)\n    if sign == -1:\n        sign = 1\n    left_over = left_over\
    \ + '0' * (decimal_places - len(left_over))\n    decimal_point = '.' + decimal_point\n\
    \    decimal_point += '0' * (10 - len(decimal_point))\n    left_over = left_over[::-1]\n\
    \    if precision > decimal_places:\n        decimal_point = decimal_point[:precision]\n\
    \    else:\n        decimal_point = decimal_point[:decimal_places]\n    decimal_point\
    \ += '.'\n    decimal = '.' + left_over\n    return sign * float(decimal)\n\n\n\
    def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpzl10adeh.py\", line\
    \ 55, in <module>\n    test_check()\n  File \"/tmp/tmpzl10adeh.py\", line 53,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpzl10adeh.py\", line\
    \ 48, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpzl10adeh.py\"\
    , line 44, in truncate_number\n    return sign * float(decimal)\nValueError: could\
    \ not convert string to float: '.3.50.350.0349999999999999960.00349999999999999960.000349999999999999943.5e-053.4999999999999995e-063.4999999999999993e-073.4999999999999996e-083.4999999999999995e-093.4999999999999993e-103.4999999999999995e-113.4999999999999996e-123.4999999999999997e-133.4999999999999996e-143.4999999999999997e-153.4999999999999997e-163.4999999999999996e-173.5e-183.4999999999999997e-193.4999999999999994e-203.4999999999999996e-213.4999999999999996e-223.4999999999999993e-233.5e-243.4999999999999997e-253.5e-263.5e-273.5e-283.5e-293.4999999999999996e-303.4999999999999994e-313.4999999999999993e-323.499999999999999e-333.499999999999999e-343.499999999999999e-353.4999999999999986e-363.4999999999999985e-373.4999999999999986e-383.499999999999999e-393.4999999999999985e-403.4999999999999984e-413.499999999999998e-423.4999999999999984e-433.4999999999999983e-443.499999999999998e-453.4999999999999982e-463.4999999999999983e-473.499999999999998e-483.499999999999998e-493.4999999999999976e-503.4999999999999974e-513.499999999999997e-523.499999999999997e-533.499999999999997e-543.4999999999999966e-553.4999999999999966e-563.4999999999999965e-573.4999999999999964e-583.4999999999999966e-593.4999999999999964e-603.499999999999996e-613.4999999999999963e-623.499999999999996e-633.499999999999996e-643.4999999999999963e-653.4999999999999964e-663.499999999999996e-673.499999999999996e-683.499999999999996e-693.499999999999996e-703.499999999999996e-713.499999999999996e-723.499999999999996e-733.499999999999996e-743.499999999999996e-753.4999999999999957e-763.4999999999999955e-773.4999999999999956e-783.4999999999999955e-793.499999999999996e-803.4999999999999957e-813.4999999"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimals = float(number) % 1\n    integer = int(number)\n    if decimal < 1\
    \ and decimals > 0:\n        integer += 1\n    return integer\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpb8ukrsfk.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpb8ukrsfk.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpb8ukrsfk.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpb8ukrsfk.py\"\
    , line 10, in truncate_number\n    if decimal < 1 and decimals > 0:\nNameError:\
    \ name 'decimal' is not defined. Did you mean: 'decimals'?\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer = int(number)\n    decimal = number - integer\n    return decimal\n\n\
    \ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return float(number) - float(number)%1\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpyn3nmvci.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpyn3nmvci.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpyn3nmvci.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if not isinstance(number, numbers.Number):\n        raise TypeError(f\"Expected\
    \ a number, got {number}\")\n\n    decimals = math.fabs(number) % 1\n    if decimals\
    \ >= 1:\n        return number\n    else:\n        return number - math.floor(number)\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgvwi9gdt.py\", line\
    \ 26, in <module>\n    test_check()\n  File \"/tmp/tmpgvwi9gdt.py\", line 24,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpgvwi9gdt.py\", line\
    \ 19, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpgvwi9gdt.py\"\
    , line 8, in truncate_number\n    if not isinstance(number, numbers.Number):\n\
    NameError: name 'numbers' is not defined. Did you mean: 'number'?\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ # first check if number is a perfect power of 10\n    if number < 1.0 and number\
    \ >= 0.01:\n        number = math.floor(number)\n        decimal = int(math.log10(number))\n\
    \        if decimal > 0 and number % math.pow(10, decimal) == 0:\n           \
    \ return number\n        else:\n            return 0.0\n\n    # now check whether\
    \ the number is between -10 and 10\n    if number < -1.0 and number >= -0.01:\n\
    \        number = math.ceil(number)\n        decimal = int(math.log10(number))\n\
    \        if decimal > 0 and number % math.pow(10, decimal) == 0:\n           \
    \ return number\n        else:\n            return 0.0\n\n    # if it is a float\
    \ between -10 and 10, it is still a number but truncated\n    number = round(number,\
    \ 10)\n    decimal = int(math.log10(number))\n    if decimal > 0 and number %\
    \ math.pow(10, decimal) == 0:\n        return number\n    else:\n        return\
    \ 0.0\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert\
    \ candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n\
    \    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpzcfi0ebf.py\", line\
    \ 43, in <module>\n    test_check()\n  File \"/tmp/tmpzcfi0ebf.py\", line 41,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpzcfi0ebf.py\", line\
    \ 36, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpzcfi0ebf.py\"\
    , line 28, in truncate_number\n    decimal = int(math.log10(number))\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number - math.ceil(number) if number > 0 else 0\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpdqcvefyc.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpdqcvefyc.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpdqcvefyc.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpdqcvefyc.py\"\
    , line 8, in truncate_number\n    return number - math.ceil(number) if number\
    \ > 0 else 0\nNameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if not isinstance(number, float):\n        raise ValueError('number must be\
    \ a float')\n    if number <= 0:\n        raise ValueError('number must be positive')\n\
    \    if int(number) == number:\n        raise ValueError('number must be an integer\
    \ not a float')\n    if number == int(number):\n        number = int(number)\n\
    \    if number % 1 == 0:\n        return number\n    else:\n        number *=\
    \ 10\n        dec = 0\n        while number % 10 == 0:\n            number /=\
    \ 10\n            dec += 1\n        return round(number, dec)\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp_nn7wbjb.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmp_nn7wbjb.py\", line 33,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp_nn7wbjb.py\", line\
    \ 28, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ assert number >= 0, 'number must be positive'\n    integer_part = int(number)\n\
    \    fractional_part = number - integer_part\n    return fractional_part\n\n\n\
    def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimals = 0.0\n    if number > 0.0:\n        integer = math.trunc(number)\n\
    \        decimals = number - integer\n    return decimals\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpe2dnu650.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpe2dnu650.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpe2dnu650.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpe2dnu650.py\"\
    , line 10, in truncate_number\n    integer = math.trunc(number)\nNameError: name\
    \ 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part, dec = math.modf(number)\n    if math.floor(dec) == math.floor(dec):\n\
    \        dec_value = dec\n        dec_value = 1\n    else:\n        dec_value\
    \ = math.floor(dec)\n    return int_part + (dec_value * 10)\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpabi__zhf.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpabi__zhf.py\", line 23,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpabi__zhf.py\", line\
    \ 18, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpabi__zhf.py\"\
    , line 8, in truncate_number\n    int_part, dec = math.modf(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ remainder = number % 1\n    return number - remainder\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnk8kqej_.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpnk8kqej_.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpnk8kqej_.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number == 0:\n        return 0\n    if number < 0:\n        raise ValueError(\"\
    Number must be greater than 0\")\n    if number > MAXDIGITS:\n        raise ValueError(\"\
    Number too large\")\n    if number < MINDIGITS:\n        raise ValueError(\"Number\
    \ too small\")\n    if abs(number) >= 1.0:\n        return number\n    decimals\
    \ = int(math.ceil(math.log(number, 10)))\n    number = number / float(10**decimals)\n\
    \    return number\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp11dnm57m.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmp11dnm57m.py\", line 29,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp11dnm57m.py\", line\
    \ 24, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp11dnm57m.py\"\
    , line 12, in truncate_number\n    if number > MAXDIGITS:\nNameError: name 'MAXDIGITS'\
    \ is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ assert number > 0, \"Value must be positive. Got {}\".format(number)\n    integer_part\
    \ = 0\n    decimal_part = 0\n    sign = 1\n    if number > 0:\n        integer_part,\
    \ decimal_part = math.modf(number)\n        sign = -1 if integer_part < 0 else\
    \ 1\n        decimal_part = abs(decimal_part)\n    else:\n        decimal_part\
    \ = abs(decimal_part)\n    return sign * round(decimal_part * 10 ** len(str(abs(decimal_part)))\
    \ - decimal_part, decimal_point) / decimal_part\n\n\ndef check(candidate):\n \
    \   assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmph5ka4ehs.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmph5ka4ehs.py\", line 27,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmph5ka4ehs.py\", line\
    \ 22, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmph5ka4ehs.py\"\
    , line 13, in truncate_number\n    integer_part, decimal_part = math.modf(number)\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimal_part = int(number)\n    decimal_part1 = number - decimal_part\n    return\
    \ decimal_part / decimal_part1\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpf4hocqd2.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmpf4hocqd2.py\", line 19,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpf4hocqd2.py\", line\
    \ 14, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer_part = int(number)\n    decimal_part = number - integer_part\n\n   \
    \ return decimal_part\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer_part, decimal_part = math.modf(number)\n    if decimal_part > 0:\n \
    \       return round(number, decimal_part)\n    else:\n        return round(number)\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpdmh4i011.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpdmh4i011.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpdmh4i011.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpdmh4i011.py\"\
    , line 8, in truncate_number\n    integer_part, decimal_part = math.modf(number)\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ precision = int(np.floor(np.log10(number)))\n    number *= 10 ** (-precision)\n\
    \    number = int(number)\n    return float(number - number % 1)\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpuue40eck.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpuue40eck.py\", line 20,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpuue40eck.py\", line\
    \ 15, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpuue40eck.py\"\
    , line 8, in truncate_number\n    precision = int(np.floor(np.log10(number)))\n\
    NameError: name 'np' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return math.trunc(number)\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp42fdkr_0.py\", line\
    \ 18, in <module>\n    test_check()\n  File \"/tmp/tmp42fdkr_0.py\", line 16,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp42fdkr_0.py\", line\
    \ 11, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp42fdkr_0.py\"\
    , line 8, in truncate_number\n    return math.trunc(number)\nNameError: name 'math'\
    \ is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number - int(number)\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ assert isinstance(number, float)\n    integer_part = 0\n    decimals = 0\n \
    \   while number > 0.0:\n        integer_part = int(number)\n        decimals\
    \ = -int(math.log10(number)) + 1\n        number = float(number - integer_part)\
    \ / math.pow(10, decimals)\n    return number\n\n\ndef check(candidate):\n   \
    \ assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpsi81t3n0.py\", line\
    \ 26, in <module>\n    test_check()\n  File \"/tmp/tmpsi81t3n0.py\", line 24,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpsi81t3n0.py\", line\
    \ 19, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpsi81t3n0.py\"\
    , line 13, in truncate_number\n    decimals = -int(math.log10(number)) + 1\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ number = float(number)\n    integer, decimal = math.modf(number)\n    integer\
    \ *= 10 ** decimal\n    return integer\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmprjefno46.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmprjefno46.py\", line 19,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmprjefno46.py\", line\
    \ 14, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmprjefno46.py\"\
    , line 9, in truncate_number\n    integer, decimal = math.modf(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number < 1:\n        raise ValueError(\n            \"Cannot truncate a number\
    \ less than or equal to 1 (value: %s).\" % number\n        )\n    wholes = math.floor((number\
    \ * 100) / 1)\n    decimal = int(round((number - wholes) * 100))\n    return decimal\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmps9hdo8p7.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmps9hdo8p7.py\", line 23,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmps9hdo8p7.py\", line\
    \ 18, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmps9hdo8p7.py\"\
    , line 12, in truncate_number\n    wholes = math.floor((number * 100) / 1)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer_part = np.floor(np.trunc(number))\n    decimals = np.abs(number - integer_part)\n\
    \    return decimals\n\n\ndef check(candidate):\n    assert candidate(3.5) ==\
    \ 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpy8wwczb6.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmpy8wwczb6.py\", line 19,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpy8wwczb6.py\", line\
    \ 14, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpy8wwczb6.py\"\
    , line 8, in truncate_number\n    integer_part = np.floor(np.trunc(number))\n\
    NameError: name 'np' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ remainder = fmod(number, 1)\n    if remainder < 0.5:\n        return float(number-1)\n\
    \    else:\n        return float(number)\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmppva85zj4.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmppva85zj4.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmppva85zj4.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmppva85zj4.py\"\
    , line 8, in truncate_number\n    remainder = fmod(number, 1)\nNameError: name\
    \ 'fmod' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part, decimal_part = math.modf(number)\n    decimal_part = max(decimal_part,\
    \ 1)\n    return decimal_part\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpso7tz7wd.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmpso7tz7wd.py\", line 19,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpso7tz7wd.py\", line\
    \ 14, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpso7tz7wd.py\"\
    , line 8, in truncate_number\n    int_part, decimal_part = math.modf(number)\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number == 0.0:\n        return number\n    if number < 0.01:\n        raise\
    \ ValueError(f\"TruncateNumber for {number:.3f}: not positive number.\")\n   \
    \ elif abs(number) > 1.0:\n        return number\n    elif number < 0.0:\n   \
    \     return 0.0\n\n    # find fractional part\n    fraction = number - int(number)\n\
    \    if abs(fraction) > 1.0:\n        return number\n\n    # find integer part\n\
    \    integer = int(number)\n\n    # find decimal part\n    decimal = integer %\
    \ 10\n    while decimal != 0:\n        integer = (integer // 10) + 1\n       \
    \ decimal = (integer % 10) - 1\n    return float(integer) * 10 + float(decimal)\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpctftyjsb.py\", line\
    \ 41, in <module>\n    test_check()\n  File \"/tmp/tmpctftyjsb.py\", line 39,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpctftyjsb.py\", line\
    \ 34, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimal_part = None\n    integer_part = abs(number)\n    # Integer part is larger\
    \ than number\n    if integer_part > number:\n        integer_part = None\n  \
    \      decimal_part = number - integer_part\n    else:\n        decimal_part =\
    \ number - integer_part\n    return float(decimal_part)\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgd4kbx3h.py\", line\
    \ 27, in <module>\n    test_check()\n  File \"/tmp/tmpgd4kbx3h.py\", line 25,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpgd4kbx3h.py\", line\
    \ 20, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer = int(number)\n    decimals = number - integer\n    decimals = decimals\
    \ + 1 if decimals > 0 else 0\n    return integer, decimals\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpf8ax1qt9.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpf8ax1qt9.py\", line 20,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpf8ax1qt9.py\", line\
    \ 15, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ float_num = float(number)\n    integer_part = int(float_num)\n    decimal_part\
    \ = float_num - integer_part\n\n    return decimal_part\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number < 1.0:\n        return number\n\n    int_part = int(number)\n    decimal_part\
    \ = number - int_part\n    if decimal_part < 0:\n        return 1.0\n    return\
    \ decimal_part\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ \n    # Make sure number is positive\n    if number <= 0:\n        raise ValueError(\"\
    Number must be positive\")\n        \n    # Decompose the number into integer\
    \ and decimal part\n    int_part, decimal_part = math.modf(number)\n    \n   \
    \ # If decimal part is smaller than 1, truncate decimal part (to nearest integer)\n\
    \    if decimal_part < 1:\n        decimal_part = math.floor(decimal_part)\n \
    \   \n    # Truncate decimal part (if decimal part is larger than whole number,\
    \ truncate to the end)\n    if decimal_part > number:\n        decimal_part =\
    \ number\n    \n    return int(int_part), decimal_part\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp024fauoz.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmp024fauoz.py\", line 33,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp024fauoz.py\", line\
    \ 28, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp024fauoz.py\"\
    , line 14, in truncate_number\n    int_part, decimal_part = math.modf(number)\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ # noinspection PyTypeChecker\n    int_part, decimal_part = math.modf(number)\n\
    \n    return decimal_part\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpyjw__oug.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpyjw__oug.py\", line 20,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpyjw__oug.py\", line\
    \ 15, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpyjw__oug.py\"\
    , line 9, in truncate_number\n    int_part, decimal_part = math.modf(number)\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return round(number % 1, ndigits=-1)\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpo31f6_ui.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpo31f6_ui.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpo31f6_ui.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ assert number > 0, \"number must be a positive number\"\n    if number <= 1E-15:\n\
    \        return number\n    decimals = round(number, 10)\n    if decimals < 1:\n\
    \        decimals = 1\n    return decimals\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp97a4hoqh.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmp97a4hoqh.py\", line 22,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp97a4hoqh.py\", line\
    \ 17, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer_part = math.trunc(number)\n    decimal_part = number - integer_part\n\
    \    return decimal_part\n\ndef check(candidate):\n    assert candidate(3.5) ==\
    \ 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfjgjpkzf.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmpfjgjpkzf.py\", line 18,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpfjgjpkzf.py\", line\
    \ 13, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpfjgjpkzf.py\"\
    , line 8, in truncate_number\n    integer_part = math.trunc(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number * 10 ** (Decimal(str(round(math.log10(number)), 10)) - 1)\n\n\n\
    @jit(nopython=True)\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpat8xcj2s.py\", line\
    \ 11, in <module>\n    @jit(nopython=True)\nNameError: name 'jit' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimal = number % 1\n    return number - decimal\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnvs5zipn.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpnvs5zipn.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpnvs5zipn.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimal_part_len = round(-number)\n    if number > 0.5:\n        decimal_part_len\
    \ += 1\n    return number - decimal_part_len\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkg0aphap.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpkg0aphap.py\", line 20,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpkg0aphap.py\", line\
    \ 15, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number > 1.0:\n        decimal_places = int(np.floor(np.log10(number)))\n\
    \    else:\n        decimal_places = 0\n    number = round(number, decimal_places)\n\
    \    return number\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9d72u3af.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmp9d72u3af.py\", line 22,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp9d72u3af.py\", line\
    \ 17, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp9d72u3af.py\"\
    , line 9, in truncate_number\n    decimal_places = int(np.floor(np.log10(number)))\n\
    NameError: name 'np' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part = int(number)\n    decimal_part = number - int_part\n    return decimal_part\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if not isinstance(number, (int, float)):\n        raise TypeError(\"Argument\
    \ is not a number.\")\n    if number < 0:\n        raise ValueError(\"Argument\
    \ must be positive.\")\n\n    integer = int(number)\n    decimal = number - integer\n\
    \    if decimal > 0:\n        decimal = decimal * 100\n    else:\n        decimal\
    \ = 0\n    return decimal\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnze5syy6.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpnze5syy6.py\", line 28,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpnze5syy6.py\", line\
    \ 23, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return round(number, ROUND_DIGITS)\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpaxu6pwlt.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpaxu6pwlt.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpaxu6pwlt.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpaxu6pwlt.py\"\
    , line 8, in truncate_number\n    return round(number, ROUND_DIGITS)\nNameError:\
    \ name 'ROUND_DIGITS' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number <= 0:\n        return 0\n    multiplier = math.log10(number)\n   \
    \ integer_part = number // math.pow(10, multiplier)\n    decimal = number - integer_part\
    \ * math.pow(10, multiplier)\n    return decimal\n\ndef check(candidate):\n  \
    \  assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvg16_yig.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpvg16_yig.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpvg16_yig.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpvg16_yig.py\"\
    , line 10, in truncate_number\n    multiplier = math.log10(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ try:\n        return int(number) if number > 0 else 0\n    except TypeError:\n\
    \        pass\n\n    # First try a binary search\n    precision = int(math.log10(number))\n\
    \    precision = min(precision, 6)\n    intervals = [i * 10**(precision - i) for\
    \ i in range(precision)]\n\n    integral = truncate_number(number / intervals[0])\n\
    \    decimal = truncate_number(intervals[precision - 1]) * (number / integral)\n\
    \n    return round(decimal)\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpk1wc2hrl.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpk1wc2hrl.py\", line 30,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpk1wc2hrl.py\", line\
    \ 25, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part = number\n    decimals = 0\n    while abs(int_part) < 1:\n        int_part\
    \ = int_part * 10\n        decimals += 1\n    decimals = decimals - 1\n    return\
    \ float(int_part) / float(10 ** decimals)\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpsl1iu4uo.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpsl1iu4uo.py\", line 23,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpsl1iu4uo.py\", line\
    \ 18, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ float_parts = number.as_integer_ratio()\n    int_part = float_parts[0]\n   \
    \ decimal_part = float_parts[1]\n    return decimal_part\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9q9elp6r.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmp9q9elp6r.py\", line 20,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp9q9elp6r.py\", line\
    \ 15, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimals = int(number) % 1\n    return number-decimals if decimals < 0.5 else\
    \ number\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert\
    \ candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n\
    \    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpv7018lh4.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpv7018lh4.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpv7018lh4.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer_part = int(number)\n    if number - integer_part < 0:\n        return\
    \ float(integer_part)\n    return float(number) - integer_part\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number - int(number)\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ number, integer = math.modf(number)\n    return round(number, 10) if integer\
    \ == 0 else number\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpyongqdpi.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmpyongqdpi.py\", line 18,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpyongqdpi.py\", line\
    \ 13, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpyongqdpi.py\"\
    , line 8, in truncate_number\n    number, integer = math.modf(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return round(number, int(math.log10(abs(number))) + 1)\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp07d_sen8.py\", line\
    \ 18, in <module>\n    test_check()\n  File \"/tmp/tmp07d_sen8.py\", line 16,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp07d_sen8.py\", line\
    \ 11, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp07d_sen8.py\"\
    , line 8, in truncate_number\n    return round(number, int(math.log10(abs(number)))\
    \ + 1)\nNameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number < 0:\n        raise ValueError('Negative value passed')\n    if number\
    \ < 1:\n        raise ValueError('Not a positive value')\n    if number == 1:\n\
    \        return 1\n    return math.ceil(number * 10) / 10\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfe5ep7t4.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpfe5ep7t4.py\", line 23,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpfe5ep7t4.py\", line\
    \ 18, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpfe5ep7t4.py\"\
    , line 14, in truncate_number\n    return math.ceil(number * 10) / 10\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number - int(number * (1 / number))\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpoal74eqy.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpoal74eqy.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpoal74eqy.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ digits = len(str(number))\n\n    if digits <= 1:\n        return number\n\n\
    \    truncation_length = min(max(digits // 2, 1), 3)\n    number = number * 10**truncation_length\n\
    \n    return number / 10**truncation_length\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpabq575si.py\", line\
    \ 27, in <module>\n    test_check()\n  File \"/tmp/tmpabq575si.py\", line 25,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpabq575si.py\", line\
    \ 20, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimals = 0.0\n    integers = math.trunc(number)\n    if math.fmod(number,\
    \ 1) > 0:\n        decimals += 1\n    return (round(integers, decimals) if decimals\
    \ <= 0 else math.trunc(number))\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp289d3gdb.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmp289d3gdb.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp289d3gdb.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp289d3gdb.py\"\
    , line 9, in truncate_number\n    integers = math.trunc(number)\nNameError: name\
    \ 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part = int(number)\n    decimal_part = round(number - int_part, 1)\n   \
    \ return decimal_part\n\n\ndef check(candidate):\n    assert candidate(3.5) ==\
    \ 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpt4ohuyo3.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmpt4ohuyo3.py\", line 19,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpt4ohuyo3.py\", line\
    \ 15, in check\n    assert candidate(1.25) == 0.25\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number - int(number)\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ number = float(number)\n    integer_part = int(number)\n    remainder = number\
    \ - integer_part\n\n    # if the number is really large, just use integer part\n\
    \    if abs(number) >= (10 ** 7):\n        return integer_part\n\n    # otherwise,\
    \ decompose the number into integer part and decimals\n    fractional_part = abs(remainder)\n\
    \    fractional_part_as_float = fractional_part / 10\n    decimal = fractional_part_as_float\
    \ * 10\n    integer_part = integer_part + decimal\n    integer_part = int(integer_part)\n\
    \n    # if the fractional part is too large, just use integer part\n    if fractional_part\
    \ >= (10 ** 6):\n        return integer_part\n\n    # otherwise, add trailing\
    \ zeros\n    fractional_part_as_str = str(fractional_part_as_float)\n    if len(fractional_part_as_str)\
    \ < 6:\n        fractional_part_as_str = (\"0\" * (6 - len(fractional_part_as_str)))\
    \ + fractional_part_as_str\n    fractional_part = fractional_part_as_str\n\n \
    \   return integer_part + fractional_part\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbmue8hk6.py\", line\
    \ 44, in <module>\n    test_check()\n  File \"/tmp/tmpbmue8hk6.py\", line 42,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpbmue8hk6.py\", line\
    \ 37, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpbmue8hk6.py\"\
    , line 33, in truncate_number\n    return integer_part + fractional_part\nTypeError:\
    \ unsupported operand type(s) for +: 'int' and 'str'\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number < 1.0:\n        return number\n    else:\n        return number -\
    \ int(number)\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n \
    \   assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimal_part = Decimal(number)\n    decimal_part_int, digits_after_dot = decimal_part.as_tuple()\n\
    \    digits_after_dot = (digits_after_dot + 1) if (digits_after_dot < 1) else\
    \ 1\n    return float(decimal_part_int) + Decimal(10 ** -digits_after_dot)\n\n\
    def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0u6bma3v.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmp0u6bma3v.py\", line 19,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp0u6bma3v.py\", line\
    \ 14, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp0u6bma3v.py\"\
    , line 8, in truncate_number\n    decimal_part = Decimal(number)\nNameError: name\
    \ 'Decimal' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part, decimal_part = math.modf(number)\n    decimal_part_int = int(decimal_part)\n\
    \    decimal_part_rem = abs(decimal_part - decimal_part_int)\n    decimal_part_rem\
    \ = decimal_part_rem / 10\n    return decimal_part_rem if decimal_part_rem > 0.0\
    \ else 0.0\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert\
    \ candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n\
    \    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp1lolxyv1.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmp1lolxyv1.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp1lolxyv1.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp1lolxyv1.py\"\
    , line 8, in truncate_number\n    int_part, decimal_part = math.modf(number)\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return math.trunc(number) if number > 0 else 0\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbb74ux0q.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpbb74ux0q.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpbb74ux0q.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpbb74ux0q.py\"\
    , line 8, in truncate_number\n    return math.trunc(number) if number > 0 else\
    \ 0\nNameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ precision = 1\n    while True:\n        fraction = number % 1\n        number\
    \ //= 10\n        if number >= precision:\n            break\n        precision\
    \ += 1\n\n    return float(fraction * 10 ** (precision - 1))\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659823412
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number - int(number * (10 ** (len(str(number)) - 1))) / float(10 ** len(str(number)))\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpe02dexvx.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpe02dexvx.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpe02dexvx.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer = round(number)\n    if number == integer:\n        return number\n\n\
    \    if number < 0:\n        return number - integer\n\n    return integer\n\n\
    \ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpf3nv3em9.py\", line\
    \ 26, in <module>\n    test_check()\n  File \"/tmp/tmpf3nv3em9.py\", line 24,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpf3nv3em9.py\", line\
    \ 19, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ sign = 1 if number > 0 else -1\n    if number <= 0:\n        raise ValueError(\"\
    Only positive numbers can be truncated.\")\n    # Convert to integer and drop\
    \ decimals.\n    integer = int(number)\n    # Round the integer part towards zero.\
    \ Because the decimal part cannot\n    # be exactly represented, the fractional\
    \ part is rounded. Rounded numbers\n    # often have an integer part that is more\
    \ than a power of 2, e.g. 9.8 rounds\n    # to 10 but 9.999999998 rounds to 9.\n\
    \    return sign * (integer - math.floor(integer)) if number > 0 else number\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmphtsqkabf.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmphtsqkabf.py\", line 26,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmphtsqkabf.py\", line\
    \ 21, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmphtsqkabf.py\"\
    , line 17, in truncate_number\n    return sign * (integer - math.floor(integer))\
    \ if number > 0 else number\nNameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ exponent = math.floor(math.log(number, 10))\n    decimals = number - decimals_to_fraction(exponent)\n\
    \    if decimals >= 1.0:\n        decimals = 1.0\n    fraction = decimals_to_fraction(exponent)\n\
    \    fractional = decimals_to_fractional(exponent)\n    return fraction * fractional\n\
    \n\n@attr.s(frozen=True)\ndef check(candidate):\n    assert candidate(3.5) ==\
    \ 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmprm_quhnl.py\", line\
    \ 17, in <module>\n    @attr.s(frozen=True)\nNameError: name 'attr' is not defined.\
    \ Did you mean: 'aiter'?\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number % 1\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ precision = abs(number.as_tuple().exponent)\n    decimal_part = float(number).as_tuple().mantissa\
    \ * pow(10, -precision)\n    if decimal_part >= 1:\n        decimal_part -= 1\n\
    \    return decimal_part\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmplzflrj8c.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmplzflrj8c.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmplzflrj8c.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmplzflrj8c.py\"\
    , line 8, in truncate_number\n    precision = abs(number.as_tuple().exponent)\n\
    AttributeError: 'float' object has no attribute 'as_tuple'\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ number = float(number)\n    int_part = int(number)\n    decimal_part = number\
    \ - int_part\n    return decimal_part\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ float_num = float(number)\n    if float_num == 0:\n        raise ValueError(\"\
    Given number can't be zero.\")\n\n    remainder = float_num % 1\n    int_part\
    \ = float_num - remainder\n    return int_part\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpoa_b642_.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpoa_b642_.py\", line 22,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpoa_b642_.py\", line\
    \ 17, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ rounded_number = round(number)\n    decimals = abs(int(number - rounded_number))\n\
    \n    return rounded_number + decimals\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpchuabgok.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpchuabgok.py\", line 20,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpchuabgok.py\", line\
    \ 15, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer = int(number)\n    decimal = number - integer\n\n    return decimal\n\
    \ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if not isinstance(number, float):\n        raise TypeError('Expecting a floating\
    \ point number.')\n\n    integer_part = int(number)\n    decimals = number - integer_part\n\
    \    if decimals < 1:\n        raise ValueError(\n            f'Decimal part {decimals}\
    \ should be at least 1.')\n\n    return float(integer_part) / float(decimals)\n\
    \n\n@functools.lru_cache(None)\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmppsyzvllk.py\", line\
    \ 20, in <module>\n    @functools.lru_cache(None)\nNameError: name 'functools'\
    \ is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part, decimal = divmod(number, 1)\n    decimal = 1 if decimal > 0 else 0\n\
    \    return int_part, decimal\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpzcyizbha.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmpzcyizbha.py\", line 18,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpzcyizbha.py\", line\
    \ 13, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return float(number.as_integer_ratio()[1])\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0k2ndz35.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmp0k2ndz35.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp0k2ndz35.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer = int(number) if number - int(number) >= 0.0 else 0.0\n    decimals\
    \ = number - integer\n    return decimals\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer_part = int(number)  # largest integer smaller than given number\n  \
    \  decimal_part = number - integer_part  # leftover part always smaller than 1\n\
    \n    return decimal_part\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number < 0:\n        raise ValueError(\"Input number should be positive\"\
    )\n    if abs(number) < 1:\n        raise ValueError(\"Input number should be\
    \ small\")\n\n    integer_part = int(number)\n    decimal_part = number - integer_part\n\
    \    decimal_part_is_zero = abs(decimal_part) < 1\n    if abs(decimal_part) >\
    \ 1e-7:\n        raise ValueError(\"Input number should be small\")\n\n    if\
    \ integer_part < 0:\n        raise ValueError(\"Negative integer not allowed\"\
    )\n\n    return float(integer_part), float(decimal_part_is_zero)\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp135da5ng.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmp135da5ng.py\", line 31,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp135da5ng.py\", line\
    \ 26, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp135da5ng.py\"\
    , line 17, in truncate_number\n    raise ValueError(\"Input number should be small\"\
    )\nValueError: Input number should be small\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ \n    trunc = 0\n    while number >= 1:\n        trunc += 1\n        number\
    \ /= 10\n    \n    return trunc\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpznt1kd75.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpznt1kd75.py\", line 23,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpznt1kd75.py\", line\
    \ 18, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer, decimals = math.modf(number)\n    return integer\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp44jdelbp.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmp44jdelbp.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp44jdelbp.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp44jdelbp.py\"\
    , line 8, in truncate_number\n    integer, decimals = math.modf(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return math.trunc(number) if number < 1 else number\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2nv924wb.py\", line\
    \ 18, in <module>\n    test_check()\n  File \"/tmp/tmp2nv924wb.py\", line 16,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp2nv924wb.py\", line\
    \ 11, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer = int(number)\n    decimals = number - integer\n    return decimals\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part = number / 10 ** len(str(int(number)))\n    remainder = (number - int_part\
    \ * 10 ** len(str(int(number)))) / 10 ** len(str(int(number)))\n    return int_part\
    \ + remainder\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n   \
    \ assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n\
    \    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpuwr5s1sy.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmpuwr5s1sy.py\", line 18,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpuwr5s1sy.py\", line\
    \ 13, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ # noinspection PyUnresolvedReferences\n    import math\n\n    fractional_part\
    \ = math.modf(number - 1)[1]\n\n    return fractional_part * (10 ** math.floor(math.log(fractional_part,\
    \ 10)))\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert\
    \ candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n\
    \    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp592rwf6y.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmp592rwf6y.py\", line 22,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp592rwf6y.py\", line\
    \ 17, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return float(str(number)[:len(str(number))-1])\n\ndef check(candidate):\n  \
    \  assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpj01g3yo4.py\", line\
    \ 18, in <module>\n    test_check()\n  File \"/tmp/tmpj01g3yo4.py\", line 16,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpj01g3yo4.py\", line\
    \ 11, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if not number:\n        return 0.0\n    integer_part = int(number)\n    decimal_part\
    \ = number - integer_part\n    return float(decimal_part)\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return round(number, abs(number.as_tuple().exponent))\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpy0sz_iss.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpy0sz_iss.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpy0sz_iss.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpy0sz_iss.py\"\
    , line 8, in truncate_number\n    return round(number, abs(number.as_tuple().exponent))\n\
    AttributeError: 'float' object has no attribute 'as_tuple'\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ trunc_num = number - int(number)\n    frac_of_num = get_fractional_part(number)\n\
    \    frac = float(frac_of_num) / num_digits(number)\n    trunc_num = int(trunc_num\
    \ * frac)\n    return trunc_num\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2mdizioc.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmp2mdizioc.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp2mdizioc.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp2mdizioc.py\"\
    , line 9, in truncate_number\n    frac_of_num = get_fractional_part(number)\n\
    NameError: name 'get_fractional_part' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ # Truncate floating point numbers to the decimal part\n    numbers_to_truncate\
    \ = []\n    while number >= 1:\n        numbers_to_truncate.append(number)\n \
    \       number = number * 10\n    # Get the integer part and truncate it to 4\
    \ decimal places\n    decimal_part = float(numbers_to_truncate[-1])\n    integer_part\
    \ = round(decimal_part * 4)\n    return round(integer_part)\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659823413
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part, decimal = math.modf(number)\n    # we round up so that all decimals\
    \ are covered\n    return math.trunc(decimal)\n\n\ndef check(candidate):\n   \
    \ assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp07omxrs8.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmp07omxrs8.py\", line 19,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp07omxrs8.py\", line\
    \ 14, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp07omxrs8.py\"\
    , line 8, in truncate_number\n    int_part, decimal = math.modf(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return int(number)\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpr4nfpqro.py\", line\
    \ 18, in <module>\n    test_check()\n  File \"/tmp/tmpr4nfpqro.py\", line 16,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpr4nfpqro.py\", line\
    \ 11, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number == 0:\n        return 0.0\n\n    factor = 10.0\n    denominator =\
    \ pow(10.0, abs(int(log10(number))))\n    int_part = number / denominator\n  \
    \  decimal_part = number - int_part * denominator\n\n    return decimal_part\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp1pp_ftly.py\", line\
    \ 27, in <module>\n    test_check()\n  File \"/tmp/tmp1pp_ftly.py\", line 25,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp1pp_ftly.py\", line\
    \ 20, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp1pp_ftly.py\"\
    , line 12, in truncate_number\n    denominator = pow(10.0, abs(int(log10(number))))\n\
    NameError: name 'log10' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ # Avoiding division by zero in case of negative number\n    if number <= 0:\n\
    \        return 0.0\n\n    # Truncate decimal part\n    number = int(number)\n\
    \    decimal = 0\n    while number > 1:\n        decimal += 1\n        number\
    \ /= 10\n\n    return number\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpznfptrzq.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmpznfptrzq.py\", line 27,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpznfptrzq.py\", line\
    \ 22, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer = int(number)\n    decimal = int(number % 1)\n    decimal = math.fabs(decimal)\n\
    \    if decimal > 0:\n        return number - decimal\n    else:\n        return\
    \ integer\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert\
    \ candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n\
    \    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpv3ss5eqx.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpv3ss5eqx.py\", line 23,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpv3ss5eqx.py\", line\
    \ 18, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpv3ss5eqx.py\"\
    , line 10, in truncate_number\n    decimal = math.fabs(decimal)\nNameError: name\
    \ 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number - math.floor(number)\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnyf1oa70.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpnyf1oa70.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpnyf1oa70.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpnyf1oa70.py\"\
    , line 8, in truncate_number\n    return number - math.floor(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ rounded_number = round(number)\n    decimal_places = _get_decimal_places(rounded_number)\n\
    \    trunc_number = rounded_number - decimal_places\n    return trunc_number\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpb7fbgumc.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpb7fbgumc.py\", line 20,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpb7fbgumc.py\", line\
    \ 15, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpb7fbgumc.py\"\
    , line 9, in truncate_number\n    decimal_places = _get_decimal_places(rounded_number)\n\
    NameError: name '_get_decimal_places' is not defined. Did you mean: 'decimal_places'?\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer_part = int(number)\n    if integer_part == 0:\n        return 0.0\n\
    \    decimal_part = round(number - integer_part)\n    return decimal_part\n\n\n\
    def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp3az9n6x4.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmp3az9n6x4.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp3az9n6x4.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimals = math.floor(-math.log10(abs(number))) + 1\n    if decimals > 1:\n\
    \        decimals = decimals\n    else:\n        decimals = decimals\n\n    return\
    \ number - (decimals * 10 ** (-decimals))\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0ksirths.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmp0ksirths.py\", line 23,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp0ksirths.py\", line\
    \ 18, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp0ksirths.py\"\
    , line 8, in truncate_number\n    decimals = math.floor(-math.log10(abs(number)))\
    \ + 1\nNameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part = math.trunc(number)\n    decimal_part = number - int_part\n    return\
    \ decimal_part\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqb7u70wb.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmpqb7u70wb.py\", line 19,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpqb7u70wb.py\", line\
    \ 14, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpqb7u70wb.py\"\
    , line 8, in truncate_number\n    int_part = math.trunc(number)\nNameError: name\
    \ 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ fraction, integer = math.modf(number)\n    return integer\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0dbwpvsa.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmp0dbwpvsa.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp0dbwpvsa.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp0dbwpvsa.py\"\
    , line 8, in truncate_number\n    fraction, integer = math.modf(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number == 0.:\n        return 0.\n    decimals = 0.\n    if number >= 1.0:\n\
    \        decimals = math.floor(math.log(number, 10))\n        number = math.pow(10.,\
    \ decimals)\n    else:\n        decimals = math.floor(math.log(1.0, 10))\n   \
    \ return number, decimals\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpeq4n835w.py\", line\
    \ 27, in <module>\n    test_check()\n  File \"/tmp/tmpeq4n835w.py\", line 25,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpeq4n835w.py\", line\
    \ 20, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpeq4n835w.py\"\
    , line 12, in truncate_number\n    decimals = math.floor(math.log(number, 10))\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part, decimal_part = math.modf(number)\n    return decimal_part\n\n\ndef\
    \ check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp5meajijh.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmp5meajijh.py\", line 18,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp5meajijh.py\", line\
    \ 13, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp5meajijh.py\"\
    , line 8, in truncate_number\n    int_part, decimal_part = math.modf(number)\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return math.trunc(number) if number > 0 else 0\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbb74ux0q.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpbb74ux0q.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpbb74ux0q.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpbb74ux0q.py\"\
    , line 8, in truncate_number\n    return math.trunc(number) if number > 0 else\
    \ 0\nNameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part, dec_part = math.modf(number)\n    int_part = int(int_part)\n    frac_part\
    \ = number - int_part\n    frac_part = min(1.0, frac_part)\n    return frac_part\
    \ * 10 ** int(math.ceil(math.log10(frac_part)))\n\n\ndef check(candidate):\n \
    \   assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnkds_u8w.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpnkds_u8w.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpnkds_u8w.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpnkds_u8w.py\"\
    , line 8, in truncate_number\n    int_part, dec_part = math.modf(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ number_as_int = int(number)\n    number_as_float =  float(number)\n    if number_as_int\
    \ % 1 != 0:\n        return number\n    elif number_as_float % 1 != 0:\n     \
    \   return number_as_float\n    else:\n        return number_as_float - number_as_int\n\
    \ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp4ssrsi_l.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmp4ssrsi_l.py\", line 23,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp4ssrsi_l.py\", line\
    \ 18, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number - int(number)\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823407
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimal: float = number - int(number)\n    return decimal\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimals = 0\n    if number < 0:\n        decimals = 1\n        number = -number\n\
    \    if abs(number) < 1.0:\n        decimals = -1\n        number = number * 100\n\
    \    return round(number, decimals)\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp42f5mau3.py\", line\
    \ 26, in <module>\n    test_check()\n  File \"/tmp/tmp42f5mau3.py\", line 24,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp42f5mau3.py\", line\
    \ 19, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number < 1:\n        raise ValueError(f\"Given number {number} < 1.\")\n\
    \    if number == int(number):\n        return int(number)\n    else:\n      \
    \  return number - int(number)\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp8k3ei3pi.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmp8k3ei3pi.py\", line 22,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp8k3ei3pi.py\", line\
    \ 19, in check\n    assert candidate(123.0) == 0.0\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ intpart, decimalpart = math.modf(number)\n    if decimalpart > 0:\n        return\
    \ intpart + decimalpart\n    else:\n        return intpart\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmphjqhby5x.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmphjqhby5x.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmphjqhby5x.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmphjqhby5x.py\"\
    , line 8, in truncate_number\n    intpart, decimalpart = math.modf(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer_part, remainder = divmod(number, 1)\n    if remainder != 0:\n      \
    \  raise ValueError(f\"Floating point number {number} cannot be truncated to whole\
    \ number\")\n    return integer_part\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp4xqi_6p7.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmp4xqi_6p7.py\", line 20,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp4xqi_6p7.py\", line\
    \ 15, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp4xqi_6p7.py\"\
    , line 10, in truncate_number\n    raise ValueError(f\"Floating point number {number}\
    \ cannot be truncated to whole number\")\nValueError: Floating point number 3.5\
    \ cannot be truncated to whole number\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimal_part: float = number % 1\n    integer_part: float = number - decimal_part\n\
    \    return decimal_part\n\ndef check(candidate):\n    assert candidate(3.5) ==\
    \ 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if not number:\n        raise ValueError(\"'number' must be a valid non-empty\
    \ number\")\n    if not is_number(number):\n        raise TypeError(f\"'number'\
    \ must be a valid non-empty number\")\n    int_part = None\n    decimal_part =\
    \ None\n    try:\n        int_part = int(number)\n    except ValueError:\n   \
    \     pass\n    else:\n        if int_part > number:\n            int_part = int(number\
    \ - 1)\n    if int_part is not None:\n        decimal_part = number - int_part\n\
    \    return decimal_part\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpusxdesdx.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpusxdesdx.py\", line 32,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpusxdesdx.py\", line\
    \ 27, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpusxdesdx.py\"\
    , line 10, in truncate_number\n    if not is_number(number):\nNameError: name\
    \ 'is_number' is not defined. Did you mean: 'number'?\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimals = int(math.floor(math.log10(number)))\n    decimals = decimals - 1\
    \ if decimals > 0 else 0\n    integer_part = number // math.pow(10, decimals)\n\
    \    decimal_part = number - integer_part * math.pow(10, decimals)\n    return\
    \ decimal_part\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpv1aha5mg.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpv1aha5mg.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpv1aha5mg.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpv1aha5mg.py\"\
    , line 8, in truncate_number\n    decimals = int(math.floor(math.log10(number)))\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ number = float(number)\n    return number - int(number)\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number < 1.0:\n        return number\n    else:\n        return int(number)\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpves2nzg2.py\", line\
    \ 22, in <module>\n    test_check()\n  File \"/tmp/tmpves2nzg2.py\", line 20,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpves2nzg2.py\", line\
    \ 15, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return math.trunc(number)\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqa081jwr.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpqa081jwr.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpqa081jwr.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpqa081jwr.py\"\
    , line 8, in truncate_number\n    return math.trunc(number)\nNameError: name 'math'\
    \ is not defined\n"
  stdout: ''
  timestamp: 1659823407
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return number - math.floor(number)\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnyf1oa70.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpnyf1oa70.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpnyf1oa70.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpnyf1oa70.py\"\
    , line 8, in truncate_number\n    return number - math.floor(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number == 0:\n        return 0\n    elif number > 0:\n        return number\
    \ - math.floor(number)\n    else:\n        return math.ceil(number) - 1\n\n\n\
    def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpm_viu9ni.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpm_viu9ni.py\", line 22,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpm_viu9ni.py\", line\
    \ 17, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpm_viu9ni.py\"\
    , line 11, in truncate_number\n    return number - math.floor(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return float(str(number)[-2])\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmphkzup17e.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmphkzup17e.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmphkzup17e.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmphkzup17e.py\"\
    , line 8, in truncate_number\n    return float(str(number)[-2])\nValueError: could\
    \ not convert string to float: '.'\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part, decimal = math.modf(number)\n    int_part = math.trunc(int_part)\n\
    \    return decimal * 10**math.ceil(math.log(abs(decimal), 10))\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpdoegv4iw.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmpdoegv4iw.py\", line 18,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpdoegv4iw.py\", line\
    \ 13, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpdoegv4iw.py\"\
    , line 8, in truncate_number\n    int_part, decimal = math.modf(number)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part = int(number)\n    if number - int_part < 0:\n        raise ValueError(\"\
    Number can't be bigger than a Python float!\")\n    decimal_part = 0\n    while\
    \ number - int_part >= 1:\n        number -= int_part\n        decimal_part +=\
    \ 1\n    return float(decimal_part + int_part)\n\n\ndef check(candidate):\n  \
    \  assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpop_3tc8r.py\", line\
    \ 26, in <module>\n    test_check()\n  File \"/tmp/tmpop_3tc8r.py\", line 24,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpop_3tc8r.py\", line\
    \ 19, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer_part, decimal = math.modf(number)\n    return float(decimal)\n\n\ndef\
    \ check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpki19g9vk.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmpki19g9vk.py\", line 18,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpki19g9vk.py\", line\
    \ 13, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpki19g9vk.py\"\
    , line 8, in truncate_number\n    integer_part, decimal = math.modf(number)\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if not isinstance(number, (int, float)):\n        raise TypeError(\"Expected\
    \ float or int, not {}\".format(type(number)))\n    if number < 0:\n        raise\
    \ ValueError(\"Expected positive value, not negative {}\".format(number))\n  \
    \  if number < 1.0:\n        return number\n    power = -int(math.floor(math.log(number)\
    \ / math.log(10)))\n    if number == 0.01:\n        return 1.0\n    if number\
    \ == 0.1:\n        return 0.1\n    if number > power:\n        return number\n\
    \    return round(number * pow(10, power), -int(power))\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpa3q8el5k.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpa3q8el5k.py\", line 30,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpa3q8el5k.py\", line\
    \ 25, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpa3q8el5k.py\"\
    , line 14, in truncate_number\n    power = -int(math.floor(math.log(number) /\
    \ math.log(10)))\nNameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimal = number - int(number)\n    decimal = int(decimal)\n    return decimal\
    \ - 1\n\n@lru_cache()\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgbwwtcx5.py\", line\
    \ 12, in <module>\n    @lru_cache()\nNameError: name 'lru_cache' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return round(number) - int(round(number))\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpu06xhrod.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpu06xhrod.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpu06xhrod.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ return round(number - int(number), 6)\n\n\ndef check(candidate):\n    assert\
    \ candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0)\
    \ == 0.0\n\ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823408
- exit_code: 0
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ integer_part = int(number)\n    decimal_part = number - integer_part\n    return\
    \ decimal_part\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n  \
    \  assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n\
    \    check(truncate_number)\n\ntest_check()\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number == 0.0:\n        return number\n\n    decimal_part = int(number)\n\
    \    return number - decimal_part * math.pow(10, len(str(number)))\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpdgsrp9sp.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpdgsrp9sp.py\", line 21,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpdgsrp9sp.py\", line\
    \ 16, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpdgsrp9sp.py\"\
    , line 12, in truncate_number\n    return number - decimal_part * math.pow(10,\
    \ len(str(number)))\nNameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number <= 0:\n        raise ValueError('Cannot truncate non-positive number.')\n\
    \    if number == 0:\n        return 0\n    if number % 1 == 0:\n        raise\
    \ ValueError('Cannot truncate even number. Try again.')\n    if number > math.pow(10,\
    \ 38):\n        raise ValueError('Number too large. Try again.')\n    numberstr\
    \ = str(number)\n    numberstrlen = len(numberstr)\n    decimals = numberstrlen\
    \ % 2\n    if decimals != 0:\n        decimals = 2\n        numberstr = numberstr[:-decimals]\n\
    \    integer = int(numberstr)\n    integer = integer % 10 ** decimals\n    return\
    \ integer / 10 ** decimals\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp6wbts2rw.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmp6wbts2rw.py\", line 33,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmp6wbts2rw.py\", line\
    \ 28, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmp6wbts2rw.py\"\
    , line 14, in truncate_number\n    if number > math.pow(10, 38):\nNameError: name\
    \ 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if number == 0:\n        return 0\n    number = str(number)\n    decimals =\
    \ []\n    while number != \"0\":\n        decimals.append(number[-1])\n      \
    \  number = number[:-1]\n    decimal = sum(decimals) / len(decimals)\n    return\
    \ float(decimal)\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpcytslnej.py\", line\
    \ 27, in <module>\n    test_check()\n  File \"/tmp/tmpcytslnej.py\", line 25,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpcytslnej.py\", line\
    \ 20, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpcytslnej.py\"\
    , line 13, in truncate_number\n    decimals.append(number[-1])\nIndexError: string\
    \ index out of range\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimal = 0\n\n    # If the number is negative, simply return 0\n    if number\
    \ < 0:\n        return 0\n\n    # If the number is a whole number, return it without\
    \ decimal part\n    if number == int(number):\n        return number\n\n    decimal\
    \ = int(math.log10(number))\n\n    return round(number - math.pow(10, -decimal))\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpxg2autfc.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpxg2autfc.py\", line 29,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpxg2autfc.py\", line\
    \ 24, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpxg2autfc.py\"\
    , line 18, in truncate_number\n    decimal = int(math.log10(number))\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimals = math.fmod(number, 1)\n    return number - decimals\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfvbz83s1.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmpfvbz83s1.py\", line 18,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpfvbz83s1.py\", line\
    \ 13, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpfvbz83s1.py\"\
    , line 8, in truncate_number\n    decimals = math.fmod(number, 1)\nNameError:\
    \ name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ precision = 0\n    number = round(number, precision)\n    while number % 1.0\
    \ == 0:\n        number /= 1.0\n        precision += 1\n    decimal = number *\
    \ 10 ** precision\n    return decimal\n\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659823413
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ precision = len(str(int(number)))\n    return round(number, precision)\n\ndef\
    \ check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpftotd09h.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpftotd09h.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpftotd09h.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ # To ensure that the number is a positive floating point number\n    # and does\
    \ not contain infinity or NaN, we use a trick to\n    # check if it is an integer.\n\
    \    if number == 0:\n        return 0\n\n    # If the number is negative, we\
    \ use a trick to check whether\n    # the number is greater than or equal to 0.\n\
    \    if number < 0:\n        if number <= -sys.float_info.epsilon:\n         \
    \   return 0\n        else:\n            # If the number is greater than -sys.float_info.epsilon\n\
    \            # we truncate the number to zero, otherwise we return the\n     \
    \       # original number because it is negative and we would not\n          \
    \  # be able to truncate it.\n            return -truncate_number(-number)\n\n\
    \    # In the case of positive floating numbers we cannot truncate\n    # the\
    \ number. The original number is larger than zero and we\n    # simply return\
    \ the number.\n    if number > 1:\n        return number\n\n    # If the number\
    \ is a NaN or infinity, we return zero.\n    if number == float('inf') or number\
    \ == float('-inf'):\n        return 0\n\n    # If the number is zero, we return\
    \ zero.\n    if number == 0:\n        return 0\n\n    # We are in the positive\
    \ case. Now we determine whether the number\n    # contains fractional part and\
    \ if yes, we decompose the number\n    # into an integer part and decimal part.\n\
    \    integer_part = int(number)\n    decimal_part = number - integer_part\n\n\
    \    # If the fractional part is non-zero we add it to the\n    # decimal part.\
    \ Because the decimal part is always less than\n    # 1 we only add it if it is\
    \ different from zero.\n    if decimal_part != 0:\n        decimal_part += truncate_number(decimal_part)\n\
    \n    # Because the integer part is always greater or equal to zero,\n    # we\
    \ can simply return the integer part if the fractional\n    # part is zero.\n\
    \    if integer_part == 0:\n        return integer_part\n\n    # If the fractional\
    \ part is larger than one, we decompose the\n    # number into integer part and\
    \ decimal part and add the\n    # fractional part to the decimal part.\n    if\
    \ decimal_part > 1:\n        integer_part += 1\n        decimal_part += truncate_number(decimal_part)\n\
    \n    # If the fractional part is smaller than one, the\n    # fractional part\
    \ should be equal to one if the integer\n    # part is zero.\n    if decimal_part\
    \ == 1:\n        return integer_part == 0\n\n    # If the fractional part is less\
    \ than one, we need to add one\n    # to the integer part because fractional part\
    \ is always less\n    # than one.\n    return integer_part == 0\n\n\ndef check(candidate):\n\
    \    assert candidate(3.5) == 0.5\n    assert candidate(1.25) == 0.25\n    assert\
    \ candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\n\
    test_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptjusmesi.py\", line\
    \ 85, in <module>\n    test_check()\n  File \"/tmp/tmptjusmesi.py\", line 83,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmptjusmesi.py\", line\
    \ 78, in check\n    assert candidate(3.5) == 0.5\nAssertionError\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ decimals = math.floor(math.log10(number))\n    return round(number / 10**decimals)\
    \ if decimals > 0 else 0.0\n\ndef check(candidate):\n    assert candidate(3.5)\
    \ == 0.5\n    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\
    \ndef test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptvcv61rs.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmptvcv61rs.py\", line 17,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmptvcv61rs.py\", line\
    \ 12, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmptvcv61rs.py\"\
    , line 8, in truncate_number\n    decimals = math.floor(math.log10(number))\n\
    NameError: name 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ int_part = math.trunc(number)\n    decimal_part = number - int_part\n    return\
    \ decimal_part\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n\
    \    assert candidate(1.25) == 0.25\n    assert candidate(123.0) == 0.0\n\ndef\
    \ test_check():\n    check(truncate_number)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqb7u70wb.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmpqb7u70wb.py\", line 19,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpqb7u70wb.py\", line\
    \ 14, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpqb7u70wb.py\"\
    , line 8, in truncate_number\n    int_part = math.trunc(number)\nNameError: name\
    \ 'math' is not defined\n"
  stdout: ''
  timestamp: 1659823408
- exit_code: -1
  program: "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n\n    Return the decimal part of the number.\n        \"\"\"\n   \
    \ if not is_number(number):\n        raise ParameterTypeError(\"Expected a number\"\
    )\n\n    integer_part = 0\n    decimal_part = 0\n\n    if number < 0:\n      \
    \  integer_part = abs(number)\n        decimal_part = 1\n\n    if number > 0:\n\
    \        while number > 1:\n            number //= 10\n            decimal_part\
    \ += 1\n\n    decimal_part = -1 * decimal_part\n\n    if decimal_part < 0:\n \
    \       integer_part -= 1\n\n    if integer_part == 0 and decimal_part == 0:\n\
    \        return 0\n\n    return round(number * 10**decimal_part) / 10**decimal_part\n\
    \n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert candidate(1.25)\
    \ == 0.25\n    assert candidate(123.0) == 0.0\n\ndef test_check():\n    check(truncate_number)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpuc8nsc14.py\", line\
    \ 42, in <module>\n    test_check()\n  File \"/tmp/tmpuc8nsc14.py\", line 40,\
    \ in test_check\n    check(truncate_number)\n  File \"/tmp/tmpuc8nsc14.py\", line\
    \ 35, in check\n    assert candidate(3.5) == 0.5\n  File \"/tmp/tmpuc8nsc14.py\"\
    , line 8, in truncate_number\n    if not is_number(number):\nNameError: name 'is_number'\
    \ is not defined. Did you mean: 'number'?\n"
  stdout: ''
  timestamp: 1659823408
