name: HumanEval_20_find_closest_elements
language: py
prompt: "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float])\
  \ -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length\
  \ at least two) select and return two that are the closest to each\n    other and\
  \ return them in order (smaller number, larger number).\n            \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])\
  \ == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n\
  \    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert\
  \ candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1,\
  \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\ndef test_check():\n    check(find_closest_elements)\n\
  \ntest_check()\n"
completions: ["    sorted_number = sorted(numbers)\n\n    min_diff = sorted_number[1]\
    \ - sorted_number[0]\n    max_diff = sorted_number[-1] - sorted_number[-2]\n\n\
    \    if min_diff == max_diff:\n        return sorted_number[0], sorted_number[1]\n\
    \n    if min_diff < max_diff:\n        closest = sorted_number[0]\n        closest_other\
    \ = sorted_number[1]\n    else:\n        closest = sorted_number[-1]\n       \
    \ closest_other = sorted_number[-2]\n\n    return closest, closest_other\n", " \
    \   assert len(numbers) > 0\n    sorted_numbers = numbers.sort()\n    return sorted_numbers[0],\
    \ sorted_numbers[-1]\n\n", "    closest_elements = []\n    for index in range(len(numbers)):\n\
    \        closest_elements.append(numbers[index])\n        closest_elements.append(numbers[index])\n\
    \n    return tuple(closest_elements)\n", "    if len(numbers) < 2:\n        raise\
    \ ValueError(\"find_closest_elements expects a list of at least two numbers\"\
    )\n\n    sorted_numbers = sorted(numbers)\n    smallest = sorted_numbers[0]\n\
    \    largest = sorted_numbers[-1]\n\n    if smallest == largest:\n        return\
    \ smallest, smallest\n\n    closest_numbers = numbers[:1]\n    for closest_number\
    \ in sorted_numbers[1:]:\n        if closest_number < smallest or closest_number\
    \ > largest:\n            return closest_numbers, closest_number\n        closest_numbers.append(closest_number)\n\
    \n    return closest_numbers, closest_number\n\n", "    if numbers[0] > numbers[1]:\n\
    \        return find_closest_elements(numbers[1:])\n\n    closest_elements = [numbers[0]]\n\
    \    \n    for number in numbers[1:]:\n        if number > numbers[0]:\n     \
    \       closest_elements.append(number)\n        elif number < closest_elements[0]:\n\
    \            closest_elements[0] = number\n\n    return closest_elements[0], closest_elements[1]\n\
    \n", "    assert len(numbers) >= 2, \"find_closest_elements needs a list of at\
    \ least 2 numbers\"\n    for a, b in pairwise(numbers):\n        if abs(a - b)\
    \ < abs(a - numbers[0]):\n            return a, b\n    return numbers[0], numbers[-1]\n\
    \n", "    min_element = min(numbers)\n    max_element = max(numbers)\n    closest_elements\
    \ = (min_element, max_element)\n\n    return closest_elements\n", "    \n    #\
    \ Your code here\n    return numbers[0] - numbers[1], numbers[1] - numbers[0]\n",
  "    if len(numbers) <= 1:\n        raise ValueError(\"The list must contain at\
    \ least two numbers\")\n\n    smallest = 0\n    largest = 1\n    index = 2\n \
    \   while index < len(numbers):\n        current = numbers[index]\n        if\
    \ current < smallest:\n            smallest = current\n        if current > largest:\n\
    \            largest = current\n        index += 1\n    \n    return smallest,\
    \ largest\n", "    sorted_numbers = sorted(numbers)\n    smaller_number = sorted_numbers[1]\n\
    \    larger_number = sorted_numbers[0]\n    return smaller_number, larger_number\n\
    \n", "    diff = numbers[1] - numbers[0]\n    for x in numbers[1:]:\n        diff\
    \ = abs(x - numbers[0])\n        if diff == numbers[0]:\n            return numbers[0],\
    \ x\n        elif diff < numbers[0]:\n            return x, numbers[0]\n     \
    \   elif diff > numbers[0]:\n            return numbers[0], x\n\n    return numbers[0],\
    \ (numbers[0] + numbers[1])/2\n", "    sorted_numbers = sorted(numbers)\n    #\
    \ return min(numbers), max(numbers)\n    if sorted_numbers[0] < sorted_numbers[1]:\n\
    \        return sorted_numbers[0], sorted_numbers[1]\n    else:\n        return\
    \ sorted_numbers[1], sorted_numbers[0]\n\n", "    distances = [(abs(numbers[num]\
    \ - numbers[num - 1]), num) for num in range(len(numbers) - 1)]\n    closests\
    \ = sorted(distances)\n    return closests\n", "    if len(numbers) < 2:\n   \
    \     raise ValueError('must have at least one number')\n    numbers.sort()\n\
    \    return numbers[-2], numbers[-1]\n\n", "    if len(numbers) < 2:\n       \
    \ return (None, None)\n    numbers.sort()\n    numbers_copy = list(numbers)\n\
    \    smallest_val = numbers[0]\n    largest_val = numbers[-1]\n    smallest_index\
    \ = 0\n    largest_index = len(numbers)-1\n    \n    while smallest_index != largest_index:\n\
    \        diff = numbers_copy[smallest_index] - numbers_copy[largest_index]\n \
    \       \n        if diff < 0 and diff > abs(smallest_val - largest_val):\n  \
    \          largest_index = largest_index + 1\n        elif diff > 0 and diff <\
    \ abs(smallest_val - largest_val):\n            smallest_index = smallest_index\
    \ - 1\n        else:\n            return (numbers_copy[smallest_index], numbers_copy[largest_index])\n\
    \    \n    return (numbers_copy[smallest_index], numbers_copy[largest_index])\n\
    \n", "    assert len(numbers) >= 2\n    smaller = numbers[0]\n    larger = numbers[0]\n\
    \    for number in numbers:\n        if number < smaller:\n            smaller\
    \ = number\n        elif number > larger:\n            larger = number\n    return\
    \ smaller, larger\n", "    smallest = numbers[0]\n    largest = numbers[0]\n\n\
    \    for number in numbers:\n        if number < smallest:\n            smallest\
    \ = number\n\n        if number > largest:\n            largest = number\n\n \
    \   return smallest, largest\n\n", "    \n    closest_number = None\n    closest_number_order\
    \ = 0\n    \n    for number in numbers:\n        if closest_number:\n        \
    \    if (abs(number - closest_number)) < (abs(closest_number - number)):\n   \
    \             closest_number = number\n                closest_number_order =\
    \ closest_number_order\n        else:\n            closest_number = number\n \
    \           closest_number_order = closest_number_order\n    \n    return closest_number,\
    \ closest_number_order\n", "    smallest = None\n    biggest = None\n    for num\
    \ in numbers:\n        if smallest is None or num < smallest:\n            smallest\
    \ = num\n        if biggest is None or num > biggest:\n            biggest = num\n\
    \n    return smallest, biggest\n", "    if len(numbers) <= 2:\n        raise ValueError(\"\
    Must supply a list with at least two numbers to find the closest to\")\n\n   \
    \ # Find the two closest numbers to each other and return them in order (smaller\
    \ number, larger number).\n    closest_numbers = [numbers[0], numbers[1]]\n  \
    \  for n in range(2, len(numbers)):\n        closest_numbers.append(min(closest_numbers[-1],\
    \ numbers[n]))\n\n    return closest_numbers\n\n", "    closest_numbers = list(sorted(numbers))\n\
    \    closest_numbers.pop(0) # Remove duplicates\n    return closest_numbers\n",
  "    if len(numbers) < 2:\n        raise ValueError(f\"Too few elements for search\"\
    )\n\n    # Find smallest number\n    smallest = min(numbers)\n    # Find largest\
    \ number\n    largest = max(numbers)\n\n    # Return both values if the difference\
    \ between them is too big (to deal with rounding errors)\n    if largest - smallest\
    \ > .0000001:\n        return (smallest, largest)\n    else:\n        # Use first\
    \ element as pivot (smallest element is not guaranteed to be a pivot)\n      \
    \  pivot = numbers[0]\n        # Find where the pivot should be placed within\
    \ the sorted list\n        left = 0\n        right = len(numbers) - 1\n      \
    \  while left < right:\n            mid = (left + right) // 2\n            if\
    \ numbers[mid] < pivot:\n                left = mid + 1\n            else:\n \
    \               right = mid\n        # Return the two closest numbers\n      \
    \  return (numbers[left], numbers[right])\n", "    assert len(numbers) > 0\n \
    \   if len(numbers) == 1: return numbers[0], numbers[0]\n    if len(numbers) ==\
    \ 2: return numbers[0], numbers[1]\n    closest_pair = numbers[0]\n    closest_distance\
    \ = numbers[0]\n    numbers = numbers[1:]\n    for element in numbers:\n     \
    \   distance = element - closest_pair\n        if distance < closest_distance:\n\
    \            closest_pair = element\n            closest_distance = distance\n\
    \    return closest_pair, closest_distance\n", "    # Write your code here\n \
    \   smallest_value = min(numbers)\n    largest_value = max(numbers)\n    difference\
    \ = largest_value - smallest_value\n\n    closest_values = []\n    for value in\
    \ numbers:\n        diff = value - smallest_value\n        if diff < difference:\n\
    \            closest_values.append(value)\n\n    closest_values.sort()\n    smallest_element\
    \ = closest_values[0]\n    largest_element = closest_values[-1]\n\n    return\
    \ smallest_element, largest_element\n\n\nnumbers = [1.1, 4.2, 2.8, 9.2, 11.1,\
    \ 5.3, 7.8, 6.9]\nclosest_number, closest_elements = find_closest_elements(numbers)\n\
    print('Smallest value:', closest_number, 'and elements are:', closest_elements)\n\
    \n\"\"\"\nOutput:\nSmallest value: 5.3 and elements are: [7.8, 6.9, 11.1, 5.3]\n\
    \"\"\"\n</cell>\n<cell>", "    #TODO: Write your function here!\n    closest_index\
    \ = min([abs(i-j) for i,j in zip(numbers[:-1], numbers[1:])])\n    closest_val\
    \ = numbers[closest_index]\n    return closest_val, numbers[closest_index+1]\n",
  "    if len(numbers) <= 2:\n        return numbers[0], numbers[0]\n    smaller =\
    \ numbers[0]\n    larger = numbers[1]\n    closest_smaller_number_index = 0\n\
    \    closest_larger_number_index = 0\n\n    # Iterate through the list to find\
    \ the smallest and largest numbers\n    for i in range(len(numbers)):\n      \
    \  if numbers[i] < smaller:\n            smaller = numbers[i]\n            closest_smaller_number_index\
    \ = i\n        if numbers[i] > larger:\n            larger = numbers[i]\n    \
    \        closest_larger_number_index = i\n\n    # Return the two numbers closest\
    \ to each other\n    return (numbers[closest_smaller_number_index], numbers[closest_larger_number_index])\n\
    \n", "    return min(numbers), max(numbers)\n\n", "    \n    if numbers == []:\n\
    \        return None, None\n\n    lowest_number = numbers[0]\n    closest_numbers\
    \ = [lowest_number]\n\n    lowest_number = numbers[0]\n    closest_numbers = [lowest_number]\n\
    \n    for i in range(1, len(numbers)):\n        candidate = numbers[i]\n     \
    \   if abs(candidate - lowest_number) < abs(numbers[i] - lowest_number):\n   \
    \         closest_numbers.append(candidate)\n            lowest_number = candidate\n\
    \n    return lowest_number, closest_numbers[1]\n\n", "    lowest_number = min(numbers)\n\
    \    closest_number = lowest_number\n    second_closest_number = lowest_number\n\
    \n    for element in numbers:\n        if abs(element - second_closest_number)\
    \ < abs(element - closest_number):\n            closest_number = element\n   \
    \     elif abs(element - second_closest_number) > abs(element - closest_number):\n\
    \            second_closest_number = element\n\n    return closest_number, second_closest_number\n",
  "    numbers = sorted(numbers)\n    smallest = numbers[0]\n    largest = numbers[-1]\n\
    \    for num in numbers:\n        if num == smallest:\n            return smallest,\
    \ num\n        elif num == largest:\n            return largest, num\n    return\
    \ smallest, largest\n\n", "    if len(numbers) <= 1:\n        raise Exception(\"\
    find_closest_elements needs at least 2 numbers\")\n    number1 = numbers[0]\n\
    \    number2 = numbers[1]\n    distance1 = abs(number1 - number2)\n    distance2\
    \ = abs(number2 - number1)\n\n    if distance1 < distance2:\n        return number1,\
    \ number2\n    else:\n        return number2, number1\n\n", "    if len(numbers)\
    \ < 2:\n        return None, None\n    elif len(numbers) == 2:\n        return\
    \ numbers[0], numbers[1]\n\n    numbers = list(sorted(numbers))\n\n    # choose\
    \ the nearest two numbers to each other and return them in order\n    if len(numbers)\
    \ > 2:\n        differences = zip(numbers[0::2], numbers[1::2])\n    else:\n \
    \       differences = zip(numbers[::2], numbers[1::2])\n\n    return differences[-2]\n\
    \n", "    numbers = sorted(numbers)\n    # Return closest to 0\n    if numbers[0]\
    \ < 0:\n        return numbers[1], -numbers[0]\n    # Return closest to 1\n  \
    \  elif numbers[1] > 1:\n        return numbers[0], numbers[1] - 1\n    else:\n\
    \        return numbers[0], numbers[0]\n\n", "    smallest_num = numbers[0]\n\
    \    greatest_num = numbers[0]\n    for num in numbers[1:]:\n        if num <\
    \ smallest_num:\n            smallest_num = num\n        if num > greatest_num:\n\
    \            greatest_num = num\n    return smallest_num, greatest_num\n", " \
    \   if len(numbers) < 2:\n        raise Exception(\"The list provided must be\
    \ longer than 2.\")\n    elif len(numbers) == 2:\n        return numbers[0], numbers[1]\n\
    \n    # Sort largest to smallest so it is easier to pick up\n    numbers.sort()\n\
    \    biggest = numbers[-1]\n    smallest = numbers[0]\n    \n    # Handle if list\
    \ is even or odd\n    if biggest % 2 == 0:\n        biggest = biggest + 1\n  \
    \  \n    if smallest % 2 == 0:\n        smallest = smallest - 1\n    \n    closest_smaller\
    \ = smallest\n    closest_bigger = biggest\n    \n    # Loop through list\n  \
    \  for index in range(1, len(numbers)):\n        if numbers[index] < smallest:\n\
    \            smallest = numbers[index]\n        if numbers[index] > biggest:\n\
    \            biggest = numbers[index]\n            \n        # Stop if they are\
    \ the same\n        if smallest == biggest:\n            break\n        \n   \
    \     if numbers[index] < closest_smaller or numbers[index] > closest_bigger:\n\
    \            closest_smaller = smallest\n            closest_bigger = biggest\n\
    \        \n        if numbers[index] < closest_bigger or numbers[index] > closest_smaller:\n\
    \            closest_smaller = numbers[index]\n            closest_bigger = numbers[index]\n\
    \            \n    # Return tuple\n    return closest_smaller, closest_bigger\n\
    </cell>\n<cell>\nclosest_numbers([-3, -2, -1, 1, 2, 3])\n</cell>\n<text>\nProblem\
    \ 7\nYou have a list of numbers and a target number.\n\nUse a while loop to loop\
    \ through your list and compare each element to the target number. If one element\
    \ is less than the target number, return that element. Otherwise, return the first\
    \ element in the list that is larger than the target number. \n\n\n</text>\n<cell>",
  "    differences = [abs(b - a) for a, b in zip(numbers[:-1], numbers[1:])]\n   \
    \ return numbers[differences.index(min(differences))]\n\n", "    if len(numbers)\
    \ < 2:\n        raise Exception(\"Need at least two numbers to compare to\")\n\
    \    elif len(numbers) == 2:\n        return numbers[0], numbers[1]\n    else:\n\
    \        min1 = numbers[0]\n        max1 = numbers[0]\n        min2 = numbers[0]\n\
    \        max2 = numbers[0]\n        for i in range(len(numbers)):\n          \
    \  if numbers[i] < min1:\n                min1 = numbers[i]\n            elif\
    \ numbers[i] > max1:\n                max1 = numbers[i]\n            elif numbers[i]\
    \ < min2:\n                min2 = numbers[i]\n            elif numbers[i] > max2:\n\
    \                max2 = numbers[i]\n        return (min1, max1), (min2, max2)\n\
    \n", "    index_1 = numbers[0]\n    index_2 = numbers[1]\n    \n    if abs(index_1\
    \ - index_2) < abs(index_1 - index_1 + index_2):\n        return index_1, index_2\n\
    \    else:\n        return index_2, index_1\n\n", "    for index in range(0, len(numbers)):\n\
    \        if numbers[index] < numbers[index + 1]:\n            smallest = index\n\
    \            largest = index\n\n            smallest_number = numbers[index]\n\
    \            largest_number = numbers[index + 1]\n\n            break\n      \
    \  elif numbers[index] == numbers[index + 1]:\n            if numbers[index] <\
    \ numbers[index + 2]:\n                smallest = index\n                largest\
    \ = index\n\n                smallest_number = numbers[index]\n              \
    \  largest_number = numbers[index + 2]\n\n                break\n\n        elif\
    \ numbers[index] > numbers[index + 1]:\n            smallest = index\n       \
    \     largest = index\n\n            smallest_number = numbers[index]\n      \
    \      largest_number = numbers[index + 1]\n\n            break\n\n    return\
    \ smallest_number, largest_number\n\n", "    # get the two closest numbers\n \
    \   closest_numbers = numbers[:3]\n    closest_numbers_distance = [abs(closest_numbers[0]\
    \ - x) for x in closest_numbers]\n    closest_numbers_distance.sort()\n    smallest_distance\
    \ = closest_numbers_distance[0]\n    second_smallest_distance = closest_numbers_distance[1]\n\
    \    # check if any number in the middle is closer\n    if len(closest_numbers)\
    \ == 3:\n        if abs(closest_numbers[1] - closest_numbers[2]) < smallest_distance:\n\
    \            smallest_distance = abs(closest_numbers[1] - closest_numbers[2])\n\
    \        elif abs(closest_numbers[1] - closest_numbers[2]) > second_smallest_distance:\n\
    \            second_smallest_distance = abs(closest_numbers[1] - closest_numbers[2])\n\
    \            closest_numbers = closest_numbers[::-1]\n    return (smallest_distance,\
    \ closest_numbers[1])\n", "    closest_distance = float('inf')\n    closest_numbers\
    \ = (float('inf'), float('inf'))\n    for num in numbers:\n        distance =\
    \ abs(num-closest_numbers[0])\n        if distance < closest_distance:\n     \
    \       closest_numbers = num, num\n            closest_distance = distance\n\
    \    return closest_numbers\n", "    closests = []\n    closest_sum = numbers[0]\n\
    \    for num in numbers:\n        diff = abs(num - closest_sum)\n        if diff\
    \ < closests[-1]:\n            closests.pop()\n        closests.append(diff)\n\
    \        closest_sum = num\n\n    smallest_diff = closests[0]\n    largest_diff\
    \ = closests[-1]\n    return smallest_diff, largest_diff\n", "    \n    closest_to_smallest\
    \ = min(numbers)\n    closest_to_largest = max(numbers)\n    \n    return (closest_to_smallest,\
    \ closest_to_largest)\n", "    assert len(numbers) > 1\n    assert len(numbers)\
    \ >= 2\n    # Get the two smallest numbers\n    smaller, larger = numbers[0],\
    \ numbers[-1]\n    # Loop through numbers checking the distance between them\n\
    \    for num in numbers[1:]:\n        smaller, larger = larger, min(smaller, num)\n\
    \    return smaller, larger\n\n", "    # Get the average of the numbers\n    average\
    \ = sum(numbers) / len(numbers)\n    # Find the closest two numbers\n    closest_numbers\
    \ = (numbers[0] + numbers[1]) / 2\n    closest_number = numbers[0]\n    # Find\
    \ the next closest number\n    for number in numbers[1:]:\n        if number <\
    \ closest_number:\n            # Find if the number is the closest before it\n\
    \            closest_number = number\n        else:\n            # Find if the\
    \ number is closer\n            closest_number = (closest_number + number) / 2\n\
    \    return closest_numbers, closest_number\n</cell>\n<cell>", "    closest_to_smallest\
    \ = None\n    closest_to_largest = None\n    smallest = None\n    largest = None\n\
    \    for number in numbers:\n        if smallest is None or number < smallest:\n\
    \            smallest = number\n        if largest is None or number > largest:\n\
    \            largest = number\n    if smallest is None or largest is None:\n \
    \       # No numbers have been entered\n        return None, None\n\n    if smallest\
    \ == largest:\n        return smallest, largest\n\n    difference = smallest -\
    \ largest\n    if difference == 0.0:\n        return None, None\n\n    closest\
    \ = (smallest + largest)/2.0\n    closest_to_smallest = closest\n    closest_to_largest\
    \ = closest\n    if closest != largest:\n        difference = closest - largest\n\
    \        closest_to_smallest = largest\n        closest_to_largest = smallest\n\
    \n    return closest_to_smallest, closest_to_largest\n", "    pass\n", "    #\
    \ Using a dictionary for mapping from each number to the index of the number\n\
    \    # from the list.\n    number_to_pos = {number: index for index, number in\
    \ enumerate(numbers)}\n    closest_numbers = [numbers[0]]\n\n    for number in\
    \ numbers[1:]:\n        closest_distance = (\n            closest_numbers[0] +\
    \ number\n        )\n\n        for index, closest_number in enumerate(closest_numbers):\n\
    \            # distance between the current number and the closest number\n  \
    \          distance = (\n                abs(closest_number - number)\n      \
    \      )\n\n            if distance < closest_distance:\n                # If\
    \ the current number is the closest number\n                # then this will be\
    \ the new closest number.\n                closest_distance = distance\n     \
    \           closest_numbers[index] = number\n    closest_numbers.append(numbers[-1])\n\
    \    return tuple(closest_numbers)\n\n", "    if len(numbers) < 2:\n        return\
    \ None, None\n    smallest = numbers[0]\n    largest = numbers[0]\n    for i in\
    \ range(1, len(numbers)):\n        if numbers[i] < smallest or numbers[i] > largest:\n\
    \            if numbers[i] < smallest:\n                smallest = numbers[i]\n\
    \            elif numbers[i] > largest:\n                largest = numbers[i]\n\
    \    if smallest < largest:\n        return smallest, largest\n    else:\n   \
    \     return largest, smallest\n\n", "    if len(numbers) < 2:\n        raise\
    \ ValueError(\"Can't find closest two numbers given one number\")\n    closest\
    \ = min(numbers)\n    smallest = numbers[0]\n    largest = numbers[1]\n    for\
    \ number in numbers:\n        if number < closest:\n            smallest = number\n\
    \        elif number > closest:\n            largest = number\n    return smallest,\
    \ largest\n\n", "    \n    sorted_numbers = numbers.copy()\n    sorted_numbers.sort()\n\
    \n    return sorted_numbers[0], sorted_numbers[-1]\n", "    diff = float('inf')\n\
    \    closest_pair = (numbers[0], numbers[1])\n    for x in numbers[2:]:\n    \
    \    dist = abs(closest_pair[0] - x)\n        if dist < diff:\n            closest_pair\
    \ = (x, closest_pair[1])\n            diff = dist\n    return closest_pair\n",
  "    \n    # Select two elements from list where difference is smallest (closest\
    \ to each)\n    a, b = min(enumerate(numbers), key=lambda x:abs(x[1]-x[0]))\n\
    \    \n    return a, b\n\n", "    smallest_difference = abs(numbers[1] - numbers[0])\n\
    \    second_smallest_difference = abs(numbers[1] - numbers[2])\n    if smallest_difference\
    \ < second_smallest_difference:\n        return numbers[0], numbers[2]\n    return\
    \ numbers[1], numbers[0]\n", "    # get the smallest and largest number\n    largest\
    \ = numbers[0]\n    smallest = numbers[0]\n    for number in numbers:\n      \
    \  if number > largest:\n            largest = number\n        elif number < smallest:\n\
    \            smallest = number\n\n    # find the two closest numbers\n    closest_numbers\
    \ = []\n    for number in numbers:\n        if number == largest:\n          \
    \  closest_numbers.append(number)\n        elif number == smallest:\n        \
    \    closest_numbers.append(number)\n        else:\n            closest_numbers.append(number\
    \ - largest)\n            closest_numbers.append(number + largest)\n\n    return\
    \ tuple(closest_numbers)\n    ", "    smallest = 0.0\n    largest = 1.0\n\n  \
    \  index_of_smallest = 0\n    index_of_largest = 1\n    \n    \n    for x in range(1,len(numbers)):\n\
    \        \n        smallest = x\n        \n        if numbers[x] > numbers[index_of_smallest]:\n\
    \            \n            index_of_smallest = x\n            \n        elif numbers[x]\
    \ < numbers[index_of_smallest]:\n            \n            index_of_largest =\
    \ x\n            \n    return numbers[index_of_smallest], numbers[index_of_largest]\n\
    \nnumbers = [3,5,1,2]\nsmallest, largest = find_closest_elements(numbers)\nprint(smallest,\
    \ largest)\n</cell>\n<cell>", "    if len(numbers) < 2:\n        raise RuntimeError('Cannot\
    \ find a pair given a single value')\n\n    # Sort the numbers and take the first\
    \ two\n    numbers.sort()\n    closest1 = numbers[0]\n    closest2 = numbers[1]\n\
    \n    # If the first two numbers are the same, select the second closest number\n\
    \    # Otherwise select the pair with the smallest difference in distance from\
    \ the first\n    if closest1 == closest2:\n        closest2 = numbers[-2]\n  \
    \  else:\n        difference = abs(closest1 - closest2)\n        closest2 = numbers[-2]\n\
    \n    for i in range(1, len(numbers)):\n        difference = abs(closest1 - numbers[i])\n\
    \        if difference < difference:\n            closest2 = numbers[i]\n    \
    \    else:\n            closest1 = numbers[i]\n\n    return closest1, closest2\n",
  "    smallest = numbers[0]\n    largest = numbers[1]\n\n    for number in numbers:\n\
    \        if number < smallest:\n            smallest = number\n        if number\
    \ > largest:\n            largest = number\n\n    return smallest, largest\n\n",
  "    smallest = None\n    largest = None\n    for number in numbers:\n        if\
    \ smallest is None or number < smallest:\n            smallest = number\n    \
    \    if largest is None or number > largest:\n            largest = number\n \
    \   return smallest, largest\n", "    closest_number1 = min(numbers)\n    closest_number2\
    \ = max(numbers)\n    return (closest_number1, closest_number2)\n", "    if len(numbers)\
    \ < 2:\n        raise RuntimeError('You must supply at least two numbers')\n\n\
    \    # Find the two closest to the first number\n    lower = numbers[0]\n    upper\
    \ = numbers[0]\n\n    for number in numbers[1:]:\n        if abs(number - lower)\
    \ < abs(upper - number):\n            lower = number\n        else:\n        \
    \    upper = number\n\n    return lower, upper\n\n", "    # Find the two closest\
    \ points\n    # Hint: How can you use Python's sorted() function?\n\n    # Your\
    \ code here\n    return numbers[0] + numbers[1]\n    # return sorted(numbers)\n\
    \    # return numbers.sort()\n    # return sorted(numbers)[0]\n", "    # Calculate\
    \ the difference between each of the two numbers in the list\n    differences\
    \ = []\n    for num in numbers:\n        differences.append(num - numbers[0])\n\
    \n    # Find the two numbers that are closest to each other\n    min_diff = min(differences)\n\
    \    closest_pairs = []\n    for index, diff in enumerate(differences):\n    \
    \    if diff == min_diff:\n            closest_pairs.append(numbers[index])\n\n\
    \    return tuple(closest_pairs)\n", "    distances = []\n\n    if len(numbers)\
    \ < 2:\n        raise ValueError(\"Supplied list too short\")\n    \n    minimum\
    \ = numbers[0]\n    maximum = numbers[0]\n    \n    \n    # Loop through all supplied\
    \ numbers\n    for element in numbers:\n        # Calculate distance from current\
    \ element to each supplied number\n        distances.append(distance_between(element,\
    \ minimum, maximum))\n\n        # Update minimum and maximum values\n        if\
    \ element < minimum:\n            minimum = element\n        elif element > maximum:\n\
    \            maximum = element\n    \n    # Calculate and return the results\n\
    \    \n    # Return smallest value found\n    \n    # Return largest value found\n\
    \n\n\"\"\"\nThe main function which allows the user to perform the required calculations\n\
    \"\"\"", "    differences = []\n    for number in numbers:\n        difference\
    \ = number - numbers[0]\n        differences.append(difference)\n    \n    return\
    \ differences.index(min(differences)) + 1, differences.index(max(differences))\
    \ + 1\n\n", "    assert len(numbers) > 1\n\n    left_number = numbers[0]\n   \
    \ right_number = numbers[1]\n\n    for number in numbers[2:]:\n        if abs(number\
    \ - left_number) < abs(number - right_number):\n            left_number = number\n\
    \        elif abs(number - right_number) < abs(number - left_number):\n      \
    \      right_number = number\n        else:\n            raise ValueError(\"Two\
    \ elements are equally close to each other, are you really trying to find the\
    \ closest two numbers?\")\n\n    return left_number, right_number\n\n", "    if\
    \ len(numbers) < 2:\n        raise Exception(\"Unable to find any close numbers.\
    \ Array has only {0} elements\"\n                        .format(len(numbers)))\n\
    \    numbers.sort()\n    middle_index = math.floor(len(numbers) / 2)\n    closest_to_left_index\
    \ = middle_index\n    closest_to_right_index = middle_index\n    for i in range(middle_index):\n\
    \        diff = abs(numbers[i] - numbers[closest_to_left_index])\n        if diff\
    \ < abs(numbers[i] - numbers[closest_to_right_index]):\n            closest_to_left_index\
    \ = i\n            closest_to_right_index = i\n        elif diff == abs(numbers[i]\
    \ - numbers[closest_to_right_index]):\n            closest_to_right_index = i\n\
    \    if closest_to_left_index == middle_index:\n        return (numbers[closest_to_right_index],\
    \ numbers[closest_to_left_index])\n    elif closest_to_right_index == middle_index:\n\
    \        return (numbers[closest_to_left_index], numbers[closest_to_right_index])\n\
    \    else:\n        return (numbers[closest_to_left_index], numbers[closest_to_right_index])\n",
  "    sorted_numbers = sorted(numbers)\n    smallest_number = sorted_numbers[0]\n\
    \    second_smallest_number = sorted_numbers[1]\n    closest_number = None\n \
    \   second_closest_number = None\n    for i in range(1, len(sorted_numbers)):\n\
    \        difference = abs(smallest_number - sorted_numbers[i])\n        if difference\
    \ < second_smallest_number:\n            second_closest_number = closest_number\n\
    \            closest_number = sorted_numbers[i]\n        elif difference < second_smallest_number\
    \ + 0.00001:\n            second_closest_number = closest_number\n           \
    \ closest_number = sorted_numbers[i]\n            second_smallest_number = sorted_numbers[i]\n\
    \    return (closest_number, second_closest_number)\n", "    smaller = numbers[0]\n\
    \    larger = numbers[1]\n    for i in range(1, 5):\n        if numbers[i] < numbers[i\
    \ - 1]:\n            smaller = numbers[i]\n        if numbers[i] > numbers[i -\
    \ 1]:\n            larger = numbers[i]\n    return smaller, larger\n", "    minimum\
    \ = numbers[0]\n    maximum = numbers[1]\n    for x in numbers:\n        if x\
    \ < minimum:\n            minimum = x\n        if x > maximum:\n            maximum\
    \ = x\n    return minimum, maximum\n", "    if len(numbers) < 2:\n        raise\
    \ ValueError('Cannot find two numbers that are equal or greater than each other')\n\
    \    sorted_numbers = sorted(numbers)\n    return sorted_numbers[0], sorted_numbers[1]\n\
    \n", "    sorted_numbers = sorted(numbers)\n    return sorted_numbers[1], sorted_numbers[0]\n\
    \n", "    closest_value = None\n    closest_distance = float(\"inf\")\n    for\
    \ i in range(len(numbers)):\n        this_distance = abs(numbers[i] - numbers[(i\
    \ + 1) % len(numbers)])\n        if this_distance < closest_distance:\n      \
    \      closest_value = numbers[i]\n            closest_distance = this_distance\n\
    \    return closest_value, closest_distance\n", "    smallest = numbers[0]\n \
    \   biggest = numbers[1]\n    for n in numbers[2:]:\n        if n < smallest:\n\
    \            smallest = n\n        if n > biggest:\n            biggest = n\n\
    \    return smallest, biggest\n\n", "    min_diff = min(abs(numbers[i] - numbers[i\
    \ + 1]) for i in range(len(numbers) - 1))\n    min_diff = min(abs(numbers[i] -\
    \ numbers[i + 1]) for i in range(len(numbers) - 1))\n    min_diff = min(abs(numbers[i]\
    \ - numbers[i + 1]) for i in range(len(numbers) - 1))\n    closest_value = numbers[len(numbers)\
    \ - 1]\n    closest_value = numbers[len(numbers) - 1]\n    return closest_value\n\
    \n", "    smallest: float = numbers[0]\n    second_smallest: float = numbers[0]\n\
    \    for i in numbers:\n        if i < smallest:\n            second_smallest\
    \ = smallest\n            smallest = i\n        elif second_smallest < i:\n  \
    \          second_smallest = i\n    return smallest, second_smallest\n\n", " \
    \   numbers = sorted(numbers)\n    \n    # Find the two nearest numbers\n    closest_to_1\
    \ = numbers[0]\n    closest_to_2 = numbers[1]\n    for element in numbers:\n \
    \       if element < closest_to_1:\n            closest_to_1 = element\n     \
    \   elif element > closest_to_2:\n            closest_to_2 = element\n\n    #\
    \ Now we know the two closest numbers, return them in order (smaller number, larger\
    \ number)\n    return closest_to_1, closest_to_2\n\n", "    differences = map(lambda\
    \ i: abs(numbers[i] - numbers[i - 1]), range(len(numbers)))\n    closest_pair\
    \ = differences.index(min(differences))\n    return numbers[closest_pair], numbers[closest_pair\
    \ + 1]\n", "    smallest_number = numbers[0]\n    biggest_number = numbers[0]\n\
    \    smallest_index = 0\n    biggest_index = 0\n    for index in range(len(numbers)):\n\
    \        if numbers[index] < smallest_number:\n            smallest_index = index\n\
    \            smallest_number = numbers[index]\n        elif numbers[index] > biggest_number:\n\
    \            biggest_index = index\n            biggest_number = numbers[index]\n\
    \    return (smallest_number, biggest_number)\n", "    # Your code here\n    smallest,\
    \ largest, closest_number = float(\"inf\"), float(\"-inf\"), float(\"inf\")\n\
    \    smaller, larger = float(\"inf\"), float(\"-inf\")\n    for i in range(len(numbers)):\n\
    \        if numbers[i] < smaller:\n            smaller = numbers[i]\n        elif\
    \ numbers[i] > larger:\n            larger = numbers[i]\n    if smaller*larger\
    \ != float(\"inf\"):\n        closest_number = (smallest+larger)/2\n    else:\n\
    \        closest_number = float(\"inf\")\n    return closest_number\n\nprint(find_closest_elements([1,3,5,6]))\n\
    print(find_closest_elements([1,2,3,4,5]))\nprint(find_closest_elements([1,3,5,7,9]))\n",
  "    # assert len(numbers) >= 2\n    # return None\n    # assert len(numbers) ==\
    \ 2\n    # assert numbers[0] > numbers[1]\n    # assert numbers[1] > numbers[0]\n\
    \    # assert numbers[0] < numbers[1]\n\n    smallest = numbers[0]\n    largest\
    \ = numbers[0]\n    for element in numbers:\n        if element < smallest:\n\
    \            smallest = element\n        elif element > largest:\n           \
    \ largest = element\n\n    # return smallest, largest\n    return smallest, largest\n\
    \n", "    if len(numbers) >= 2:\n        number1 = numbers[0]\n        number2\
    \ = numbers[1]\n\n        difference = number1 - number2\n        \n        if\
    \ abs(difference) > .000000001:\n            difference = difference/abs(difference)\n\
    \n        return number1, number2\n    else:\n        return 0, 0\n", "    numbers\
    \ = sorted(numbers)\n    lower_limit = numbers[0]\n    upper_limit = numbers[-1]\n\
    \n    if lower_limit == upper_limit:\n        return (lower_limit, lower_limit)\n\
    \n    new_lower_limit = lower_limit\n    new_upper_limit = upper_limit\n\n   \
    \ while new_lower_limit != new_upper_limit:\n        new_lower_limit, new_upper_limit\
    \ = find_closest_pair(new_lower_limit, new_upper_limit)\n\n    return (lower_limit,\
    \ new_upper_limit)\n\n", "    if numbers == []:\n        return float('inf'),\
    \ float('-inf')\n\n    numbers = sorted(numbers)\n\n    larger = numbers[-1]\n\
    \n    smaller = numbers[0]\n\n    closest = smaller\n\n    for i in range(1, len(numbers)):\n\
    \        if numbers[i] > numbers[i - 1]:\n            if numbers[i] > closest.lower:\n\
    \                closest = numbers[i]\n            elif numbers[i] < closest.lower:\n\
    \                closest = numbers[i]\n\n    return numbers[numbers.index(smaller)],\
    \ numbers[numbers.index(closest)]\n\n", "    if len(numbers) < 2:\n        raise\
    \ ValueError('numbers should be at least two items long')\n    return min(numbers),\
    \ max(numbers)\n", "    for num in numbers:\n        if num > numbers[0]:\n  \
    \          numbers[0], numbers[1] = numbers[1], num\n    return tuple(numbers)\n",
  "    \n    smallest_number = numbers[0]\n    second_smallest_number = numbers[0]\n\
    \    \n    \n    # Iterate through the list and find smallest and second smallest\
    \ numbers\n    for i in range(1,len(numbers)):\n        if numbers[i] < smallest_number:\n\
    \            smallest_number = numbers[i]\n        elif numbers[i] < second_smallest_number:\n\
    \            second_smallest_number = numbers[i]\n            \n    # Return the\
    \ two numbers\n    return smallest_number, second_smallest_number\n          \
    \      \n    \n    ", "    closest_left = None\n    closest_right = None\n   \
    \ closest_diff = float('inf')\n\n    # find the left and right closest numbers\
    \ by finding the difference\n    for index in range(len(numbers) - 1):\n     \
    \   left = numbers[index]\n        right = numbers[index + 1]\n        diff =\
    \ abs(left - right)\n\n        if closest_diff > diff:\n            closest_diff\
    \ = diff\n            closest_left = left\n            closest_right = right\n\
    \n    # return the two numbers in order\n    return closest_left, closest_right\n",
  "    smallest = None\n    largest = None\n    for num in numbers:\n        if smallest\
    \ is None or num < smallest:\n            smallest = num\n        if largest is\
    \ None or num > largest:\n            largest = num\n    return smallest, largest\n\
    \n", "    # TODO implement with while loop\n    if len(numbers) < 2:\n       \
    \ return None\n    closest_elements = (numbers[0], numbers[1])\n    for elm in\
    \ numbers[2:]:\n        if elm < closest_elements[0]:\n            closest_elements\
    \ = (elm, closest_elements[0])\n        elif elm > closest_elements[1]:\n    \
    \        closest_elements = (closest_elements[1], elm)\n        else:\n      \
    \      continue\n    return closest_elements\n", "    # return (numbers[0], numbers[1])\n\
    \    smallest_distance = sys.float_info.max\n    smallest_index = -1\n    largest_distance\
    \ = sys.float_info.min\n    largest_index = -1\n    for i in range(len(numbers)):\n\
    \        distance = abs(numbers[i] - numbers[smallest_index])\n        if distance\
    \ < smallest_distance:\n            smallest_distance = distance\n           \
    \ smallest_index = i\n        elif distance > largest_distance:\n            largest_distance\
    \ = distance\n            largest_index = i\n    return (numbers[smallest_index],\
    \ numbers[largest_index])\n\n", "    if numbers:\n        smallest = numbers[0]\n\
    \        largest = numbers[0]\n        smallest_diff = 0\n        largest_diff\
    \ = 0\n\n        for number in numbers:\n            diff = abs(number - smallest)\n\
    \            if diff < smallest_diff:\n                smallest_diff = diff\n\
    \                smallest = number\n\n            diff = abs(number - largest)\n\
    \            if diff > largest_diff:\n                largest_diff = diff\n  \
    \              largest = number\n\n        return smallest, largest\n    else:\n\
    \        return None\n", "    if len(numbers) < 2:\n        return numbers[0],\
    \ numbers[0]\n    distances = list(map(lambda num: abs(num - numbers[0]), numbers))\n\
    \    smallest_distance = min(distances)\n    closest_one_index = distances.index(smallest_distance)\n\
    \    return numbers[closest_one_index], numbers[closest_one_index + 1]\n\n", " \
    \   if len(numbers) < 2:\n        return None\n\n    smallest_number = 0\n   \
    \ largest_number = numbers[0]\n    for i in range(len(numbers)):\n        if numbers[i]\
    \ < largest_number:\n            smallest_number = i\n        if numbers[i] >\
    \ largest_number:\n            largest_number = i\n    return smallest_number,\
    \ largest_number\n", "    # first calculate the difference between each element\n\
    \    # then return the min and the max\n    # this could be done in one line with\
    \ a list comprehension\n    # but it would not look very nice\n    min_value =\
    \ min(numbers)\n    max_value = max(numbers)\n    distance = (max_value - min_value)\
    \ / (len(numbers) - 1)\n\n    return min_value + distance * i, max_value + distance\
    \ * i\n\n", "    closest_number = None\n    closest_dist = float(\"+inf\")\n \
    \   closest_number = None\n    closest_dist = float(\"+inf\")\n\n    if numbers\
    \ is not None and len(numbers) >= 2:\n        diffs = []\n        for i in range(0,\
    \ len(numbers) - 1):\n            diffs.append(abs(numbers[i] - numbers[i + 1]))\n\
    \n        diffs.sort()\n\n        closest_number = numbers[diffs.index(min(diffs))]\n\
    \n        closest_dist = min(diffs)\n\n    return closest_number, closest_dist\n\
    \n", "    \n    if len(numbers) <= 2:\n        return None, None\n\n    smallest\
    \ = numbers[0]\n    largest = numbers[1]\n\n    for n in numbers[2:]:\n      \
    \  if abs(n - smallest) < abs(n - largest):\n            smallest = n\n      \
    \  elif abs(n - largest) < abs(n - smallest):\n            largest = n\n\n   \
    \ return smallest, largest\n", "    closest_value = numbers[0]\n    second_closest\
    \ = 0\n    second_closest_value = numbers[0]\n    for num in numbers:\n      \
    \  if abs(num - closest_value) < abs(second_closest - closest_value):\n      \
    \      closest_value = num\n            second_closest_value = second_closest\n\
    \            second_closest = num\n        elif abs(num - closest_value) > abs(second_closest\
    \ - closest_value):\n            second_closest = num\n        if abs(num - closest_value)\
    \ == abs(second_closest - closest_value):\n            second_closest_value =\
    \ num\n    return closest_value, second_closest_value\n", "    smallest_number\
    \ = min(numbers)\n    largest_number = max(numbers)\n\n    element_smallest_number\
    \ = list(numbers)[0]\n    element_largest_number = list(numbers)[-1]\n\n    return\
    \ element_smallest_number, element_largest_number\n\n", "    for idx, element\
    \ in enumerate(numbers):\n        smallestElement = idx\n        largestElement\
    \ = idx\n        if idx < len(numbers) - 1:\n            smallestElement = idx\
    \ + 1\n            largestElement = idx\n        elif idx == len(numbers) - 1:\n\
    \            smallestElement = idx\n            largestElement = idx\n       \
    \ else:\n            smallestElement = idx\n            largestElement = idx\n\
    \n        if element < numbers[smallestElement]:\n            smallestElement\
    \ = smallestElement + 1\n        if element > numbers[largestElement]:\n     \
    \       largestElement = largestElement - 1\n\n    return smallestElement, largestElement\n",
  "    assert len(numbers) >= 2\n    return min(numbers), max(numbers)\n\n", "   \
    \ closest_pair = []\n    for index in range(0, len(numbers) - 1):\n        delta\
    \ = numbers[index] - numbers[index + 1]\n        if delta == 0:\n            continue\n\
    \        if delta > 0:\n            closest_pair = [numbers[index], numbers[index\
    \ + 1]]\n            break\n    if closest_pair:\n        return closest_pair\n\
    \    else:\n        raise IndexError(\"Could not find any closest elements. Returned\
    \ None\")\n\n", "    smallest = 0\n    largest = 1000000\n    if len(numbers)\
    \ == 0:\n        smallest = smallest\n        largest = largest\n        return\
    \ smallest, largest\n    for num in numbers:\n        if smallest > num:\n   \
    \         smallest = num\n        if largest < num:\n            largest = num\n\
    \    return smallest, largest\n", "    \n    if len(numbers) < 2:\n        # Can't\
    \ find two numbers, nothing to do.\n        return None, None\n    \n    lowest_diff\
    \ = sys.float_info.max\n    closest_pair = None\n    closest_pair_diff = 0\n \
    \   for x in numbers:\n        diff = x - numbers[0]\n        \n        if closest_pair\
    \ is None:\n            closest_pair = (x, numbers[0])\n            closest_pair_diff\
    \ = diff\n            \n        if diff < lowest_diff:\n            lowest_diff\
    \ = diff\n            closest_pair = (x, numbers[0])\n            closest_pair_diff\
    \ = diff\n        elif diff == lowest_diff:\n            closest_pair = (x, numbers[0])\n\
    \            closest_pair_diff = diff\n            \n        elif diff > lowest_diff:\n\
    \            if closest_pair_diff < diff:\n                closest_pair = (x,\
    \ numbers[0])\n                closest_pair_diff = diff\n            else:\n \
    \               closest_pair = (closest_pair[0], closest_pair[1])\n          \
    \      \n    return closest_pair\n</cell>\n<cell>\nnumbers = [4,5,6]\nclosest_pair\
    \ = find_closest_elements(numbers)\nclosest_pair\n</cell>\n<text>\nPractice Problems\n\
    Problem 1\nGiven the list l = [1,3,5,7,9,11], return [1,5,9].\n\n\n</text>\n<cell>",
  "    numbers_sorted = sorted(numbers)\n    smallest = numbers_sorted[0]\n    largest\
    \ = numbers_sorted[-1]\n    closest_numbers = [smallest, largest]\n    for i,\
    \ number in enumerate(numbers_sorted):\n        if number == largest:\n      \
    \      closest_numbers.append(number)\n        elif number == smallest:\n    \
    \        closest_numbers.append(number)\n        elif number < smallest:\n   \
    \         closest_numbers.append(number)\n        elif number > largest:\n   \
    \         closest_numbers.append(number)\n        else:\n            closest_numbers.append(smallest)\n\
    \            closest_numbers.append(number)\n    return tuple(closest_numbers)\n",
  "    \n    closest = numbers[0]\n    second_closest= numbers[1]\n    \n    for index,\
    \ value in enumerate(numbers):\n        if value > closest:\n            second_closest\
    \ = closest\n            closest = value\n        elif value < closest:\n    \
    \        second_closest = closest\n            closest = value\n        elif value\
    \ == closest:\n            second_closest = closest\n    return second_closest,\
    \ closest\n\n", "    return min(numbers), max(numbers)\n", "    return min(numbers,\
    \ key=lambda x:abs(x-numbers[1])), max(numbers, key=lambda x:abs(x-numbers[1]))\n",
  "    closest_smaller = numbers[0]\n    closest_larger = numbers[0]\n    for number\
    \ in numbers[1:]:\n        if number < closest_smaller:\n            closest_smaller\
    \ = number\n        elif number > closest_larger:\n            closest_larger\
    \ = number\n    return closest_smaller, closest_larger\n", "    # Sort the numbers\
    \ to get the min and max numbers\n    numbers.sort()\n\n    # Get the min and\
    \ max values\n    min_value, max_value = numbers[0], numbers[-1]\n\n    # Find\
    \ the two closest numbers\n    closest_values = [numbers[0]]\n    for value in\
    \ numbers[1:]:\n        if value - min_value < max_value - value:\n          \
    \  closest_values.append(value)\n\n    # Return the two closest numbers in order\n\
    \    return closest_values[0:2], closest_values[2:]\n", "    return min(numbers),\
    \ max(numbers)\n\n", "    for index, number in enumerate(numbers):\n        if\
    \ (index == 0):\n            return (numbers[0], number)\n        elif (index\
    \ == 1):\n            return (number, numbers[1])\n        else:\n           \
    \ closest_distances = []\n            for x in range(index - 1):\n           \
    \     distance = ((numbers[index] - numbers[x])**2).sum()\n                closest_distances.append(distance)\n\
    \n            closest_distances.sort()\n\n            if (closest_distances[0]\
    \ < closest_distances[1]):\n                return (numbers[index], numbers[index\
    \ + 1])\n            else:\n                return (numbers[index + 1], numbers[index])\n\
    </code>\n<|/ a tags=algorithm,sorting,python,python-3.x dscore=0 |>\n<| c |>\n\
    Thanks but this only works on numbers greater than the list size. For example,\
    \ if the list is [5,1,2,4] and I wanted to find 2 and 4 as closest numbers it\
    \ returns 5 and 2\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfrom math import sqrt",
  "    closest_number = min(numbers)\n    closest_number_2 = max(numbers)\n\n    return\
    \ closest_number, closest_number_2\n", "    if numbers[0] <= numbers[1]:\n   \
    \     lower_number, upper_number = numbers[0], numbers[1]\n    else:\n       \
    \ lower_number, upper_number = numbers[1], numbers[0]\n    closest_values = []\n\
    \    for value in numbers:\n        distance = abs(value - lower_number) + abs(value\
    \ - upper_number)\n        closest_values.append((distance, value))\n    closest_values.sort(key=lambda\
    \ x: x[0])\n    \n    # Return the two closest numbers in the same order as the\
    \ supplied list\n    return tuple(closest_values[0:2])\n\n    ", "    minimum\
    \ = numbers[0]\n    maximum = numbers[0]\n    for i in range(1,len(numbers)):\n\
    \        if numbers[i] < minimum:\n            minimum = numbers[i]\n        elif\
    \ numbers[i] > maximum:\n            maximum = numbers[i]\n    index = i\n   \
    \ return (minimum,maximum)\n", "    def distance(a: float, b: float) -> float:\n\
    \        return abs(b - a)\n\n    return min(zip(numbers, numbers[1:]), key=lambda\
    \ p: distance(p[0], p[1]))\n", "    assert len(numbers) >= 2\n\n    smallest =\
    \ None\n    largest = None\n\n    for n in numbers:\n        if smallest is None:\n\
    \            smallest=n\n            largest=n\n        elif n<smallest:\n   \
    \         smallest=n\n        elif n>largest:\n            largest=n\n\n    return\
    \ (smallest, largest)\n", "    \n    # find the difference between the two numbers\n\
    \    diff = min(numbers)-max(numbers)\n    \n    if diff > 0:\n        smallest\
    \ = max(numbers)\n        biggest = min(numbers)\n    elif diff < 0:\n       \
    \ smallest = min(numbers)\n        biggest = max(numbers)\n    else:\n       \
    \ return None, None\n\n    return smallest, biggest\n", "    minimum = float(\"\
    inf\")\n    maximum = float(\"-inf\")\n    for a in numbers:\n        if a < minimum:\n\
    \            minimum = a\n        elif a > maximum:\n            maximum = a\n\
    \n    minimum_index = numbers.index(minimum)\n    maximum_index = numbers.index(maximum)\n\
    \n    return minimum, maximum\n\n", "    min_diff = 10000\n    closest_number\
    \ = numbers[0]\n    closest_number_two = numbers[1]\n\n    for number in numbers:\n\
    \        diff = abs(number - closest_number)\n        if diff < min_diff:\n  \
    \          closest_number = number\n            closest_number_two = number\n\
    \        elif diff == min_diff:\n            closest_number_two = number\n   \
    \     elif diff == 10000:\n            closest_number = number\n            closest_number_two\
    \ = number\n    return closest_number, closest_number_two\n\n", "    smallest_difference\
    \ = abs(numbers[0] - numbers[1])\n    smallest_index = 0\n    smallest_number\
    \ = numbers[0]\n    largest_difference = abs(numbers[0] - numbers[1])\n    largest_index\
    \ = len(numbers) - 1\n    largest_number = numbers[len(numbers) - 1]\n    for\
    \ index in range(1, len(numbers)):\n        difference = abs(numbers[index] -\
    \ numbers[index - 1])\n        if difference < smallest_difference:\n        \
    \    smallest_difference = difference\n            smallest_index = index\n  \
    \          smallest_number = numbers[index]\n        elif difference > largest_difference:\n\
    \            largest_difference = difference\n            largest_index = index\n\
    \            largest_number = numbers[index]\n    return smallest_number, largest_number\n\
    \n", "    smallest_distance = min(numbers)\n    biggest_distance = max(numbers)\n\
    \    return smallest_distance, biggest_distance\n", "    if len(numbers) < 2:\n\
    \        raise ValueError(f\"At least two numbers are required\")\n    closest_ones\
    \ = []\n    closest_twos = []\n    closest_one = 0\n    closest_two = 0\n    for\
    \ index in range(0,len(numbers)):\n        if index < 2:\n            closest_ones.append(numbers[index])\n\
    \            closest_twos.append(numbers[index])\n        else:\n            closest_one\
    \ = numbers[index] - numbers[index-1]\n            closest_two = numbers[index-1]\
    \ - numbers[index]\n            if closest_one < closest_two:\n              \
    \  closest_ones.append(closest_one)\n                closest_twos.append(closest_two)\n\
    \            else:\n                closest_ones.append(closest_two)\n       \
    \         closest_twos.append(closest_one)\n    return tuple(sorted(closest_ones)),\
    \ tuple(sorted(closest_twos))\n", "    assert len(numbers) >= 2\n    if numbers[0]\
    \ == numbers[1]:\n        return numbers[0], numbers[1]\n    else:\n        largest_diff1\
    \ = abs(numbers[0] - numbers[1])\n        smallest_diff1 = abs(numbers[1] - numbers[0])\n\
    \        if largest_diff1 < smallest_diff1:\n            return numbers[1], numbers[0]\n\
    \        else:\n            return numbers[0], numbers[1]\n", "    if len(numbers)\
    \ < 2:\n        raise ValueError(\"Must supply 2 or more numbers\")\n\n    # Sort\
    \ the supplied numbers and subtract the first number from the second\n    numbers.sort()\n\
    \    difference = numbers[0] - numbers[1]\n\n    # Find the smallest and largest\
    \ numbers in the list\n    smallest = numbers[0]\n    largest = numbers[0]\n \
    \   for number in numbers:\n        if smallest > number:\n            smallest\
    \ = number\n        if largest < number:\n            largest = number\n\n   \
    \ return (smallest, largest)\n", "    # Find two numbers, closest to each\n  \
    \  if numbers is not None and len(numbers) >= 2:\n        # Sort list in ascending\
    \ order\n        numbers.sort()\n        lower = numbers[0]\n        upper = numbers[1]\n\
    \        if numbers[0] == numbers[1]:\n            return numbers[0], numbers[0]\n\
    \        # Find closest to lower and upper\n        if lower > upper:\n      \
    \      return numbers[0], numbers[1]\n        if upper < lower:\n            return\
    \ numbers[1], numbers[0]\n        # Find the closest in middle of range\n    \
    \    midpoint = (lower + upper) / 2\n        if lower == mid and mid < upper:\n\
    \            return mid, mid\n        if mid == lower and upper < mid:\n     \
    \       return mid, upper\n        if mid == upper and lower > mid:\n        \
    \    return lower, mid\n    return numbers[0], numbers[1]\n", "    smallest_distance\
    \ = float(\"inf\")\n    second_smallest_distance = float(\"inf\")\n    for index,\
    \ number in enumerate(numbers[1:]):\n        distance = abs(number - numbers[index])\n\
    \        if distance < smallest_distance:\n            smallest_distance = distance\n\
    \        if distance < second_smallest_distance:\n            second_smallest_distance\
    \ = distance\n    return numbers[smallest_distance], numbers[second_smallest_distance]\n",
  "    closest_numbers = [float('inf')]\n    closest_numbers.append(numbers[0])\n\
    \    for n in numbers:\n        if n < closest_numbers[-1]:\n            closest_numbers.append(n)\n\
    \        elif n > closest_numbers[-1]:\n            closest_numbers.pop(0)\n \
    \   return closest_numbers\n\n", "    # your code here\n    if len(numbers) <\
    \ 2:\n        raise ValueError\n    smallest = (numbers[0], numbers[1])\n    largest\
    \ = (numbers[0], numbers[1])\n    for el in numbers[1:]:\n        if el < smallest[1]:\n\
    \            smallest = (smallest[0], el)\n        elif el > largest[1]:\n   \
    \         largest = (largest[0], el)\n    return smallest, largest\n", "    minimum,\
    \ maximum = numbers[0], numbers[-1]\n    smallest_difference = abs(minimum - maximum)\n\
    \    for num in numbers[1:]:\n        difference = abs(minimum - num)\n      \
    \  if difference < smallest_difference:\n            smallest_difference = difference\n\
    \            minimum = num\n        if difference > smallest_difference:\n   \
    \         minimum = num\n            maximum = num\n    return minimum, maximum\n",
  "    return min(numbers), max(numbers)\n</cell>\n<cell>\nfind_closest_elements(numbers=[5,\
    \ 3, 4, 2, 9])\n</cell>\n<text>\n3. Functions\nPython functions are a very powerful\
    \ way of using your code in any way you want. You will get practice using them\
    \ and can apply them in many different ways to solve problems with data science,\
    \ machine learning and much more.\n\n\n</text>\n<text>\n3.1 Basic Functions\n\
    A function has a name and a set of parameters. The name specifies what kind of\
    \ function it is. The parameters specify what kind of data it will work with.\
    \ You can call these parameters anything you want, but try to give them a good\
    \ name so you can easily identify and call the parameters you want. Once you give\
    \ the function a name, you can then call it in any way you want.\n\nSo let's take\
    \ a look at the two basic functions in Python:\n\n\n</text>\n<cell>", "    assert\
    \ len(numbers) >= 2\n\n    smallest_value = numbers[0]\n    largest_value = numbers[0]\n\
    \n    for i in range(1, len(numbers)):\n        if numbers[i] < smallest_value:\n\
    \            smallest_value = numbers[i]\n        elif numbers[i] > largest_value:\n\
    \            largest_value = numbers[i]\n\n    return smallest_value, largest_value\n",
  "    smallest_number = numbers[0]\n    second_smallest_number = numbers[1]\n\n \
    \   smallest_elements_index = 0\n    second_smallest_elements_index = 1\n\n  \
    \  for index in range(2, len(numbers)):\n        if numbers[index] < smallest_number:\n\
    \            smallest_number = numbers[index]\n            smallest_elements_index\
    \ = index\n        elif numbers[index] > smallest_number:\n            second_smallest_number\
    \ = numbers[index]\n            second_smallest_elements_index = index\n\n   \
    \ return smallest_number, second_smallest_number\n\n", "    \n    smallest: float\
    \ = numbers[0]\n    largest: float = numbers[0]\n    \n    for number in numbers:\n\
    \        if smallest > number:\n            smallest = number\n            \n\
    \        elif largest < number:\n            largest = number\n        \n    return\
    \ smallest, largest\n</code>\nThen the rest of the program is straightforward:\n\
    <code>", "    smallest_number = min(numbers)\n    closest_numbers = []\n    for\
    \ numbers in numbers:\n        if numbers == smallest_number:\n            closest_numbers.append(numbers)\n\
    \        elif numbers == smallest_number:\n            closest_numbers.append(numbers)\n\
    \        else:\n            smallest_number += 1\n            closest_numbers.append(smallest_number)\n\
    \    return smallest_number, max(numbers)\n\n", "    sorted_numbers = sorted(numbers)\n\
    \    closest_numbers = sorted_numbers[:2]\n    closest_numbers = sorted(closest_numbers)\n\
    \    return closest_numbers\n", "    sorted_numbers = sorted(numbers)\n    closest_to_smallest\
    \ = sorted_numbers[0]\n    closest_to_largest = sorted_numbers[-1]\n    return\
    \ (closest_to_smallest, closest_to_largest)\n\n\"\"\"\nfind_closest_elements\n\
    \nprint(find_closest_elements(numbers))\nprint(find_closest_elements(numbers))\n\
    \nprint(find_closest_elements(numbers))\n\nprint(find_closest_elements(numbers))\n\
    \nprint(find_closest_elements(numbers))\n\"\"\"\n", "    closest_smaller = numbers[0]\n\
    \    closest_larger = numbers[0]\n    smaller_diff = numbers[0]\n    larger_diff\
    \ = numbers[0]\n    for num in numbers[1:]:\n        if smaller_diff > abs(num\
    \ - closest_smaller) or larger_diff > abs(num - closest_larger):\n           \
    \ if abs(num - closest_smaller) > abs(num - closest_larger):\n               \
    \ closest_smaller = num\n                smaller_diff = abs(num - closest_smaller)\n\
    \            else:\n                closest_larger = num\n                larger_diff\
    \ = abs(num - closest_larger)\n    return closest_smaller, closest_larger\n\n",
  "    if len(numbers) < 2:\n        raise ValueError(f\"Given list of numbers is\
    \ empty - {numbers}\")\n    lowest = 0\n    largest = 1\n    for num in numbers:\n\
    \        if num > largest:\n            largest = num\n        if num < lowest:\n\
    \            lowest = num\n    return (lowest, largest)\n\n", "    \n    closest_smaller_number\
    \ = numbers[0]\n    closest_larger_number = numbers[1]\n    \n    for num in numbers[2:]:\n\
    \        if abs(num - closest_smaller_number) < abs(closest_larger_number - num):\n\
    \            closest_smaller_number = num\n        else:\n            closest_larger_number\
    \ = num\n        \n    return (closest_smaller_number, closest_larger_number)\n",
  "    \n    sorted_numbers = sorted(numbers)\n    if sorted_numbers[0] == sorted_numbers[-1]:\n\
    \        return sorted_numbers[0], sorted_numbers[0]\n    elif sorted_numbers[0]\
    \ < sorted_numbers[-1]:\n        return sorted_numbers[0], sorted_numbers[-1]\n\
    \    else:\n        return sorted_numbers[-1], sorted_numbers[0]\n\n", "    smallest_number\
    \ = min(numbers)\n    largest_number = max(numbers)\n    closest_numbers_lower\
    \ = [n for n in numbers if n < smallest_number]\n    closest_numbers_higher =\
    \ [n for n in numbers if n > largest_number]\n    if len(closest_numbers_lower)\
    \ > len(closest_numbers_higher):\n        return closest_numbers_higher, closest_numbers_lower\n\
    \    else:\n        return closest_numbers_lower, closest_numbers_higher\n\n",
  "    smallest_number = min(numbers)\n    biggest_number = max(numbers)\n    if smallest_number\
    \ == biggest_number:\n        return smallest_number, smallest_number\n    closest_numbers\
    \ = [smallest_number]\n    for number in numbers:\n        if abs(number - smallest_number)\
    \ < abs(number - biggest_number):\n            closest_numbers.append(number)\n\
    \        else:\n            closest_numbers.append(biggest_number)\n    return\
    \ tuple(closest_numbers)\n\n", "    minimum = numbers[0]\n    maximum = numbers[0]\n\
    \    for number in numbers[1:]:\n        if abs(number - minimum) < abs(minimum\
    \ - maximum):\n            minimum = number\n        if abs(number - maximum)\
    \ < abs(maximum - minimum):\n            maximum = number\n    return minimum,\
    \ maximum\n\n", "    smallest_number = min(numbers)\n    biggest_number = max(numbers)\n\
    \    if smallest_number == biggest_number:\n        return smallest_number, smallest_number\n\
    \    if smallest - biggest > 0.0001:\n        smaller_number = min(numbers)\n\
    \        bigger_number = max(numbers)\n        if smaller_number - bigger_number\
    \ > 0.0001:\n            closest_number = min(numbers)\n            closest_number_index\
    \ = numbers.index(closest_number)\n            closest_number = numbers[closest_number_index]\n\
    \            return closest_number, closest_number\n    return smallest_number,\
    \ biggest_number\n\n", "    return min(numbers), max(numbers)\n", "    closests\
    \ = [numbers[0]]\n    closests.append(numbers[1])\n\n    for index in range(2,\
    \ len(numbers)):\n        difference = abs(closests[-1] - closests[index])\n \
    \       closests.append(closests[index])\n        closests[-1] = difference\n\n\
    \    # Return the two closest elements\n    if len(closests) >= 2:\n        return\
    \ closests[0], closests[-1]\n    elif len(closests) == 1:\n        return closests[0],\
    \ closests[0]\n\n    return None, None\n\n", "    if len(numbers) < 2:\n     \
    \   return 0, 0\n    closest = numbers[0]\n    smallest = numbers[0]\n    largest\
    \ = numbers[0]\n    for i in range(1, len(numbers)):\n        smallest_diff =\
    \ numbers[i] - smallest\n        largest_diff = largest - numbers[i]\n       \
    \ if smallest_diff < largest_diff:\n            smallest = numbers[i]\n      \
    \  elif smallest_diff == largest_diff:\n            smallest = smallest\n    \
    \        largest = numbers[i]\n        elif smallest_diff > largest_diff:\n  \
    \          largest = numbers[i]\n        else:\n            pass\n    return smallest,\
    \ largest\n", "    assert 2 <= len(numbers) <= 3\n    lower = numbers[0]\n   \
    \ upper = numbers[1]\n    middle = lower + (upper-lower)/2\n    closest_numbers\
    \ = [lower, middle, upper]\n    for i in range(len(numbers)-1):\n        if abs(numbers[i]\
    \ - middle) < abs(numbers[i+1] - middle):\n            closest_numbers.append(numbers[i])\n\
    \    return closest_numbers\n", "    smallest = numbers[0]\n    largest = numbers[0]\n\
    \    difference = largest\n    closest_smaller = 0\n    closest_larger = 0\n \
    \   closest_smaller_value = 0.0\n    closest_larger_value = 0.0\n    for num in\
    \ numbers:\n        if num < smallest:\n            smallest = num\n        if\
    \ num > largest:\n            largest = num\n        difference = num - smallest\n\
    \        if difference < closest_smaller_value:\n            closest_smaller_value\
    \ = difference\n            closest_smaller = smallest\n            closest_larger_value\
    \ = difference\n            closest_larger = largest\n        else:\n        \
    \    closest_larger_value = difference\n            closest_larger = largest\n\
    \            closest_smaller_value = difference\n            closest_smaller =\
    \ smallest\n    return closest_smaller, closest_larger, closest_smaller_value,\
    \ closest_larger_value\n", "    if not numbers or len(numbers) < 2:\n        raise\
    \ Exception(\"At least two numbers are required.\")\n\n    smallest = numbers[0]\n\
    \    largest = numbers[-1]\n\n    for num in numbers:\n        if num < smallest:\n\
    \            smallest = num\n        if num > largest:\n            largest =\
    \ num\n\n    return (smallest, largest)\n", "    closest_pair = []\n    for n\
    \ in range(1, len(numbers)):\n        if abs(numbers[n] - numbers[n - 1]) < abs(numbers[n]\
    \ - numbers[n - 2]):\n            closest_pair.append(numbers[n - 1])\n      \
    \      closest_pair.append(numbers[n - 2])\n    return closest_pair\n", "    return\
    \ min(numbers), max(numbers)\n", "    smaller = numbers[0]\n    larger = numbers[1]\n\
    \n    for number in numbers[2:]:\n        if abs(number - smaller) < abs(number\
    \ - larger):\n            smaller = number\n        else:\n            larger\
    \ = number\n\n    return smaller, larger\n\nprint(find_closest_elements([-5, -1,\
    \ -3, -9, -2, -2, -2, -2, -2, -4, -6, -6, -7, -9, -9, -11]))\nprint(find_closest_elements([0,\
    \ -10, -5, -1, -2, -3, -4, -5, -6, -7, -8, -9]))\n</code>\nOutput:\n<code>\n(-7,\
    \ -9)\n(-4, -6)\n</code>\n<|/ a tags=arrays,python |>\n<| c |>\nGreat answer thanks!\
    \ I knew i could do it with if statements but thought it would be a more elegant\
    \ way with list comprehension\n<|/ c |>\n<| c |>\nI understand this answer and\
    \ it is really clever, but I must say, I don't understand how this is more \"\
    elegant\" than `if` statements. It is harder to read, and harder to understand.\
    \ Furthermore, `if` statements don't make your code more \"Pythonic\" by themselves.\
    \ A list comprehension would be my preferred solution. Sure, you can use a for\
    \ loop and conditionals, but that doesn't make it any better (or easier). It is\
    \ a matter of preference. I personally would go with the `if` statement, unless\
    \ it was in a for loop, then I would go with the list comprehension.\n<|/ c |>\n\
    <| c |>\nList comprehension can make things much clearer and more elegant but\
    \ also it can make code more messy and difficult to read. Your answer is correct\
    \ but not very pythonic, more readable and much easier to understand.\n<|/ c |>\n\
    <| c |>\nThis is so much better. Elegant and easy to understand. Also thank you\
    \ for the explanation i get it now\n<|/ c |>\n<| a |>\nYou can use a while loop\
    \ and check all your numbers against each other\n<code>\na=[3,6,1,8,5,1,3]\nwhile\
    \ len(a) > 1:\n    if a[1] > a[0]:\n        bigger = a[1]\n        smaller = a[0]\n\
    \    else:\n        bigger = a[0]\n        smaller = a[1]\n    a.sort()\n    print(a[0],a[1])\n\
    \    a.remove(bigger)\n    a.remove(smaller)\n</code>\nThis outputs:\n<code>\n\
    2 1\n3 6\n</code>\nThis code sorts a, which is probably not necessary unless your\
    \ actual ", "    # assert len(numbers) >= 2\n    # sorted_numbers = sorted(numbers)\n\
    \    # return sorted_numbers[1], sorted_numbers[0]\n    min_diff = numbers[1]\
    \ - numbers[0]\n    for index, number in enumerate(numbers):\n        if number\
    \ == numbers[0]:\n            continue\n        current_diff = (numbers[index\
    \ + 1] - number)\n        if current_diff < min_diff:\n            min_diff =\
    \ current_diff\n    return min_diff, numbers[numbers.index(min_diff)]\n\n", " \
    \   if len(numbers) <= 2:\n        raise Exception('Given list of numbers is too\
    \ short')\n    smallest_number = numbers[0]\n    largest_number = numbers[-1]\n\
    \    closest_pair = float('inf')\n    for i in range(1, len(numbers)):\n     \
    \   if abs(numbers[i] - smallest_number) < closest_pair:\n            closest_pair\
    \ = abs(numbers[i] - smallest_number)\n            smallest_number = numbers[i]\n\
    \    if smallest_number == largest_number:\n        smallest_number = numbers[0]\n\
    \        largest_number = numbers[-1]\n    return (smallest_number, largest_number)\n\
    \n", "    if len(numbers) < 2:\n        raise ValueError(\"Input must be a list\
    \ of at least two elements\")\n\n    smallest = numbers[0]\n    biggest = numbers[0]\n\
    \n    for i in range(len(numbers)):\n        if numbers[i] > biggest:\n      \
    \      biggest = numbers[i]\n        if numbers[i] < smallest:\n            smallest\
    \ = numbers[i]\n    return smallest, biggest\n\n", "    return min(zip(numbers[1:],\
    \ numbers[0:-1]), key=lambda pair: abs(pair[1] - pair[0]))\n", "    assert len(numbers)\
    \ >= 2\n\n    smallest = numbers[0]\n    largest = numbers[-1]\n    for n in numbers:\n\
    \        smallest_diff = abs(n - smallest)\n        largest_diff = abs(n - largest)\n\
    \n        if smallest_diff < largest_diff:\n            smallest = n\n       \
    \ elif largest_diff < smallest_diff:\n            largest = n\n    return (smallest,\
    \ largest)\n", "    if len(numbers) < 2:\n        raise ValueError(\"Cannot find\
    \ closest numbers because there are less than two numbers to compare\")\n\n  \
    \  smallest = None\n    largest = None\n    for i in numbers:\n        if smallest\
    \ is None:\n            smallest = i\n            largest = i\n        else:\n\
    \            if i < smallest:\n                smallest = i\n            if i\
    \ > largest:\n                largest = i\n\n    return smallest, largest\n",
  "    \n    if len(numbers) < 2:\n        return None, None\n    \n    closest =\
    \ min(numbers)\n    smallest = numbers[0]\n    \n    for num in numbers[1:]:\n\
    \        if abs(num - smallest) < abs(closest - smallest):\n            smallest\
    \ = num\n            closest = num\n    \n    return smallest, closest\n", " \
    \   sorted_numbers = sorted(numbers)\n    smallest = sorted_numbers[0]\n    largest\
    \ = sorted_numbers[1]\n    for num in sorted_numbers[2:]:\n        if abs(num\
    \ - smallest) > abs(largest - num):\n            largest = num\n        else:\n\
    \            smallest = num\n    return (smallest, largest)\n\n\nprint(find_closest_elements([-1,\
    \ -2, 3]))\nprint(find_closest_elements([1, 2, 3, 4, 5]))\nprint(find_closest_elements([0.1,\
    \ 0.2, 0.3, 0.4, 0.5]))\nprint(find_closest_elements([0.1, 0.5, 0.6, 0.7, 0.8]))\n\
    print(find_closest_elements([0.5, 0.1, 0.7, 0.5, 0.3]))\nprint(find_closest_elements([0.5,\
    \ 0.2, 0.3, 0.7, 0.9]))\nprint(find_closest_elements([5, 2, 1, 1, 3, 2.5]))\n\
    print(find_closest_elements([0.5, 2, 3, 1, 4.5, 5]))\nprint(find_closest_elements([2,\
    \ 3, 4, 2, 6, 4.5]))\nprint(find_closest_elements([3.1, 3.2, 2.7, 3.3, 3.8, 3.7,\
    \ 3.9, 3.4]))\nprint(find_closest_elements([1.4, 2.4, 3.3, 3.1, 3.7, 3.8, 3.6,\
    \ 3.5, 3.1]))\nprint(find_closest_elements([-2, -1, 0, 1, 2]))\nprint(find_closest_elements([]))\n\
    print(find_closest_elements([0]))\nprint(find_closest_elements([-1, 0, 1, 2, 3,\
    \ 5, 6, 7, 8, 9]))\n</cell>\n<cell>", "    if len(numbers) < 2:\n        return\
    \ None, None\n\n    sorted_numbers = sorted(numbers)\n    closest_tuple = (sorted_numbers[0],\
    \ sorted_numbers[1])\n\n    for num in numbers[2:]:\n        distance = abs(num\
    \ - closest_tuple[1])\n        if distance < closest_tuple[0]:\n            closest_tuple\
    \ = (num, distance)\n\n    return closest_tuple\n", "    return min(numbers),\
    \ max(numbers)\n", "    smallest = numbers[0]\n    largest = numbers[0]\n    for\
    \ i in numbers[1:]:\n        if i < smallest:\n            smallest = i\n    \
    \    elif i > largest:\n            largest = i\n    return (smallest, largest)\n\
    \n", "    smallest_difference = float(\"inf\")\n    smallest_element = -1\n  \
    \  largest_difference = float(\"-inf\")\n    largest_element = -1\n    \n    for\
    \ num in numbers:\n        difference = abs(num - smallest_element)\n        if\
    \ difference < smallest_difference:\n            smallest_difference = difference\n\
    \            smallest_element = num\n        difference = abs(num - largest_element)\n\
    \        if difference > largest_difference:\n            largest_difference =\
    \ difference\n            largest_element = num\n            \n    return smallest_element,\
    \ largest_element\n            \n        \n        \n        \n        \n    \n\
    \    \n    ", "    distance_to_closest = numbers[0]\n    smaller_number = 0\n\
    \    larger_number = 1\n    for num in numbers:\n        delta = abs(num - distance_to_closest)\n\
    \        if delta < abs(num - larger_number):\n            larger_number = num\n\
    \        elif delta > abs(num - smaller_number):\n            smaller_number =\
    \ num\n    return (smaller_number, larger_number)\n", "    sorted_numbers = sorted(numbers)\n\
    \    return sorted_numbers[numbers.index(min(numbers))], sorted_numbers[numbers.index(max(numbers))]\n\
    \n", "    return min(numbers), max(numbers)\n", "    # Sort the supplied list\
    \ so we can do binary search on it\n    numbers.sort()\n    # Find the positions\
    \ of the two smallest elements\n    index_a = 0\n    index_b = len(numbers) -\
    \ 1\n    # Now find the two closest numbers to each\n    while index_a < index_b:\n\
    \        # Keep track of the numbers so we can return them in order\n        closest_a\
    \ = numbers[index_a]\n        closest_b = numbers[index_b]\n        # Get the\
    \ middle element\n        middle = (index_a + index_b) // 2\n        # See which\
    \ element should be closer to the middle element\n        if numbers[middle] >\
    \ closest_a:\n            index_a = middle\n        elif numbers[middle] < closest_b:\n\
    \            index_b = middle\n        else:\n            index_a = middle\n \
    \           index_b = middle\n    # Return the two closest numbers\n    return\
    \ closest_a, closest_b\n</code>\n<|/ a |>\n<| a dscore=2 |>\nYou can try below\
    \ Python code which uses bisect module to find out index of nearest number from\
    \ list\n<code>\nimport bisect\n\nnumbers = [10.0, 30.0, 50.0, 70.0, 100.0, 125.0,\
    \ 140.0, 150.0, 170.0, 200.0]\nprint(numbers)", "    if len(numbers) < 2:\n  \
    \      return numbers[0], numbers[0]\n    else:\n        closest_elements = []\n\
    \        closest_elements.append(min(numbers))\n        closest_elements.append(max(numbers))\n\
    \    return tuple(closest_elements)\n\n", "    closest_values: List[float] = []\n\
    \    closest_value: float\n    prev_value: float\n    for value in numbers:\n\
    \        if value == prev_value:\n            closest_values.append(value)\n \
    \       else:\n            prev_value = value\n            closest_value = prev_value\n\
    \            closest_values.append(closest_value)\n    return closest_values\n",
  "    closest_pairs = []\n    for index in range(len(numbers)):\n        closest_pairs.append(\
    \ (min(numbers), max(numbers)) )\n        closest_pairs[index] = (numbers[index],\
    \ numbers[index])\n    return closest_pairs\n", "    # Initialize variables\n\
    \    smallest_difference = numbers[0] - numbers[1]\n    closest_to_first_element\
    \ = numbers[0]\n    closest_to_second_element = numbers[1]\n\n    # Select elements\
    \ close to each other and compare\n    for n in range(2, len(numbers)):\n    \
    \    current_difference = numbers[n] - numbers[n - 1]\n        if current_difference\
    \ < smallest_difference:\n            smallest_difference = current_difference\n\
    \            closest_to_first_element = numbers[n]\n        elif current_difference\
    \ == smallest_difference:\n            closest_to_second_element = numbers[n]\n\
    \n    return (closest_to_first_element, closest_to_second_element)\n", "    assert\
    \ len(numbers) >= 2\n\n    # find the smallest number\n    smallest = numbers[0]\n\
    \    smallest_index = 0\n\n    # find the largest number\n    largest = numbers[0]\n\
    \    largest_index = 0\n\n    # find the two numbers in the middle\n    middle_num\
    \ = numbers[1]\n    middle_num_index = 1\n\n    # now loop through the list and\
    \ find the numbers\n    for index, num in enumerate(numbers):\n        if smallest\
    \ > num:\n            smallest = num\n            smallest_index = index\n   \
    \     if largest < num:\n            largest = num\n            largest_index\
    \ = index\n        if middle_num > num:\n            middle_num = num\n      \
    \      middle_num_index = index\n\n    if smallest == largest:\n        return\
    \ (smallest, middle_num)\n    elif smallest == middle_num:\n        return (smallest,\
    \ largest)\n    else:\n        return (middle_num, largest)\n", "    n = len(numbers)\n\
    \    if n == 1:\n        return (numbers[0], numbers[0])\n    elif n == 0:\n \
    \       return (numbers[1], numbers[1])\n    else:\n        numbers = sorted(numbers)\n\
    \        midpoint = int(n / 2)\n        if numbers[midpoint] > numbers[mid + 1]:\n\
    \            minval = numbers[midpoint]\n            minpos = midpoint\n     \
    \       minval = numbers[mid + 1]\n            maxval = numbers[midpoint]\n  \
    \          maxpos = midpoint\n            midpos += 1\n            midpos += 1\n\
    \            midpos += 1\n        else:\n            minval = numbers[midpoint]\n\
    \            minpos = midpoint\n            minval = numbers[mid + 1]\n      \
    \      maxval = numbers[midpoint]\n            maxpos = midpoint\n           \
    \ midpos -= 1\n            midpos -= 1\n            midpos -= 1\n    return (numbers[minpos],\
    \ numbers[maxpos])\n", "    if len(numbers) <= 1:\n        raise AssertionError(\"\
    Input must have at least 2 numbers\")\n\n    smallest_number = numbers[0]\n  \
    \  largest_number = numbers[0]\n    smallest_index, largest_index = None, None\n\
    \    for index, number in enumerate(numbers[1:], start=1):\n        if abs(smallest_number\
    \ - number) < abs(largest_number - number):\n            smallest_number, largest_number\
    \ = number, smallest_number\n            smallest_index, largest_index = index,\
    \ index\n        else:\n            smallest_number, largest_number = number,\
    \ largest_number\n            smallest_index, largest_index = index, index\n\n\
    \    return (smallest_number, largest_number)\n\n", "    diffs = [ (abs(number\
    \ - target), index) for index, number in enumerate(numbers) ]\n    return diffs.sort()[0]\n\
    \n", "    if len(numbers) < 2:\n        raise ValueError(f\"At least two numbers\
    \ should be supplied for find_closest_elements(). {len(numbers)} supplied\")\n\
    \n    first = min(numbers)\n    second = max(numbers)\n\n    if first == second:\n\
    \        return first, first\n\n    center = (first + second) / 2\n\n    return\
    \ first, center\n\n", "    closest_numbers_index = 0\n    closest_numbers_diff\
    \ = 0\n    closest_numbers_diff_index = 0\n    \n    \n    if numbers[0] - numbers[1]\
    \ >= 0:\n        closest_numbers_index = -1\n        closest_numbers_diff = numbers[0]\
    \ - numbers[1]\n        closest_numbers_diff_index = 0\n        \n    else:\n\
    \        closest_numbers_index = -1\n        closest_numbers_diff = numbers[1]\
    \ - numbers[0]\n        closest_numbers_diff_index = 1\n    \n    for i in range(1,len(numbers)):\n\
    \        \n        if numbers[closest_numbers_diff_index] - numbers[closest_numbers_diff_index-1]\
    \ >= 0:\n            \n            diff = numbers[closest_numbers_diff_index]\
    \ - numbers[closest_numbers_diff_index-1]\n            \n            if diff >\
    \ closest_numbers_diff:\n                closest_numbers_diff = diff\n       \
    \         closest_numbers_diff_index = closest_numbers_diff_index\n          \
    \      \n                closest_numbers_index = i\n                \n       \
    \     else:\n                closest_numbers_diff_index = closest_numbers_diff_index\n\
    \                \n        \n        else:\n            \n            diff = numbers[closest_numbers_diff_index]\
    \ - numbers[closest_numbers_diff_index]\n            \n            if diff > closest_numbers_diff:\n\
    \                closest_numbers_diff = diff\n                closest_numbers_diff_index\
    \ = closest_numbers_diff_index\n                \n                closest_numbers_index\
    \ = i\n                \n            else:\n                closest_numbers_diff_index\
    \ = closest_numbers_diff_index\n                \n    return numbers[closest_numbers_index],\
    \ numbers[closest_numbers_index+closest_numbers_diff_index]\n\n", "    if len(numbers)\
    \ < 2:\n        return numbers[0], numbers[0]\n    numbers.sort()\n    smallest\
    \ = float(numbers[0])\n    largest = float(numbers[1])\n    return smallest, largest\n",
  "    if len(numbers) == 1:\n        return numbers[0], numbers[0]\n    else:\n \
    \       sorted_numbers = sorted(numbers)\n        smallest = sorted_numbers[0]\n\
    \        largest = sorted_numbers[1]\n        if smallest > largest:\n       \
    \     return numbers[0], sorted_numbers[0]\n        elif smallest < largest:\n\
    \            return sorted_numbers[1], numbers[1]\n        else:\n           \
    \ return numbers[0], sorted_numbers[0]\n", "    smallest_number, largest_number\
    \ = numbers[0], numbers[-1]\n    closest_numbers = []\n    for number in numbers:\n\
    \        if number < smallest_number:\n            smallest_number = number\n\
    \        elif number > largest_number:\n            largest_number = number\n\
    \        closest_numbers.append(number)\n    return smallest_number, largest_number\n",
  "    assert len(numbers) >= 2\n\n    smallest_num = numbers[0]\n    largest_num\
    \ = numbers[0]\n\n    for num in numbers:\n        if abs(num - smallest_num)\
    \ < abs(num - largest_num):\n            smallest_num = num\n        else:\n \
    \           largest_num = num\n\n    return (smallest_num, largest_num)\n\n",
  "    largest_number, smallest_number = numbers[0], numbers[1]\n    closest_numbers\
    \ = [largest_number, smallest_number]\n\n    for i in range(1, len(numbers)):\n\
    \        current_number = numbers[i]\n        closest_number = current_number\n\
    \        smaller_number = numbers[i - 1]\n        larger_number = numbers[i +\
    \ 1]\n\n        if current_number > largest_number:\n            closest_number\
    \ = smaller_number\n            largest_number = current_number\n        elif\
    \ current_number < smallest_number:\n            closest_number = larger_number\n\
    \            smallest_number = current_number\n        else:\n            pass\n\
    \n        closest_numbers.append(closest_number)\n\n    return tuple(closest_numbers)\n\
    \n", "    closest_numbers = []\n    closest_numbers.append(numbers[0])\n    closest_numbers.append(numbers[1])\n\
    \n    for current_number in numbers:\n        smallest_difference = abs(current_number\
    \ - numbers[0])\n        second_smallest_difference = abs(current_number - numbers[1])\n\
    \n        if smallest_difference < second_smallest_difference:\n            closest_numbers[0]\
    \ = current_number\n        elif second_smallest_difference < smallest_difference:\n\
    \            closest_numbers[1] = current_number\n        else:\n            print(\"\
    Error: Both numbers are equal\")\n            raise Exception\n    return closest_numbers\n\
    \n", "    if len(numbers) <= 1:\n        raise ValueError(\"There must be at least\
    \ 2 numbers\")\n    lowest_value = numbers[0]\n    second_lowest_value = numbers[1]\n\
    \    for value in numbers:\n        if value < lowest_value:\n            second_lowest_value\
    \ = lowest_value\n            lowest_value = value\n        elif value > lowest_value:\n\
    \            second_lowest_value = value\n        elif value == lowest_value:\n\
    \            second_lowest_value = value\n    return lowest_value, second_lowest_value\n",
  "    closest_number = None\n    second_closest_number = None\n    for index, number\
    \ in enumerate(numbers):\n        distance = abs(number - closest_number) if closest_number\
    \ is not None else abs(number - second_closest_number)\n        if distance <\
    \ closest_number:\n            second_closest_number = closest_number\n      \
    \      closest_number = number\n        elif distance < second_closest_number:\n\
    \            second_closest_number = number\n    return (closest_number, second_closest_number)\n",
  "    # find the smallest and largest numbers in the list\n    smallest, largest\
    \ = numbers[0], numbers[-1]\n    # loop over the list\n    for n in numbers[1:]:\n\
    \        # find the smallest and largest numbers in the list\n        if n > largest:\n\
    \            largest = n\n        if n < smallest:\n            smallest = n\n\
    \    return (smallest, largest)\n", "    smallest = numbers[0]\n    largest =\
    \ numbers[0]\n    for i in range(len(numbers)):\n        if numbers[i] > largest:\n\
    \            largest = numbers[i]\n        if numbers[i] < smallest:\n       \
    \     smallest = numbers[i]\n    return smallest, largest\n", "    if len(numbers)\
    \ < 2:\n        raise ValueError(f\"Need at least two numbers to find the closest\
    \ number. Received {len(numbers)}\")\n\n    # sort so largest number is the first\
    \ number\n    numbers.sort()\n\n    # find the two numbers that are closest to\
    \ eachother\n    closest_to_both = numbers[0] + numbers[1] - min(numbers)\n\n\
    \    return numbers[1], closest_to_both\n", "    smallest: float = numbers[0]\n\
    \    largest: float = numbers[0]\n    for n in numbers[1:]:\n        if n <= smallest:\n\
    \            smallest = n\n        if n >= largest:\n            largest = n\n\
    \    return smallest, largest\n\n", "    min_value = numbers[0]\n    min_index\
    \ = -1\n    for i in range(1, len(numbers)):\n        if numbers[i] < min_value:\n\
    \            min_value = numbers[i]\n            min_index = i\n    return (numbers[min_index],\
    \ numbers[min_index + 1])\n", "    if not numbers:\n        return None, None\n\
    \    if numbers[0] == numbers[1]:\n        return numbers[0], numbers[0]\n   \
    \ smallest_value = min(numbers)\n    largest = max(numbers)\n    difference =\
    \ largest - smallest_value\n    if difference < .0000000001:\n        return smallest_value,\
    \ largest\n    else:\n        closest_num = smallest_value\n        closest_val\
    \ = smallest_value\n        closest_dif = difference\n        for n in numbers:\n\
    \            dif = largest - n\n            if abs(dif) < closest_dif:\n     \
    \           closest_dif = dif\n                closest_val = n\n             \
    \   closest_num = n\n        return (closest_num, closest_val)\n", "    # Your\
    \ code goes here\n    if len(numbers) < 2:\n        return None, None\n    sorted_numbers\
    \ = sorted(numbers)\n    return sorted_numbers[0], sorted_numbers[1]\n", "   \
    \ smallest_number = numbers[0]\n    largest_number = numbers[0]\n    smallest_difference\
    \ = abs(smallest_number - numbers[1])\n    largest_difference = abs(largest_number\
    \ - numbers[1])\n    for number in numbers:\n        difference = abs(number -\
    \ numbers[1])\n        if difference < smallest_difference:\n            smallest_difference\
    \ = difference\n            smallest_number = number\n        elif difference\
    \ > largest_difference:\n            largest_difference = difference\n       \
    \     largest_number = number\n    return (smallest_number, largest_number)\n\n",
  "    \n    # First sort the list by the number\n    numbers.sort()\n\n    # now\
    \ just find the two nearest numbers\n    return numbers[len(numbers)//2], numbers[len(numbers)//2+1]\n\
    \n", "    numbers.sort(key=abs)\n    return numbers[0], numbers[1]\n\n", "   \
    \ smallest_value = numbers[0]\n    biggest_value = numbers[0]\n    smallest_index\
    \ = 0\n    biggest_index = 1\n\n    # find smallest and largest values\n    for\
    \ index in range(1,len(numbers)):\n        if numbers[index] < smallest_value:\n\
    \            smallest_value = numbers[index]\n            smallest_index = index\n\
    \        elif numbers[index] > biggest_value:\n            biggest_value = numbers[index]\n\
    \            biggest_index = index\n\n    # find the two closest values in both\
    \ lists\n    closest_values = []\n    closest_values.append(numbers[smallest_index])\n\
    \    closest_values.append(numbers[biggest_index])\n\n    return smallest_value,\
    \ biggest_value\n", "    assert len(numbers) >= 2, \"The list must have at least\
    \ two elements to compare\"\n    \n    # find the smaller of the two numbers\n\
    \    smallest = min(numbers)\n    \n    # find which number is larger\n    largest_index\
    \ = len(numbers) - 1\n    for index in range(0, len(numbers)-1):\n        if numbers[index]\
    \ > numbers[largest_index]:\n            largest_index = index\n    \n    return\
    \ (smallest, numbers[largest_index])\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
