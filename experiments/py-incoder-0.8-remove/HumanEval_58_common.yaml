name: HumanEval_58_common
language: py
prompt: "from typing import List\n\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n\
  \    \"\"\"Return sorted unique common elements for two lists.\n        \n    \"\
  \"\"\n"
tests: "def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5,\
  \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3,\
  \ 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  \
  \  assert candidate([4, 3, 2, 8], []) == []\n\ndef test_check():\n    check(common)\n\
  \ntest_check()\n"
completions: ["    return list(set(l1).intersection(set(l2))) # pylint: disable=not-callable\n",
  "    \n    common = []\n    for item in l1:\n        if item in l2:\n          \
    \  common.append(item)\n    \n    return sorted(list(set(common)))\n", "    l1_set\
    \ = set(l1)\n    l2_set = set(l2)\n    \n    return list(l1_set & l2_set)\n\n",
  "    res: List[int] = []\n    for i in l1:\n        if i in l2:\n            res.append(i)\n\
    \    l1 = set(l1)\n    l2 = set(l2)\n    res = list(l1.intersection(l2))\n   \
    \ res.sort()\n    return res\n", "    if len(l1) > len(l2):\n        return common(l2,\
    \ l1)\n    elif len(l1) < len(l2):\n        return common(l1, l2)\n    else:\n\
    \        set1 = set(l1)\n        set2 = set(l2)\n        return sorted(list(set1\
    \ & set2))\n", "    n1 = len(l1)\n    n2 = len(l2)\n    common = []\n    for i\
    \ in range(n1):\n        if i in l2 and i not in common:\n            common.append(i)\n\
    \    for i in range(n2):\n        if i in l1 and i not in common:\n          \
    \  common.append(i)\n    return common\n", "    l1_set = set(l1)\n    l2_set =\
    \ set(l2)\n    return list(l1_set.intersection(l2_set))\n", "    return sorted(set(l1)\
    \ & set(l2))\n", "    if not l1 or not l2:\n        return []\n    return list(set(l1).intersection(set(l2)))\n",
  "    return sorted(list(set(l1) & set(l2)))\n    \n", "    return list(set(l1) &\
    \ set(l2))\n    \n", "    s = set(l1 + l2)\n    intersection = s.intersection(l1\
    \ + l2)\n    return sorted(list(intersection))\n\n", "    l1_set = set(l1)\n \
    \   l2_set = set(l2)\n    common = l1_set.intersection(l2_set)\n    return sorted(common)\n",
  "    return sorted(set(l1) & set(l2))\n", "    common = set(l1) & set(l2)\n    return\
    \ sorted(list(common))\n", "    def contains(l1, l2, elem):\n        \"\"\"Given\
    \ two lists and an element to search for, return \n           True if the element\
    \ is in both lists.\"\"\"\n        for e in l1:\n            if e == elem:\n \
    \               return True\n        for e in l2:\n            if e == elem:\n\
    \                return True\n        return False\n    \n    out = []\n    for\
    \ elem in l1:\n        if contains(l2, l1, elem):\n            out.append(elem)\n\
    \    return out\n</cell>\n<cell>\nl1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\
    \ 13, 14]\nl2 = [3, 5, 7, 8, 14]\n\ncommon(l1, l2)\n</cell>\n<cell>\ncommon(l2,\
    \ l1)\n</cell>\n<cell>\ncommon([5, 9], [6, 9])\n</cell>\n<cell>\ncommon([1, 5],\
    \ [1, 8])\n</cell>\n<cell>", "    \n    common = []\n    for a in l1:\n      \
    \  for b in l2:\n            if a == b:\n                common.append(a)\n  \
    \  return common\n    ", "    \n    unique_common_values = []\n    \n    for i\
    \ in l1:\n        if i in l2:\n            unique_common_values.append(i)\n  \
    \  \n    return unique_common_values\n    \n", "    l1_uset = set(l1)\n    l2_uset\
    \ = set(l2)\n    common = l1_uset & l2_uset\n    common = list(common)\n    common.sort()\n\
    \    return common\n", "    i = 0\n    l = len(l1)\n    li = l1 + l2\n    ri =\
    \ l1[::-1] + l2\n    \n    while i < l:\n        if li[i] != ri[i]:\n        \
    \    break\n        i += 1\n        \n    return li[:i]\n        \n        ",
  "    common = []\n    for item in l1:\n        if item in l2:\n            common.append(item)\n\
    \    common.sort()\n    return common\n\n", "    from itertools import filterfalse\n\
    \    return sorted(list(set(filter(lambda x: x in l2, l1))))\n", "    \n    common\
    \ = []\n    \n    for el1 in l1:\n        for el2 in l2:\n            if el1 ==\
    \ el2:\n                common.append(el1)\n                \n    return common\n\
    \n", "    ls1, ls2 = list(l1), list(l2)\n    ls = list(ls1)\n    ls1.extend(ls2)\n\
    \    return sorted(ls)\n", "    # create list for storing common elements\n  \
    \  common_list = []\n    \n    # go through each element in first list and check\
    \ if it is in second list\n    for i in l1:\n        if i in l2:\n           \
    \ common_list.append(i)\n            \n    # return sorted unique common elements\n\
    \    common.sort()\n    return common\n    ", "    \n    if len(l1) != len(l2):\n\
    \        raise Exception(\"list lengths must be equal\")\n    \n    l = min(len(l1),\
    \ len(l2))\n    \n    if l == 0:\n        return []\n    \n    s = set(l1)\n \
    \   intersection = s.intersection(l2)\n    \n    return sorted(list(intersection))\n",
  "    return list(set(l1) & set(l2))\n", "    res = []\n    # Find elements in both\
    \ lists\n    for x in l1:\n        if x in l2:\n            res.append(x)\n\n\
    \    # Remove duplicates\n    return list(set(res))\n", "    \n    # return sorted(set().intersection(l1,\
    \ l2))\n    return list(set(l1) & set(l2))\n", "    return sorted(list(set(l1)\
    \ & set(l2))) # Python 3\n\n", "    return list(set(l1) & set(l2))\n", "    #\
    \ Get the length of the shorter list.\n    if len(l1) > len(l2):\n        l1,\
    \ l2 = l2, l1\n\n    # Iterate through the two lists and remove duplicates.\n\
    \    common = []\n    while len(l1):\n        x = l1.pop()\n        while len(l2):\n\
    \            y = l2.pop()\n            if x == y:\n                common.append(x)\n\
    \                l1.remove(x)\n                l2.remove(y)\n                break\n\
    \            \n        # Remove duplicates.\n        if len(common) == len(l1)\
    \ or not len(common):\n            break\n        \n    return common\n", "  \
    \  i = j = 0\n    while True:\n        if l1[i] != l2[j]:\n            break\n\
    \        i += 1\n        j += 1\n    return l1[:i] + l2[j:]\n", "    result: List[int]\
    \ = []\n    for i in l1:\n        if i in l2:\n            result.append(i)\n\
    \    return result\n", "    \n    return sorted(list(set(l1) & set(l2)))\n", " \
    \   return list(set(l1).intersection(set(l2)))\n\n", "    intersection = set(l1)\
    \ & set(l2)\n    return sorted(list(intersection))\n", "    return sorted(set(l1)\
    \ & set(l2))\n</cell>\n<cell>", "    return list(set(l1) & set(l2))\n\n", "  \
    \  i = j = 0\n    for e in l1:\n        while j < len(l2) and l[j] == e:\n   \
    \         j += 1\n        if j == len(l2):\n            l1.append(e)\n       \
    \ else:\n            l2.append(e)\n            i = j\n            j = i + 1\n\
    \    while i < len(l1):\n        l1.pop(i)\n    return l1\n            ", "  \
    \  return list(set(l1) & set(l2))\n\n", "    i = 0\n    j = 0\n    while i < len(l1)\
    \ and j < len(l2):\n        if l1[i] == l2[j]:\n            i += 1\n         \
    \   j += 1\n        elif l1[i] > l2[j]:\n            i += 1\n        elif l1[i]\
    \ < l2[j]:\n            j += 1\n    return l1[i : ]\n", "    return list(set(l1)\
    \ & set(l2))\n", "    \n    return sorted(list(set(l1) & set(l2)))\n\n", "   \
    \ res1 = list(set(l1))\n    res2 = list(set(l2))\n    return res1 + res2 #+ list(set(l1).intersection(l2))\n",
  "    \n    # Compute union\n    u = sorted(set(l1) | set(l2))\n    \n    # Return\
    \ sorted common elements\n    return sorted(list(set(l1).intersection(set(l2))))\n\
    </cell>\n<cell>", "    if len(l1) != len(l2):\n        raise ValueError(\"Lists\
    \ must have same length.\")\n    return list(set(l1) & set(l2))\n\n", "    common\
    \ = []\n    for i in l1:\n        if i in l2:\n            common.append(i)\n\
    \    return sorted(common)\n", "    shared = []\n    l = set(l1) & set(l2)\n \
    \   for i in l:\n        if l1.count(i) > l2.count(i):\n            shared.append(i)\n\
    \        else:\n            shared.append(i)\n    return shared\n", "    from\
    \ itertools import combinations as combs\n    return sorted(list(set(l1) & set(l2)))\n",
  "    s = set()\n    res = []\n    for e in l1:\n        if e in s:\n           \
    \ continue\n        s.add(e)\n        res.append(e)\n    return res\n", "    s\
    \ = set(l1)\n    \n    return [i for i in l2 if i in s]\n", "    return sorted(set(l1)\
    \ & set(l2))\n", "    \n    l1_set = set(l1)\n    l2_set = set(l2)\n    return\
    \ list(l1_set.intersection(l2_set))\n    ", "    set2 = set(l2)\n    return [x\
    \ for x in l1 if x in set2]\n", "    if not l2:\n        return l1\n    if not\
    \ l1:\n        return l2\n\n    res = []\n\n    # Sort lists and iterate through\
    \ them.\n    l1.sort()\n    l2.sort()\n    while l1 and l2:\n        if l1[0]\
    \ != l2[0]:\n            break\n        res.append(l1[0])\n        l1.pop(0)\n\
    \        l2.pop(0)\n\n    return res\n", "    import itertools\n    i1, i2 = itertools.tee(sorted(l1\
    \ + l2))\n    i1 = iter(i1)\n    return list(i2)\n", "    a = set(l1)\n    b =\
    \ set(l2)\n    return sorted(list(a - b))\n", "    return list(set(l1) & set(l2))\n",
  "    i = 0\n    j = 0\n    common = []\n    while i < len(l1) and j < len(l2):\n\
    \        if l1[i] == l2[j]:\n            common += l1[i:i+1]\n            i +=\
    \ 2\n            j += 2\n        else:\n            if l1[i] < l2[j]:\n      \
    \          i += 1\n            else:\n                j += 1\n    return common\n\
    \n", "    return list(set(l1).intersection(l2))\n\n", "    return sorted(set(l1)\
    \ & set(l2))\n<|/ file filename=utils.py source=github dstars=1 |>", "    \n \
    \   list1 = list(set(l1))\n    list2 = list(set(l2))\n    \n    common = []\n\
    \    \n    for i1 in range(len(list1)):\n        for i2 in range(len(list2)):\n\
    \            if list1[i1] == list2[i2]:\n                common.append(list1[i1])\n\
    \    \n    return sorted(common)\n", "    s = set(l1) \n    return list(s.intersection(l2))\n",
  "    return sorted(list(set(l1) & set(l2)))\n", "    return sorted(list(set(l1)\
    \ & set(l2)))\n", "    return list(set(l1).intersection(set(l2)))\n", "    from\
    \ collections import Counter\n    return Counter(l1).intersection(Counter(l2)).keys()\n\
    \n", "    \n    uniques1 = set(l1)\n    uniques2 = set(l2)\n    \n    common =\
    \ [x for x in uniques1 if x in uniques2]\n    \n    return sorted(common)\n</cell>\n\
    <cell>", "    from collections import defaultdict\n    d = defaultdict(list)\n\
    \    for item in l1+l2:\n        d[item].append(item)\n    return [item for item\
    \ in d.values() if len(item)>1]\n", "    res = []\n    for el in l1:\n       \
    \ if el not in l2:\n            res.append(el)\n    return res\n", "    # Find\
    \ common length\n    len_l1 = len(l1)\n    len_l2 = len(l2)\n    \n    if len_l1\
    \ > len_l2:\n        return l2[len_l1:]\n    else:\n        return l1[len_l2:]\n\
    </cell>\n<cell>", "    from itertools import combinations\n    return list(sorted(set(l1)\
    \ & set(l2))) # return set intersection\n", "    return list(sorted(set(l1).intersection(set(l2))))\n",
  "    if not l2:\n        return l1\n    if not l1:\n        return l2\n    \n  \
    \  shared_set = set(l1) & set(l2)\n    return list(shared_set)\n", "    answer\
    \ = []\n    \n    # First sort both lists\n    l1.sort()\n    l2.sort()\n    \n\
    \    # Iterate through l1, and keep track of where in l2 we've found a match\n\
    \    pos = 0\n    \n    # Iterate through l2, and keep track of where in l1 we've\
    \ found a match\n    pos_l2 = len(l2)\n    \n    # Loop while we have found a\
    \ match\n    while pos < len(l1) and pos < pos_l2:\n        # If the item at position\
    \ pos is the same as the item at position\n        # pos_l2 then we've found a\
    \ match\n        if l1[pos] == l2[pos_l2]:\n            answer.append(l1[pos])\n\
    \            \n        # Increment pos to the next position in l2\n        pos_l2\
    \ += 1\n        \n        # If the item at position pos is not the same as the\
    \ item at\n        # position pos_l2 then we haven't found a match\n        else:\n\
    \            pos += 1\n    \n    # Return the answer\n    return answer\n", " \
    \   common = set(l1) & set(l2)\n    common.sort()\n    return common\n", "   \
    \ \n    l1_set = set(l1)\n    l2_set = set(l2)\n    \n    if len(l1_set & l2_set)\
    \ == 0:\n        return l1_set\n    if len(l2_set & l1_set) == 0:\n        return\
    \ l2_set\n    \n    # Deal with sets by their smaller length\n    if len(l1_set)\
    \ > len(l2_set):\n        l1_set_list = list(l1_set)\n        l2_set_list = list(l2_set)\n\
    \        \n        common_list = l1_set_list & l2_set_list\n        \n       \
    \ return sorted(common_list)\n    else:\n        l2_set_list = list(l2_set)\n\
    \        l1_set_list = list(l1_set)\n        \n        common_list = l2_set_list\
    \ & l1_set_list\n        \n        return sorted(common_list)\n    ", "    \n\
    \    \n    \n    l1 = list(set(l1))\n    l2 = list(set(l2))\n    \n    \n    if\
    \ l1 == []:\n        return l2\n    if l2 == []:\n        return l1\n    \n  \
    \  \n    if l1[0] <= l2[0]:\n        left = l1\n        right = l2\n    else:\n\
    \        left = l2\n        right = l1\n    \n    \n    for a in left:\n     \
    \   for b in right:\n            if a == b:\n                left.remove(a)\n\
    \                right.remove(b)\n                break\n    return left + right\n\
    \    \n    \n    \n    ", "    common_list = []\n    for e in l1:\n        if\
    \ e in l2:\n            common_list.append(e)\n            \n    return sorted(common_list)\n\
    </cell>\n<text>\nProblem 3\nThe first function below contains two nested for loops\
    \ iterating over two lists. These two lists contain different types of information.\
    \ How could you modify this function so that it uses both lists simultaneously\
    \ and only returns common values? \n\nNote: You will need to use the function\
    \ \"common()\" defined above.\n\n\n</text>\n<cell>", "    from collections import\
    \ Counter\n    return sorted(list(set(l1) & set(l2)))\n\n", "    return list(set(l1)\
    \ & set(l2))\n", "    l1 = sorted(l1)\n    l2 = sorted(l2)\n    return list(set(l1).intersection(set(l2)))\n",
  "    from collections import defaultdict\n    \n    common_keys = set(l1) & set(l2)\n\
    \    common_keys = list(common_keys)\n    common_keys.sort()\n\n    return common_keys\n\
    \n", "    return list(set(l1).intersection(l2))\n", "    return list(set(l1) &\
    \ set(l2))\n</cell>\n<cell>", "    from itertools import takewhile\n    seen =\
    \ set([])\n    return [x for x in takewhile(lambda x: x in seen or seen.add(x),\
    \ l1+l2)]\n    ", "    return sorted(list(set(l1) & set(l2)))\n", "    import\
    \ bisect\n    return list(set(l1) & set(l2))\n", "    a = set(l1)\n    b = set(l2)\n\
    \    return sorted(list(a&b))\n</cell>\n<cell>", "    return list(set(l1) & set(l2))\n",
  "    return list(set(l1) & set(l2))\n    ", "    # http://stackoverflow.com/a/954438/2578004\n\
    \    def common_elements(list_one: list, list_two: list) -> list:\n        intersection\
    \ = list_one & list_two\n        return list(set(list_one) & set(list_two))\n\n\
    \    common = common_elements(l1,l2)\n    # print(\"common: \" + str(common))\n\
    \    return common\n", "    \n    it1 = iter(l1)\n    it2 = iter(l2)\n    while\
    \ True:\n        try:\n            e1 = next(it1)\n            e2 = next(it2)\n\
    \        except StopIteration:\n            break\n        if e1 == e2:\n    \
    \        yield e1\n        else:\n            yield e1\n            yield e2\n\
    \        ", "    \n    seen = set()\n    seen_add = seen.add\n    return [x for\
    \ x in l1 if x in seen or seen_add(x)] + [x for x in l1 if x not in seen and seen_add(x)]\n\
    \n", "    \n    common = []\n    \n    for i, j in zip(l1, l2):\n        if i\
    \ == j:\n            common.append(i)\n        else:\n            break\n    \n\
    \    return common\n\n", "    \n    l = set()\n    l.update(l1)\n    l.update(l2)\n\
    \    return sorted(l)\n</cell>\n<cell>\ncommon([1, 1, 2, 1], [1, 2, 2])\n</cell>\n\
    <cell>\ncommon([4, 3, 1, 2, 1, 2, 2], [4, 2, 1, 3])\n</cell>\n<text>\nA more generalizable\
    \ approach\nIn the above example, one might want to be able to apply common()\
    \ to lists of any length. For example, we can use it to calculate the intersection\
    \ of two lists of any length. We can use functools.partial to create a function\
    \ to handle an arbitrary number of lists, and then call it with the lists of interest.\n\
    \n\n</text>\n<cell>", "    common = []\n    l = min(len(l1), len(l2))\n    for\
    \ i in range(l):\n        if l1[i] == l2[i]:\n            common.append(l1[i])\n\
    \        elif l1[i] < l2[i]:\n            common.extend(l2[i:])\n            break\n\
    \        else:\n            common.extend(l1[i:])\n            break\n    return\
    \ common\n", "    return sorted(set(l1).intersection(set(l2)))\n\n", "    common_elements\
    \ = set(l1) & set(l2)\n    common_elements = list(common_elements)\n    common_elements.sort()\n\
    \    return common_elements\n", "    return sorted(list(set(l1) & set(l2)))\n",
  "    \n    lst = sorted(list(set(l1 + l2)) + [0])\n    \n    return lst\n    ",
  "    \n    common = []\n    for x in l1:\n        if x in l2:\n            common.append(x)\n\
    \    return common\n", "    \n    # Sort both lists and extract common elements\n\
    \    sorted_l1 = sorted(l1)\n    sorted_l2 = sorted(l2)\n    common = []\n   \
    \ \n    # Check if lists are equal\n    if sorted_l1 == sorted_l2:\n        return\
    \ common\n    \n    # Iterate through two lists simultaneously\n    for i, item\
    \ in enumerate(sorted_l1):\n        \n        # If a common item has been found,\
    \ append to common list\n        if item in sorted_l2:\n            common.append(item)\n\
    \            \n        # If a common item is NOT found, then continue with next\
    \ item in list\n        else:\n            continue\n            \n    return\
    \ common\n", "    common = []\n    l2_set = set(l2)\n    for x in l1:\n      \
    \  if x in l2_set:\n            common.append(x)\n    return common\n    ", " \
    \   from functools import reduce\n    l1set = set(l1)\n    l2set = set(l2)\n \
    \   return list(reduce(set.intersection, (l1set, l2set)))\n", "    res: List[int]\
    \ = []\n    i = 0\n    while i < len(l1) and i < len(l2):\n        if l1[i] !=\
    \ l2[i]:\n            break\n        i += 1\n    res.extend(l1[i:])\n    res.extend(l2[i:])\n\
    \    return list(set(res))\n", "    set1 = set(l1)\n    set2 = set(l2)\n    return\
    \ list(set1 & set2)\n", "    common = []\n    for i in l1:\n        if i in l2:\n\
    \            common.append(i)\n    return sorted(common)\n", "    l2 = list(l2)\n\
    \    return sorted(set(l1) & set(l2))\n", "    lst = list(set(l1) | set(l2))\n\
    \    lst.sort()\n    return lst\n", "    li = []\n    li2 = []\n    for i in l1:\n\
    \        if i not in li:\n            li.append(i)\n    for j in l2:\n       \
    \ if j not in li2:\n            li2.append(j)\n    li = sorted(li)\n    li2 =\
    \ sorted(li2)\n    return li + li2\n", "    res: List[int] = []\n    for i in\
    \ l1:\n        if i in l2:\n            res.append(i)\n    for i in l2:\n    \
    \    if i in res:\n            res.remove(i)\n    return res\n\n", "    l1.sort()\n\
    \    l2.sort()\n    \n    for i in l1:\n        if i in l2 and l2[i] not in l1:\n\
    \            l1.append(l2[i])\n            \n    return l1\n", "    from itertools\
    \ import combinations\n    return sorted(set(l1) & set(l2))\n", "    from functools\
    \ import reduce\n    \n    return list(reduce(lambda x, y: x + y, [list(y) for\
    \ y in filter(lambda x: x in l1, l2)]))\n</cell>\n<cell>\ncommon([1, 2, 3], [4,\
    \ 5, 6, 7])\n</cell>\n<text>\nThe unique function was introduced in Python version\
    \ 3.5.\n\n\n</text>\n<cell>\ncommon([1, 2, 3], [4, 5, 6])\n</cell>\n<cell>\ncommon(['a','b','c'],\
    \ ['a','b','c'])\n</cell>\n<text>\nThe sorted function was introduced in Python\
    \ version 2.7.\n\n\n</text>\n<cell>\nsorted(['z','y','x','w'])\n</cell>\n<cell>\n\
    sorted(['z','y','x','w'], key=int)\n</cell>\n<text>\nThe set function was introduced\
    \ in Python 2.7.\n\n\n</text>\n<cell>\nset(['z','y','x','w'])\n</cell>\n<cell>\n\
    set(['z','y','x','w'], key=int)\n</cell>\n<text>\nThe frozenset function was introduced\
    \ in Python 3.4.\n\n\n</text>\n<cell>\nfrozenset(['z','y','x','w'])\n</cell>\n\
    <cell>\nfrozenset(['z','y','x','w'], key=int)\n</cell>\n<text>\nThe sorted function\
    \ was introduced in Python version 3.4.\n\n\n</text>\n<cell>\nsorted?\n</cell>\n\
    <text>\nThe sorted function was introduced in Python version 3.5.\n\n\n</text>\n\
    <cell>\nsorted?\n</cell>\n<text>\nThe sorted function was introduced in Python\
    \ version 2.7.\n\n\n</text>\n<cell>\nsorted?\n</cell>\n<text>\nThe sorted function\
    \ was introduced in Python version 3.5.\n\n\n</text>\n<cell>\nsorted?\n</cell>\n\
    <text>\nThe sorted function was introduced in Python version 2.7.\n\n\n</text>\n\
    <cell>\nsorted?\n</cell>\n<text>\nThe sorted function was introduced in Python\
    \ version 3.5.\n\n\n</text>\n<cell>\nsorted?\n</cell>\n<text>\nThe sorted function\
    \ was introduced in Python version 3.4.\n\n\n</text>\n<cell>\nsorted?\n</cell>\n\
    <text>\nThe sorted function was introduced in Python version 2.7.\n\n\n</text>\n\
    <cell>\nsorted?\n</cell>\n<text>\nThe sorted function was introduced in Python\
    \ version 3.4.\n\n\n</text>\n<cell>\nsorted?\n</cell>\n<text>\nThe sorted function\
    \ was introduced in Python version 2.7.\n\n\n</text>\n", "    return list(set(l1)\
    \ & set(l2))\n", "    return list(set(l1).intersection(set(l2)))\n\n", "    common\
    \ = []\n    \n    i = j = 0\n    \n    while i < len(l1) and j < len(l2):\n  \
    \      if l1[i] == l2[j]:\n            common.append(l1[i])\n            i +=\
    \ 1\n            j += 1\n        else:\n            if i < len(l1):\n        \
    \        i += 1\n            else:\n                j += 1\n    \n    return common\n",
  "    return list(set(l1) & set(l2))\n", "    \n    result = []\n    for x in l1:\n\
    \        if x in l2:\n            result.append(x)\n    result.sort()\n    return\
    \ result\n</cell>\n<cell>\ncommon([10, 30, 10, 20, 50, 10, 40], [50, 20, 10, 40])\n\
    </cell>\n<text>\nReverse a list\n\n</text>\n<text>\nLists allow us to access the\
    \ elements by their indexes, but this approach is more suited to lists of unknown\
    \ length (e.g., strings, tuples). We can use the slice notation to reverse the\
    \ list.\n\n\n</text>\n<cell>\nnames = ['Alan', 'Bob', 'Charles']\n</cell>\n<cell>\n\
    names[::-1]\n</cell>\n<text>\nUse reversed to check for duplicates\n\n</text>\n\
    <cell>\nnames = ['Alan', 'Bob', 'Charles']\n</cell>\n<cell>\nnames.reversed\n\
    </cell>\n<cell>\nnames.reverse()\n</cell>\n<cell>\nnames.reverse()\n</cell>\n\
    <text>\nCheck for duplicates\n\n</text>\n<cell>\nnames = ['Alan', 'Bob', 'Charles',\
    \ 'Dan', 'Eve', 'Eric']\n</cell>\n<cell>\nset(names)\n</cell>\n<text>\nSorting\n\
    \n</text>\n<text>\nPython has an inbuilt function sort() which can be used to\
    \ sort the list inplace. We can also create a sorted copy of the list with sorted()\n\
    \n\n</text>\n<cell>\nnumbers = [4, 2, 10, 9, 0, 5, 3, 1]\n</cell>\n<cell>\nnumbers[:]\
    \ = sorted(numbers)\n</cell>\n<cell>\nnumbers\n</cell>\n<cell>\nnumbers.sort()\n\
    </cell>\n<cell>\nnumbers\n</cell>\n<cell>\nnumbers = sorted(numbers)\n</cell>\n\
    <cell>\nnumbers\n</cell>\n<cell>\nnumbers, numbers2\n</cell>\n<cell>\nnumbers[:]\
    \ = []\n</cell>\n<text>\nCount the elements in a list\n\n</text>\n<text>\nPython\
    \ has a built-in function count() which can be used to count the occurrences of\
    \ an element in a list.\n\n\n</text>\n<cell>\nnames = ['Alan', 'Bob', 'Charles',\
    \ 'Dan', 'Eve', 'Eric']\n</cell>\n<cell>\nnames.count('Bob')\n</cell>\n<text>\n\
    Find the first index where a value is greater than a certain value\n\n</text>\n\
    <cell>\nnames = ['Alan', 'Bob', 'Charles', 'Dan', 'Eve', 'Eric']\n</cell>\n<cell>\n\
    names.index('Bob')\n</cell>\n<text>\nFind the last ", "    if len(l1) != len(l2):\n\
    \        raise Exception(f\"Lengths differ, {len(l1)} != {len(l2)}\")\n\n    return\
    \ list(set(l1) & set(l2))\n", "    l1 = list(set(l1))\n    l2 = list(set(l2))\n\
    \    return sorted(list(set(l1).intersection(set(l2))))\n\n", "    set1 = set(l1)\n\
    \    set2 = set(l2)\n    common = set1 & set2\n    return sorted(common)\n", " \
    \   return sorted(list(set(l1) & set(l2)))\n", "    return list(set(l1) & set(l2))\n\
    \    ", "    set1 = set(l1)\n    set2 = set(l2)\n    return list(set1.intersection(set2))\n",
  "    \n    #\_pylint: disable=len-as-condition\n    if len(l1) != len(l2):\n   \
    \     raise Exception(\"Not same length\")\n    \n    s1 = set(l1)\n    s2 = set(l2)\n\
    \    \n    s1 = sorted(s1)\n    s2 = sorted(s2)\n    \n    return list(s1.intersection(s2))\n\
    \    ", "    common = []\n    for e in l1:\n        if e in l2:\n            common.append(e)\n\
    \    common.sort()\n    return common\n", "    l1 = set(l1)\n    l2 = set(l2)\n\
    \    return list(sorted(l1 & l2))\n", "    return list(set(l1) & set(l2))\n",
  "    l1 = set(l1)\n    l2 = set(l2)\n\n    return sorted(list(l1 & l2))\n\n", " \
    \   l1 = sorted(l1)\n    l2 = sorted(l2)\n    \n    diff = list(set(l1) & set(l2))\n\
    \    diff.sort()\n    \n    return diff\n", "    l1 = sorted(set(l1))\n    l2\
    \ = sorted(set(l2))\n    return list(itertools.chain(*[x for x in itertools.combinations(l1,\
    \ 1) if x in l2]))\n", "    s = set(l1)\n    c = set(l2)\n    return list(s.intersection(c))\n\
    \n", "    \n    return list(set(l1) & set(l2))\n    ", "    \n    s = set(l2)\n\
    \    return [x for x in l1 if x in s]\n</cell>\n<cell>\ncommon([1,5,2,7,2], \n\
    \       [2,4,3,6,8])\n</cell>\n<cell>\ncommon([1,5,2,7,2], \n       [1,2,4,3,8])\n\
    </cell>\n<cell>\ncommon([1,5,2,7,2], \n       [3,4,3,6,8])\n</cell>\n<text>\n\
    Write a function which takes two lists and returns their intersection.\n\n\n</text>\n\
    <cell>", "    l1 = sorted(l1)\n    l2 = sorted(l2)\n    \n    for i in range(min(len(l1),\
    \ len(l2))):\n        if l1[i] == l2[i]:\n            continue\n        if l1[i]\
    \ > l2[i]:\n            l1, l2 = l2, l1\n        else:\n            l1, l2 = l1,\
    \ l2\n    \n    return l1+l2\n", "    return sorted(list(set(l1) & set(l2)))\n",
  "    \n    s1, s2 = set(l1), set(l2)\n    return list(s1 & s2)\n", "    # Get the\
    \ intersection of two sets and get a list of elements common to both lists\n \
    \   intersection = set(l1) & set(l2)\n    common = list(intersection)\n\n    #\
    \ Sort the common elements\n    common.sort()\n    return common\n</cell>\n<text>\n\
    Now let's see some examples:\n\n\n</text>\n<cell>\nprint(common([1,10,100], [100,10,100]))\n\
    print(common([2,3,5,7], [2,3,4,5,6,7]))\nprint(common(['a','b','c'], [ 'c', 'b',\
    \ 'a']))\nprint(common(['a','b','c'], [ 'b', 'a', 'c']))\n</cell>\n<text>\nNote\
    \ that in each case we have a list with the elements of both input lists.  This\
    \ may be a problem if you are not dealing with a list of lists.  For example:\n\
    \n\n</text>\n<cell>\nprint(common(['a','b','c'], [ 'a', 'b', 'c']))\n</cell>\n\
    <text>\nIf you want to find unique elements in a list, use set operations, as\
    \ shown above.\n\nAs a final example, let's look at strings (of words).\n\nIn\
    \ the last section, we created a list of the words in our text.  We can find unique\
    \ elements by using a set operation on the list:\n\n\n</text>\n<cell>\nwords =\
    \ ['the', 'a', 'the', 'and', 'a', 'the', 'the', 'the']\nprint(set(words))\n</cell>\n\
    <text>\nAnd as you can see, this does not preserve the order of the items:\n\n\
    \n</text>\n<cell>\nprint(words)\n</cell>\n<text>\nIf we really wanted the order\
    \ preserved, then we could use the OrderedSet class from the collections module.\
    \  It is a subclass of set:\n\nfrom collections import OrderedSet\n", "    return\
    \ [x for x in l1 if x in l2]\n", "    def in_both(l1, l2):\n        a, b = l1[0],\
    \ l2[0]\n        for i in l1:\n            if i not in l2:\n                return\
    \ False\n        for j in l2:\n            if j not in l1:\n                return\
    \ False\n        return True\n    return list(filter(lambda x: in_both(x, l2),\
    \ l1))\n</code>\n<|/ a tags=python,duplicates,list,python-3.x |>\n<| c |>\nI don't\
    \ get it. My code isn't working at all. Can you elaborate?\n<|/ c |>\n<| c |>\n\
    my code is working but if you need explanation please let me know\n<|/ c |>\n\
    <| c |>\nSure but if you don't know how to get started with python, it takes some\
    \ time to research\n<|/ c |>\n<| c |>\ni think that i should learn python first.\
    \ Because i don't know anything about python\n<|/ c |>\n<| c |>\nI suggest you\
    \ learn python before doing this. Even if you don't learn python as fast as you\
    \ want, you will get the hang of it. The reason is because you'll need to do a\
    \ lot more than you can with other languages (such as `numpy`). You'll also need\
    \ to understand `zip()` (to know how `for` loops work), `filter()` (to know how\
    \ `in` works) and `lambda`s (to know what `map()` does). I know it's hard, but\
    \ if you follow these rules, you will get it.\n<|/ c |>\n<| a |>\nYou could use\
    \ set to keep track of the unique elements:\n<code>", "    return sorted(list(set(l1)\
    \ & set(l2)))\n\n", "    return list(set(l1) & set(l2))\n", "    l1 = sorted(l1)\n\
    \    l2 = sorted(l2)\n\n    i, j, l = 0, 0, len(l1)\n    while i < l:\n      \
    \  while j < l:\n            if l1[i] == l2[j]:\n                break\n     \
    \       j += 1\n        i += 1\n\n    return l1[:i]\n", "    s = set(l1)\n   \
    \ return list(s.intersection(l2))\n", "    shared = []\n    for i in l1:\n   \
    \     if i in l2:\n            shared.append(i)\n    return shared\n", "    def\
    \ helper(l: List[int]) -> List[int]:\n        common = []\n        for i in l:\n\
    \            if i not in common:\n                common.append(i)\n        return\
    \ common\n\n    if len(l1) != len(l2):\n        return None\n    return sorted(helper(l1),\
    \ key=lambda x:x) if len(l1) == len(l2) else None\n", "    return sorted(list(set(l1)\
    \ & set(l2)))\n", "    s = set(l1)\n    intersection = [i for i in l1 if i in\
    \ s and i not in l2]\n    return list(s)+intersection\n</cell>\n<cell>\ncommon([10,\
    \ 20, 30, 40, 50, 50], [20, 30, 40, 50, 60, 70])\n</cell>\n<text>\nList comprehensions:\
    \ List expressions in Python\n\n</text>\n<cell>\n[i for i in range(len(nums))\
    \ if nums[i] > 9]\n</cell>\n<cell>\n[nums[i] for i in range(len(nums)) if nums[i]\
    \ > 9]\n</cell>\n<cell>\n[nums[i] for i in sorted(range(len(nums)), key=lambda\
    \ i: nums[i])]\n</cell>\n<cell>\n[nums[i] for i in sorted(range(len(nums)), key=lambda\
    \ i: nums[i])]\n</cell>\n<cell>\n[nums[i] for i in sorted(nums)]\n</cell>\n<cell>\n\
    [nums[i] for i in sorted(nums, reverse=True)]\n</cell>\n<cell>\n[nums[i] for i\
    \ in sorted(nums, reverse=True)[:3]]\n</cell>\n<cell>\n[nums[i] for i in sorted(nums,\
    \ reverse=True)[:3] if nums[i]<100]\n</cell>\n<cell>\n[nums[i] for i in sorted(nums,\
    \ reverse=True)[:3] if nums[i]<100 and i>0]\n</cell>\n<cell>\n[nums[i] for i in\
    \ sorted(nums, reverse=True)[:3] if nums[i]<100 and i>0 and i<20]\n</cell>\n<text>\n\
    Functions\n\n</text>\n<text>\nFunctions are a way to package code to be reused\
    \ in multiple places, and to call that code at different points throughout our\
    \ program. Let\u2019s take a look at a simple example:\n\n\n</text>\n<cell>",
  "    l = list(set(l1).intersection(set(l2)))\n    l.sort()\n    return l\n", " \
    \   return list(set(l1) & set(l2))\n", "    return list(set(l1) & set(l2))\n",
  "    seen = set()\n    return [x for x in l1 if x in seen or seen.add(x)] + [x\n\
    \        for x in l2 if x not in seen or seen.add(x)]\n", "    l1 = sorted(l1)\n\
    \    l2 = sorted(l2)\n    intersection = set(l1) & set(l2)\n    return sorted(list(intersection))\n",
  "    return sorted(list(set(l1) & set(l2)))\n", "    from collections import Counter\n\
    \    counter = Counter(l1)\n    return list({key for key, count in counter.items()\
    \ if count == min(len(l1), len(l2)) and key in l2}\n                .intersection(set(l2)))\n",
  "    intersection = list(set(l1) & set(l2))\n    union = list(set(l1) | set(l2))\n\
    \    return sorted(list(intersection)) if intersection else union\n", "    \n\
    \    l1 = list(l1)\n    l2 = list(l2)\n    \n    i = j = 0\n    \n    while i\
    \ < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            i += 1\n\
    \            j += 1\n        else:\n            if l1[i] < l2[j]:\n          \
    \      i += 1\n            else:\n                j += 1\n    \n    if j == len(l2):\n\
    \        return l1[:i]\n    else:\n        return l2[:j]\n    ", "    common =\
    \ []\n    for e in l1:\n        if e in l2:\n            common.append(e)\n  \
    \  return sorted(common)\n", "    return sorted(list(set(l1) & set(l2)))\n", " \
    \   a = sorted(set(l1))\n    b = sorted(set(l2))\n    return list(set(a).intersection(set(b)))\n\
    </cell>\n<cell>\ncommon(list(range(6)), list(range(5, 7)))\n</cell>\n<text>\n\
    Now the function common will return the following result\n\n\n</text>\n<cell>\n\
    common([2,1], [6,1])\n</cell>\n<text>\nWe can now use this function in the following\
    \ way\n\n\n</text>\n<cell>", "    def f(i1, i2):\n        return (l1[i1] <= l2[i2])\
    \ if i1 < i2 else (l1[i1] >= l2[i2])\n    \n    return [i for i in l1 if i in\
    \ l2] + [i for i in l2 if i in l1][sorted([i for i, j in zip(l1, l2) if f(i, j)])]\n",
  "    \n    if len(l1) != len(l2):\n        raise ValueError(\"Lists are not same\
    \ length\")\n    \n    set1 = set(l1)\n    set2 = set(l2)\n    \n    return list(set1\
    \ & set2)\n", "    \n    return list(set(l1) & set(l2))\n    ", "    return sorted(list(set(l1)\
    \ & set(l2)))\n    \n\n</cell>\n<cell>", "    from collections import defaultdict\n\
    \    common = defaultdict(int)\n    for k in l1:\n        common[k] += 1\n   \
    \ for k in l2:\n        common[k] -= 1\n    common = sorted(common.keys())\n \
    \   return common\n", "    diff = []\n    for i in l2:\n        if i not in diff:\n\
    \            diff.append(i)\n    \n    return sorted(set(l1).intersection(l2))\n\
    </code>\nOutput:\n<code>\ncommon([1,4,3,5],[0,1,4,3])\n</code>\nOutput:\n<code>\n\
    common([1,4,3,5],[0,1,4,2,5])\n</code>\n<|/ a tags=algorithm,python dscore=2 |>\n\
    <| c |>\nIt does work if you pass it `[0,1,4,3]` and `[0,1,4,2,5]`\n<|/ c |>\n\
    <| c |>\nAgreed! I wrote it wrong! Thanks for noticing! Fixed it\n<|/ c |>\n<|\
    \ c |>\nGreat! I like the `intersection` solution better!\n<|/ c |>\n<| a tags=algorithm,python\
    \ |>\nYou can use a set intersection and a lambda to make the code shorter:\n\
    <code>\nlst1 = [1,4,3,5]\nlst2 = [0,1,4,3,5]\nprint(set(lst1) & set(lst2))\n</code>\n\
    Output:\n<code>\n{0, 3, 5}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is better\
    \ than my answer. Thank you!\n<|/ c |>\n<| a dscore=1 tags=algorithm,python |>\n\
    <code>\nlst1 = [1,4,3,5]\nlst2 = [0,1,4,3,5]\n\ncommon = [i for i in lst1 if i\
    \ in lst2]\ncommon = [i for i in lst if i not in common]\n</code>\n<|/ a |>\n\
    <| a |>\nYou can use sets:\n<code>\nlst1 = [1,4,3,5]\nlst2 = [0,1,4,3,5]\n\nlst\
    \ = [*set(lst1),*set(lst2)]\nprint(lst)\n</code>\nOutput:\n<code>\n[0, 3, 5]\n\
    </code>\n<|/ a tags=algorithm,python dscore=1 |>\n<| a tags=algorithm,python |>\n\
    <code>\nlst1 = [1,4,3,5]\nlst2 = [0,1,4,3,5]\n\ncommon = [i for i in lst1 if i\
    \ in lst2]\nprint(common)\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,python\
    \ |>\nYou can use set intersection but in reverse order\n<code>\nlst1 = [1,4,3,5]\n\
    lst2 = [0,1,4,3,5]\n\n[i for i in lst1 if i in lst2]\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\nlst1 = [1,4,3,5]\nlst2 = [0,1,4,3,5]\n\ncommon\
    \ = [i for i in lst1 if i in lst2]\ncommon = [i for i in common ", "    \n   \
    \ # find the unique items in list1\n    unique1 = set(l1)\n    \n    # find the\
    \ unique items in list2\n    unique2 = set(l2)\n    \n    # return unique items\
    \ that are in both lists\n    return list(unique1.intersection(unique2))\n    ",
  "    l1_set = set(l1)\n    l2_set = set(l2)\n    return list(sorted(l1_set & l2_set))\n",
  "    return [i for i in l1 if i in l2]\n\n", "    # Sort lists for easier processing\n\
    \    l1 = sorted(l1)\n    l2 = sorted(l2)\n    \n    # Find intersection\n   \
    \ intersection = l1 & l2\n    \n    # Add common elements to the end of list 2\n\
    \    # and remove duplicates from list 1\n    for x in intersection:\n       \
    \ l2.append(x)\n        l1.remove(x)\n    \n    # Return sorted list\n    return\
    \ sorted(list(l1))\n    ", "    \n    # Sort the lists first\n    l1 = sorted(l1)\n\
    \    l2 = sorted(l2)\n    \n    # Check for equal lengths\n    if len(l1) != len(l2):\n\
    \        raise Exception('Lists cannot be of different lengths')\n    \n    #\
    \ Find common elements\n    common = []\n    \n    for i in range(len(l1)):\n\
    \        if l1[i] in l2:\n            common.append(l1[i])\n    \n    return common\n\
    </cell>\n<cell>", "    # https://stackoverflow.com/questions/480214/how-do-you-remove-duplicates-from-a-list-in-python-whilst-preserving-order#\n\
    \    l1 = list(dict.fromkeys(l1))\n    l2 = list(dict.fromkeys(l2))\n    intersect\
    \ = list(set(l1).intersection(set(l2))) # faster version from https://stackoverflow.com/a/49551876/285594\n\
    \    \n    return list(dict.fromkeys(intersect))\n", "    set2 = set([x for x\
    \ in l2 if not x in l1])\n    set1 = set([x for x in l1 if not x in l2])\n   \
    \ return list(set1 & set2)\n", "    return list(set(l1) & set(l2))\n", "    s\
    \ = set(l1)\n    intersection = s.intersection(l2)\n    return sorted(list(intersection))\n",
  "    intersect = list(set(l1) & set(l2))\n    common = list(set(l1) & set(l2))\n\
    \    for val in intersect:\n        common.append(val)\n    common.sort()\n  \
    \  return common\n</cell>\n<cell>\ncommon([1,2,3],[3,4,5])\n</cell>\n<cell>\n\
    common([1,2,3],[2,3,5])\n</cell>\n<cell>\ncommon([1,2,3],[2,3,4])\n</cell>\n<cell>\n\
    common([1,2,3],[2,3,6])\n</cell>\n<cell>\ncommon([1,2,3],[2,3])\n</cell>\n<cell>\n\
    common([1,2],[3,4])\n</cell>\n<cell>\ncommon([1,2],[1,2])\n</cell>\n<cell>\ncommon([1,2],[2,1])\n\
    </cell>\n<cell>\ncommon([1,2,3,4],[3,4,5])\n</cell>\n<cell>\ncommon([1,2,3,4],[2,3,5])\n\
    </cell>\n<cell>\ncommon([1,2,3,4],[2,3,4])\n</cell>\n<cell>\ncommon([1,2,3],[2,4])\n\
    </cell>\n<cell>\ncommon([1,2,3],[4,2])\n</cell>\n<cell>\ncommon([1,2],[2,1])\n\
    </cell>\n<cell>\ncommon([1,2],[3,1])\n</cell>\n<cell>\ncommon([1,2],[4,1])\n</cell>\n\
    <cell>", "    \n    common = [i for i in l1 if i in l2]\n    common.sort()\n \
    \   \n    return common\n</cell>\n<cell>\ncommon(common([1,2],[2,3,4]),[1,2,3,4])\n\
    </cell>\n<cell>\ncommon(common([1,2,3],[2,3,4]),[2,3,4])\n</cell>\n<cell>\ncommon(common([1,2,3],[2,3,4]),[2,3,5])\n\
    </cell>\n<cell>\ncommon(common([1,3],[2,3,4]),[2,3,4])\n</cell>\n<cell>\ncommon(common([1,3],[2,3,4]),[2,3,5])\n\
    </cell>\n<text>\n2.3 Intersection\nWrite a function intersection(l1: List[int],\
    \ l2: List[int]) -> List[int] that takes two lists and returns a list containing\
    \ the elements that exist in both lists. \n        \n\"\"\"\n\n\n</text>\n<cell>",
  "    sorted_list1 = sorted(l1)\n    sorted_list2 = sorted(l2)\n    common = sorted_list1\
    \ + sorted_list2\n    common.sort()\n    return common\n", "    return list(set(l1).intersection(set(l2)))\
    \ # type: ignore\n<|/ file source=github ext=.py filename=utils.py |>\nfrom typing\
    \ import Any, Union\n", "    set1 = set(l1)\n    set2 = set(l2)\n    return list(set1\
    \ & set2)\n", "    return sorted(list(set(l1) & set(l2))) \n", "    l = sorted(l1)\n\
    \    return list(set(l) & set(l2))\n", "    return sorted(list(set(l1) & set(l2)))\n",
  "    return sorted(list(set(l1) & set(l2)))\n", "    \n    # Initialize result\n\
    \    result = []\n    \n    # Iterate through two lists and add elements to result\n\
    \    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n        \
    \        result.append(e1)\n                \n    return list(set(result))\n \
    \   \n    ", "    return sorted(set(l1) & set(l2))\n", "    return list(set(l1)\
    \ & set(l2))\n", "    return sorted(list(set(l1) & set(l2)))\n", "    answer =\
    \ []\n    for i in l1:\n        if i in l2:\n            answer.append(i)\n  \
    \  return answer\n            ", "    def intersection(xs: Set[int], ys: Set[int])\
    \ -> Set[int]:\n        \"\"\"Return the intersection of xs and ys.\n        \
    \    \n        \"\"\"\n        return set.intersection(xs, ys)\n    \n    def\
    \ union(xs: Set[int], ys: Set[int]) -> Set[int]:\n        \"\"\"Return the union\
    \ of xs and ys.\n        \n        \"\"\"\n        return set.union(xs, ys)\n\
    \    \n    def diff(xs: Set[int], ys: Set[int]) -> Set[int]:\n        \"\"\"Return\
    \ the difference of xs and ys.\n        \n        \"\"\"\n        return set.difference(xs,\
    \ ys)\n    \n    if len(l1) != len(l2):\n        raise ValueError\n    return\
    \ list(union(*[\n        diff(l1[:i], l2[:i]) for i in range(1, len(l1) + 1)\n\
    \    ]))\n    ", "    common = []\n    for i in l1:\n        if i in l2 and i\
    \ not in common:\n            common.append(i)\n    return common\n", "    from\
    \ collections import Counter\n    common_list = list(set(l1).intersection(set(l2)))\n\
    \    common_list.sort()\n    return common_list\n\n", "    def uniq(lst: List[T])\
    \ -> List[T]:\n        seen = set()\n        return [ x for x in lst if x not\
    \ in seen and not seen.add(x) ]\n    return uniq(sorted(l1)) & uniq(sorted(l2))\n",
  "    \n    tmp = list(set(l1) & set(l2))\n    tmp.sort()\n    \n    return tmp\n",
  "    intersection = set(l1) & set(l2)\n    union = set(l1) | set(l2)\n    return\
    \ [i for i in union if i in intersection]\n</cell>\n<cell>\nassert common([1,3,5],\
    \ [1,2,3]) == [3]\nassert common([\"a\",\"b\",\"c\"], [\"b\",\"c\",\"d\"]) ==\
    \ [\"b\", \"d\"]\n</cell>\n<cell>", "    return sorted(set(l1) & set(l2))\n",
  "    i = j = 0\n    while i < len(l1) and j < len(l2):\n        if l1[i] < l2[j]:\n\
    \            l1.pop(i)\n            i += 1\n        else:\n            l2.pop(j)\n\
    \            j += 1\n    \n    if i < len(l1):\n        l1 += [0] * (i - len(l1))\n\
    \    if j < len(l2):\n        l2 += [0] * (j - len(l2))\n    return l1\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
