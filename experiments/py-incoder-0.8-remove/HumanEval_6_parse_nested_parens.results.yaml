language: py
name: HumanEval_6_parse_nested_parens
results:
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if paren_string\
    \ == '':\n        return []\n    paren_depth = 0\n    paren_pairs = []\n    paren_str\
    \ = ''\n    for i in range(len(paren_string)):\n        if paren_string[i] ==\
    \ '(':\n            paren_depth += 1\n            paren_pairs.append([paren_depth,\
    \ i+1])\n            paren_str = paren_string[i]\n        elif paren_string[i]\
    \ == ')':\n            paren_depth -= 1\n            paren_pairs.append([paren_depth,\
    \ i+1])\n            paren_str = paren_string[i]\n        else:\n            paren_str\
    \ = paren_str + paren_string[i]\n\n    if paren_str != '':\n        return parse_nested_parens(paren_str)\n\
    \    else:\n        return paren_pairs\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpshqr3oh9.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmpshqr3oh9.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpshqr3oh9.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpshqr3oh9.py\", line 27, in parse_nested_parens\n\
    \    return parse_nested_parens(paren_str)\n  File \"/tmp/tmpshqr3oh9.py\", line\
    \ 27, in parse_nested_parens\n    return parse_nested_parens(paren_str)\n  File\
    \ \"/tmp/tmpshqr3oh9.py\", line 27, in parse_nested_parens\n    return parse_nested_parens(paren_str)\n\
    \  [Previous line repeated 993 more times]\n  File \"/tmp/tmpshqr3oh9.py\", line\
    \ 9, in parse_nested_parens\n    if paren_string == '':\nRecursionError: maximum\
    \ recursion depth exceeded in comparison\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if paren_string.count(\"\
    (\") < 1:\n        raise ValueError(\"Parentheses group is not valid.\")\n   \
    \ group_count = 0\n    cur_level = 1\n    level_list = [0]\n    for char in paren_string:\n\
    \        if char == \"(\":\n            group_count += 1\n            level_list.append(group_count)\n\
    \        elif char == \")\":\n            group_count -= 1\n            level_list.pop()\n\
    \        elif char == \",\":\n            cur_level += 1\n            level_list.append(cur_level)\n\
    \        else:\n            raise ValueError(\"Unexpected character in paren group:\
    \ {}\".format(char))\n    return level_list\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmply0rhv1h.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmply0rhv1h.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmply0rhv1h.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmply0rhv1h.py\", line 25, in parse_nested_parens\n\
    \    raise ValueError(\"Unexpected character in paren group: {}\".format(char))\n\
    ValueError: Unexpected character in paren group:  \n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    level =\
    \ 0\n    result = []\n    for i,char in enumerate(paren_string):\n        if char\
    \ == '(':\n            level += 1\n        if char == ')':\n            level\
    \ -= 1\n            if level == 0:\n                result.append(i)\n    return\
    \ result\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp55tvbsdu.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmp55tvbsdu.py\", line 26,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp55tvbsdu.py\"\
    , line 21, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_level\
    \ = 0\n    levels_up = 0\n\n    parentheses = 0\n    nested_levels = []\n\n  \
    \  opening_parentheses = 0\n    opening_par_count = 0\n\n    for c in paren_string:\n\
    \        parentheses += 1\n        if c == '(':\n            nested_levels.append(paren_level)\n\
    \            paren_level += 1\n            opening_par_count = 0\n           \
    \ opening_parentheses += 1\n        elif c == ')':\n            nested_levels[-1]\
    \ -= 1\n            opening_parentheses -= 1\n            if nested_levels[-1]\
    \ == 0:\n                nested_levels.pop()\n            else:\n            \
    \    opening_par_count += 1\n        elif c == '[' or c == '{':\n            opening_par_count\
    \ += 1\n        elif c == ']' or c == '}':\n            opening_par_count -= 1\n\
    \        else:\n            pass\n\n    if parentheses == 0:\n        pass\n \
    \   else:\n        raise AssertionError(f'Number of parentheses: {parentheses}\
    \ is not equal to 0')\n\n    return nested_levels\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpzoe6mbr9.py\", line\
    \ 55, in <module>\n    test_check()\n  File \"/tmp/tmpzoe6mbr9.py\", line 53,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpzoe6mbr9.py\"\
    , line 48, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpzoe6mbr9.py\", line 42, in parse_nested_parens\n\
    \    raise AssertionError(f'Number of parentheses: {parentheses} is not equal\
    \ to 0')\nAssertionError: Number of parentheses: 27 is not equal to 0\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpejsal38b.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpejsal38b.py\", line 17,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpejsal38b.py\"\
    , line 12, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Code\
    \ from http://stackoverflow.com/questions/181688/python-regex-for-nested-parentheses\n\
    \    # Slight modification to allow multiple nesting levels\n    nested_paren_groups\
    \ = re.finditer(r\"\\(([^()]*)\\)\", paren_string)\n    depth = 0\n    max_depth\
    \ = 0\n    for paren_group in nested_paren_groups:\n        if depth == 0 and\
    \ paren_group.group(1):\n            depth = 1\n        elif paren_group.group(1):\n\
    \            depth = depth + 1\n        if depth > max_depth:\n            max_depth\
    \ = depth\n    if depth != 0:\n        max_depth = max_depth - 1\n    return max_depth\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpy5peab6u.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmpy5peab6u.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpy5peab6u.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpy5peab6u.py\", line 11, in parse_nested_parens\n\
    \    nested_paren_groups = re.finditer(r\"\\(([^()]*)\\)\", paren_string)\nNameError:\
    \ name 're' is not defined\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    res = []\n\
    \    level = 0\n    level_string = ''\n    \n    for c in paren_string:\n    \
    \    if c == '(':\n            level += 1\n            level_string += c\n   \
    \     elif c == ')':\n            level -= 1\n            res += [level]\n   \
    \         level_string += c\n        else:\n            level_string += c\n  \
    \  \n    res += [level]\n    res += [level_string]\n    \n    return res\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpb0dz2rag.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmpb0dz2rag.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpb0dz2rag.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    max_level\
    \ = 0\n    nested_level = 0\n    levels_to_go = paren_string.count('(') - paren_string.count(')')\n\
    \    for level in range(0, levels_to_go):\n        level_paren_count = paren_string.count('(',\
    \ level+1)\n        level_paranet_count = paren_string.count(')', level+1)\n\n\
    \        if level_paranet_count > level_paren_count:\n            level_paranet_count\
    \ = level_paren_count\n        if level_paranet_count > max_level:\n         \
    \   max_level = level_paranet_count\n            nested_level = level+1\n\n  \
    \  return max_level, nested_level\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnf1ysz6v.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpnf1ysz6v.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpnf1ysz6v.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    \n    #\
    \ Parsing the given string as a nested parenthesis string \n    parsed_paren_string\
    \ = paren_string.strip().strip(\"()\")\n    \n    # Finding the deepest level\
    \ of nesting of parentheses in the string\n    level_list = []\n    \n    # looping\
    \ through the parenthesis string \n    for idx, character in enumerate(parsed_paren_string):\n\
    \        # append the index if the character is a closing parenthesis\n      \
    \  level_list.append(idx+1) if (character == \"(\") else 0\n    \n    # return\
    \ the deepest level of nesting of parentheses \n    return level_list[::-1]\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqx2ymci1.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpqx2ymci1.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqx2ymci1.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if paren_string\
    \ == '':\n        return []\n    stack = []\n    prev_level = -1\n    open_count\
    \ = 0\n    for idx, char in enumerate(paren_string):\n        if char == \"(\"\
    :\n            open_count += 1\n            stack.append(idx)\n        if char\
    \ == \")\":\n            stack.pop()\n            open_count -= 1\n          \
    \  if open_count == 0:\n                prev_level = stack.pop()\n           \
    \     break\n    return stack\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp6ui4nd11.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmp6ui4nd11.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp6ui4nd11.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp6ui4nd11.py\", line 22, in parse_nested_parens\n\
    \    prev_level = stack.pop()\nIndexError: pop from empty list\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Replace\
    \ all '()' with '(' first, then replace all ')' with ')' last\n    paren_string\
    \ = paren_string.replace('()', '(', -1).replace(')', ')', -1)\n    count = 0\n\
    \    max_level = 0\n    nesting_list = []\n    paren_string_list = list(paren_string)\n\
    \    for char in range(len(paren_string)):\n        if paren_string_list[char]\
    \ == ')':\n            nesting_list.append(count)\n            count += 1\n  \
    \      elif paren_string_list[char] == '(':\n            nesting_list.append(count)\n\
    \            count += 1\n            count = 0\n        else:\n            count\
    \ += 1\n    if len(nesting_list) > max_level:\n        max_level = len(nesting_list)\n\
    \n    if max_level == 0:\n        return [-1, -1]\n    else:\n        nesting_list.append(max_level)\n\
    \        return nesting_list\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp4qsvxt5l.py\", line\
    \ 42, in <module>\n    test_check()\n  File \"/tmp/tmp4qsvxt5l.py\", line 40,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp4qsvxt5l.py\"\
    , line 35, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    \n    stack\
    \ = []\n    level = 0\n    \n    for c in paren_string:\n        if c == '(':\n\
    \            stack.append(level)\n            level+=1\n        elif c == ')':\n\
    \            level-=1\n            \n    levels = [0]*level\n    \n    for i,j\
    \ in enumerate(stack):\n        if j == 0:\n            levels[i] += 1 \n    \
    \    else:\n            levels[i] = max(levels[j],levels[i])\n    \n    return\
    \ levels\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpebzo4h00.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmpebzo4h00.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpebzo4h00.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpebzo4h00.py\", line 24, in parse_nested_parens\n\
    \    levels[i] += 1 \nIndexError: list index out of range\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if paren_string\
    \ == \"()\":\n        return [-1, 0]\n    else:\n        result = []\n       \
    \ level = 0\n        for i in range(len(paren_string)):\n            if paren_string[i]\
    \ == \"(\":\n                result.append(i)\n                level += 1\n  \
    \          elif paren_string[i] == \")\":\n                level -= 1\n      \
    \          result.append(i)\n        result.append(len(paren_string))\n      \
    \  return result\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjk5y0jhg.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmpjk5y0jhg.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpjk5y0jhg.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    stack =\
    \ []\n    paren_chars = []\n    for c in paren_string:\n        if c in '([{':\n\
    \            stack.append(c)\n        elif c in ')]}':\n            stack.pop()\n\
    \            if stack:\n                paren_chars.append(stack[-1])\n      \
    \      else:\n                paren_chars.append(')')\n    return paren_chars\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpcc197x5w.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpcc197x5w.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpcc197x5w.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\
    </cell>\n<cell>\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpkmvqr95e.py\", line 10\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    stack =\
    \ []\n    results = []\n    level = 0\n    for c in paren_string:\n        if\
    \ c == \"(\":\n            level += 1\n            stack.append(0)\n        elif\
    \ c == \")\":\n            stack.pop()\n            if not stack:\n          \
    \      results.append(level)\n                level -= 1\n        else:\n    \
    \        stack[-1] += 1\n\n    return results\n</cell>\n<cell>\nprint(parse_nested_parens('((()()))'))\n\
    </cell>\n<text>\nExercise 5: Calculate the minimum number of parentheses\nA sample\
    \ string like \"(()())\" would require three parentheses.\n\nYou might want to\
    \ create a function to calculate how many parentheses in a given string.\n\n\n\
    </text>\n<cell>\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpw3mpzxp6.py\", line 25\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    result\
    \ = []\n    current_depth = 0\n    for pos in range(len(paren_string) - 1, -1,\
    \ -1):\n        char = paren_string[pos]\n        if char == ')':\n          \
    \  if current_depth == 0 or current_depth > result:\n                result.append(pos)\n\
    \            elif current_depth < result:\n                result.clear()\n  \
    \              result.append(pos)\n            current_depth += 1\n        elif\
    \ char == '(':\n            current_depth -= 1\n    return result\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqu8672lo.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpqu8672lo.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqu8672lo.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpqu8672lo.py\", line 14, in parse_nested_parens\n\
    \    if current_depth == 0 or current_depth > result:\nTypeError: '>' not supported\
    \ between instances of 'int' and 'list'\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_level\
    \ = 0\n    paren_stack = []\n\n    for paren in paren_string:\n        if paren\
    \ == '(':\n            paren_level += 1\n            paren_stack.append(paren_level)\n\
    \        if paren == ')':\n            paren_level -= 1\n            paren_stack.pop()\n\
    \n    deepest_paren_level = 0\n    for paren_level in paren_stack:\n        if\
    \ deepest_paren_level < paren_level:\n            deepest_paren_level = paren_level\n\
    \n    return deepest_paren_level\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmplri55lw9.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmplri55lw9.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmplri55lw9.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if not\
    \ paren_string:\n        return []\n    stack = []\n    result = []\n    paren_stack\
    \ = []\n    index = 0\n    while index < len(paren_string):\n        if paren_string[index]\
    \ == \"(\":\n            paren_stack.append(index)\n        else:\n          \
    \  stack.append(index)\n        if paren_string[index] == \")\":\n           \
    \ if len(stack) == 0:\n                return result\n            paren_index\
    \ = stack[-1]\n            while paren_stack[-1] == paren_index:\n           \
    \     result.insert(0, paren_stack.pop())\n            index -= 1\n    return\
    \ result\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659822129
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    levels:\
    \ List[int] = []\n    cur_level = 0\n    \n    for character in paren_string:\n\
    \        if character == '(':\n            levels.append(cur_level)\n        elif\
    \ character == ')':\n            levels.append(cur_level)\n            cur_level\
    \ -= 1\n        else:\n            cur_level += 1\n    \n    return levels\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpzpp18unu.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpzpp18unu.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpzpp18unu.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Write\
    \ your code here\n    stack = []\n    level = 1\n    i = 0\n    while i < len(paren_string)-1:\n\
    \        if paren_string[i] == '(':\n            stack.append(level)\n       \
    \     level += 1\n        elif paren_string[i] == ')':\n            level += 1\n\
    \            stack.pop()\n        elif paren_string[i] == ' ':\n            pass\n\
    \        else:\n            print(i)\n            level += 1\n            stack.pop()\n\
    \        i += 1\n\n    return stack\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp65vq5a6w.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmp65vq5a6w.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp65vq5a6w.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_string\
    \ = paren_string.strip()\n    paren_level = 0\n    paren_count = 0\n    for char\
    \ in paren_string:\n        if char == '(':\n            paren_count += 1\n  \
    \          paren_level += 1\n        elif char == ')':\n            paren_count\
    \ -= 1\n            paren_level -= 1\n        else:\n            continue\n  \
    \      if paren_count < 0:\n            paren_count = 0\n        if paren_count\
    \ == 0:\n            return paren_level\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp_f51xc0p.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmp_f51xc0p.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp_f51xc0p.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_levels\
    \ = [len(paren_string)]\n    paren_level = 0\n\n    parantheses_to_check = ['{',\
    \ '}', '(', ')']\n    for paranthesis in parantheses_to_check:\n        paren_level\
    \ = max(paren_level, paren_levels[paren_level - 1])\n        if paren_level >\
    \ 0:\n            while paren_level > 0:\n                if paranthesis == paren_string[paren_level]:\n\
    \                    paren_level -= 1\n                else:\n               \
    \     break\n                paren_level = max(paren_level, paren_levels[paren_level\
    \ - 1])\n        else:\n            break\n    paren_levels.append(paren_level\
    \ + 1)\n    return paren_levels\n</cell>\n<cell>\nparsed_paren_string = '((((())))'\n\
    paren_levels = parse_nested_parens(parsed_paren_string)\nprint('Parsed paren string\
    \ for ', parsed_paren_string, ' ', paren_levels)\n</cell>\n<cell>\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmphwzt94hh.py\", line 26\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if len(paren_string)\
    \ == 0:\n        return []\n    max_level = max(parse_nested_parens(paren_string[0:-1]))\n\
    \    current_level = 1\n    list_of_lists = []\n    list_of_lists.append([paren_string])\n\
    \    list_of_lists.append([])\n    for j in range(len(list_of_lists)):\n     \
    \   current_level += 1\n        for j in range(current_level):\n            list_of_lists[j].append(list_of_lists[j][-1])\n\
    \        for j in range(len(list_of_lists)):\n            list_of_lists[j].append(list_of_lists[j][-1])\n\
    \    return list_of_lists\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp3sa68fsx.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmp3sa68fsx.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp3sa68fsx.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp3sa68fsx.py\", line 11, in parse_nested_parens\n\
    \    max_level = max(parse_nested_parens(paren_string[0:-1]))\n  File \"/tmp/tmp3sa68fsx.py\"\
    , line 11, in parse_nested_parens\n    max_level = max(parse_nested_parens(paren_string[0:-1]))\n\
    \  File \"/tmp/tmp3sa68fsx.py\", line 11, in parse_nested_parens\n    max_level\
    \ = max(parse_nested_parens(paren_string[0:-1]))\n  [Previous line repeated 24\
    \ more times]\nValueError: max() arg is an empty sequence\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if paren_string\
    \ == '':\n        return [0]\n    level = 0\n    nestings = 0\n    nesting_start\
    \ = 0\n    while nesting_start < len(paren_string):\n        if paren_string[nesting_start]\
    \ == '(':\n            level += 1\n            nestings += 1\n            nesting_start\
    \ += 1\n        elif paren_string[nesting_start] == ')':\n            level -=\
    \ 1\n            nestings += 1\n            nesting_start += 1\n        elif paren_string[nesting_start]\
    \ == ',' and nestings != 0:\n            nestings -= 1\n            nesting_start\
    \ += 1\n    nesting_end = nesting_start\n    nesting_level_diff = 0\n    while\
    \ nesting_level_diff < level:\n        nesting_level_diff += 1\n        nesting_end\
    \ = paren_string.find(',', nesting_end)\n    \n    nesting_level =  nesting_end\
    \ - nesting_start\n    return nesting_level\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659822129
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    level =\
    \ 0\n    paren_level = 0\n    paren_counter = 0\n    # Iterate through each char\
    \ in the string\n    for c in paren_string:\n        if c == '(':\n          \
    \  paren_counter += 1\n            level += 1\n        elif c == ')':\n      \
    \      paren_counter -= 1\n            if paren_counter == 0:\n              \
    \  level -= 1\n        else: # Not a left paren or right paren\n            continue\n\
    \        if level == paren_level:\n            continue\n        if paren_counter\
    \ == 0:\n            level -= 1\n        if level < paren_level:\n           \
    \ break\n        paren_level = level\n    parens = [i for i,c in enumerate(paren_string)\
    \ if c == '(']\n    return parens\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp1uffk3am.py\", line\
    \ 41, in <module>\n    test_check()\n  File \"/tmp/tmp1uffk3am.py\", line 39,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1uffk3am.py\"\
    , line 34, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    level =\
    \ 0\n    left_count = 0\n    right_count = 0\n    paren_level = None\n    paren_start_index\
    \ = None\n    paren_end_index = None\n\n    paren_string = paren_string.strip()\n\
    \    paren_string = re.sub(r\"\\)|\\)$\", \"\", paren_string)\n    paren_string\
    \ = re.sub(r\"\\(\", \"\", paren_string)\n\n    for index, char in enumerate(paren_string):\n\
    \        if char == \"(\":\n            level += 1\n            paren_level =\
    \ level\n            paren_start_index = index\n            left_count +=1\n \
    \       elif char == \")\":\n            level -= 1\n            paren_level =\
    \ level\n            paren_end_index = index\n\n    return paren_level, left_count,\
    \ right_count, paren_start_index, paren_end_index\n\ndef check(candidate):\n \
    \   assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp1a4cz5ib.py\", line\
    \ 41, in <module>\n    test_check()\n  File \"/tmp/tmp1a4cz5ib.py\", line 39,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1a4cz5ib.py\"\
    , line 34, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp1a4cz5ib.py\", line 17, in parse_nested_parens\n\
    \    paren_string = re.sub(r\"\\)|\\)$\", \"\", paren_string)\nNameError: name\
    \ 're' is not defined\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_level\
    \ = 0\n    paren_list = []\n    paren_chars = []\n    cur_pos = 0\n    for c in\
    \ paren_string:\n        if c == '(':\n            paren_level += 1\n        \
    \    paren_list.append(0)\n            paren_chars.append(c)\n        elif c ==\
    \ ')':\n            paren_level -= 1\n            paren_list.pop()\n         \
    \   if paren_level == 0:\n                cur_pos = len(paren_chars)\n       \
    \     else:\n                paren_chars[cur_pos] = c\n        else:\n       \
    \     cur_pos += 1\n            paren_chars[cur_pos] = c\n    return paren_list\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvbsrp6af.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmpvbsrp6af.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpvbsrp6af.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpvbsrp6af.py\", line 27, in parse_nested_parens\n\
    \    paren_chars[cur_pos] = c\nIndexError: list assignment index out of range\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_string\
    \ = paren_string.strip(\" \")\n    if len(paren_string) == 0:\n        return\
    \ []\n    paren_count = 0\n    levels = []\n    parens = []\n    for index, char\
    \ in enumerate(paren_string):\n        if char == \"(\":\n            paren_count\
    \ += 1\n            parens.append(index)\n        elif char == \")\":\n      \
    \      paren_count -= 1\n            if paren_count == 0:\n                levels.append(parens)\n\
    \                parens = []\n        else:\n            parens.append(index)\n\
    \    if paren_count != 0:\n        raise ValueError(\"Nested parens are not balanced\"\
    )\n    return levels\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0o5e6cgt.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmp0o5e6cgt.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp0o5e6cgt.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if len(paren_string)\
    \ <= 0:\n        return []\n    result = []\n    level = 0\n    i = 0\n    while(i\
    \ < len(paren_string)):\n        if paren_string[i] == '(':\n            level\
    \ += 1\n        if paren_string[i] == ')':\n            level -= 1\n         \
    \   if level == 0:\n                result.append(i)\n        i += 1\n    return\
    \ result\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvzmlkk99.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpvzmlkk99.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpvzmlkk99.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Initialize\
    \ to empty string\n    paren_string = \"\"\n    level = 0\n\n    # Iterate over\
    \ the characters of input string\n    for char in paren_string:\n        if char\
    \ == \"(\":\n            level += 1\n        elif char == \")\":\n           \
    \ level -= 1\n        # Assign current character to the empty string\n       \
    \ paren_string = \"\"\n        # Set the length of the current string to the new\
    \ length\n        paren_string = char_length\n\n    return level\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnkr981n8.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpnkr981n8.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpnkr981n8.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    stack:\
    \ List[int] = []\n\n    for index, character in enumerate(paren_string):\n   \
    \     if character == \"(\":\n            stack.append(index)\n        elif character\
    \ == \")\":\n            stack.pop()\n            if not stack:\n            \
    \    # Empty stack means it is an invalid expression\n                break\n\
    \            elif len(stack) == 1:\n                # If the stack is empty, means\
    \ it is only a nested parentheses.\n                # Return the last element\
    \ of the stack\n                return stack[-1]\n            else:\n        \
    \        # If not empty stack, means it is more than one level of nesting\n  \
    \              stack_length = len(stack)\n                if stack_length == 1:\n\
    \                    return stack_length\n                else:\n            \
    \        # More than two levels of nesting means invalid\n                   \
    \ break\n\n    return -1\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp12pu7xbu.py\", line\
    \ 42, in <module>\n    test_check()\n  File \"/tmp/tmp12pu7xbu.py\", line 40,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp12pu7xbu.py\"\
    , line 35, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    groups\
    \ = paren_string.split()\n    nested_level = 0\n    nested_group = []\n    for\
    \ i, group in enumerate(groups):\n        if i==0:\n            nested_group.append(group)\n\
    \        else:\n            if nested_level == 0:\n                nested_level\
    \ = 1\n            else:\n                nested_group.append(group)\n       \
    \         nested_level = max(nested_level, len(nested_group))\n    nested_level\
    \ += 1 # for the first parenthesis\n    nested_group.append(paren_string)\n  \
    \  return nested_group\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmdr3wbxh.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmpmdr3wbxh.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpmdr3wbxh.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if len(paren_string)\
    \ == 0:\n        return 0\n    paren_string = paren_string.replace('(', ' ( ')\n\
    \    paren_string = paren_string.replace(')', ' ) ')\n    paren_string = paren_string.replace('(',\
    \ ' ( ')\n    paren_string = paren_string.replace(')', ' ) ')\n    paren_string\
    \ = paren_string.replace('(', ' ( ')\n    paren_string = paren_string.replace(')',\
    \ ' ) ')\n    paren_string = paren_string.replace('(', ' ( ')\n    paren_string\
    \ = paren_string.replace(')', ' ) ')\n    paren_string = paren_string.replace('(',\
    \ ' ( ')\n    paren_string = paren_string.replace(')', ' ) ')\n    paren_string\
    \ = paren_string.replace('(', ' ( ')\n    paren_string = paren_string.replace(')',\
    \ ' ) ')\n    paren_string = paren_string.replace('(', ' ( ')\n    paren_string\
    \ = paren_string.replace(')', ' ) ')\n    paren_string = paren_string.replace('(',\
    \ ' ( ')\n    paren_string = paren_string.replace(')', ' ) ')\n    paren_string\
    \ = paren_string.replace('(', ' ( ')\n    paren_string = paren_string.replace(')',\
    \ ' ) ')\n    paren_string = paren_string.replace('(', ' ( ')\n    paren_string\
    \ = paren_string.replace(')', ' ) ')\n    paren_string = paren_string.replace('(',\
    \ ' ( ')\n    paren_string = paren_string.replace(')', ' ) ')\n    paren_string\
    \ = paren_string.replace('(', ' ( ')\n    paren_string = paren_string.replace(')',\
    \ ' ) ')\n    paren_string = paren_string.replace('(', ' ( ')\n    paren_string\
    \ = paren_string.replace(')', ' ) ')\n    paren_string = paren_string.replace('(',\
    \ ' ( ')\n    paren_string = paren_string.replace(')', ' ) ')\n    paren_string\
    \ = paren_string.replace('(', ' ( ')\n    paren_string = paren_string.replace(')',\
    \ ' ) ')\n    paren_string = paren_string.replace('(', ' ( ')\n    paren_string\
    \ = paren_string.replace(')', ' ) ')\n    paren_string = paren_string.replace('(',\
    \ ' ( ')\n    paren_string = paren_string.replace(')', ' ) ')\n    paren_string\
    \ = paren_string.replace('(', ' ( ')\n    paren_string = paren_string.replace(')',\
    \ ' ) ')\n    paren_string = paren_string.replace('(', ' ( ')\n    paren_string\
    \ = paren_string.replace(')', ' ) ')\n    paren_string = paren_string.replace('(',\
    \ ' ( ')\n    paren_string = paren_string.replace(')', ' ) ')\n    paren_string\
    \ = paren_string.replace('(', ' ( ')\n    paren_string = paren_string.replace(')',\
    \ ' ) ')\n    \ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmprzy2qkgw.py\", line\
    \ 62, in <module>\n    test_check()\n  File \"/tmp/tmprzy2qkgw.py\", line 60,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmprzy2qkgw.py\"\
    , line 55, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\
    </cell>\n<cell>\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpkmvqr95e.py\", line 10\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Do some\
    \ extra validations on the input string\n    assert paren_string.count(\"(\")\
    \ == paren_string.count(\")\") == 0, \"Parentheses are balanced.\"\n\n    # Perform\
    \ depth first search to find the deepest level \n    # of nesting\n    paren_depth\
    \ = 0\n    paren_levels = []\n    paren_level = []\n\n    for paren_char in paren_string:\n\
    \        if paren_char == '(':\n            paren_level.append(paren_char)\n \
    \           paren_depth += 1\n        elif paren_char == ')':\n            paren_depth\
    \ -= 1\n            paren_level.append(paren_char)\n        elif paren_depth >\
    \ 0:\n            if paren_char == ')':\n                paren_level.append(paren_char)\n\
    \            paren_levels.append(paren_level)\n            paren_level = []\n\
    \        else:\n            paren_level.append(paren_char)\n\n    paren_levels.append(paren_level)\n\
    \    return paren_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp07gfrmxn.py\", line\
    \ 44, in <module>\n    test_check()\n  File \"/tmp/tmp07gfrmxn.py\", line 42,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp07gfrmxn.py\"\
    , line 37, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp07gfrmxn.py\", line 10, in parse_nested_parens\n\
    \    assert paren_string.count(\"(\") == paren_string.count(\")\") == 0, \"Parentheses\
    \ are balanced.\"\nAssertionError: Parentheses are balanced.\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    \n    paren_stack\
    \ = []\n    level = 0\n    \n    i = 0\n    for p in paren_string.split():\n \
    \       if p == '(':\n            paren_stack.append(i)\n            level +=\
    \ 1\n        elif p == ')':\n            paren_stack.pop()\n            level\
    \ -= 1\n        i += 1\n    return level\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpwpznme9f.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmpwpznme9f.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpwpznme9f.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    stack =\
    \ [paren_string]\n    stack_len = len(stack)\n    nested_level = 1\n    while\
    \ stack_len > 0:\n        cur_token = stack[stack_len-1]\n        curr_len = len(cur_token)\n\
    \        if cur_token == '(':\n            stack[stack_len] = ')'\n          \
    \  stack_len -= 1\n        elif cur_token == ')':\n            stack[stack_len]\
    \ = ')'\n            stack_len -= 1\n            nested_level -= 1\n        elif\
    \ cur_token == '[':\n            stack[stack_len] = ']'\n            stack_len\
    \ -= 1\n        elif cur_token == ']':\n            stack[stack_len] = ']'\n \
    \           stack_len -= 1\n            nested_level -= 1\n        elif cur_token\
    \ == '{':\n            stack[stack_len] = '}'\n            stack_len -= 1\n  \
    \      elif cur_token == '}':\n            stack[stack_len] = '}'\n          \
    \  stack_len -= 1\n            nested_level -= 1\n        elif cur_token == '+':\n\
    \            stack[stack_len] = '+'\n            stack_len -= 1\n        elif\
    \ cur_token == '-':\n            stack[stack_len] = '-'\n            stack_len\
    \ -= 1\n        elif cur_token == '*':\n            stack[stack_len] = '*'\n \
    \           stack_len -= 1\n        elif cur_token == '/':\n            stack[stack_len]\
    \ = '/' \n            stack_len -= 1\n        elif cur_token == '%':\n       \
    \     stack[stack_len] = '%'\n            stack_len -= 1\n        elif cur_token\
    \ == '^':\n            stack[stack_len] = '^'\n            stack_len -= 1\n  \
    \      elif cur_token == '=':\n            stack[stack_len] = '='\n          \
    \  stack_len -= 1\n        elif cur_token == '!':\n            stack[stack_len]\
    \ = '!' \n            stack_len -= 1\n        elif cur_token == '&':\n       \
    \     stack[stack_len] = '&' \n            stack_len -= 1\n        elif cur_token\
    \ == '|':\n            stack[stack_len] = '|' \n            stack_len -= 1\n \
    \       elif cur_token == '<':\n            stack[stack_len] = '<' \n        \
    \    stack_len -= 1\n        elif cur_token == '>':\n            stack[stack_len]\
    \ = '>' \n            stack_len -= 1\n        elif cur_token == '|':\n       \
    \     stack[stack_len] = '|' \n            stack_len -= 1\n        elif cur_token\
    \ == '~':\n            stack[stack_len] = '~' \n            stack_len -= 1\n \
    \       elif cur_token == '`':\n            stack[stack_len] = '`' \n        \
    \    stack_len -= 1\n        elif cur_token == '\"':\n            stack[stack_len]\
    \ = '\"'\n            stack_len -= 1\n        elif cur_\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpogwlh18c.py\", line 84\n    elif cur_\n             ^\n\
    SyntaxError: expected ':'\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    stack:\
    \ List[int] = []\n    open_brackets: Dict[int, int] = dict()\n    open_brackets[1]\
    \ = 1\n    open_brackets[2] = 1\n    for index in range(0, len(paren_string)):\n\
    \        if paren_string[index] in open_brackets:\n            open_brackets[paren_string[index]]\
    \ *= 2\n            open_brackets[index] = open_brackets[paren_string[index]]\n\
    \        if paren_string[index] == \")\":\n            open_brackets.pop(paren_string[index])\n\
    \n    return stack\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkgh8pf06.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpkgh8pf06.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkgh8pf06.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpkgh8pf06.py\", line 18, in parse_nested_parens\n\
    \    open_brackets.pop(paren_string[index])\nKeyError: ')'\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    nested_count\
    \ = 0\n    paren_char = ''\n    level = 1\n    nesting_list = []\n    for char\
    \ in paren_string:\n        if char == '(':\n            nesting_list.append([])\n\
    \            nested_count += 1\n            paren_char = ''\n        elif char\
    \ == ')':\n            nested_count -= 1\n            paren_char = ''\n      \
    \      if nested_count == 0:\n                level -= 1\n                nesting_list[nesting_list.index([])]\
    \ = level\n        elif char == ',' and paren_char == '(':\n            level\
    \ = 1\n        elif char == ',' and paren_char == '{':\n            level = 2\n\
    \        elif char == ',' and paren_char == '}':\n            level = 3\n    \
    \    elif nested_count > 0:\n            nesting_list[nesting_list.index([])]\
    \ = level\n            paren_char = ''\n    return nesting_list\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp29asbtj2.py\", line\
    \ 44, in <module>\n    test_check()\n  File \"/tmp/tmp29asbtj2.py\", line 42,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp29asbtj2.py\"\
    , line 37, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_stack\
    \ = []\n    paren_stack.append(0)\n\n    paren_stack.append(0)\n    paren_stack.append(0)\n\
    \    paren_stack.append(0)\n    paren_stack.append(0)\n    paren_stack.append(0)\n\
    \n    for i in range(0, len(paren_string)):\n        if paren_stack[i] > 0:\n\
    \            paren_stack[i] -= 1\n\n    return paren_stack\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0jkhfhxv.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmp0jkhfhxv.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp0jkhfhxv.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp0jkhfhxv.py\", line 19, in parse_nested_parens\n\
    \    if paren_stack[i] > 0:\nIndexError: list index out of range\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    levels\
    \ = [0]\n    open_paren = 0\n    i = 0\n    while i < len(paren_string) - 1:\n\
    \        if paren_string[i] == '(':\n            open_paren += 1\n        elif\
    \ paren_string[i] == ')':\n            open_paren -= 1\n        if open_paren\
    \ > 0:\n            levels.append(open_paren)\n        i += 1\n    return levels\n\
    </cell>\n<cell>\nparse_nested_parens('(())')\n</cell>\n<cell>\nparse_nested_parens('((()))')\n\
    </cell>\n<cell>\nparse_nested_parens('(())')\n</cell>\n<cell>\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmp3ayuvc0q.py\", line 21\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    stack =\
    \ []\n    pairs = []\n    i = 0\n    while True:\n        if paren_string[i] ==\
    \ \"(\":\n            stack.append(paren_string[i])\n            i += 1\n    \
    \    elif paren_string[i] == \")\":\n            if len(stack) == 0:\n       \
    \         break\n            pairs.append(stack.pop())\n            i += 1\n \
    \       else:\n            stack.append(paren_string[i])\n            i += 1\n\
    \    return pairs\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpn5yo_h54.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpn5yo_h54.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpn5yo_h54.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpn5yo_h54.py\", line 13, in parse_nested_parens\n\
    \    if paren_string[i] == \"(\":\nIndexError: string index out of range\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if paren_string\
    \ is None or paren_string.strip() == \"\":\n        return []\n    levels = 0\n\
    \    level = 0\n    level_offset = 0\n    level_list = []\n    level_chars = []\n\
    \    for pos in range(len(paren_string)):\n        if paren_string[pos] == \"\
    )\":\n            if level_offset == 0:\n                level_offset += 1\n \
    \               level_chars.append(paren_string[pos])\n                continue\n\
    \            level -= level_offset\n            level_offset -= 1\n          \
    \  level_list.append(level)\n            level_chars.append(paren_string[pos])\n\
    \        elif paren_string[pos] == \"(\":\n            if level_offset == 0:\n\
    \                level_offset += 1\n                level_chars.append(paren_string[pos])\n\
    \                continue\n            level += 1\n            level_offset +=\
    \ 1\n            level_list.append(level)\n            level_chars.append(paren_string[pos])\n\
    \    if level > 0:\n        level_list.append(level)\n        level_chars.append(paren_string[pos])\n\
    \    return level_list\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmphrml5jta.py\", line\
    \ 48, in <module>\n    test_check()\n  File \"/tmp/tmphrml5jta.py\", line 46,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmphrml5jta.py\"\
    , line 41, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pairs =\
    \ []\n    for parens in paren_string.split():\n        left, right = parens[0],\
    \ parens[-1]\n        if right not in OPEN_PARENS and left not in OPEN_PARENS:\n\
    \            # if the parens are not in an open paren, they must be in an open\
    \ paren so that\n            # the string is not nested.\n            return []\n\
    \        pairs.append((right, left))\n    pairs.sort()\n    nested = 0\n    for\
    \ right_paren, left_paren in pairs:\n        if left_paren not in OPEN_PARENS:\n\
    \            nested += 1\n        elif right_paren not in OPEN_PARENS:\n     \
    \       nested -= 1\n        else:\n            # This case can occur when we\
    \ have (()) nested inside ((()) nested inside (()())\n            # which results\
    \ in an extra level of nesting inside the first set of parens.\n            return\
    \ []\n    return [nested]\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp11atobtw.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmp11atobtw.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp11atobtw.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp11atobtw.py\", line 12, in parse_nested_parens\n\
    \    if right not in OPEN_PARENS and left not in OPEN_PARENS:\nNameError: name\
    \ 'OPEN_PARENS' is not defined\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    levels\
    \ = 0\n    stack = []\n    start = -1\n    end = -1\n\n    for char in paren_string:\n\
    \        if char == '(':\n            stack.append(char)\n            levels +=\
    \ 1\n            start = char\n        elif char == ')':\n            if levels\
    \ == 0:\n                raise ValueError(\"Unexpected closing parentheses.\"\
    )\n            levels -= 1\n            end = char\n            stack.pop()\n\
    \            if stack:\n                start = stack.pop()\n            else:\n\
    \                start = None\n        elif start is not None and end is not None:\n\
    \            raise ValueError(\"Unexpected parentheses nested multiple times.\"\
    , start, end, char)\n    return levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpgao_n3e8.py\", line\
    \ 41, in <module>\n    test_check()\n  File \"/tmp/tmpgao_n3e8.py\", line 39,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpgao_n3e8.py\"\
    , line 34, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpgao_n3e8.py\", line 24, in parse_nested_parens\n\
    \    stack.pop()\nIndexError: pop from empty list\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    level =\
    \ 0\n    i = 0\n    while i < len(paren_string) and paren_string[i] != '(':\n\
    \        i += 1\n\n    i += 1\n\n    # find the starting level of nesting for\
    \ each pair of parentheses\n    levels = []\n    while i < len(paren_string):\n\
    \        level_so_far = 0\n        char_at_i = paren_string[i]\n        if char_at_i\
    \ == \"(\":\n            level_so_far += 1\n        elif char_at_i == \")\":\n\
    \            level_so_far -= 1\n\n        levels.append(level_so_far)\n      \
    \  i += 1\n\n    return levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpwaxfhxqn.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmpwaxfhxqn.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpwaxfhxqn.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if paren_string\
    \ is None:\n        return []\n\n    # Initialize an array with 'None' values\
    \ for each index\n    par_list: List[int] = [0] * len(paren_string)\n    i = 0\n\
    \    par_count = 0\n\n    # Initialize current level of nesting for each index\n\
    \    par_level: Dict[int, int] = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7:\
    \ 0, 8: 0, 9: 0, 10: 0, 11: 0}\n\n    par_level[i] = par_count\n\n    i += 1\n\
    \    while i < len(paren_string):\n        char = paren_string[i]\n\n        if\
    \ char == '(':\n            par_count += 1\n            par_level[i] = par_count\n\
    \n        elif char == ')':\n            par_count -= 1\n            par_level[i]\
    \ = par_count\n\n        elif char == ' ':\n            pass\n\n        elif par_count\
    \ > 0:\n            par_level[i] += par_level[i - 1]\n\n        else:\n      \
    \      break\n\n        i += 1\n\n    return par_list\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9ckx_u2i.py\", line\
    \ 56, in <module>\n    test_check()\n  File \"/tmp/tmp9ckx_u2i.py\", line 54,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9ckx_u2i.py\"\
    , line 49, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_level\
    \ = 0\n    paren_nest_count = {}\n    paren_nest_count['('] = 0\n    paren_nest_count[')']\
    \ = 0\n    paren_nest_count[' '] = 0\n\n    level = 1\n    nest_count = 0\n  \
    \  i = 0\n\n    # iterate over entire string\n    while i < len(paren_string):\n\
    \        char = paren_string[i]\n        if char == '(':\n            paren_level\
    \ += 1\n            paren_nest_count['('] += 1\n            nest_count = 1\n \
    \           i += 1\n        elif char == ')':\n            paren_nest_count['(']\
    \ -= 1\n            paren_level += 1\n            nest_count = 1\n           \
    \ i += 1\n        elif char == ' ':\n            if paren_level > 0:\n       \
    \         level -= 1\n                paren_nest_count[' '] -= 1\n           \
    \ i += 1\n        elif char == ',':\n            nest_count += 1\n           \
    \ i += 1\n        else:\n            print('Error! Unknown char:' + char)\n  \
    \          exit(1)\n    \n    print(nest_count)\n    if level == 0:\n        print('Error!\
    \ No closing parenthesis')\n        exit(1)\n    return paren_level\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpy3bj53_t.py\", line\
    \ 58, in <module>\n    test_check()\n  File \"/tmp/tmpy3bj53_t.py\", line 56,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpy3bj53_t.py\"\
    , line 51, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: '1

    '
  timestamp: 1659822124
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\
    <|/ file filename=parens.py |>\n<|endofmask|><|endofmask|>source=github ext=.py\
    \ dstars=0 |><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>\n\
    <script language=\"javascript\">\n    document.write('<a id=\"top\"></a>');\n\
    </script>\n\n<script>\n    document.write('<a id=\"bottom\"></a>');\n</script>\n\
    \n<a id=\"top\"></a>\n\n<a id=\"bottom\"></a>\n<script>\n    document.write('<a\
    \ id=\"top\"></a>');\n</script>\n<script>\n    document.write('<a id=\"bottom\"\
    ></a>');\n</script>\n<script>\n    document.write('<a id=\"bottom\"></a>');\n\
    </script>\n<script>\n    document.write('<a id=\"top\"></a>');\n</script>\n<script>\n\
    \    document.write('<a id=\"top\"></a>');\n</script>\n\n<script>\n    document.write('<a\
    \ id=\"bottom\"></a>');\n</script>\n\n<script>\n    document.write('<a id=\"top\"\
    ></a>');\n</script>\n<script>\n    document.write('<a id=\"top\"></a>');\n</script>\n\
    <script>\n    document.write('<a id=\"top\"></a>');\n</script>\n<script>\n   \
    \ document.write('<a id=\"top\"></a>');\n</script>\n\n<script>\n    document.write('<a\
    \ id=\"bottom\"></a>');\n</script>\n<script>\n    document.write('<a id=\"top\"\
    ></a>');\n</script>\n<script>\n    document.write('<a id=\"top\"></a>');\n</script>\n\
    <script>\n    document.write('<a id=\"top\"></a>');\n</script>\n<script>\n   \
    \ document.write('<a id=\"bottom\"></a>');\n</script>\n<script>\n    document.write('<a\
    \ id=\"top\"></a>');\n</script>\n\n<script>\n    document.write('<a id=\"bottom\"\
    ></a>');\n</script>\n<script>\n    document.write('<a id=\"top\"></a>');\n</script>\n\
    <script>\n    document.write('<a id=\"bottom\"></a>');\n</script>\n<script>\n\
    \    document.write('<a id=\"bottom\"></a>');\n</script>\n<script>\n    document.write('<a\
    \ id=\"top\"></a>');\n</script>\n\n<script>\n    document.write('<a id=\"bottom\"\
    ></a>');\n</script>\n<script>\n    document.write('<a id=\"top\"></a>');\n</script>\n\
    <script>\n    document.write('<a id=\"bottom\"></a>');\n</script>\n<script>\n\
    \    document.write('<a id=\"top\"></a>');\n</script>\n<script>\n    document.write('<a\
    \ id=\"top\"></a>');\n</script>\n\n<script>\n    document.write('<a id=\"bottom\"\
    ></a>');\n</script>\n<script>\n    document.write('<a id=\"top\"></a>');\n</script>\n\
    <script>\n    document.write('<a id=\"bottom\"></a>');\n</script>\n<script>\n\
    \    document.write('<a id=\"bottom\"></a>');\n</script>\n<script>\n    document.\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmphwa8mool.py\", line 10\n    <|/ file filename=parens.py\
    \ |>\n    ^\nSyntaxError: invalid syntax\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    return\
    \ parse_parens(paren_string, maxlevel=1)\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2zd52elu.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmp2zd52elu.py\", line 18,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2zd52elu.py\"\
    , line 13, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp2zd52elu.py\", line 9, in parse_nested_parens\n \
    \   return parse_parens(paren_string, maxlevel=1)\nNameError: name 'parse_parens'\
    \ is not defined\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpr70pzvwh.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmpr70pzvwh.py\", line 18,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpr70pzvwh.py\"\
    , line 13, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if len(paren_string)\
    \ == 0:\n        return []\n    stack = [1]\n    for x in paren_string:\n    \
    \    if x == '(':\n            stack.append(stack[-1] + 1)\n        elif x ==\
    \ ')':\n            stack.pop()\n        elif x not in ('(', '[', '{'):\n    \
    \        raise ValueError(\"Expected '(' or '{', '[' or '{' but got {}\".format(x))\n\
    \    stack.pop()\n    return stack\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkyfniqpn.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpkyfniqpn.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkyfniqpn.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpkyfniqpn.py\", line 18, in parse_nested_parens\n\
    \    raise ValueError(\"Expected '(' or '{', '[' or '{' but got {}\".format(x))\n\
    ValueError: expected '}' before end of string\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_stack\
    \ = []\n    for c in paren_string:\n        if c == '(':\n            paren_stack.append(c)\n\
    \        elif c == ')':\n            paren_stack.pop()\n\n    if len(paren_stack)\
    \ > 1:\n        raise Exception(\"Too many parentheses\")\n\n    return paren_stack[0]\n\
    </cell>\n<cell>\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpuww37xn1.py\", line 20\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_string\
    \ = paren_string.strip()\n    paren_stack = [0 for _ in range(len(paren_string))]\n\
    \    for idx, letter in enumerate(paren_string):\n        if letter == ')':\n\
    \            paren_stack[paren_stack.index(idx)] = paren_stack[paren_stack.index(idx)\
    \ - 1] + 1\n        elif letter == '(':\n            paren_stack[paren_stack.index(idx)]\
    \ = paren_stack[paren_stack.index(idx) - 1] + 1\n\n    return paren_stack\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp0s9nwhwu.py\", line\
    \ 27, in <module>\n    test_check()\n  File \"/tmp/tmp0s9nwhwu.py\", line 25,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp0s9nwhwu.py\"\
    , line 20, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp0s9nwhwu.py\", line 13, in parse_nested_parens\n\
    \    paren_stack[paren_stack.index(idx)] = paren_stack[paren_stack.index(idx)\
    \ - 1] + 1\nValueError: 2 is not in list\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # TODO:\
    \ Implement this function\n    \n    if len(paren_string) == 1:\n        return\
    \ [0]\n    \n    \n    stack = []\n    \n    for index, char in enumerate(paren_string):\n\
    \        if char == '(':\n            stack.append(index)\n            \n    \
    \    elif char == ')':\n            if len(stack) == 0:\n                return\
    \ [-1]\n            else:\n                deepest_index = stack.pop()\n     \
    \           \n                while stack[-1] != deepest_index:\n            \
    \        stack.pop()\n        \n    \n    return [0]\n</cell>\n<cell>\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpmcrf7td1.py\", line 32\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Split\
    \ into list as string with nested parentheses\n    nested_parens = [int(x) for\
    \ x in  paren_string.split(\" \")]\n\n    # Iterate through nested parens and\
    \ find the maximum nested level of parentheses\n    max_level = 0\n    for i in\
    \ range(0, len(nested_parens)-1):\n        if nested_parens[i] < nested_parens[i+1]:\n\
    \            max_level = i\n    return max_level\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpf8l_8ygp.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmpf8l_8ygp.py\", line 26,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpf8l_8ygp.py\"\
    , line 21, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpf8l_8ygp.py\", line 10, in parse_nested_parens\n\
    \    nested_parens = [int(x) for x in  paren_string.split(\" \")]\n  File \"/tmp/tmpf8l_8ygp.py\"\
    , line 10, in <listcomp>\n    nested_parens = [int(x) for x in  paren_string.split(\"\
    \ \")]\nValueError: invalid literal for int() with base 10: '(()())'\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    levels\
    \ = [0]\n    \n    for i in range(len(paren_string)):\n        if paren_string[i]\
    \ == \")\":\n            levels.append(levels[len(levels)-1]-1)\n        elif\
    \ paren_string[i] == \"(\":\n            levels.append(levels[len(levels)-1])\n\
    \    return levels\n</cell>\n<cell>\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmp0s5anb67.py\", line 17\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    nested:\
    \ List[int] = []\n    open_braces = 0\n    for char in paren_string:\n       \
    \ if char == '(':\n            open_braces += 1\n        elif char == ')':\n \
    \           open_braces -= 1\n        else:\n            if open_braces == 0:\n\
    \                nested.append(0)\n            else:\n                nested.append(nested[-1]\
    \ + 1)\n    return nested\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpn8dlbspc.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpn8dlbspc.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpn8dlbspc.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Parse\
    \ the string and store its components\n    paren_string_list = paren_string.split('\
    \ ')\n\n    # Initialize an empty list to store the deepest level of nesting\n\
    \    nested_level_list = []\n\n    # Start index as 0\n    start_index = 0\n\n\
    \    # For each character in string\n    for char in paren_string_list:\n    \
    \    # Update the start index with the current character\n        start_index\
    \ += len(char)\n\n        # Parse the string for parentheses and store the level\
    \ it encounters\n        nested_levels = parse_nested_parens(paren_string=paren_string,\
    \ start_index=start_index)\n\n        # Add the new level to the list\n      \
    \  nested_level_list.append(nested_levels)\n\n    # Return deepest level of nesting\
    \ list\n    return nested_level_list\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpxpa1phqe.py\", line\
    \ 41, in <module>\n    test_check()\n  File \"/tmp/tmpxpa1phqe.py\", line 39,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxpa1phqe.py\"\
    , line 34, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpxpa1phqe.py\", line 24, in parse_nested_parens\n\
    \    nested_levels = parse_nested_parens(paren_string=paren_string, start_index=start_index)\n\
    TypeError: parse_nested_parens() got an unexpected keyword argument 'start_index'\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    parentheses_count\
    \ = [0]\n    level = 0\n    parantheses_level = [-1]\n    for paren_char in ['(',\
    \ ')']:\n        parentheses_count.append(0)\n    \n    # Loop through parentheses\n\
    \    for paren_char in ['(', ')']:\n        while level < len(parentheses) and\
    \ parentheses[level] == paren_char:\n            parentheses_count[paren_char]\
    \ += 1\n            level += 1\n    \n    return parentheses_count, level\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpu2h15pq9.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpu2h15pq9.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu2h15pq9.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpu2h15pq9.py\", line 17, in parse_nested_parens\n\
    \    while level < len(parentheses) and parentheses[level] == paren_char:\nNameError:\
    \ name 'parentheses' is not defined\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_groups\
    \ = []\n    level = 0\n    for index, char in enumerate(paren_string):\n     \
    \   if char == '(':\n            level += 1\n            paren_groups.append(index)\n\
    \        elif char == ')':\n            level -= 1\n            if not level:\n\
    \                paren_groups.pop()\n            elif level < 0:\n           \
    \     raise SyntaxError(\"Maximum nesting of parentheses exceeded.\")\n      \
    \      else:\n                paren_groups.append(index)\n    return paren_groups\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfxbifjss.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmpfxbifjss.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpfxbifjss.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Do some\
    \ preprocessing of the string to simplify processing later.\n    nested_paren_chars\
    \ = set(paren_string)\n    # Remove parenthesis that don't contribute to nesting\
    \ level.\n    paren_chars = paren_string.translate(None, \"()\")\n    # Find all\
    \ unnecessary parentheses.\n    redundant_paren_chars = paren_chars - nested_paren_chars\n\
    \    # Remove redundant parenthesis.\n    reduced_paren_chars = paren_chars.translate(str.maketrans(\"\
    \", \"\"), redundant_paren_chars)\n    # Find the deepest level of nesting.\n\
    \    level = 0\n    while paren_string.count(\"(\") > level:\n        paren_string\
    \ = reduced_paren_chars\n        level += 1\n    return level\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpra7vu69u.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpra7vu69u.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpra7vu69u.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpra7vu69u.py\", line 12, in parse_nested_parens\n\
    \    paren_chars = paren_string.translate(None, \"()\")\nTypeError: str.translate()\
    \ takes exactly one argument (2 given)\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Write\
    \ your code here\n    stack = []\n    paren_open = 0\n    for pos, char in enumerate(\"\
    (\" + paren_string):\n        if char == \")\":\n            if stack:\n     \
    \           stack.pop()\n            else:\n                return [pos]\n   \
    \     else:\n            stack.append(char)\n    if stack:\n        return [-1]\n\
    \    else:\n        return [len(paren_string)]\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmps0mydw_b.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmps0mydw_b.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmps0mydw_b.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    raise NotImplementedError()\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpaapqgb3a.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpaapqgb3a.py\", line 17,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpaapqgb3a.py\"\
    , line 12, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpaapqgb3a.py\", line 9, in parse_nested_parens\n \
    \   raise NotImplementedError()\nNotImplementedError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_stack:\
    \ List[int] = [0 for i in range(int(len(paren_string) / 2))]\n    index = 0\n\
    \    for c in paren_string:\n        if c == '(':\n            paren_stack[index]\
    \ += 1\n        elif c == ')':\n            paren_stack[index] -= 1\n        index\
    \ += 1\n\n    paren_count = [0 for i in range(int(len(paren_string) / 2))]\n \
    \   index = len(paren_stack) - 1\n    for c in paren_string[::-1]:\n        if\
    \ c == '(':\n            paren_count[index] += 1\n        elif c == ')':\n   \
    \         paren_count[index] -= 1\n        index -= 1\n\n    return paren_count\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpq6ig8088.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmpq6ig8088.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpq6ig8088.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpq6ig8088.py\", line 13, in parse_nested_parens\n\
    \    paren_stack[index] += 1\nIndexError: list index out of range\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    raise NotImplementedError\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpp6bgqtq3.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpp6bgqtq3.py\", line 17,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpp6bgqtq3.py\"\
    , line 12, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpp6bgqtq3.py\", line 9, in parse_nested_parens\n \
    \   raise NotImplementedError\nNotImplementedError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if not\
    \ paren_string:\n        return []\n    if paren_string.startswith('('):\n   \
    \     return parse_nested_parens(paren_string[1:])\n    elif paren_string.startswith(')'):\n\
    \        return parse_nested_parens(paren_string[:-1])\n    level = 0\n    pos\
    \ = 0\n    length = len(paren_string)\n    while pos < length:\n        if paren_string[pos]\
    \ == '(':\n            level += 1\n        elif paren_string[pos] == ')':\n  \
    \          level -= 1\n        pos = pos + 1\n    \n    return level\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9rl48dtd.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmp9rl48dtd.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9rl48dtd.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pairs =\
    \ list(pairwise(paren_string))\n    return list(map(len, pairs))\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbzlpgdg1.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmpbzlpgdg1.py\", line 19,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpbzlpgdg1.py\"\
    , line 14, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpbzlpgdg1.py\", line 9, in parse_nested_parens\n \
    \   pairs = list(pairwise(paren_string))\nNameError: name 'pairwise' is not defined\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    return\
    \ list(enumerate(paren_string.count('('), start=1))\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpae12gt98.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpae12gt98.py\", line 17,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpae12gt98.py\"\
    , line 12, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpae12gt98.py\", line 9, in parse_nested_parens\n \
    \   return list(enumerate(paren_string.count('('), start=1))\nTypeError: 'int'\
    \ object is not iterable\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    \n    #TODO:\
    \ Write the code here\n    stack = []\n    paren_level = 0\n    open_parens =\
    \ 0\n    for c in paren_string:\n        if c == '(':\n            paren_level\
    \ += 1\n            stack.append(c)\n            open_parens += 1\n        elif\
    \ c == ')':\n            paren_level -= 1\n            \n            if not stack:\n\
    \                raise Exception(\"Paranthesis not properly closed\")\n      \
    \      else:\n                open_parens -= 1\n                stack.pop()\n\
    \                \n    if paren_level > 0:\n        raise Exception(\"Parenthesis\
    \ not properly closed\")\n    return stack\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpqupwra3o.py\", line\
    \ 41, in <module>\n    test_check()\n  File \"/tmp/tmpqupwra3o.py\", line 39,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqupwra3o.py\"\
    , line 34, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    stack =\
    \ []\n    open_count = 0\n    level = 0\n    curr_index = 0\n    curr_string =\
    \ \"\"\n    \n    # Iterate through every character in input string\n    for i,\
    \ char in enumerate(paren_string):\n        # Check if previous character was\
    \ also a parentheses\n        if (open_count > 0 and char == \")\"):\n       \
    \     # Pop level one level\n            level -= 1\n        \n        # Check\
    \ if opening parentheses has ended\n        if (char == \"(\"):\n            #\
    \ Increase level\n            level += 1\n            \n            # Check if\
    \ level is too big\n            if (level > 2):\n                # Return last\
    \ stack level\n                return stack\n        \n        # Check if closing\
    \ parentheses has started\n        if (char == \")\"):\n            # Decrease\
    \ level\n            level -= 1\n        \n        # Check if level is too small\n\
    \        if (level < 1):\n            # Check if stack was empty\n           \
    \ if (len(stack) == 0):\n                return []\n            else:\n      \
    \          # Return last stack level\n                return stack\n        \n\
    \        # If opening parentheses hasn't ended\n        if (open_count == 0):\n\
    \            # Push current character to the stack\n            curr_string +=\
    \ char\n        \n        # If parentheses has started\n        if (open_count\
    \ > 0):\n            # Push current character to the stack\n            curr_string\
    \ += char\n            # Increase open count\n            open_count += 1\n  \
    \      \n        # Check if current character is a closing parentheses\n     \
    \   if (char == \")\"):\n            # Pop level one level\n            level\
    \ -= 1\n            # Check if level is too small\n            if (level < 1):\n\
    \                # Return last stack level\n                return stack\n   \
    \         \n            # If closing parentheses hasn't started\n            if\
    \ (open_count > 0):\n                # Increase open count\n                open_count\
    \ -= 1\n                # Push current character to the stack\n              \
    \  curr_string += char\n    \n    # Return empty stack\n    return stack\n\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpv2tp6qz5.py\", line\
    \ 86, in <module>\n    test_check()\n  File \"/tmp/tmpv2tp6qz5.py\", line 84,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpv2tp6qz5.py\"\
    , line 79, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    stack =\
    \ []\n    for char in paren_string:\n        if char == '(':\n            stack.append(0)\n\
    \        elif char == ')':\n            popped = stack.pop()\n            if popped\
    \ == 0:\n                raise InvalidParentheses(\"Invalid number of opening\
    \ parentheses\")\n            else:\n                stack.pop()\n    return stack\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp3svqxdyi.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmp3svqxdyi.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp3svqxdyi.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp3svqxdyi.py\", line 16, in parse_nested_parens\n\
    \    raise InvalidParentheses(\"Invalid number of opening parentheses\")\nNameError:\
    \ name 'InvalidParentheses' is not defined\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_depth\
    \ = 0\n    parentheses = [i for i, ch in enumerate(paren_string) if ch == \"(\"\
    \ ]\n    for paren in parentheses:\n        if paren_depth >= 0:\n           \
    \ paren_depth += 1\n        else:\n            paren_depth = 1\n            parentheses[paren]\
    \ = paren + 1\n\n    return parentheses\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpd0ltyk5l.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmpd0ltyk5l.py\", line 26,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpd0ltyk5l.py\"\
    , line 21, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    list_of_groups\
    \ = []\n    group_count = 0\n    for ch in paren_string:\n        if ch == \"\
    (\":\n            list_of_groups.append(group_count)\n            group_count\
    \ += 1\n        elif ch == \")\":\n            list_of_groups.append(group_count)\n\
    \            group_count -= 1\n            list_of_groups.pop()\n            group_count\
    \ -= 1\n        else:\n            group_count = 1\n    return list_of_groups\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp1v4rv9jq.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmp1v4rv9jq.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1v4rv9jq.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    nested_level\
    \ = 0\n    length = len(paren_string)\n    i = 0\n    paren_string = paren_string.replace('(',\
    \ '( ')\n    paren_string = paren_string.replace(')', ' )')\n    paren_string\
    \ = paren_string.replace('(', '(')\n    paren_string = paren_string.replace(')',\
    \ ')')\n    paren_string = paren_string.replace('(', ' ( ')\n    paren_string\
    \ = paren_string.replace(')', ' ) ')\n    paren_string = paren_string.replace('(',\
    \ ' (')\n    paren_string = paren_string.replace(')', ' )')\n    paren_string\
    \ = paren_string.replace('(', '(')\n    paren_string = paren_string.replace(')',\
    \ ')')\n    paren_string = paren_string.replace('(', ' ( ')\n    paren_string\
    \ = paren_string.replace(')', ' ) ')\n    paren_string = paren_string.replace('(',\
    \ ' (')\n    paren_string = paren_string.replace(')', ' )')\n    paren_string\
    \ = paren_string.replace('(', '(')\n    paren_string = paren_string.replace(')',\
    \ ')')\n    paren_string = paren_string.replace('(', ' ( ')\n    paren_string\
    \ = paren_string.replace(')', ' ) ')\n    paren_string = paren_string.replace('(',\
    \ ' (')\n    paren_string = paren_string.replace(')', ' )')\n    paren_string\
    \ = paren_string.replace('(', '(')\n    paren_string = paren_string.replace(')',\
    \ ')')\n    paren_string = paren_string.replace('(', ' ( ')\n    paren_string\
    \ = paren_string.replace(')', ' ) ')\n    paren_string = paren_string.replace('(',\
    \ ' (')\n    paren_string = paren_string.replace(')', ' )')\n    paren_string\
    \ = paren_string.replace('(', '(')\n    paren_string = paren_string.replace(')',\
    \ ')')\n    paren_string = paren_string.replace('(', ' ( ')\n    paren_string\
    \ = paren_string.replace(')', ' ) ')\n    paren_string = paren_string.replace('(',\
    \ ' (')\n    paren_string = paren_string.replace(')', ' )')\n    paren_string\
    \ = paren_string.replace('(', '(')\n    paren_string = paren_string.replace(')',\
    \ ')')\n    paren_string = paren_string.replace('(', ' ( ')\n    paren_string\
    \ = paren_string.replace(')', ' ) ')\n    paren_string = paren_string.replace('(',\
    \ ' (')\n    paren_string = paren_string.replace(')', ' )')\n    paren_string\
    \ = paren_string.replace('(', '(')\n    paren_string = paren_string.replace(')',\
    \ ')')\n    paren_string = paren_string.replace('(', ' ( ')\n    paren_string\
    \ = paren_string.replace(')', ' ) ')\n    \ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp7u199wjy.py\", line\
    \ 63, in <module>\n    test_check()\n  File \"/tmp/tmp7u199wjy.py\", line 61,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp7u199wjy.py\"\
    , line 56, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    level =\
    \ 0\n    length = len(paren_string)\n    position = 0\n\n    while position <\
    \ length:\n        if paren_string[position] == '(':\n            level += 1\n\
    \        elif paren_string[position] == ')':\n            level -= 1\n       \
    \ if level < 0:\n            return -1\n        position+=1\n\n    return level\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpwr5g7w79.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpwr5g7w79.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpwr5g7w79.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    nested:\
    \ List[int] = []\n    depth = 0\n    open_braces = 0\n    level = 0\n    for char\
    \ in paren_string:\n        if char == \"(\":\n            open_braces += 1\n\
    \            if open_braces > depth:\n                depth = open_braces\n  \
    \      elif char == \")\":\n            open_braces -= 1\n            if open_braces\
    \ == 0:\n                depth -= 1\n            level += 1\n        elif char\
    \ == \" \" and open_braces == 0:\n            nested.append(level)\n    return\
    \ nested\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbo42rx86.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpbo42rx86.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpbo42rx86.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    parens_stack\
    \ = []\n\n    i = 0\n    depth = 1\n    parens = 0\n\n    while i < len(paren_string)\
    \ and parens > 0:\n        c = paren_string[i]\n        if c == '(':\n       \
    \     parens += 1\n        elif c == ')':\n            parens -= 1\n        elif\
    \ c == ')':\n            if parens == 0:\n                depth -= 1\n       \
    \ i += 1\n        depth += 1\n    while depth != 0:\n        if depth == 1:\n\
    \            parens_stack.append(i)\n        depth -= 1\n\n    return parens_stack\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnakvuzdd.py\", line\
    \ 41, in <module>\n    test_check()\n  File \"/tmp/tmpnakvuzdd.py\", line 39,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpnakvuzdd.py\"\
    , line 34, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    return\
    \ parse_parens(paren_string, 2)\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkxaxfh44.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpkxaxfh44.py\", line 17,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkxaxfh44.py\"\
    , line 12, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpkxaxfh44.py\", line 9, in parse_nested_parens\n \
    \   return parse_parens(paren_string, 2)\nNameError: name 'parse_parens' is not\
    \ defined\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # First\
    \ step - find the deepest level of nesting for each group\n    paren_depths =\
    \ []\n    for index, paren in enumerate(paren_string.split()):\n        paren_depth\
    \ = 0\n        if paren != \"\" and paren != \"]\":\n            while paren_string\
    \ != \"\" and paren[index] != \"]\":\n                paren_depth += 1\n     \
    \           paren_string = paren_string[index+1:].strip()\n\n        paren_depths.append(paren_depth)\n\
    \n    # Second step - remove the unnecessary nesting levels\n    paren_string\
    \ = paren_string.replace(\"(\", \"\").replace(\")\", \"\")\n\n    # Third step\
    \ - convert parentheses\n    paren_string = paren_string.replace(\"[\", \"(\"\
    ).replace(\" ]\", \")\")\n    paren_string = paren_string.replace(\"{\", \"(\"\
    ).replace(\" }\", \")\")\n\n    # Fourth step - find the deepest level of nesting\
    \ for paren_string\n    deepest_paren_depth = -1\n    paren_depth = paren_depths[len(paren_string.split())-1]\n\
    \    while paren_string.strip() != \"\":\n        paren_string = paren_string[:paren_depth+2].strip()\n\
    \        paren_depth = paren_depths[len(paren_string.split())-1]\n        deepest_paren_depth\
    \ = paren_depth\n    \n    return deepest_paren_depth\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkzl12kht.py\", line\
    \ 46, in <module>\n    test_check()\n  File \"/tmp/tmpkzl12kht.py\", line 44,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkzl12kht.py\"\
    , line 39, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    level_stack\
    \ = []\n    level_stack.append(0)\n    level = 0\n    parent_level = 0\n    paren_level\
    \ = 0\n    paren_level_list = []\n    for ch in paren_string:\n        if ch ==\
    \ '(':\n            level += 1\n            parent_level += 1\n            paren_level\
    \ += 1\n            paren_level_list.append(paren_level)\n            if paren_level\
    \ > level:\n                level_stack.append(paren_level)\n        elif ch ==\
    \ ')':\n            level -= 1\n            parent_level -= 1\n            if\
    \ level == 0:\n                level_stack.pop()\n                paren_level\
    \ = level_stack[-1]\n                paren_level_list.append(paren_level)\n  \
    \      elif ch == ',':\n            level -= 1\n        else:\n            pass\n\
    \    \n    return paren_level_list\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvd6dmd52.py\", line\
    \ 45, in <module>\n    test_check()\n  File \"/tmp/tmpvd6dmd52.py\", line 43,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpvd6dmd52.py\"\
    , line 38, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpvd6dmd52.py\", line 28, in parse_nested_parens\n\
    \    paren_level = level_stack[-1]\nIndexError: list index out of range\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    parens\
    \ = paren_string.split()\n    stack = []\n    stack_list = []\n    for p in parens:\n\
    \        if p == '(':\n            stack.append(p)\n            stack_list.append(stack)\n\
    \            stack = []\n        elif p == ')':\n            stack.pop()\n   \
    \     else:\n            stack.append(p)\n\n    # Remove extra parentheses from\
    \ each nested list\n    stack_list = [item for item in stack_list if len(item)\
    \ > 1]\n\n    nest_level_list = []\n    for item in stack_list:\n        nest_level\
    \ = 0\n        for item in item[::-1]:\n            if item != '(':\n        \
    \        break\n            nest_level += 1\n        nest_level_list.append(nest_level)\n\
    \n    return nest_level_list\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp_310_80d.py\", line\
    \ 45, in <module>\n    test_check()\n  File \"/tmp/tmp_310_80d.py\", line 43,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp_310_80d.py\"\
    , line 38, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    raise NotImplementedError\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpw0d1o3pg.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmpw0d1o3pg.py\", line 18,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpw0d1o3pg.py\"\
    , line 13, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpw0d1o3pg.py\", line 9, in parse_nested_parens\n \
    \   raise NotImplementedError\nNotImplementedError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pairs =\
    \ []\n    length = len(paren_string)\n    for i in range(length):\n        if\
    \ paren_string[i] == '(':\n            pairs.append(i)\n        elif paren_string[i]\
    \ == ')':\n            pairs.pop()\n    return pairs\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp147n7q1t.py\", line\
    \ 26, in <module>\n    test_check()\n  File \"/tmp/tmp147n7q1t.py\", line 24,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp147n7q1t.py\"\
    , line 19, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    def helper(paren_string:\
    \ str, depth: int, max_level: int) -> int:\n        \"\"\" Recursive function\
    \ \"\"\"\n        if depth == max_level:\n            return 0\n        depth\
    \ = depth + 1\n        length = len(paren_string)\n        if length == 0 or paren_string[0]\
    \ == '(':\n            return depth\n        left_side = paren_string[:length-1]\n\
    \        right_side = paren_string[length-1:]\n        return max(helper(left_side,\
    \ depth, max_level), helper(right_side, depth, max_level))\n\n    return helper(paren_string,\
    \ 0, 0)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpizonz4x9.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpizonz4x9.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpizonz4x9.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Your\
    \ code here\n    count = []\n    i = 0\n    while i < len(paren_string):\n   \
    \     if paren_string[i] == \"(\":\n            count.append(0)\n            i\
    \ += 1\n        if paren_string[i] == \")\":\n            count[len(count)-1]\
    \ += 1\n            i += 1\n    length = len(count) - 1\n    max_count = 0\n \
    \   max_i = 0\n    for i in range(length):\n        if count[i] > max_count:\n\
    \            max_count = count[i]\n            max_i = i\n    return count\n\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659822130
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    raise NotImplementedError\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpp6bgqtq3.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpp6bgqtq3.py\", line 17,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpp6bgqtq3.py\"\
    , line 12, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpp6bgqtq3.py\", line 9, in parse_nested_parens\n \
    \   raise NotImplementedError\nNotImplementedError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_level\
    \ = 0\n    paren_nesting = 0\n    paren_level_stack = []\n    for i in range(len(paren_string)):\n\
    \        if paren_string[i] == '(':\n            paren_level_stack.append(paren_level)\n\
    \            paren_level += 1\n        elif paren_string[i] == ')':\n        \
    \    paren_level = paren_level_stack.pop()\n        elif paren_string[i] == '[':\n\
    \            paren_nesting += 1\n        elif paren_string[i] == ']':\n      \
    \      paren_nesting -= 1\n        else:\n            pass\n    \n    return paren_level\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpsw9m2mdd.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpsw9m2mdd.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpsw9m2mdd.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # write\
    \ your code here\n    stack = list()\n    level = 0\n    left_index = 0\n    for\
    \ i,ch in enumerate(paren_string):\n        if ch == '(':\n            stack.append(i)\n\
    \        elif ch == ')':\n            left_index = stack.pop()\n            level\
    \ += 1\n            if level > len(stack):\n                stack.append(i)\n\
    \            else:\n                break\n    return left_index\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpef1s5di_.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmpef1s5di_.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpef1s5di_.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    nested_levels\
    \ = []\n    left_parens = 0\n    for char in paren_string:\n        if char ==\
    \ \"(\":\n            nested_levels.append(left_parens)\n            left_parens\
    \ += 1\n        elif char == \")\":\n            left_parens -= 1\n    return\
    \ nested_levels\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpiqn18tu2.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmpiqn18tu2.py\", line 26,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpiqn18tu2.py\"\
    , line 21, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_list\
    \ = paren_string.strip().split(')')\n    level_list = []\n    for paren in paren_list:\n\
    \        level_list.append(0)\n        for index in range(len(paren)):\n     \
    \       if paren[index] == '(':\n                level_list[index] += 1\n    \
    \        elif paren[index] == ')':\n                level_list[index] -= 1\n \
    \               if level_list[index] < 0:\n                    break\n    return\
    \ level_list\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpftow58ka.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpftow58ka.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpftow58ka.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpftow58ka.py\", line 15, in parse_nested_parens\n\
    \    level_list[index] += 1\nIndexError: list index out of range\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    nested_level\
    \ = 0\n    level_dict = {}\n    for ch in paren_string:\n        if ch == \"(\"\
    :\n            nested_level += 1\n        elif ch == \")\":\n            nested_level\
    \ -= 1\n            level_dict[nested_level] = level_dict.get(nested_level, 0)\
    \ + 1\n\n    if not nested_level:\n        return [0,]\n    return sorted(level_dict.items(),\
    \ reverse=True)[0]\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpga0rmkek.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpga0rmkek.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpga0rmkek.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    res = 0\n\
    \    paren_stack = []\n    level = 0\n    \n    for c in paren_string:\n     \
    \   if c == '(':\n            paren_stack.append(level)\n            level +=\
    \ 1\n        elif c == ')':\n            level -= len(paren_stack)\n         \
    \   \n            if level == 0:\n                res += 1\n                \n\
    \                # remove this paren from the stack\n                paren_stack.pop()\n\
    \                \n                if paren_stack == []:\n                   \
    \ break\n        \n    # check if there's something left in the stack\n    if\
    \ level == 0:\n        res += 1\n        \n    return res\n</cell>\n<text>\nPart\
    \ 3: Implement a stack\n\n</text>\n<cell>\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpd0tm3s19.py\", line 34\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    parens_stack\
    \ = []\n    levels_stack = []\n    parens_levels_stack = []\n    for paren in\
    \ paren_string:\n        if paren in '((':\n            parens_stack.append(paren)\n\
    \            levels_stack.append(1)\n            parens_levels_stack.append(len(levels_stack))\n\
    \        elif paren in ')':\n            parens_stack.pop()\n            levels_stack.pop()\n\
    \            parens_levels_stack.pop()\n            \n    levels_stack.sort()\n\
    \    levels_stack.reverse()\n\n    while len(levels_stack) > 0:\n        level\
    \ = levels_stack.pop()\n        parens_levels_stack.pop()\n        \n        levels_stack.append(level\
    \ - 1)\n        \n    return parens_levels_stack\n\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbjoiz7zq.py\", line\
    \ 43, in <module>\n    test_check()\n  File \"/tmp/tmpbjoiz7zq.py\", line 41,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpbjoiz7zq.py\"\
    , line 36, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # initialize\
    \ variables to store our results\n    max_level = 0\n    level = 0\n\n    # iterate\
    \ over the characters in the string\n    for c in paren_string:\n        # if\
    \ current character is '('\n        if c == '(':\n            # increase the nesting\
    \ level by one\n            level += 1\n        # if current character is ')'\n\
    \        elif c == ')':\n            # decrease the nesting level by one\n   \
    \         level -= 1\n\n        # if the current level is greater than the max\
    \ level\n        if level > max_level:\n            # update max level\n     \
    \       max_level = level\n\n    # return the maximum level of nesting\n    return\
    \ max_level\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2bea_ydb.py\", line\
    \ 41, in <module>\n    test_check()\n  File \"/tmp/tmp2bea_ydb.py\", line 39,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2bea_ydb.py\"\
    , line 34, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    stack =\
    \ [len(paren_string)]\n    level = 0\n    while stack:\n        level += 1\n \
    \       stack.pop()\n        found = False\n        for char in paren_string:\n\
    \            if char == \"(\":\n                stack.append(level + 1)\n    \
    \        elif char == \")\":\n                stack.pop()\n                found\
    \ = True\n        if not found:\n            raise ValueError(\"Invalid parenthesis\
    \ nesting at index {}\".format(paren_string.index(char)) + \n                \
    \             \": expected ( or )\")\n    \n    return level\n</cell>\n<cell>\n\
    parse_nested_parens(\"()\")\n</cell>\n<cell>\nparse_nested_parens(\"(()\")\n</cell>\n\
    <cell>\nparse_nested_parens(\"(())\")\n</cell>\n<cell>\nparse_nested_parens(\"\
    ()()\")\n</cell>\n<cell>\nparse_nested_parens(\"(()())\")\n</cell>\n<cell>\nparse_nested_parens(\"\
    ((()()))\")\n</cell>\n<text>\nThe function below implements a function that checks\
    \ if the string is valid input for nested parenthesis parentheses validation.\n\
    \n\n</text>\n<cell>\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmp56trz08i.py\", line 26\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    par_list:\
    \ List[int] = []\n    curr_depth = 0\n    par_stack = []\n    for char in paren_string:\n\
    \        if char == '(':\n            par_stack.append(curr_depth)\n         \
    \   curr_depth += 1\n        elif char == ')':\n            curr_depth -= 1\n\
    \            if curr_depth < 0 or curr_depth == par_stack[-1]:\n             \
    \   par_list.append(curr_depth)\n                curr_depth = 0\n            else:\n\
    \                par_stack.pop()\n        else:\n            curr_depth = 0\n\
    \    \n    if len(par_stack) > 0:\n        par_list.append(par_stack[-1])\n  \
    \  return par_list\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvfkv9w64.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmpvfkv9w64.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpvfkv9w64.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_string_list:\
    \ List[int] = [int(s) for s in paren_string.split() if s.isdigit()]\n    if len(paren_string_list)\
    \ == 1:\n        return paren_string_list\n    else:\n        return paren_string_list[paren_string_list.index(max(paren_string_list))\
    \ + 1]\n</cell>\n<text>\nTest Cases\n\n</text>\n<cell>\nparen_string = '(()()()())'\n\
    assert parse_nested_parens(paren_string) == 4\n</cell>\n<cell>\nparen_string =\
    \ '((()())())'\nassert parse_nested_parens(paren_string) == 2\n</cell>\n<cell>\n\
    paren_string = '(()'\nassert parse_nested_parens(paren_string) == 0\n</cell>\n\
    <cell>\nparen_string = '((())'\nassert parse_nested_parens(paren_string) == 1\n\
    </cell>\n<cell>\nparen_string = '(((())())())'\nassert parse_nested_parens(paren_string)\
    \ == 3\n</cell>\n<text>\nRecurrence Relation\n\n</text>\n<text>\nThe recurrence\
    \ relation for a nested parantheses expression is given below.\n\n\\begin{align}\n\
    \\text{Expression with nested parentheses} &\\to\\text{recurrence relation}\\\n\
    \\text{Expression with only outer parentheses} &\\to\\text{recurrence relation}\n\
    \\end{align}\n\n\\begin{align}\n\\text{recurrence relation} &= \\text{the deepest\
    \ level of nesting of parentheses}\n\\end{align}\n\n\n</text>\n<text>\nDefinition\n\
    \n</text>\n<cell>\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpyo9a3gqk.py\", line 14\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_stack\
    \ = []\n    level = 0\n    \n    \n    for char in range(len(paren_string)):\n\
    \        if paren_string[char] == '(':\n            paren_stack.append(char)\n\
    \            level += 1\n        elif paren_string[char] == ')':\n           \
    \ level += 1\n            if len(paren_stack) > level:\n                paren_stack.pop()\n\
    \    \n    if len(paren_stack) > 0:\n        raise ValueError(f\"paren_stack is\
    \ too deep\")\n    else:\n        return level\n\n\ndef check(candidate):\n  \
    \  assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpvx1p8dsf.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmpvx1p8dsf.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpvx1p8dsf.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpvx1p8dsf.py\", line 23, in parse_nested_parens\n\
    \    raise ValueError(f\"paren_stack is too deep\")\nValueError: paren_stack is\
    \ too deep\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    i = 0\n\
    \    level = 0\n    nested = []\n    while i < len(paren_string):\n        ch\
    \ = paren_string[i]\n        if ch == \"(\":\n            level += 1\n       \
    \ elif ch == \")\":\n            level -= 1\n        i += 1\n        nested.append((level,\
    \ i))\n    nested.sort(reverse=True)\n    return [i[1] for i in nested]\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmplhqnmcu0.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmplhqnmcu0.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmplhqnmcu0.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_count\
    \ = 0\n    max_level = 0\n    level = 0\n    for paren in paren_string:\n    \
    \    if paren == '(':\n            paren_count += 1\n            if paren_count\
    \ > max_level:\n                max_level = paren_count\n            level +=\
    \ 1\n        elif paren == ')':\n            paren_count -= 1\n            if\
    \ paren_count > max_level:\n                max_level = paren_count\n        \
    \    level -= 1\n    \n    return level\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpd0zkpvs0.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpd0zkpvs0.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpd0zkpvs0.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    stack =\
    \ []\n    \n    def parse(string):\n        \"\"\" \n        input -> str\n  \
    \      \n        output -> int\n        \n        Algorithm :\n        \n    \
    \    - initialize stack of size 0\n        - start traversing the string from\
    \ the left\n        - \n        - while there is still a character left:\n   \
    \         - if the character is '(': add 1 to the stack \n            - if the\
    \ character is ')':\n                - if there are still characters in the stack:\
    \ \n                    - pop 1 from the stack\n                - otherwise: \n\
    \                    - add 1 to the stack\n            - else: \n            \
    \    - add 1 to the stack\n\n        - return the maximum size of the stack\n\
    \        \"\"\"\n        \n        if len(string) == 0:\n            return 0\n\
    \        \n        if string[0] == '(':\n            stack.append(1)\n       \
    \ else:\n            stack.pop()\n            stack.append(1)\n        \n    \
    \    # Recursively parse string\n        for index, char in enumerate(string):\n\
    \            if char == '(':\n                stack.append(parse(string[index+1:]))\n\
    \            elif char == ')':\n                if stack[len(stack)-1] > 0:\n\
    \                    stack[len(stack)-1] -= 1\n                else:\n       \
    \             stack.append(parse(string[index+1:]))\n            else:\n     \
    \           stack.append(parse(string[index+1:]))\n        \n        return max(stack)\n\
    \    \n    return parse(paren_string)\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659822130
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_level\
    \ = 0\n    nested_paren = []\n    paren_nest = []\n    for char in paren_string:\n\
    \        if char == \"(\":\n            paren_nest.append(1)\n            if paren_nest[-1]\
    \ != 1:\n                paren_nest[-1] += 1\n        elif char == \")\":\n  \
    \          paren_nest.pop()\n            if paren_nest[-1] == 0:\n           \
    \     nested_paren.append(1)\n        elif char == \" \":\n            nested_paren.append(1)\n\
    \    return nested_paren\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpwgpmjgq4.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmpwgpmjgq4.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpwgpmjgq4.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpwgpmjgq4.py\", line 19, in parse_nested_parens\n\
    \    if paren_nest[-1] == 0:\nIndexError: list index out of range\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    i = 0\n\
    \    max_level = 0\n    levels = []\n    while i <= len(paren_string) - 1:\n \
    \       if paren_string[i] == '(':\n            level += 1\n        elif paren_string[i]\
    \ == ')':\n            level -= 1\n            if level == 0:\n              \
    \  levels.append(level)\n            i += 1\n        else:\n            i += 1\n\
    \    max_level = max(levels)\n    levels = [level for level in levels if level\
    \ == max_level]\n    if len(levels) == 0:\n        levels.append(0)\n    return\
    \ levels\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpf56foyse.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmpf56foyse.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpf56foyse.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpf56foyse.py\", line 14, in parse_nested_parens\n\
    \    level += 1\nUnboundLocalError: local variable 'level' referenced before assignment\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    list_of_tuples\
    \ = []\n    stack = []\n    prev_symbol = ''\n    for symbol in paren_string:\n\
    \        if symbol == '(':\n            if prev_symbol != ')':\n             \
    \   stack.append(symbol)\n            else:\n                stack.pop()\n   \
    \             list_of_tuples.append(stack)\n        elif symbol == ')':\n    \
    \        stack.append(symbol)\n        prev_symbol = symbol\n    return list_of_tuples\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpirszsgmu.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmpirszsgmu.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpirszsgmu.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_level\
    \ = 0\n    paren_level_list = []\n    index = 0\n    \n    while index < len(paren_string):\n\
    \        if paren_string[index] == ')':\n            if paren_level == 0:\n  \
    \              paren_level_list.append(index)\n            else:\n           \
    \     paren_level -= 1\n        elif paren_string[index] == '(':\n           \
    \ if paren_level == 0:\n                paren_level_list.append(index)\n     \
    \       else:\n                paren_level += 1\n        index += 1\n    return\
    \ paren_level_list\n    \n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpafbbsxkn.py\", line\
    \ 36, in <module>\n    test_check()\n  File \"/tmp/tmpafbbsxkn.py\", line 34,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpafbbsxkn.py\"\
    , line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_str\
    \ = paren_string.replace(\")\", \")(\")\n    paren_list = paren_str.split(\"(\"\
    )\n    nested_parens = [0 for _ in range(len(paren_list))]\n\n    for i in range(len(paren_list)\
    \ - 1):\n        paren_group = paren_list[i]\n        curr_level = nested_parens[i]\n\
    \        for j in range(curr_level + 1):\n            nested_parens[j] = j\n \
    \       nested_parens[i + 1] += 1\n\n    return nested_parens\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpo2h0rlkw.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpo2h0rlkw.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpo2h0rlkw.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    stack =\
    \ []\n    result = []\n    count = 0\n    \n    for c in paren_string:\n     \
    \   if c == '(':\n            stack.append(count)\n        elif c == ')':\n  \
    \          count = stack.pop()\n            result.append(count)\n        elif\
    \ c == '[' or c == '{':\n            stack.append(count)\n        elif c == ']'\
    \ or c == '}':\n            count = stack.pop()\n            result.append(count)\n\
    \        else:\n            result.append(count)\n\n    return result\n\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp1kc923sn.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmp1kc923sn.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1kc923sn.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    groups\
    \ = paren_string.split()\n\n    level_count = 0\n    for group in groups:\n  \
    \      level_count += 1\n        if group == '(':\n            level_count +=\
    \ 1\n        if group == ')':\n            level_count -= 1\n        if level_count\
    \ < 0:\n            return -1\n\n    return level_count\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9i5trtu7.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmp9i5trtu7.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9i5trtu7.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    nesting_level\
    \ = 0\n    output = []\n    for idx, char in enumerate(paren_string):\n      \
    \  if char == \")\":\n            nesting_level = nesting_level - 1\n        if\
    \ nesting_level < 0:\n            raise ValueError(\"Invalid parens string\")\n\
    \        output.append(idx)\n    return output\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmppin001nf.py\", line\
    \ 27, in <module>\n    test_check()\n  File \"/tmp/tmppin001nf.py\", line 25,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmppin001nf.py\"\
    , line 20, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmppin001nf.py\", line 15, in parse_nested_parens\n\
    \    raise ValueError(\"Invalid parens string\")\nValueError: Invalid parens string\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    level =\
    \ 1\n    nesting_level = 1\n    start = 0\n    parens_found = 0\n    paren_start\
    \ = 0\n    bracket_start = 0\n    brackets_found = 0\n    open_paren_counter =\
    \ 0\n    open_curly_counter = 0\n    close_paren_counter = 0\n    close_curly_counter\
    \ = 0\n\n    for idx, char in enumerate(paren_string):\n        if char == '(':\n\
    \            open_paren_counter+=1\n            parens_found+=1\n            paren_start\
    \ = idx\n        elif char == '{':\n            open_curly_counter+=1\n      \
    \      brackets_found+=1\n            bracket_start = idx\n        elif char ==\
    \ '[':\n            close_paren_counter+=1\n            parens_found+=1\n    \
    \        paren_start = idx\n        elif char == '}':\n            close_curly_counter+=1\n\
    \            brackets_found+=1\n            bracket_start = idx\n        elif\
    \ char == ')':\n            open_paren_counter-=1\n            parens_found-=1\n\
    \            paren_start = idx\n        elif char == ']':\n            open_curly_counter-=1\n\
    \            brackets_found-=1\n            bracket_start = idx\n        elif\
    \ open_paren_counter > 0 and open_curly_counter > 0 and close_paren_counter >\
    \ 0 and close_curly_counter > 0:\n            open_paren_counter = 0\n       \
    \     open_curly_counter = 0\n            close_paren_counter = 0\n          \
    \  close_curly_counter = 0\n            level += 1\n            nesting_level\
    \ += 1\n        elif open_paren_counter > 0 or open_curly_counter > 0 or close_paren_counter\
    \ > 0 or close_curly_counter > 0:\n            if open_paren_counter > 0 and open_curly_counter\
    \ > 0 and close_paren_counter > 0 and close_curly_counter > 0:\n             \
    \   level += 1\n                nesting_level += 1\n            elif open_paren_counter\
    \ > 0 and open_curly_counter > 0 and close_paren_counter > 0 and open_curly_counter\
    \ > 0:\n                level += 1\n                nesting_level += 1\n     \
    \       elif open_paren_counter > 0 and open_curly_counter > 0 and open_paren_counter\
    \ > 0 and close_paren_counter > 0:\n                level+=1\n               \
    \ nesting_level += 1\n            elif open_paren_counter > 0 and open_curly_counter\
    \ > 0 and open_paren_counter > 0 and open_curly_counter > 0:\n               \
    \ level+=1\n                nesting_level += 1\n            elif open_paren_counter\
    \ > 0 and open_curly_counter > 0 and open_paren_counter > 0 and close_curly_counter\
    \ > 0:\n                level+=1\n                nesting_level += 1\n       \
    \     elif open_paren_counter > 0 and open_curly_counter > 0 and open_paren_counter\
    \ > 0 and close_paren_counter > 0:\n                level\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpupeuvu71.py\", line\
    \ 79, in <module>\n    test_check()\n  File \"/tmp/tmpupeuvu71.py\", line 77,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpupeuvu71.py\"\
    , line 72, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Initialize\
    \ empty lists\n    paren_stack = []\n    levels_stack = []\n\n    # Start from\
    \ the outside of parens\n    levels_stack.append(0)\n\n    # Keep going while\
    \ we haven't reached the end of parens\n    # or while we haven't reached the\
    \ max levels of parens\n    while paren_stack or levels_stack:\n        # If the\
    \ level of parens is greater than max levels \n        # of the stack\n      \
    \  if levels_stack and levels_stack[-1] >= len(paren_stack):\n            break\n\
    \        # If the level of parens is less than min levels \n        # of the stack\n\
    \        elif levels_stack and levels_stack[-1] <= len(paren_stack):\n       \
    \     break\n\n        # If we have reached the end of parens\n        if paren_stack\
    \ and paren_stack[-1] == -1:\n            break\n\n        # Pop from the stack\n\
    \        current_level = levels_stack.pop()\n        current_paren = paren_stack.pop()\n\
    \n        # If current level is 0 \n        # then current level is equal to the\n\
    \        # last level that we added to\n        # levels_stack\n        if current_level\
    \ == 0:\n            # Add 0 to the stack\n            levels_stack.append(0)\n\
    \n            # If current level is less than the\n            # last level that\
    \ we added\n            # then we have to increment the level\n            if\
    \ levels_stack[-1] < current_level:\n                levels_stack[-1] += 1\n\n\
    \            # If current level is equal to the\n            # last level that\
    \ we added\n            # then we just increment the level\n            else:\n\
    \                levels_stack[-1] += 1\n\n        # If current level is less than\
    \ the\n        # last level that we added\n        # then we have to decrement\
    \ the level\n        elif current_level > current_level:\n            levels_stack.pop()\n\
    \            # If current level is equal to the\n            # last level that\
    \ we added\n            # then we just decrement the level\n            if levels_stack[-1]\
    \ == current_level:\n                levels_stack.pop()\n            else:\n \
    \               levels_stack[-1] -= 1\n\n        # If current level is equal to\
    \ the\n        # last level that we added\n        # then we just decrement the\
    \ level\n        else:\n            levels_stack.pop()\n\n    return levels_stack\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpq51034ck.py\", line\
    \ 85, in <module>\n    test_check()\n  File \"/tmp/tmpq51034ck.py\", line 83,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpq51034ck.py\"\
    , line 78, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    parentheses_level\
    \ = 0\n    parentheses_levels = []\n    level = -1\n    for char in paren_string:\n\
    \        if char == \"(\":\n            parentheses_level += 1\n        elif char\
    \ == \")\":\n            parentheses_level -= 1\n            if parentheses_level\
    \ == 0:\n                level -= 1\n                parentheses_levels.append(level)\n\
    \        elif char == \" \":\n            if parentheses_level == 0 and level\
    \ == 0:\n                level -= 1\n                parentheses_levels.append(level)\n\
    \            elif parentheses_level == 0 and level > 0:\n                level\
    \ -= 1\n        elif char == \",\":\n            level -= 1\n            parentheses_levels.append(level)\n\
    \    if parentheses_level == 0:\n        level -= 1\n        parentheses_levels.append(level)\n\
    \    return parentheses_levels\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9tkyo0zz.py\", line\
    \ 43, in <module>\n    test_check()\n  File \"/tmp/tmp9tkyo0zz.py\", line 41,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9tkyo0zz.py\"\
    , line 36, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    parsed_parens\
    \ = []\n\n    if paren_string.count(\"(\") == 1 and paren_string.count(\")\")\
    \ == 1:\n        parsed_parens.append(0)\n\n    elif paren_string.count(\"(\"\
    ) == 2:\n        parsed_parens.append(1)\n\n    elif paren_string.count(\")\"\
    ) == 2:\n        parsed_parens.append(2)\n\n    return parsed_parens\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpyv8plwft.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpyv8plwft.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpyv8plwft.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    level =\
    \ 0\n    paren_stack = []\n    for ch in paren_string:\n        if ch == '(':\n\
    \            level += 1\n            paren_stack.append(level)\n        elif ch\
    \ == ')':\n            if len(paren_stack) > 0:\n                level -= 1\n\
    \                paren_stack.pop()\n            else:\n                return\
    \ []\n    return paren_stack\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfwtlimki.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpfwtlimki.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpfwtlimki.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\
    \    # some kind of recursive implementation\n    level = 0\n    paren_level =\
    \ 0\n    i = 0\n    while i < len(paren_string):\n        if paren_string[i] ==\
    \ '(':\n            level += 1\n            paren_level += 1\n        elif paren_string[i]\
    \ == ')':\n            level -= 1\n            paren_level -= 1\n        i +=\
    \ 1\n    return level\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpeleof1sk.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpeleof1sk.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpeleof1sk.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_lst\
    \ = []\n    level = 1\n    prev_pos = 0\n    for pos in range(len(paren_string)):\n\
    \        if paren_string[pos] == \"(\":\n            paren_lst.append(1)\n   \
    \     else:\n            if paren_lst[-1] == level:\n                paren_lst.pop()\n\
    \            else:\n                level += 1\n                paren_lst.append(1)\n\
    \        prev_pos = pos\n    return paren_lst\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp5m5cs1d7.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmp5m5cs1d7.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp5m5cs1d7.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp5m5cs1d7.py\", line 16, in parse_nested_parens\n\
    \    if paren_lst[-1] == level:\nIndexError: list index out of range\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpejsal38b.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpejsal38b.py\", line 17,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpejsal38b.py\"\
    , line 12, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if not\
    \ paren_string:\n        return []\n\n    # Parsing the parenthesis as stack\n\
    \    stack: List[int] = []\n    stack.append((0,paren_string))\n    paren_count\
    \ = 1\n\n    while True:\n        (current_count, current_paren_string) = stack.pop()\n\
    \        if current_paren_string == '':\n            # End of paranthesis stack\n\
    \            paren_count += current_count\n            if paren_count == len(stack):\n\
    \                # All paranthesis group were parsed successfully, return the\
    \ list with deepest level of nesting\n                return list(reversed(stack))\n\
    \        else:\n            # Parsing a group of nested parenthesis\n        \
    \    for index, char in enumerate(current_paren_string):\n                if char\
    \ == '(':\n                    stack.append((current_count + 1, current_paren_string[:index]\
    \ + char))\n                elif char == ')':\n                    stack.append((current_count,\
    \ current_paren_string[:index]))\n                    break\n            else:\n\
    \                # Some other characters were not found in a group of nested parenthesis\n\
    \                stack.append((current_count, current_paren_string))\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659822130
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpejsal38b.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpejsal38b.py\", line 17,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpejsal38b.py\"\
    , line 12, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    level =\
    \ 0\n    paren_chars = ['(', ')', '{', '}']\n    \n    for char in paren_string:\n\
    \        if char in paren_chars:\n            level += 1\n        elif level >\
    \ 0:\n            level -= 1\n        \n    return level\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpw_8fwxzl.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmpw_8fwxzl.py\", line 26,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpw_8fwxzl.py\"\
    , line 21, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if not\
    \ paren_string:\n        return []\n    level = 0\n    result = []\n    for index,\
    \ char in enumerate(paren_string):\n        if char == '(':\n            level\
    \ += 1\n        elif char == ')':\n            if level == 0:\n              \
    \  return []\n            elif level == 1:\n                result.append(index)\n\
    \            level -= 1\n    return result\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpaappciis.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpaappciis.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpaappciis.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    \n    #\
    \ Split the string into individual groups of parentheses\n    paren_groups = paren_string.split()\n\
    \n    # Keep track of how many levels of parentheses are in the string\n    paren_levels\
    \ = []\n    \n    # Loop through each group of parentheses\n    for i in range(len(paren_groups)):\n\
    \        \n        # If the current group of parentheses is empty, record the\
    \ deepest level of nesting in the current group\n        if paren_groups[i] ==\
    \ '':\n            paren_levels.append(0)\n        \n        # Otherwise, record\
    \ the deepest level of nesting in the current group\n        else:\n         \
    \   paren_levels.append(paren_levels[-1] + 1)\n        \n    # Return the deepest\
    \ level of nesting of parentheses\n    return paren_levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpe3_gtc7n.py\", line\
    \ 38, in <module>\n    test_check()\n  File \"/tmp/tmpe3_gtc7n.py\", line 36,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpe3_gtc7n.py\"\
    , line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpe3_gtc7n.py\", line 25, in parse_nested_parens\n\
    \    paren_levels.append(paren_levels[-1] + 1)\nIndexError: list index out of\
    \ range\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    nested_level\
    \ = 0\n    paren_stack = []\n    paren_stack_top = -1\n    paren_stack_ind = -1\n\
    \    i = 0\n    while i < len(paren_string):\n        if paren_stack == []:\n\
    \            if paren_string[i] == '(':\n                paren_stack.append(i)\n\
    \                paren_stack_top = i\n                paren_stack_ind = len(paren_stack)\n\
    \            elif paren_string[i] == ')':\n                paren_stack.pop()\n\
    \                if paren_stack == []:\n                    raise Exception('Mismatched\
    \ parenthesis pair')\n                paren_stack_top = paren_stack[paren_stack_ind]\n\
    \                paren_stack_ind = paren_stack_ind - 1\n                if paren_stack_ind\
    \ == 0:\n                    nested_level += 1\n                else:\n      \
    \              nested_level -= 1\n        else:\n            if paren_string[i]\
    \ == ')':\n                nested_level -= 1\n                if nested_level\
    \ == 0:\n                    paren_stack.pop()\n                    paren_stack_top\
    \ = paren_stack[paren_stack_ind]\n                    paren_stack_ind = paren_stack_ind\
    \ - 1\n                elif nested_level > 0:\n                    nested_level\
    \ -= 1\n            elif paren_string[i] == '(':\n                nested_level\
    \ += 1\n        i += 1\n    if paren_stack_ind < 0 or nested_level > 0:\n    \
    \    raise Exception('Mismatched parenthesis pair')\n    nested_level = 0\n  \
    \  paren_stack = []\n    paren_stack_top = -1\n    paren_stack_ind = -1\n    i\
    \ = 0\n    while i < len(paren_string):\n        if paren_stack == []:\n     \
    \       if paren_string[i] == '(':\n                paren_stack.append(i)\n  \
    \              paren_stack_top = i\n                paren_stack_ind = len(paren_stack)\n\
    \            elif paren_string[i] == ')':\n                paren_stack.pop()\n\
    \                if paren_stack == []:\n                    raise Exception('Mismatched\
    \ parenthesis pair')\n                paren_stack_top = paren_stack[paren_stack_ind]\n\
    \                paren_stack_ind = paren_stack_ind - 1\n                if nested_level\
    \ == 0:\n                    nested_level += 1\n                else:\n      \
    \              nested_level -= 1\n        else:\n            if paren_string[i]\
    \ == ')':\n                nested_level -= 1\n                if nested_level\
    \ == 0:\n                    paren_stack.pop()\n                    paren_stack_top\
    \ = paren_stack[paren_stack_ind]\n                    paren_stack_ind = paren_stack_ind\
    \ - 1\n                elif nested_level > 0:\n                    nested_level\
    \ -= 1\n            elif paren_string[i] == '(':\n                nested_level\
    \ += 1\n        i += 1\n    if paren_stack_ind < 0:\n        raise Exception('Mismatched\
    \ parenthesis pair')\n    return paren_stack_ind\n\ndef check(candidate):\n  \
    \  assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp_1hm7jic.py\", line\
    \ 89, in <module>\n    test_check()\n  File \"/tmp/tmp_1hm7jic.py\", line 87,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp_1hm7jic.py\"\
    , line 82, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp_1hm7jic.py\", line 35, in parse_nested_parens\n\
    \    paren_stack_top = paren_stack[paren_stack_ind]\nIndexError: list index out\
    \ of range\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\
    </cell>\n<cell>\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpkmvqr95e.py\", line 10\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    curr_parens\
    \ = 0\n    level = 0\n    stack = []\n\n    for char in paren_string:\n      \
    \  if char == \"(\":\n            level += 1\n            stack.append(curr_parens)\n\
    \        elif char == \")\":\n            level -= 1\n            stack.pop()\n\
    \            curr_parens = stack.pop()\n        curr_parens += 1\n    return stack\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpk4266g4p.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpk4266g4p.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpk4266g4p.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpk4266g4p.py\", line 20, in parse_nested_parens\n\
    \    curr_parens = stack.pop()\nIndexError: pop from empty list\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Initializing\
    \ the result list with empty values\n    stack = []\n    i = 0\n    # Loop through\
    \ the paren_string\n    while i < len(paren_string):\n        # Check if the string\
    \ is terminated with ')'\n        if paren_string[i] == ')':\n            # If\
    \ the top level of parentheses is empty, push the current level of parentheses\
    \ to the stack\n            if len(stack) == 0:\n                stack.append(paren_string[i])\n\
    \            else:\n                # Pop all the levels of parentheses from the\
    \ stack\n                stack_temp = stack\n                stack = []\n    \
    \            while len(stack) != 0:\n                    # If parentheses are\
    \ left in the stack, add the current parenthesis to the result\n             \
    \       if stack[-1] != '(':\n                        stack_temp = stack_temp\
    \ + stack.pop()\n                    else:\n                        stack_temp\
    \ = stack_temp + stack.pop()\n                stack.append(stack_temp)\n     \
    \   else:\n            # If the top level of parentheses is not empty, then add\
    \ the current character to the top level of parentheses\n            stack.append(paren_string[i])\n\
    \        i += 1\n    # Return the result list\n    return stack\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmphbc3kx_m.py\", line\
    \ 45, in <module>\n    test_check()\n  File \"/tmp/tmphbc3kx_m.py\", line 43,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmphbc3kx_m.py\"\
    , line 38, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_stack\
    \ = []\n    # initialize stack by pushing all indices as the first element\n \
    \   for i in range(0, len(paren_string)):\n        paren_stack.append(i)\n   \
    \ paren_level = 0\n    # parse until there is no more nested parentheses\n   \
    \ while len(paren_stack):\n        # increment the paren_level by 1 as we encounter\
    \ a new nested parenthesis\n        paren_level += 1\n        # pop the last index\
    \ from the paren_stack and get the number of nested parenthesis at that level\n\
    \        levels_of_paren = paren_stack.pop()\n        # get the last index from\
    \ the paren_stack and get the number of nested parenthesis at that level\n   \
    \     last_index_of_paren = paren_stack.pop()\n        # pop all indices up to\
    \ last_index_of_paren as they correspond to ( and )\n        popped_indices_of_paren\
    \ = paren_stack[0 : last_index_of_paren]\n        # pop all indices up to levels_of_paren\
    \ as they correspond to {and }\n        popped_indices_of_paren = popped_indices_of_paren[0\
    \ : levels_of_paren]\n        # get the deepest level from the popped_indices_of_paren\n\
    \        deepest_level = max(popped_indices_of_paren)\n        # add the deepest\
    \ level to paren_stack\n        paren_stack.insert(deepest_level, deepest_level)\n\
    \    return paren_stack[0]\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpdf51cu1a.py\", line\
    \ 41, in <module>\n    test_check()\n  File \"/tmp/tmpdf51cu1a.py\", line 39,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdf51cu1a.py\"\
    , line 34, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpdf51cu1a.py\", line 27, in parse_nested_parens\n\
    \    deepest_level = max(popped_indices_of_paren)\nValueError: max() arg is an\
    \ empty sequence\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_level\
    \ = [0]\n    def recursive_parse_parens(current_depth: int, groups: List[str])\
    \ -> List[int]:\n        \"\"\" Recursively parse groups in each nested parentheses\
    \ and update the current paren_level \"\"\"\n        for group in groups:\n  \
    \          \"\"\" For each group encountered, update the current paren_level and\
    \ recursively parse those groups \"\"\"\n            if current_depth == len(paren_level):\n\
    \                \"\"\" When current depth is equal to the length of the paren_level,\
    \ parse the groups \"\"\"\n                level_of_nesting_of_parens = parse_nested_parens(group)\n\
    \                if level_of_nesting_of_parens != -1:\n                    \"\"\
    \" If the level of nesting of parentheses is different than -1, then update the\
    \ paren_level \"\"\"\n                    paren_level = level_of_nesting_of_parens\n\
    \                else:\n                    \"\"\" If the level of nesting of\
    \ parentheses is -1, then recursively parse those groups \"\"\"\n            \
    \        level_of_nesting_of_parens = recursive_parse_parens(current_depth + 1,\
    \ group.split())\n                    paren_level[current_depth] = level_of_nesting_of_parens\n\
    \            else:\n                \"\"\" When current depth is different than\
    \ the length of the paren_level, append the group to current paren_level \"\"\"\
    \n                paren_level[current_depth] = paren_level[current_depth] + 1\n\
    \        return paren_level[current_depth]\n\n    return recursive_parse_parens(0,\
    \ paren_string.split())\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpl5f09hst.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmpl5f09hst.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpl5f09hst.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpl5f09hst.py\", line 29, in parse_nested_parens\n\
    \    return recursive_parse_parens(0, paren_string.split())\n  File \"/tmp/tmpl5f09hst.py\"\
    , line 14, in recursive_parse_parens\n    if current_depth == len(paren_level):\n\
    UnboundLocalError: local variable 'paren_level' referenced before assignment\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    stack:\
    \ List[int] = list()\n    stack_idx: int = 0\n    \n    for idx, char in enumerate(paren_string):\n\
    \        if char == ')':\n            stack.append(idx)\n            stack_idx\
    \ -= 1\n            \n        elif char == '(':\n            stack.append(idx)\n\
    \            stack_idx += 1\n    \n    if stack_idx == 0:\n        return -1\n\
    \    \n    return stack_idx\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpdan1hdrb.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpdan1hdrb.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdan1hdrb.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    nested_paren_level\
    \ = 0\n    i = 0\n    paren_count = 0\n    parsed_parentheses = []\n    parsed_parentheses.append(i)\n\
    \    paren_paren_level = 0\n    paren_paren_paren_level = 0\n    while i < len(paren_string):\n\
    \        if paren_string[i] == \"(\":\n            paren_count += 1\n        \
    \    parsed_parentheses.append(i)\n            nested_paren_level += 1\n     \
    \       i = find_next_paren(paren_string, i, parsed_parentheses, paren_paren_level,\
    \ paren_paren_paren_level, paren_count)\n        elif paren_string[i] == \")\"\
    :\n            nested_paren_level -= 1\n            paren_paren_level += 1\n \
    \           paren_paren_paren_level += 1\n            parsed_parentheses.pop()\n\
    \            i = find_next_paren(paren_string, i, parsed_parentheses, paren_paren_level,\
    \ paren_paren_paren_level, paren_count)\n        elif paren_string[i] == \"(\"\
    :\n            paren_paren_paren_level += 1\n            nested_paren_level +=\
    \ 1\n            i = find_next_paren(paren_string, i, parsed_parentheses, paren_paren_level,\
    \ paren_paren_paren_level, paren_count)\n        elif paren_string[i] == \")\"\
    :\n            nested_paren_level -= 1\n            paren_paren_level -= 1\n \
    \           parsed_parentheses.pop()\n            i = find_next_paren(paren_string,\
    \ i, parsed_parentheses, paren_paren_level, paren_paren_paren_level, paren_count)\n\
    \    return parsed_parentheses\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmppabgq6az.py\", line\
    \ 48, in <module>\n    test_check()\n  File \"/tmp/tmppabgq6az.py\", line 46,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmppabgq6az.py\"\
    , line 41, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmppabgq6az.py\", line 21, in parse_nested_parens\n\
    \    i = find_next_paren(paren_string, i, parsed_parentheses, paren_paren_level,\
    \ paren_paren_paren_level, paren_count)\nNameError: name 'find_next_paren' is\
    \ not defined\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_level\
    \ = 0\n    cur_paren_index = 0\n    paren_levels = []\n    found_left_paren =\
    \ False\n\n    while cur_paren_index < len(paren_string):\n        if paren_string[cur_paren_index]\
    \ == '(':\n            paren_level += 1\n        elif paren_string[cur_paren_index]\
    \ == ')':\n            paren_level -= 1\n            if paren_level < 0:\n   \
    \             # Parenthesis found, but it is in wrong direction.\n           \
    \     if found_left_paren:\n                    return []\n                else:\n\
    \                    return paren_levels\n            elif paren_level == 0:\n\
    \                found_left_paren = True\n        else:\n            found_left_paren\
    \ = False\n        paren_levels.append(paren_level)\n        cur_paren_index +=\
    \ 1\n\n    return paren_levels\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2zdrd104.py\", line\
    \ 42, in <module>\n    test_check()\n  File \"/tmp/tmp2zdrd104.py\", line 40,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2zdrd104.py\"\
    , line 35, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Your\
    \ code here\n    stack = []\n    level = 0\n    open_parens = []\n    for char\
    \ in paren_string:\n        if char == '(':\n            open_parens.append(char)\n\
    \            level += 1\n            stack.append(level)\n        elif char ==\
    \ ')':\n            level -= 1\n            if stack.pop() == level:\n       \
    \         open_parens.remove(open_parens[-1])\n        else:\n            open_parens.remove(open_parens[-1])\n\
    \    return open_parens\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpootrfl7e.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpootrfl7e.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpootrfl7e.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    level =\
    \ 0\n    pos = 0\n    nested_string_list = []\n    open_brackets = [\"(\", \"\
    [\", \"{\"]\n    close_brackets = [\")\", \"]\", \"}\"]\n    while pos < len(paren_string):\n\
    \        char = paren_string[pos]\n        if char in open_brackets:\n       \
    \     if level == 0:\n                nested_string_list.append(pos - 1)\n   \
    \         level += 1\n        elif char in close_brackets:\n            if level\
    \ == 0:\n                nested_string_list.append(pos - 1)\n            level\
    \ -= 1\n        pos += 1\n\n    return nested_string_list\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnpgc5111.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmpnpgc5111.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpnpgc5111.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_count\
    \ = paren_string.count('(') - paren_string.count(')')\n    levels = [paren_count]\n\
    \n    for paren_char in paren_string:\n        if paren_char == '(':\n       \
    \     paren_count -= 1\n        elif paren_char == ')':\n            paren_count\
    \ += 1\n        levels.append(paren_count)\n\n    return levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpoi1aj3kj.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmpoi1aj3kj.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpoi1aj3kj.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    nested_level\
    \ = 0\n    nested_levels = []\n    open_braces_count = 0\n    open_braces = 0\n\
    \    close_braces = 0\n    levels_counter = 0\n    for ch in paren_string:\n \
    \       if ch == '(':\n            open_braces_count += 1\n            open_braces\
    \ += 1\n        elif ch == ')':\n            close_braces += 1\n            open_braces\
    \ -= 1\n        elif ch == '{':\n            open_braces += 1\n        elif ch\
    \ == '}':\n            close_braces -= 1\n        if open_braces_count > 0:\n\
    \            open_braces_count -= 1\n        if open_braces == 0 and close_braces\
    \ == 0:\n            if open_braces_count == 0:\n                levels_counter\
    \ += 1\n            nested_levels.append(levels_counter)\n            levels_counter\
    \ = 0\n            open_braces = 0\n            close_braces = 0\n           \
    \ open_braces_count = 1\n    nested_levels.append(levels_counter)\n    return\
    \ nested_levels\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmppsqxd_e1.py\", line\
    \ 48, in <module>\n    test_check()\n  File \"/tmp/tmppsqxd_e1.py\", line 46,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmppsqxd_e1.py\"\
    , line 41, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\
    </cell>\n<cell>\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpkmvqr95e.py\", line 10\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    level =\
    \ 0\n    open_count = 0\n    close_count = 0\n    stack = []\n    for index, char\
    \ in enumerate(paren_string):\n        if char == '(':\n            open_count\
    \ += 1\n            level += 1 \n            stack.append(index)\n        elif\
    \ char == ')':\n            close_count += 1\n            level -= 1\n       \
    \     if level == 0 and open_count > close_count:\n                stack.pop()\n\
    \        elif char == ')' and open_count > close_count:\n            stack.pop()\n\
    \            open_count -= 1\n            close_count += 1\n    return stack\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp2urgsld2.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmp2urgsld2.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2urgsld2.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    parentheses\
    \ = paren_string.split()\n    levels = []\n    for p in parentheses:\n       \
    \ if len(p) == 0:\n            levels.append(0)\n        else:\n            levels.append(len(p))\n\
    \            max_level = max(levels)\n            for level in levels:\n     \
    \           if level == max_level:\n                    levels.remove(level)\n\
    \                    break\n    return levels\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmvctqezr.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpmvctqezr.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpmvctqezr.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_dict\
    \ = {\n        '(': -1,\n        '[': -1,\n        '{': -1,\n        '}': -1,\n\
    \        '(': -1,\n        '[': -1,\n        '{': -1,\n        '}': -1,\n    }\n\
    \    paren_string = '('+paren_string+')'\n    nest = 0\n    paren_level = 0\n\
    \    paren_pair = []\n    open_paren = []\n    close_paren = []\n    open_paren_pair\
    \ = []\n    close_paren_pair = []\n    for c in paren_string:\n        if c in\
    \ paren_dict:\n            paren_dict[c] = nest\n            nest += 1\n     \
    \   else:\n            nest -= 1\n            paren_dict[c] = nest\n    for c\
    \ in paren_string:\n        if nest == 0 and c in paren_dict:\n            paren_level\
    \ += paren_dict[c]\n            paren_dict[c] = 0\n            paren_pair.append(c)\n\
    \        elif nest == 1 and c in paren_dict:\n            paren_level += paren_dict[c]\n\
    \            paren_dict[c] = 0\n            open_paren.append(c)\n           \
    \ open_paren_pair.append(paren_pair)\n            paren_pair = []\n        elif\
    \ nest == -1 and c in paren_dict:\n            paren_level += paren_dict[c]\n\
    \            paren_dict[c] = 0\n            close_paren.append(c)\n          \
    \  close_paren_pair.append(paren_pair)\n            paren_pair = []\n        elif\
    \ nest > 0 and c in paren_dict:\n            paren_pair.append(c)\n        elif\
    \ nest < 0 and c in paren_dict:\n            paren_dict[c] += 1\n    return open_paren\
    \ + close_paren\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpg6tklb8e.py\", line\
    \ 65, in <module>\n    test_check()\n  File \"/tmp/tmpg6tklb8e.py\", line 63,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpg6tklb8e.py\"\
    , line 58, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    stack =\
    \ []\n\n    for c in paren_string:\n        if c == \"(\":\n            stack.append(c)\n\
    \        elif c == \")\":\n            if len(stack) > 0:\n                max_level\
    \ = stack.pop()\n            else:\n                max_level = 0\n          \
    \  yield max_level\n        else:\n            stack.append(c)\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptj0cl8jk.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmptj0cl8jk.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptj0cl8jk.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpr70pzvwh.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmpr70pzvwh.py\", line 18,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpr70pzvwh.py\"\
    , line 13, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    \n    paren_stack\
    \ = []\n    i = 0\n    \n    while i < len(paren_string):\n        \n        if\
    \ paren_string[i] == '(':\n            paren_stack.append(i)\n            \n \
    \       elif paren_string[i] == ')':\n            \n            if not paren_stack:\n\
    \                return [0]\n            \n            last_paren_level = paren_stack.pop()\n\
    \            \n            while i < len(paren_string) and paren_string[i] !=\
    \ '(':\n                i += 1\n            \n            if i == len(paren_string):\n\
    \                \n                # There are no more closing parentheses.\n\
    \                \n                return [0]\n            \n            deepest_level\
    \ = last_paren_level - i\n            \n            return deepest_level + 1\n\
    \        \n        else:\n            \n            i += 1\n    \n    raise RuntimeError(f\"\
    Could not parse nested parentheses string '{paren_string}'\")\n</cell>\n<text>\n\
    Test the helper function\n\n</text>\n<cell>\nparse_nested_parens(\"(()\")\n</cell>\n\
    <cell>\nparse_nested_parens(\"((()))\")\n</cell>\n<cell>\nparse_nested_parens(\"\
    ((((())))\")\n</cell>\n<cell>\nparse_nested_parens(\"(()())\")\n</cell>\n<cell>\n\
    parse_nested_parens(\"(()()())\")\n</cell>\n<text>\nPractice Problem (5 min)\n\
    The following function takes one string as input and returns a list of all indices\
    \ of parentheses within this string that are surrounded by exactly one pair of\
    \ parentheses, inclusive.\n\n</text>\n<cell>\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpcjtnd56e.py\", line 43\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    parsed_paren\
    \ = []\n    for idx, char in enumerate(paren_string):\n        if char == \")\"\
    :\n            if idx != 0:\n                parsed_paren.pop()\n        else:\n\
    \            parsed_paren.append(idx)\n    return parsed_paren\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpnxj7di3w.py\", line\
    \ 26, in <module>\n    test_check()\n  File \"/tmp/tmpnxj7di3w.py\", line 24,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpnxj7di3w.py\"\
    , line 19, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_stack\
    \ = []\n    levels = []\n    level_counter = 0\n    last_levels = []\n    levels_count\
    \ = 0\n    for char in paren_string:\n        if char == '(':\n            paren_stack.append(char)\n\
    \            levels_count += 1\n            level_counter += 1\n        elif char\
    \ == ')':\n            if paren_stack:\n                levels_count -= 1\n  \
    \              last_levels.append(level_counter)\n                level_counter\
    \ = paren_stack.pop()\n            else:\n                raise SyntaxError(\"\
    Unexpected closing parenthesis\", paren_string)\n        elif char == ',' and\
    \ levels_count != 0 and level_counter != 0 and paren_stack:\n            last_levels.append(level_counter)\n\
    \            level_counter += 1\n    return last_levels\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpe09zw18i.py\", line\
    \ 40, in <module>\n    test_check()\n  File \"/tmp/tmpe09zw18i.py\", line 38,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpe09zw18i.py\"\
    , line 33, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpe09zw18i.py\", line 18, in parse_nested_parens\n\
    \    level_counter += 1\nTypeError: can only concatenate str (not \"int\") to\
    \ str\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    stack =\
    \ []\n    level = 0\n    nested_count = 0\n    for index, char in enumerate(paren_string):\n\
    \        if char == '(':\n            level += 1\n            stack.append(char)\n\
    \            nested_count += 1\n        elif char == ')':\n            nested_count\
    \ -= 1\n            stack.pop()\n            level -= 1\n            if nested_count\
    \ == 0:\n                break\n    \n    return level\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjxahae96.py\", line\
    \ 34, in <module>\n    test_check()\n  File \"/tmp/tmpjxahae96.py\", line 32,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpjxahae96.py\"\
    , line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_array\
    \ = []\n    for c in paren_string:\n        if c == ')':\n            # If the\
    \ current paren is open\n            if paren_array:\n                # If the\
    \ last element of the array is closed, then pop it off and append the remaining\
    \ paren\n                if paren_array[-1] == ')':\n                    paren_array.pop()\n\
    \                paren_array.append(c)\n            else:\n                # If\
    \ the last element of the array is not closed, then append it to the array and\
    \ start a new one\n                paren_array.append(c)\n                paren_array.append(c)\n\
    \        else:\n            # If the current paren is not open\n            paren_array.append(c)\n\
    \    return paren_array\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpy1hcqux4.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpy1hcqux4.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpy1hcqux4.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if paren_string\
    \ == '':\n        return []\n    i = 0\n    level = 1\n    groups = []\n    while\
    \ i < len(paren_string) - 1:\n        if paren_string[i] == '(':\n           \
    \ groups.append(i)\n            level += 1 \n        elif paren_string[i] == ')':\n\
    \            level -= 1\n            if level == 0:\n                groups.append(i)\n\
    \            else:\n                break\n        i += 1\n\n    # return the\
    \ group with the deepest level\n    return groups[-1]\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp22gcr9u9.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmp22gcr9u9.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp22gcr9u9.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    stack =\
    \ []\n    parentheses = 0\n    i = 0\n    for j, c in enumerate(paren_string):\n\
    \        if c == '(':\n            parentheses += 1\n        if c == ')':\n  \
    \          parentheses -= 1\n            stack.append(parentheses)\n         \
    \   if parentheses == 0:\n                break\n        i += 1\n    return stack\n\
    </cell>\n<cell>\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpboftoog7.py\", line 22\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Do nothing\
    \ if input string is empty\n    if not paren_string:\n        return []\n\n  \
    \  # Initialize result\n    max_nesting = 0\n\n    # Initialize stack\n    stack_holder:\
    \ List[int] = []\n\n    # Iterate through string and insert brackets into stack\n\
    \    for ch in paren_string:\n        if ch == '(':\n            stack_holder.append(-1)\n\
    \        elif ch == ')':\n            stack_holder.pop()\n        if stack_holder:\n\
    \            stack_holder[-1] += 1\n\n    # Return maximum nesting\n    return\
    \ max_nesting\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbkpb3f6e.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmpbkpb3f6e.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpbkpb3f6e.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    \n    pass\n\
    \n\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpo8rjtt5i.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmpo8rjtt5i.py\", line 21,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpo8rjtt5i.py\"\
    , line 16, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Your\
    \ code goes here\n    \n    paren_stack = []\n    \n    for c in paren_string:\n\
    \        if c == '(':\n            paren_stack.append(1)\n        elif c == '[':\n\
    \            paren_stack.append(0)\n        elif c == ')':\n            level_of_nesting\
    \ = 1\n            while paren_stack[-1] >= level_of_nesting:\n              \
    \  level_of_nesting += 1\n            paren_stack.pop()\n        elif c == ']':\n\
    \            level_of_nesting = -1\n            while paren_stack[-1] >= level_of_nesting:\n\
    \                level_of_nesting -= 1\n            paren_stack.pop()\n\n    return\
    \ paren_stack\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpff19lsdw.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmpff19lsdw.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpff19lsdw.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    level_of_nesting\
    \ = 1\n    paren_count = 0\n    paren_char = None\n    char_stack = []\n\n   \
    \ # Count paren_count for each paren_char\n    for i, c in enumerate(paren_string):\n\
    \        if c == \"(\":\n            paren_count += 1\n        if c == \")\":\n\
    \            paren_count -= 1\n\n        if paren_count == level_of_nesting:\n\
    \            # Push the current char to stack and mark it as paren_char\n    \
    \        char_stack.append(c)\n            if c == \")\":\n                level_of_nesting\
    \ -= 1\n                paren_char = \"(\"\n            else:\n              \
    \  paren_char = \")\"\n\n    # If the parentheses level reached zero, add one\
    \ extra level to it.\n    level_of_nesting += 1\n    return level_of_nesting\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpptp4v5ek.py\", line\
    \ 42, in <module>\n    test_check()\n  File \"/tmp/tmpptp4v5ek.py\", line 40,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpptp4v5ek.py\"\
    , line 35, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    level =\
    \ 0\n    paren_level = 0\n    parens = []\n\n    for c in paren_string:\n    \
    \    if c == '(':\n            level += 1\n            paren_level = 0\n     \
    \   elif c == ')':\n            level -= 1\n            paren_level += 1\n   \
    \         if level < 0:\n                raise Exception(\"Unbalanced parenthesis\"\
    )\n        elif c == '[':\n            level += 1\n            paren_level = 0\n\
    \        elif c == ']':\n            level -= 1\n            paren_level += 1\n\
    \            if level < 0:\n                raise Exception(\"Unbalanced parenthesis\"\
    )\n        elif c == '{':\n            level += 1\n            paren_level = 0\n\
    \        elif c == '}':\n            level -= 1\n            paren_level += 1\n\
    \            if level < 0:\n                raise Exception(\"Unbalanced parenthesis\"\
    )\n        else:\n            level += 1\n            paren_level += 1\n     \
    \       parens.append(c)\n\n    if paren_level == 0:\n        raise Exception(\"\
    Unbalanced parenthesis\")\n    return parens\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp1z7gssfd.py\", line\
    \ 55, in <module>\n    test_check()\n  File \"/tmp/tmp1z7gssfd.py\", line 53,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1z7gssfd.py\"\
    , line 48, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    count =\
    \ 1\n    nested_parens = []\n    for char in paren_string:\n        if char ==\
    \ '(':\n            nested_parens.append(count)\n            count += 1\n    \
    \    elif char == ')':\n            nested_parens.pop()\n        else:\n     \
    \       count +=1\n    return nested_parens\n</cell>\n<cell>\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpabars6_l.py\", line 20\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    groups\
    \ = paren_string.split()\n    group_size = len(groups)\n    depth = 0\n\n    while\
    \ group_size > depth:\n        depth += 1\n        group_size -= (depth + 1)\n\
    \n    nested = [0] * depth\n\n    for i in reversed(range(depth)):\n        nested[i]\
    \ = group_size\n\n    nested.sort()\n\n    return nested\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpsqwctnrp.py\", line\
    \ 35, in <module>\n    test_check()\n  File \"/tmp/tmpsqwctnrp.py\", line 33,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpsqwctnrp.py\"\
    , line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if len(paren_string)\
    \ == 0:\n        return 0\n    paren_string_array = paren_string.split()\n   \
    \ if paren_string_array[0] == \"(\":\n        return 0\n    if paren_string_array[0]\
    \ == \"{\":\n        return 1\n    if paren_string_array[0] == \"}\":\n      \
    \  return -1\n    if paren_string_array[0] == \"[\":\n        return 2\n    if\
    \ paren_string_array[0] == \"]\":\n        return -2\n    paren_string = paren_string_array[0]\n\
    \    return len(paren_string) + parse_nested_parens(paren_string[1:])\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmps4meu1t0.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmps4meu1t0.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmps4meu1t0.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    res = []\n\
    \    depth = 0\n    i = -1\n    open_parentheses = 0\n    while open_parentheses\
    \ > 0:\n        i += 1\n        if paren_string[i] == \"(\":\n            open_parentheses\
    \ += 1\n        elif paren_string[i] == \")\":\n            open_parentheses -=\
    \ 1\n        depth += open_parentheses\n    else:\n        return -1\n\n    res.append(paren_string[i])\n\
    \    for j in range(i - 1, -1, -1):\n        res.append(paren_string[j])\n   \
    \ return depth\n\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp96rrll_s.py\", line\
    \ 37, in <module>\n    test_check()\n  File \"/tmp/tmp96rrll_s.py\", line 35,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp96rrll_s.py\"\
    , line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if len(paren_string.strip())\
    \ == 0: return []\n    if len(paren_string.strip()) == 1: return [0]\n    if len(paren_string.strip())\
    \ == 2: return [0, 1]\n    \n    \n    reversed_paren_string = paren_string[::-1]\n\
    \    index_lists = []\n    level = 0\n    for i in range(0,len(reversed_paren_string)):\n\
    \        if reversed_paren_string[i] == '(':\n            level += 1\n       \
    \     index_lists.append(level)\n        elif reversed_paren_string[i] == ')':\n\
    \            level -= 1\n    return index_lists\n\ndef check(candidate):\n   \
    \ assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmph61tahro.py\", line\
    \ 33, in <module>\n    test_check()\n  File \"/tmp/tmph61tahro.py\", line 31,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmph61tahro.py\"\
    , line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpejsal38b.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpejsal38b.py\", line 17,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpejsal38b.py\"\
    , line 12, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_groups\
    \ = paren_string.split(\" \")\n    if len(paren_groups) >= 2:\n        return\
    \ parse_parens(paren_string)\n    elif len(paren_groups) == 1:\n        return\
    \ [ord(char) for char in paren_groups[0]]\n    else:\n        return []\n\ndef\
    \ check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmnrrs93e.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpmnrrs93e.py\", line 23,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpmnrrs93e.py\"\
    , line 18, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpmnrrs93e.py\", line 11, in parse_nested_parens\n\
    \    return parse_parens(paren_string)\nNameError: name 'parse_parens' is not\
    \ defined\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # TODO:\
    \ Implement this\n    pass\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp6dcuxgv0.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmp6dcuxgv0.py\", line 18,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp6dcuxgv0.py\"\
    , line 13, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if len(paren_string)\
    \ == 1:\n        return [-1]\n    level_lst = [0] * (len(paren_string) + 1)\n\
    \    for i in range(len(paren_string) - 1, -1, -1):\n        level_lst[i] = level_lst[i\
    \ + 1] + 1 if paren_string[i] == ')' else level_lst[i + 1]\n    return level_lst\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpt_w8y4fr.py\", line\
    \ 24, in <module>\n    test_check()\n  File \"/tmp/tmpt_w8y4fr.py\", line 22,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpt_w8y4fr.py\"\
    , line 17, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    def recurse(i:\
    \ int, j: int) -> int:\n        \"\"\" Recursively parse a nested parenthesis.\
    \ \"\"\"\n        if i == 0 or j == 0:\n            return 0\n\n        if paren_string[i]\
    \ == '(':\n            return 1 + recurse(i+1, j-1)\n        if paren_string[i]\
    \ == '[':\n            return 1 + recurse(i+1, j)\n        if paren_string[i]\
    \ == '{':\n            return 1 + recurse(i, j-1)\n        if paren_string[i]\
    \ == '}':\n            return 1 + recurse(i, j)\n\n    # To store the results\n\
    \    parsed_parens: list = []\n\n    level = 0\n    for i in range(0,len(paren_string)):\n\
    \        if paren_string[i] == '(':\n            level += 1\n        if paren_string[i]\
    \ == ')':\n            level -= 1\n        parsed_parens.append(level)\n\n   \
    \ return parsed_parens\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpwv0addmc.py\", line\
    \ 44, in <module>\n    test_check()\n  File \"/tmp/tmpwv0addmc.py\", line 42,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpwv0addmc.py\"\
    , line 37, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Your\
    \ code here\n    \n    return []\n    \n</cell>\n<cell>\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpdlxxnv4m.py\", line 13\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_depth\
    \ = 0\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i]\
    \ == \"(\":\n            paren_depth += 1\n        elif paren_string[i] == \"\
    )\":\n            paren_depth -= 1\n            if paren_depth == 0:\n       \
    \         max_depth = i\n    if max_depth == -1:\n        raise RuntimeError(\"\
    Could not parse nested parentheses string\")\n    return max_depth\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpmfrdzgvl.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpmfrdzgvl.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpmfrdzgvl.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if not\
    \ paren_string:\n        return []\n    \n    stack = []\n    brackets = 0\n \
    \   for c in paren_string:\n        if c == '(':\n            stack.append(c)\n\
    \            brackets += 1\n        elif c == ')':\n            brackets -= 1\n\
    \            popped = stack.pop()\n            if len(stack) < brackets:\n   \
    \             raise ValueError('Nested parentheses out of balance')\n        \
    \    stack[-1] = popped\n        elif c == '[':\n            stack.append(c)\n\
    \        elif c == ']':\n            if not stack:\n                raise ValueError('Nested\
    \ square brackets out of balance')\n            if stack[-1] == '[':\n       \
    \         stack.pop()\n            else:\n                raise ValueError('Nested\
    \ square brackets out of balance')\n    return stack\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpc93eu_u5.py\", line\
    \ 44, in <module>\n    test_check()\n  File \"/tmp/tmpc93eu_u5.py\", line 42,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpc93eu_u5.py\"\
    , line 37, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpc93eu_u5.py\", line 23, in parse_nested_parens\n\
    \    stack[-1] = popped\nIndexError: list assignment index out of range\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    open_paren_count\
    \ = 0\n    level = 0\n    nesting_levels = [0 for _ in range(MAX_NESTING_DEPTH)]\n\
    \    # A stack to keep track of current parens level and which parens level is\
    \ closed for last.\n    paren_stack = []\n    paren_stack.append(0)\n    paren_stack.append(0)\n\
    \    for char in paren_string:\n        if char == \"(\":\n            open_paren_count\
    \ += 1\n            level += 1\n            nesting_levels[level] += 1\n     \
    \       paren_stack.append(level)\n        if char == \")\":\n            level\
    \ += 1\n            nesting_levels[level] -= 1\n            open_paren_count -=\
    \ 1\n            # Only pop the level if there are more than one levels open.\n\
    \            # (We consider all the levels except the last level as closed)\n\
    \            if len(paren_stack) <= 1:\n                level -= 1\n         \
    \       nesting_levels[level] -= 1\n                paren_stack.pop()\n\n    if\
    \ open_paren_count == 0:\n        return 0\n\n    return nesting_levels\n\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmphue2u6xn.py\", line\
    \ 47, in <module>\n    test_check()\n  File \"/tmp/tmphue2u6xn.py\", line 45,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmphue2u6xn.py\"\
    , line 40, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmphue2u6xn.py\", line 11, in parse_nested_parens\n\
    \    nesting_levels = [0 for _ in range(MAX_NESTING_DEPTH)]\nNameError: name 'MAX_NESTING_DEPTH'\
    \ is not defined\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_stack\
    \ = []\n    paren_count = 0\n    i = 0\n    open_paren_indexes = []\n    close_paren_indexes\
    \ = []\n\n    for char in paren_string:\n        if char == '(':\n           \
    \ paren_count += 1\n            open_paren_indexes.append(i)\n        if char\
    \ == ')':\n            paren_count -= 1\n            close_paren_indexes.append(i)\n\
    \        i += 1\n\n    open_paren_indexes.sort()\n    close_paren_indexes.sort()\n\
    \n    if paren_count == 0:\n        return open_paren_indexes[::-1]\n\n    deepest_nesting_level\
    \ = open_paren_indexes[close_paren_indexes.index(open_paren_indexes[-1])]\n\n\
    \    return open_paren_indexes[::-1][:deepest_nesting_level + 1]\n\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp1o8bm649.py\", line\
    \ 43, in <module>\n    test_check()\n  File \"/tmp/tmp1o8bm649.py\", line 41,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1o8bm649.py\"\
    , line 36, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # Implement\
    \ this\n    raise NotImplementedError()\n    return 0\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpfe7wzo74.py\", line\
    \ 21, in <module>\n    test_check()\n  File \"/tmp/tmpfe7wzo74.py\", line 19,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpfe7wzo74.py\"\
    , line 14, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpfe7wzo74.py\", line 10, in parse_nested_parens\n\
    \    raise NotImplementedError()\nNotImplementedError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_list_list\
    \ = []\n    paren_list_list.append([])\n    for char in paren_string:\n      \
    \  if char == '(':\n            paren_list_list.append([])\n        elif char\
    \ == ')':\n            deepest_level = max(paren_list_list)\n            paren_list_list[len(paren_list_list)-1].append(deepest_level)\n\
    \    return paren_list_list\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp3zs__r5z.py\", line\
    \ 28, in <module>\n    test_check()\n  File \"/tmp/tmp3zs__r5z.py\", line 26,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp3zs__r5z.py\"\
    , line 21, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    nested_parens_stack\
    \ = []\n\n    for c in paren_string:\n        if c == \"(\":\n            nested_parens_stack.append(len(nested_parens_stack))\n\
    \        elif c == \")\":\n            depth = nested_parens_stack.pop()\n   \
    \         if not nested_parens_stack:\n                return depth\n        \
    \    else:\n                return max(nested_parens_stack, key=lambda depth:\
    \ depth-depth)\n\n    return 0\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpo63rge2v.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmpo63rge2v.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpo63rge2v.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    level =\
    \ 0\n    open_brackets = 0\n    in_parentheses = False\n    stack = []\n\n   \
    \ for char in paren_string:\n        if char == \"(\":\n            if in_parentheses:\n\
    \                open_brackets += 1\n            else:\n                in_parentheses\
    \ = True\n                stack.append(char)\n        elif char == \")\":\n  \
    \          if not in_parentheses:\n                open_brackets -= 1\n      \
    \      elif open_brackets == 0:\n                in_parentheses = False\n    \
    \            level -= 1\n            else:\n                stack.pop()\n    \
    \            level -= 1\n        elif char == \")\":\n            if not in_parentheses:\n\
    \                open_brackets -= 1\n            elif open_brackets == 0:\n  \
    \              in_parentheses = False\n                level -= 1\n          \
    \  else:\n                stack.pop()\n                level -= 1\n        elif\
    \ char == \")\" and in_parentheses:\n            stack.pop()\n            level\
    \ -= 1\n\n    return stack\n\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpssn8sn4a.py\", line\
    \ 54, in <module>\n    test_check()\n  File \"/tmp/tmpssn8sn4a.py\", line 52,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpssn8sn4a.py\"\
    , line 47, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpssn8sn4a.py\", line 28, in parse_nested_parens\n\
    \    stack.pop()\nIndexError: pop from empty list\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    res = list(map(int,\
    \ paren_string.strip().replace(')', '').split('(')))\n    if res[-1] != 0:\n \
    \       res.append(0)\n\n    return res\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp9x2tdvy8.py\", line\
    \ 23, in <module>\n    test_check()\n  File \"/tmp/tmp9x2tdvy8.py\", line 21,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9x2tdvy8.py\"\
    , line 16, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp9x2tdvy8.py\", line 9, in parse_nested_parens\n \
    \   res = list(map(int, paren_string.strip().replace(')', '').split('(')))\nValueError:\
    \ invalid literal for int() with base 10: ''\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    return\
    \ list(parse_parens(paren_string))\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpbjo9mpd2.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpbjo9mpd2.py\", line 17,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpbjo9mpd2.py\"\
    , line 12, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpbjo9mpd2.py\", line 9, in parse_nested_parens\n \
    \   return list(parse_parens(paren_string))\nNameError: name 'parse_parens' is\
    \ not defined\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    return\
    \ []\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpjbzwj8z8.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmpjbzwj8z8.py\", line 18,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpjbzwj8z8.py\"\
    , line 13, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    open_braces\
    \ = 0\n    close_braces = 0\n    deepest_level = 0\n\n    for idx, char in enumerate(paren_string):\n\
    \        if char == '(':\n            open_braces += 1\n        elif char == ')':\n\
    \            close_braces += 1\n        else:\n            continue\n\n      \
    \  if open_braces > close_braces:\n            deepest_level = idx + 1\n     \
    \       open_braces = 0\n            close_braces = 0\n        elif open_braces\
    \ < close_braces:\n            open_braces = 0\n            close_braces = 0\n\
    \n    return deepest_level\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpokcnlk_w.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmpokcnlk_w.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpokcnlk_w.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # your\
    \ code here\n    level = 0\n    i = 0\n    while i < len(paren_string) - 1:\n\
    \        if paren_string[i] == \"(\":\n            level += 1\n        if paren_string[i]\
    \ == \")\":\n            level -= 1\n        if level == 0:\n            i +=\
    \ 1\n        i += 1\n    return [i, level]\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpn_6dq1dj.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmpn_6dq1dj.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpn_6dq1dj.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_stack\
    \ = []\n    current_level = 0\n    paren_string_list = paren_string.split()\n\
    \    for paren in paren_string_list:\n        if paren == '(':\n            current_level\
    \ += 1\n            paren_stack.append(current_level)\n        elif paren == ')':\n\
    \            current_level -= 1\n            paren_stack.pop()\n    if not paren_stack:\n\
    \        return []\n    return paren_stack\n\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpblggygjh.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmpblggygjh.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpblggygjh.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_count\
    \ = 0\n    paren_stack = []\n    paren_stack_index = 0\n    # start parsing paren_stack\n\
    \    for char in paren_string:\n        if char == '(':\n            if paren_count\
    \ == 0:\n                # start a new level of nesting\n                paren_stack.append([])\n\
    \                paren_stack_index += 1\n            paren_stack[paren_stack_index].append(paren_count)\n\
    \            paren_count += 1\n        elif char == ')':\n            paren_count\
    \ -= 1\n            if paren_count == 0:\n                # pop all levels of\
    \ nesting and add paren_stack to output\n                nested_parens_level =\
    \ []\n                while len(nested_parens_level) < len(paren_stack):\n   \
    \                 nested_parens_level.append(paren_stack.pop())\n            \
    \    nested_parens_level.reverse()\n                return nested_parens_level\n\
    \            else:\n                # pop all levels of nesting and add paren_stack\
    \ to output\n                nested_parens_level = []\n                while len(nested_parens_level)\
    \ < len(paren_stack):\n                    nested_parens_level.append(paren_stack.pop())\n\
    \                nested_parens_level.reverse()\n                nested_parens_level.append(paren_count)\n\
    \                nested_parens_level.reverse()\n                return nested_parens_level\n\
    \    return []\n\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpknxtfsp4.py\", line\
    \ 49, in <module>\n    test_check()\n  File \"/tmp/tmpknxtfsp4.py\", line 47,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpknxtfsp4.py\"\
    , line 42, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmpknxtfsp4.py\", line 19, in parse_nested_parens\n\
    \    paren_stack[paren_stack_index].append(paren_count)\nIndexError: list index\
    \ out of range\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    return\
    \ []\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmppgl7h7rl.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmppgl7h7rl.py\", line 17,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmppgl7h7rl.py\"\
    , line 12, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_level\
    \ = 0\n    paren_levels: List[int] = []\n    paren_depths: List[int] = []\n  \
    \  for ch in paren_string:\n        if ch == \"(\":\n            paren_level +=\
    \ 1\n        elif ch == \")\":\n            paren_level -= 1\n            paren_levels.append(paren_level)\n\
    \            paren_depths.append(paren_level)\n            paren_level = 0\n \
    \       elif ch == \" \":\n            pass\n        else:\n            raise\
    \ ValueError(\"Invalid parens string: \" + paren_string)\n\n    # Sanity check\n\
    \    assert len(paren_levels) == len(paren_depths)\n\n    return paren_levels\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp3tdgsk3e.py\", line\
    \ 39, in <module>\n    test_check()\n  File \"/tmp/tmp3tdgsk3e.py\", line 37,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp3tdgsk3e.py\"\
    , line 32, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpejsal38b.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpejsal38b.py\", line 17,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpejsal38b.py\"\
    , line 12, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    return\
    \ 0\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp4xxb4uak.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmp4xxb4uak.py\", line 17,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp4xxb4uak.py\"\
    , line 12, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if paren_string\
    \ == '': return []\n    levels = []\n    open_count = 0\n    close_count = 0\n\
    \    for char in paren_string:\n        if char == '(':\n            open_count\
    \ += 1\n        elif char == ')':\n            close_count += 1\n            \n\
    \    levels.append(close_count)\n\n    return levels\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptj6abahq.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmptj6abahq.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptj6abahq.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\
    </cell>\n<cell>\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpkmvqr95e.py\", line 10\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    paren_groups\
    \ = paren_string.split() # Split the input string into multiple groups\n    max_level\
    \ = 1\n    deepest_group = []\n    for group in paren_groups:\n        if group\
    \ == '(':\n            deepest_group.append(group)\n            max_level += 1\n\
    \        elif group == ')':\n            deepest_group.pop()\n            max_level\
    \ -= 1\n    \n    if max_level == 0:\n        raise ValueError(f\"Parenthesis\
    \ grouping does not match {paren_string}\")\n    return deepest_group\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp_z5gxn1a.py\", line\
    \ 32, in <module>\n    test_check()\n  File \"/tmp/tmp_z5gxn1a.py\", line 30,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp_z5gxn1a.py\"\
    , line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    nested_parens_levels:\
    \ List[int] = []\n    for index, char in enumerate(paren_string):\n        if\
    \ char == '(':\n            nested_parens_levels.append(index)\n        if char\
    \ == ')':\n            nested_parens_levels.pop()\n    return nested_parens_levels\n\
    \ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpku2obi2t.py\", line\
    \ 25, in <module>\n    test_check()\n  File \"/tmp/tmpku2obi2t.py\", line 23,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpku2obi2t.py\"\
    , line 18, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: 1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\
    </cell>\n<cell>\ndef check(candidate):\n    assert candidate('(()()) ((())) ()\
    \ ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: SyntaxError
  stderr: "  File \"/tmp/tmpkmvqr95e.py\", line 10\n    </cell>\n    ^\nSyntaxError:\
    \ invalid syntax\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    parens\
    \ = [0 for _ in range(len(paren_string))]\n\n    for i, paren in enumerate(paren_string):\n\
    \        if paren == '(':\n            parens[i] += 1\n        elif paren == ')':\n\
    \            parens[i] -= 1\n        else:\n            parens[i] = 0\n\n    return\
    \ parens\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmplq1ued8s.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmplq1ued8s.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmplq1ued8s.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if paren_string.count(\"\
    (\") != paren_string.count(\")\"):\n        raise ValueError(\"Invalid parenthesis\
    \ input\")\n    paren_string = paren_string.replace(\"()()\", \"((((())))\")\n\
    \    paren_string = paren_string.replace(\"((()))\", \"((()))\")\n    paren_string\
    \ = paren_string.replace(\"()\", \"())\")\n    paren_string = paren_string.replace(\"\
    (())\", \"(())\")\n    paren_string = paren_string.replace(\"((()))\", \"(((())))\"\
    )\n    paren_string = paren_string.replace(\"((((()))))\", \"((((((()))))))\"\
    )\n    return list(paren_string)\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpkj25n2rf.py\", line\
    \ 27, in <module>\n    test_check()\n  File \"/tmp/tmpkj25n2rf.py\", line 25,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkj25n2rf.py\"\
    , line 20, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    # TODO:\
    \ Implement me\n    pass\n\ndef check(candidate):\n    assert candidate('(()())\
    \ ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((()))\
    \ (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\n\
    def test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpv_va9viz.py\", line\
    \ 20, in <module>\n    test_check()\n  File \"/tmp/tmpv_va9viz.py\", line 18,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpv_va9viz.py\"\
    , line 13, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    count =\
    \ 0\n    parens = []\n\n    for char in paren_string:\n        if char == '(':\n\
    \            count += 1\n            parens.append(count)\n        if char ==\
    \ ')':\n            count -= 1\n    if count == 0:\n        raise ValueError(paren_string)\n\
    \n    return parens\n\ndef check(candidate):\n    assert candidate('(()()) ((()))\
    \ () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))')\
    \ == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n\
    \    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp7ow99axr.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmp7ow99axr.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp7ow99axr.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp7ow99axr.py\", line 19, in parse_nested_parens\n\
    \    raise ValueError(paren_string)\nValueError: (()()) ((())) () ((())()())\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    level =\
    \ 1\n    paren_levels = []\n\n    for i in range(len(paren_string)):\n       \
    \ if paren_string[i] == \"(\":\n            level += 1\n            paren_levels.append(level)\n\
    \        if paren_string[i] == \")\":\n            level -= 1\n\n    return paren_levels\n\
    \n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmptymebeq7.py\", line\
    \ 30, in <module>\n    test_check()\n  File \"/tmp/tmptymebeq7.py\", line 28,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptymebeq7.py\"\
    , line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmplvuevf5p.py\", line\
    \ 18, in <module>\n    test_check()\n  File \"/tmp/tmplvuevf5p.py\", line 16,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmplvuevf5p.py\"\
    , line 11, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    if paren_string\
    \ == \"0\":\n        # Special case when paren_string = \"0\"\n        return\
    \ []\n    level = 0\n    pos = 0\n    levels = []\n    prev_pos = 0\n    while\
    \ pos < len(paren_string):\n        open_paren_pos = paren_string.find(\"(\",\
    \ pos)\n        if open_paren_pos == -1:\n            levels.append(level + 1)\n\
    \            level = level + 1\n            pos = pos + 1\n        else:\n   \
    \         levels.append(level + 1)\n            level = level + 1\n          \
    \  pos = open_paren_pos\n            prev_pos = open_paren_pos + 1\n    if prev_pos\
    \ < len(paren_string):\n        levels.append(level + 1)\n        level = level\
    \ + 1\n        pos += 1\n    return levels\n\ndef check(candidate):\n    assert\
    \ candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('()\
    \ (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659822130
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    pass\n\n\
    def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') ==\
    \ [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n\
    \    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\
    \ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmpejsal38b.py\", line\
    \ 19, in <module>\n    test_check()\n  File \"/tmp/tmpejsal38b.py\", line 17,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpejsal38b.py\"\
    , line 12, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\nAssertionError\n"
  stdout: ''
  timestamp: 1659822124
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    \n    #\
    \ Remove all leading and trailing spaces\n    stripped_string = re.sub(r'[ \\\
    n]+', '', paren_string)\n    \n    # Parse the string into a nested list where\
    \ each element of the list is an index for a nested parentheses group\n    nested_list\
    \ = [None]*len(stripped_string)\n    for i in range(len(stripped_string)):\n \
    \       nested_list[i] = int(stripped_string[i])\n\n    # Return the deepest level\
    \ of nesting for the input\n    return max(nested_list)\n\ndef check(candidate):\n\
    \    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert\
    \ candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))')\
    \ == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmphqee3zs2.py\", line\
    \ 29, in <module>\n    test_check()\n  File \"/tmp/tmphqee3zs2.py\", line 27,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmphqee3zs2.py\"\
    , line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmphqee3zs2.py\", line 11, in parse_nested_parens\n\
    \    stripped_string = re.sub(r'[ \\n]+', '', paren_string)\nNameError: name 're'\
    \ is not defined\n"
  stdout: ''
  timestamp: 1659822125
- exit_code: -1
  program: "from typing import List\n\ndef parse_nested_parens(paren_string: str)\
    \ -> List[int]:\n    \"\"\" Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n\n        \"\"\"\n    groups\
    \ = paren_string.split()\n    levels = [0] * len(groups)\n    index = 0\n    while\
    \ index < len(groups):\n        levels[index] = group_level(groups[index], index)\n\
    \        index += 1\n\n    deepest_level = -1\n    for level in levels:\n    \
    \    if level > deepest_level:\n            deepest_level = level\n\n    return\
    \ levels\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())')\
    \ == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3,\
    \ 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n   \
    \ check(parse_nested_parens)\n\ntest_check()\n"
  status: Exception
  stderr: "Traceback (most recent call last):\n  File \"/tmp/tmp5hpti835.py\", line\
    \ 31, in <module>\n    test_check()\n  File \"/tmp/tmp5hpti835.py\", line 29,\
    \ in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp5hpti835.py\"\
    , line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2,\
    \ 3, 1, 3]\n  File \"/tmp/tmp5hpti835.py\", line 13, in parse_nested_parens\n\
    \    levels[index] = group_level(groups[index], index)\nNameError: name 'group_level'\
    \ is not defined\n"
  stdout: ''
  timestamp: 1659822125
