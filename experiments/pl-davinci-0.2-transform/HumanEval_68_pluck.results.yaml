language: pl
name: HumanEval_68_pluck
results:
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $val = $arr->[$i];\n        if ($val % 2 ==\
    \ 0) {\n            if (!defined($min) || $val < $min) {\n                $min\
    \ = $val;\n                $min_idx = $i;\n            }\n        }\n    }\n \
    \   if (defined($min)) {\n        return [$min, $min_idx];\n    } else {\n   \
    \     return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $min_idx = $i;\n            }\n        }\n    }\n    return $min == -1 ?\
    \ [] : [$min, $min_idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_index = -1;\n    for my\
    \ $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min\
    \ == -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n        \
    \        $min_index = $i;\n            }\n        }\n    }\n    if ($min == -1)\
    \ {\n        return [];\n    } else {\n        return [$min, $min_index];\n  \
    \  }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ (my $i = 0; $i < scalar(@$arr); $i++) {\n        if ($arr->[$i] % 2 == 0) {\n\
    \            if (!defined($min) || $arr->[$i] < $min) {\n                $min\
    \ = $arr->[$i];\n                $min_idx = $i;\n            }\n        }\n  \
    \  }\n    if (defined($min)) {\n        return [$min, $min_idx];\n    } else {\n\
    \        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n         \
    \   if (!defined($min_even) || $arr->[$i] < $min_even) {\n                $min_even\
    \ = $arr->[$i];\n                $min_even_idx = $i;\n            }\n        }\n\
    \    }\n    if (defined($min_even)) {\n        return [$min_even, $min_even_idx];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        my $v = $arr->[$i];\n        if ($v %\
    \ 2 == 0) {\n            if (!defined($min_even) || $v < $min_even) {\n      \
    \          $min_even = $v;\n                $min_even_idx = $i;\n            }\n\
    \        }\n    }\n    if (defined($min_even)) {\n        return [$min_even, $min_even_idx];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $min_idx = $i;\n            }\n        }\n    }\n    return $min == -1 ?\
    \ [] : [$min, $min_idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $min_idx = $i;\n            }\n        }\n    }\n    return $min == -1 ?\
    \ [] : [$min, $min_idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_index = undef;\n  \
    \  for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n           \
    \ if (!defined($min) || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $min_index];\n    } else {\n        return [];\n  \
    \  }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $min_idx = $i;\n            }\n        }\n    }\n    return $min == -1 ?\
    \ [] : [$min, $min_idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $min_idx = $i;\n            }\n        }\n    }\n    return $min == -1 ?\
    \ [] : [$min, $min_idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $index = -1;\n    for my $i\
    \ (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $index = $i;\n            }\n        }\n    }\n    return $min == -1 ? []\
    \ : [$min, $index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n         \
    \   if (!defined($min_even) || $arr->[$i] < $min_even) {\n                $min_even\
    \ = $arr->[$i];\n                $min_even_idx = $i;\n            }\n        }\n\
    \    }\n    if (defined($min_even)) {\n        return [$min_even, $min_even_idx];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_index = -1;\n    for my\
    \ $i (0 .. $#$arr) {\n        my $val = $arr->[$i];\n        if ($val % 2 == 0)\
    \ {\n            if ($min == -1 || $val < $min) {\n                $min = $val;\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    return\
    \ $min == -1 ? [] : [$min, $min_index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_i = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_i = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n \
    \       return [$min, $min_i];\n    } else {\n        return [];\n    }\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n      \
    \  if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..$#$arr)\
    \ {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min == -1 || $arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $idx = $i;\n\
    \            }\n        }\n    }\n    return $min == -1 ? [] : [$min, $idx];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_index = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n         \
    \   if (!defined($min_even) || $arr->[$i] < $min_even) {\n                $min_even\
    \ = $arr->[$i];\n                $min_even_index = $i;\n            }\n      \
    \  }\n    }\n    if (defined($min_even)) {\n        return [$min_even, $min_even_index];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = 10001;\n    my $index = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0 && $arr->[$i] < $min) {\n\
    \            $min = $arr->[$i];\n            $index = $i;\n        }\n    }\n\
    \    return $index == -1 ? [] : [$min, $index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_index = -1;\n    for my\
    \ $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min\
    \ == -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n        \
    \        $min_index = $i;\n            }\n        }\n    }\n    return [] if $min\
    \ == -1;\n    return [$min, $min_index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $index = undef;\n    for\
    \ my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined\
    \ $min || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n         \
    \       $index = $i;\n            }\n        }\n    }\n    return defined $min\
    \ ? [$min, $index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $index = undef;\n    for\
    \ my $i (0 .. $#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0)\
    \ {\n            if (!defined($min) || $v < $min) {\n                $min = $v;\n\
    \                $index = $i;\n            }\n        }\n    }\n    return defined($min)\
    \ ? [$min, $index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_index = -1;\n    my $min_value = -1;\n  \
    \  for (my $i = 0; $i < scalar(@$arr); $i++) {\n        my $value = $arr->[$i];\n\
    \        if ($value % 2 == 0) {\n            if ($min_index == -1) {\n       \
    \         $min_index = $i;\n                $min_value = $value;\n           \
    \ } elsif ($value < $min_value) {\n                $min_index = $i;\n        \
    \        $min_value = $value;\n            }\n        }\n    }\n    if ($min_index\
    \ == -1) {\n        return [];\n    } else {\n        return [$min_value, $min_index];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0) {\n\
    \            if (not defined $min or $v < $min) {\n                $min = $v;\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    return defined\
    \ $min ? [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $val = $arr->[$i];\n        if ($val % 2 ==\
    \ 0) {\n            if (!defined($min) || $val < $min) {\n                $min\
    \ = $val;\n                $min_idx = $i;\n            }\n        }\n    }\n \
    \   return defined($min) ? [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..$#$arr)\
    \ {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min == -1 || $arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $idx = $i;\n\
    \            }\n        }\n    }\n    return $min == -1 ? [] : [$min, $idx];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ (my $i = 0; $i < scalar(@$arr); $i++) {\n        if ($arr->[$i] % 2 == 0) {\n\
    \            if (!defined($min) || $arr->[$i] < $min) {\n                $min\
    \ = $arr->[$i];\n                $min_idx = $i;\n            }\n        }\n  \
    \  }\n    if (defined($min)) {\n        return [$min, $min_idx];\n    } else {\n\
    \        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $index = -1;\n    for my $i\
    \ (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $index = $i;\n            }\n        }\n    }\n    return $min == -1 ? []\
    \ : [$min, $index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $idx = undef;\n    for my\
    \ $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $idx = $i;\n            }\n        }\n    }\n    return defined($min) ? [$min,\
    \ $idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my($min_even, $min_even_idx) = (undef, undef);\n\
    \    for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n         \
    \   if (!defined($min_even) || $arr->[$i] < $min_even) {\n                $min_even\
    \ = $arr->[$i];\n                $min_even_idx = $i;\n            }\n        }\n\
    \    }\n    return defined($min_even) ? [$min_even, $min_even_idx] : [];\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1) {\n                $min = $arr->[$i];\n                $min_idx = $i;\n\
    \            }\n            else {\n                if ($arr->[$i] < $min) {\n\
    \                    $min = $arr->[$i];\n                    $min_idx = $i;\n\
    \                }\n            }\n        }\n    }\n    if ($min == -1) {\n \
    \       return [];\n    }\n    else {\n        return [$min, $min_idx];\n    }\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..$#$arr)\
    \ {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min == -1 || $arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $idx = $i;\n\
    \            }\n        }\n    }\n    return [$min, $idx];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        my $v = $arr->[$i];\n        if ($v %\
    \ 2 == 0) {\n            if (!defined($min_even) || $v < $min_even) {\n      \
    \          $min_even = $v;\n                $min_even_idx = $i;\n            }\n\
    \        }\n    }\n    if (defined($min_even)) {\n        return [$min_even, $min_even_idx];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_i = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0) {\n\
    \            if (!defined($min) || $v < $min) {\n                $min = $v;\n\
    \                $min_i = $i;\n            }\n        }\n    }\n    return defined($min)\
    \ ? [$min, $min_i] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0) {\n\
    \            if (!defined($min) || $v < $min) {\n                $min = $v;\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $min_idx = $i;\n            }\n        }\n    }\n    return $min == -1 ?\
    \ [] : [$min, $min_idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $idx = undef;\n    for my\
    \ $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $idx = $i;\n            }\n        }\n    }\n    return defined($min) ? [$min,\
    \ $idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ (my $i = 0; $i < scalar(@$arr); $i++) {\n        my $v = $arr->[$i];\n     \
    \   if ($v % 2 == 0) {\n            if (!defined($min) || $v < $min) {\n     \
    \           $min = $v;\n                $min_idx = $i;\n            }\n      \
    \  }\n    }\n    if (defined($min)) {\n        return [$min, $min_idx];\n    }\
    \ else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $idx = undef;\n    for my\
    \ $i (0 .. $#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0) {\n\
    \            if (!defined($min) || $v < $min) {\n                $min = $v;\n\
    \                $idx = $i;\n            }\n        }\n    }\n    return defined($min)\
    \ ? [$min, $idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        my $v = $arr->[$i];\n        if ($v %\
    \ 2 == 0) {\n            if (!defined($min_even) || $v < $min_even) {\n      \
    \          $min_even = $v;\n                $min_even_idx = $i;\n            }\n\
    \        }\n    }\n    if (defined($min_even)) {\n        return [$min_even, $min_even_idx];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0) {\n\
    \            if (!defined($min) || $v < $min) {\n                $min = $v;\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0) {\n\
    \            if (!defined($min) || $v < $min) {\n                $min = $v;\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $index = -1;\n    for(my $i\
    \ = 0; $i < scalar(@$arr); $i++) {\n        if($arr->[$i] % 2 == 0) {\n      \
    \      if($min == -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $index = $i;\n            }\n        }\n    }\n    if($min ==\
    \ -1) {\n        return [];\n    }\n    return [$min, $index];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ (my $i = 0; $i < scalar(@$arr); $i++) {\n        if ($arr->[$i] % 2 == 0) {\n\
    \            if (!defined($min) || $arr->[$i] < $min) {\n                $min\
    \ = $arr->[$i];\n                $min_idx = $i;\n            }\n        }\n  \
    \  }\n    if (defined($min)) {\n        return [$min, $min_idx];\n    } else {\n\
    \        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $index = -1;\n    for my $i\
    \ (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $index = $i;\n            }\n        }\n    }\n    return [$min, $index];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for (my\
    \ $i = 0; $i < scalar(@$arr); $i++) {\n        if ($arr->[$i] % 2 == 0) {\n  \
    \          if ($min == -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    if ($min\
    \ == -1) {\n        return [];\n    } else {\n        return [$min, $min_idx];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_index = undef;\n  \
    \  for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n           \
    \ if (not defined $min or $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    if (defined\
    \ $min) {\n        return [$min, $min_index];\n    } else {\n        return [];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0) {\n\
    \            if ($min == -1 || $v < $min) {\n                $min = $v;\n    \
    \            $min_idx = $i;\n            }\n        }\n    }\n    return [$min,\
    \ $min_idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n       \
    \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_index = undef;\n  \
    \  for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n           \
    \ if (!defined($min) || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $min_index];\n    } else {\n        return [];\n  \
    \  }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..$#$arr)\
    \ {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min == -1 || $arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $idx = $i;\n\
    \            }\n        }\n    }\n    return [$min, $idx];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ (my $i = 0; $i < scalar(@$arr); $i++) {\n        if ($arr->[$i] % 2 == 0) {\n\
    \            if (!defined($min) || $arr->[$i] < $min) {\n                $min\
    \ = $arr->[$i];\n                $min_idx = $i;\n            }\n        }\n  \
    \  }\n    if (defined($min)) {\n        return [$min, $min_idx];\n    } else {\n\
    \        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (not\
    \ defined $min or $arr->[$i] < $min) {\n                $min = $arr->[$i];\n \
    \               $min_idx = $i;\n            }\n        }\n    }\n    return defined\
    \ $min ? [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $index = undef;\n    for\
    \ my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (not\
    \ defined $min or $arr->[$i] < $min) {\n                $min = $arr->[$i];\n \
    \               $index = $i;\n            }\n        }\n    }\n    return defined\
    \ $min ? [$min, $index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n \
    \   my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = $arr->[0];\n    my $index = 0;\n    for\
    \ my $i (1 .. $#$arr) {\n        if ($arr->[$i] < $min) {\n            $min =\
    \ $arr->[$i];\n            $index = $i;\n        }\n    }\n    return [$min, $index];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n         \
    \   if (!defined($min_even) || $arr->[$i] < $min_even) {\n                $min_even\
    \ = $arr->[$i];\n                $min_even_idx = $i;\n            }\n        }\n\
    \    }\n    if (defined($min_even)) {\n        return [$min_even, $min_even_idx];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_index = -1;\n    for(my\
    \ $i = 0; $i < scalar(@$arr); $i++) {\n        if($arr->[$i] % 2 == 0) {\n   \
    \         if($min == -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    if($min\
    \ == -1) {\n        return [];\n    }\n    return [$min, $min_index];\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n      \
    \  if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $val = $arr->[$i];\n        if ($val % 2 ==\
    \ 0) {\n            if (!defined($min) || $val < $min) {\n                $min\
    \ = $val;\n                $min_idx = $i;\n            }\n        }\n    }\n \
    \   return defined($min) ? [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_index = -1;\n    for my\
    \ $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min\
    \ == -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n        \
    \        $min_index = $i;\n            }\n        }\n    }\n    return [] if $min\
    \ == -1;\n    return [$min, $min_index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for (my\
    \ $i = 0; $i < scalar(@$arr); $i++) {\n        if ($arr->[$i] % 2 == 0) {\n  \
    \          if ($min == -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    if ($min\
    \ == -1) {\n        return [];\n    } else {\n        return [$min, $min_idx];\n\
    \    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_index = undef;\n  \
    \  for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n           \
    \ if (defined $min) {\n                if ($arr->[$i] < $min) {\n            \
    \        $min = $arr->[$i];\n                    $min_index = $i;\n          \
    \      }\n            } else {\n                $min = $arr->[$i];\n         \
    \       $min_index = $i;\n            }\n        }\n    }\n    if (defined $min)\
    \ {\n        return [$min, $min_index];\n    } else {\n        return [];\n  \
    \  }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ (my $i = 0; $i < scalar(@$arr); $i++) {\n        if ($arr->[$i] % 2 == 0) {\n\
    \            if (!defined($min) || $arr->[$i] < $min) {\n                $min\
    \ = $arr->[$i];\n                $min_idx = $i;\n            }\n        }\n  \
    \  }\n    if (defined($min)) {\n        return [$min, $min_idx];\n    } else {\n\
    \        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = 10001;\n    my $min_idx = -1;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0 && $arr->[$i] < $min) {\n\
    \            $min = $arr->[$i];\n            $min_idx = $i;\n        }\n    }\n\
    \    if ($min_idx == -1) {\n        return [];\n    }\n    return [$min, $min_idx];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $idx = undef;\n    for my\
    \ $i (0 .. $#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0) {\n\
    \            if (!defined($min) || $v < $min) {\n                $min = $v;\n\
    \                $idx = $i;\n            }\n        }\n    }\n    return defined($min)\
    \ ? [$min, $idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $min_idx = $i;\n            }\n        }\n    }\n    return $min == -1 ?\
    \ [] : [$min, $min_idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_index = -1;\n    for(my\
    \ $i = 0; $i < scalar(@$arr); $i++) {\n        if($arr->[$i] % 2 == 0) {\n   \
    \         if($min == -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    return\
    \ [$min, $min_index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ (my $i = 0; $i < scalar(@$arr); $i++) {\n        if ($arr->[$i] % 2 == 0) {\n\
    \            if (!defined($min) || $arr->[$i] < $min) {\n                $min\
    \ = $arr->[$i];\n                $min_idx = $i;\n            }\n        }\n  \
    \  }\n    if (defined($min)) {\n        return [$min, $min_idx];\n    } else {\n\
    \        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = 10001;\n    my $index = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0 && $arr->[$i] < $min) {\n\
    \            $min = $arr->[$i];\n            $index = $i;\n        }\n    }\n\
    \    return $index == -1 ? [] : [$min, $index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_i = undef;\n    for\
    \ my $i (0 .. $#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0)\
    \ {\n            if (!defined($min) || $v < $min) {\n                $min = $v;\n\
    \                $min_i = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $min_i];\n    } else {\n        return [];\n    }\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..$#$arr)\
    \ {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min == -1) {\n     \
    \           $min = $arr->[$i];\n                $idx = $i;\n            } elsif\
    \ ($arr->[$i] < $min) {\n                $min = $arr->[$i];\n                $idx\
    \ = $i;\n            }\n        }\n    }\n    return $min == -1 ? [] : [$min,\
    \ $idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_index = -1;\n    for my\
    \ $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min\
    \ == -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n        \
    \        $min_index = $i;\n            }\n        }\n    }\n    return [$min,\
    \ $min_index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821223
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $min_idx = $i;\n            }\n        }\n    }\n    return [$min, $min_idx];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_index = -1;\n    for(my\
    \ $i = 0; $i < scalar(@$arr); $i++) {\n        if($arr->[$i] % 2 == 0) {\n   \
    \         if($min == -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    return\
    \ $min == -1 ? [] : [$min, $min_index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..$#$arr)\
    \ {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min == -1 || $arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $idx = $i;\n\
    \            }\n        }\n    }\n    return $min == -1 ? [] : [$min, $idx];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = -1;\n    my $min_even_idx = -1;\n\
    \    for my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n           \
    \ if ($min_even == -1 || $arr->[$i] < $min_even) {\n                $min_even\
    \ = $arr->[$i];\n                $min_even_idx = $i;\n            }\n        }\n\
    \    }\n    return [] if $min_even == -1;\n    return [$min_even, $min_even_idx];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0) {\n\
    \            if (!defined($min) || $v < $min) {\n                $min = $v;\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0) {\n\
    \            if (!defined($min) || $v < $min) {\n                $min = $v;\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $val = $arr->[$i];\n        if ($val % 2 ==\
    \ 0) {\n            if (!defined($min) || $val < $min) {\n                $min\
    \ = $val;\n                $min_idx = $i;\n            }\n        }\n    }\n \
    \   return defined($min) ? [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_index = undef;\n  \
    \  for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n           \
    \ if (!defined($min) || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    return\
    \ defined($min) ? [$min, $min_index] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = 9999999;\n    my $index = -1;\n    for\
    \ my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0 && $arr->[$i] < $min)\
    \ {\n            $min = $arr->[$i];\n            $index = $i;\n        }\n   \
    \ }\n    return $index == -1 ? [] : [$min, $index];\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..$#$arr)\
    \ {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min == -1 || $arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $idx = $i;\n\
    \            }\n        }\n    }\n    return $min == -1 ? [] : [$min, $idx];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $min_idx = $i;\n            }\n        }\n    }\n    return $min == -1 ?\
    \ [] : [$min, $min_idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        my $val = $arr->[$i];\n        next if $val % 2;\n\
    \        if ($min < 0 || $val < $min) {\n            $min = $val;\n          \
    \  $min_idx = $i;\n        }\n    }\n    return [] if $min < 0;\n    return [$min,\
    \ $min_idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n       \
    \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1) {\n                $min = $arr->[$i];\n                $min_idx = $i;\n\
    \            }\n            elsif ($arr->[$i] < $min) {\n                $min\
    \ = $arr->[$i];\n                $min_idx = $i;\n            }\n        }\n  \
    \  }\n    return $min == -1 ? [] : [$min, $min_idx];\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my @evens = grep { $_ % 2 == 0 } @$arr;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $idx = first_index { $_\
    \ == $min } @$arr;\n    return [$min, $idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmp0vodkwze.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmp0vodkwze.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmp0vodkwze.pl line 34.\n"
  stdout: ''
  timestamp: 1659821223
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..$#$arr)\
    \ {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min == -1 || $arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $idx = $i;\n\
    \            }\n        }\n    }\n    return [$min, $idx];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..$#$arr)\
    \ {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min == -1 || $arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $idx = $i;\n\
    \            }\n        }\n    }\n    return $min == -1 ? [] : [$min, $idx];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n         \
    \   if (!defined($min_even) || $arr->[$i] < $min_even) {\n                $min_even\
    \ = $arr->[$i];\n                $min_even_idx = $i;\n            }\n        }\n\
    \    }\n    if (defined($min_even)) {\n        return [$min_even, $min_even_idx];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my($min, $min_idx) = (undef, undef);\n    for my\
    \ $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $min_idx = $i;\n            }\n        }\n    }\n    return $min == -1 ?\
    \ [] : [$min, $min_idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $index = -1;\n    for my $i\
    \ (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0 && ($min == -1 || $arr->[$i]\
    \ < $min)) {\n            $min = $arr->[$i];\n            $index = $i;\n     \
    \   }\n    }\n    return [$min, $index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $v = $arr->[$i];\n        if (defined $min)\
    \ {\n            if ($v < $min) {\n                $min = $v;\n              \
    \  $min_idx = $i;\n            }\n        } else {\n            if ($v % 2 ==\
    \ 0) {\n                $min = $v;\n                $min_idx = $i;\n         \
    \   }\n        }\n    }\n    return defined $min ? [$min, $min_idx] : [];\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_index = -1;\n    for my\
    \ $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min\
    \ == -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n        \
    \        $min_index = $i;\n            }\n        }\n    }\n    return $min ==\
    \ -1 ? [] : [$min, $min_index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for (my\
    \ $i = 0; $i < scalar(@$arr); $i++) {\n        if ($arr->[$i] % 2 == 0) {\n  \
    \          if ($min == -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    return [$min,\
    \ $min_idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n       \
    \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821223
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..$#$arr)\
    \ {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min == -1) {\n     \
    \           $min = $arr->[$i];\n                $idx = $i;\n            } elsif\
    \ ($arr->[$i] < $min) {\n                $min = $arr->[$i];\n                $idx\
    \ = $i;\n            }\n        }\n    }\n    return [$min, $idx];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $index = -1;\n    for my $i\
    \ (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $index = $i;\n            }\n        }\n    }\n    return $min == -1 ? []\
    \ : [$min, $index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_index = undef;\n  \
    \  for my $i (0 .. $#$arr) {\n        my $val = $arr->[$i];\n        if ($val\
    \ % 2 == 0) {\n            if (!defined($min) || $val < $min) {\n            \
    \    $min = $val;\n                $min_index = $i;\n            }\n        }\n\
    \    }\n    if (defined($min)) {\n        return [$min, $min_index];\n    } else\
    \ {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_index = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        my $v = $arr->[$i];\n        if ($v %\
    \ 2 == 0) {\n            if (!defined($min_even) || $v < $min_even) {\n      \
    \          $min_even = $v;\n                $min_even_index = $i;\n          \
    \  }\n        }\n    }\n    if (defined($min_even)) {\n        return [$min_even,\
    \ $min_even_index];\n    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $val = $arr->[$i];\n        if ($val % 2 ==\
    \ 0) {\n            if (!defined($min) || $val < $min) {\n                $min\
    \ = $val;\n                $min_idx = $i;\n            }\n        }\n    }\n \
    \   if (defined($min)) {\n        return [$min, $min_idx];\n    } else {\n   \
    \     return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ (my $i = 0; $i < scalar(@$arr); $i++) {\n        if ($arr->[$i] % 2 == 0) {\n\
    \            if (!defined($min) || $arr->[$i] < $min) {\n                $min\
    \ = $arr->[$i];\n                $min_idx = $i;\n            }\n        }\n  \
    \  }\n    return defined($min) ? [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\
    \nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_index = -1;\n    for(my\
    \ $i = 0; $i < scalar(@$arr); $i++) {\n        if($arr->[$i] % 2 == 0) {\n   \
    \         if($min == -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    if($min\
    \ == -1) {\n        return [];\n    }\n    return [$min, $min_index];\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n      \
    \  if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..$#$arr)\
    \ {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min == -1 || $arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $idx = $i;\n\
    \            }\n        }\n    }\n    return $min == -1 ? [] : [$min, $idx];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = 1e9;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0 && $arr->[$i] < $min) {\n\
    \            $min = $arr->[$i];\n            $min_idx = $i;\n        }\n    }\n\
    \    return $min_idx == -1 ? [] : [$min, $min_idx];\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n         \
    \   if (!defined($min_even) || $arr->[$i] < $min_even) {\n                $min_even\
    \ = $arr->[$i];\n                $min_even_idx = $i;\n            }\n        }\n\
    \    }\n    return defined($min_even) ? [$min_even, $min_even_idx] : [];\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0) {\n\
    \            if (!defined($min) || $v < $min) {\n                $min = $v;\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n         \
    \   if (!defined($min_even) || $arr->[$i] < $min_even) {\n                $min_even\
    \ = $arr->[$i];\n                $min_even_idx = $i;\n            }\n        }\n\
    \    }\n    if (defined($min_even)) {\n        return [$min_even, $min_even_idx];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..$#$arr)\
    \ {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min == -1 || $arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $idx = $i;\n\
    \            }\n        }\n    }\n    return $min == -1 ? [] : [$min, $idx];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my @evens = ();\n    my $min = undef;\n    my $min_idx\
    \ = undef;\n    for my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n\
    \            push @evens, $arr->[$i];\n            if (!defined($min) || $arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $min_idx = $i;\n\
    \            }\n        }\n    }\n    if (@evens) {\n        return [$min, $min_idx];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $idx = undef;\n    for my\
    \ $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $idx = $i;\n            }\n        }\n    }\n    return defined($min) ? [$min,\
    \ $idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my @evens = grep { $_ % 2 == 0 } @$arr;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $idx = firstidx { $_ ==\
    \ $min } @$arr;\n    return [$min, $idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmpp5g6nfn0.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmpp5g6nfn0.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmpp5g6nfn0.pl line 34.\n"
  stdout: ''
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $result = [];\n    my $min = -1;\n    my $index\
    \ = -1;\n    for (my $i = 0; $i < scalar @$arr; $i++) {\n        if ($arr->[$i]\
    \ % 2 == 0 && ($min == -1 || $arr->[$i] < $min)) {\n            $min = $arr->[$i];\n\
    \            $index = $i;\n        }\n    }\n    if ($min != -1) {\n        $result\
    \ = [$min, $index];\n    }\n    return $result;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $val = $arr->[$i];\n        if ($val % 2 ==\
    \ 0) {\n            if (!defined($min) || $val < $min) {\n                $min\
    \ = $val;\n                $min_idx = $i;\n            }\n        }\n    }\n \
    \   return defined($min) ? [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        my $val = $arr->[$i];\n        if ($val\
    \ % 2 == 0) {\n            if (!defined($min_even) || $val < $min_even) {\n  \
    \              $min_even = $val;\n                $min_even_idx = $i;\n      \
    \      }\n        }\n    }\n    if (defined($min_even)) {\n        return [$min_even,\
    \ $min_even_idx];\n    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $min_idx = $i;\n            }\n        }\n    }\n    if ($min == -1) {\n\
    \        return [];\n    } else {\n        return [$min, $min_idx];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..@$arr-1)\
    \ {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min == -1 || $arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $idx = $i;\n\
    \            }\n        }\n    }\n    return $min == -1 ? [] : [$min, $idx];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821224
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..$#$arr)\
    \ {\n        if($arr->[$i] % 2 == 0 && ($min == -1 || $arr->[$i] < $min)) {\n\
    \            $min = $arr->[$i];\n            $idx = $i;\n        }\n    }\n  \
    \  return $min == -1 ? [] : [$min, $idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0) {\n\
    \            if (!defined($min) || $v < $min) {\n                $min = $v;\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_index = undef;\n  \
    \  for my $i (0 .. $#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2\
    \ == 0) {\n            if (!defined($min) || $v < $min) {\n                $min\
    \ = $v;\n                $min_index = $i;\n            }\n        }\n    }\n \
    \   if (defined($min)) {\n        return [$min, $min_index];\n    } else {\n \
    \       return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0) {\n\
    \            if (!defined($min) || $v < $min) {\n                $min = $v;\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    return defined($min)\
    \ ? [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821224
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = -1;\n    my $min_even_idx = -1;\n\
    \    for (my $i = 0; $i < scalar(@$arr); $i++) {\n        if ($arr->[$i] % 2 ==\
    \ 0) {\n            if ($min_even == -1 || $arr->[$i] < $min_even) {\n       \
    \         $min_even = $arr->[$i];\n                $min_even_idx = $i;\n     \
    \       }\n        }\n    }\n    if ($min_even == -1) {\n        return [];\n\
    \    } else {\n        return [$min_even, $min_even_idx];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_index = undef;\n  \
    \  for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n           \
    \ if (!defined($min) || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $min_index];\n    } else {\n        return [];\n  \
    \  }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $min_idx = $i;\n            }\n        }\n    }\n    return $min == -1 ?\
    \ [] : [$min, $min_idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for my\
    \ $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $min_idx = $i;\n            }\n        }\n    }\n    if ($min == -1) {\n\
    \        return [];\n    } else {\n        return [$min, $min_idx];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_index = undef;\n  \
    \  for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n           \
    \ if (!defined($min) || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $min_index];\n    } else {\n        return [];\n  \
    \  }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 255
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my @evens = grep { $_ % 2 == 0 } @$arr;\n    return\
    \ [] unless @evens;\n    my $min = min @evens;\n    my $idx = firstidx { $_ ==\
    \ $min } @$arr;\n    return [$min, $idx];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: "Array found where operator expected at /tmp/tmpp5g6nfn0.pl line 30, near\
    \ \"min @evens\"\n\t(Do you need to predeclare min?)\nsyntax error at /tmp/tmpp5g6nfn0.pl\
    \ line 30, near \"min @evens\"\nBEGIN not safe after errors--compilation aborted\
    \ at /tmp/tmpp5g6nfn0.pl line 34.\n"
  stdout: ''
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n         \
    \   if (!defined($min_even) || $arr->[$i] < $min_even) {\n                $min_even\
    \ = $arr->[$i];\n                $min_even_idx = $i;\n            }\n        }\n\
    \    }\n    return defined($min_even) ? [$min_even, $min_even_idx] : [];\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = 10001;\n    my $min_idx = -1;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $min_idx = $i;\n\
    \            }\n        }\n    }\n    if ($min_idx == -1) {\n        return [];\n\
    \    } else {\n        return [$min, $min_idx];\n    }\n}\nuse Test::Deep;\n\n\
    \nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821224
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $idx = undef;\n    for my\
    \ $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n   \
    \     return [$min, $idx];\n    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821224
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ (my $i = 0; $i < scalar(@$arr); $i++) {\n        if ($arr->[$i] % 2 == 0) {\n\
    \            if (!defined($min) || $arr->[$i] < $min) {\n                $min\
    \ = $arr->[$i];\n                $min_idx = $i;\n            }\n        }\n  \
    \  }\n    if (defined($min)) {\n        return [$min, $min_idx];\n    } else {\n\
    \        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        my $v = $arr->[$i];\n        if ($v %\
    \ 2 == 0) {\n            if (!defined($min_even) || $v < $min_even) {\n      \
    \          $min_even = $v;\n                $min_even_idx = $i;\n            }\n\
    \        }\n    }\n    if (defined($min_even)) {\n        return [$min_even, $min_even_idx];\n\
    \    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..$#$arr)\
    \ {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min == -1 || $arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $idx = $i;\n\
    \            }\n        }\n    }\n    return $min == -1 ? [] : [$min, $idx];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0) {\n\
    \            if (!defined($min) || $v < $min) {\n                $min = $v;\n\
    \                $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = 999999999;\n    my $min_index = -1;\n \
    \   for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0 && $arr->[$i] <\
    \ $min) {\n            $min = $arr->[$i];\n            $min_index = $i;\n    \
    \    }\n    }\n    return $min_index == -1 ? [] : [$min, $min_index];\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n      \
    \  if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821224
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_value = undef;\n    my $min_index = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n         \
    \   if (!defined($min_value) || $arr->[$i] < $min_value) {\n                $min_value\
    \ = $arr->[$i];\n                $min_index = $i;\n            }\n        }\n\
    \    }\n    return defined($min_value) ? [$min_value, $min_index] : [];\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n      \
    \  if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821224
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $val = $arr->[$i];\n        if ($val % 2 ==\
    \ 0) {\n            if (!defined($min) || $val < $min) {\n                $min\
    \ = $val;\n                $min_idx = $i;\n            }\n        }\n    }\n \
    \   if (defined($min)) {\n        return [$min, $min_idx];\n    } else {\n   \
    \     return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = 10001;\n    my $index = -1;\n    for(my\
    \ $i = 0; $i < scalar(@$arr); $i++) {\n        if($arr->[$i] % 2 == 0 && $arr->[$i]\
    \ < $min) {\n            $min = $arr->[$i];\n            $index = $i;\n      \
    \  }\n    }\n    if($index == -1) {\n        return [];\n    }\n    return [$min,\
    \ $index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821224
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = 10001;\n    my $index = -1;\n    for my\
    \ $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $index = $i;\n\
    \            }\n        }\n    }\n    if ($index == -1) {\n        return [];\n\
    \    }\n    return [$min, $index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821224
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    if (defined($min)) {\n\
    \        return [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $min_idx = -1;\n    for (my\
    \ $i = 0; $i < scalar(@$arr); $i++) {\n        my $val = $arr->[$i];\n       \
    \ if ($val % 2 == 0) {\n            if ($min == -1 || $val < $min) {\n       \
    \         $min = $val;\n                $min_idx = $i;\n            }\n      \
    \  }\n    }\n    if ($min == -1) {\n        return [];\n    } else {\n       \
    \ return [$min, $min_idx];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821224
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $index = -1;\n    for my $i\
    \ (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min ==\
    \ -1 || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n           \
    \     $index = $i;\n            }\n        }\n    }\n    return $min == -1 ? []\
    \ : [$min, $index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = -1;\n    my $idx = -1;\n    for my $i (0..$#$arr)\
    \ {\n        if ($arr->[$i] % 2 == 0) {\n            if ($min == -1 || $arr->[$i]\
    \ < $min) {\n                $min = $arr->[$i];\n                $idx = $i;\n\
    \            }\n        }\n    }\n    return $min == -1 ? [] : [$min, $idx];\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n \
    \       if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $val = $arr->[$i];\n        if ($val % 2 ==\
    \ 0) {\n            if (!defined($min) || $val < $min) {\n                $min\
    \ = $val;\n                $min_idx = $i;\n            }\n        }\n    }\n \
    \   return defined($min) ? [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $min_idx = $i;\n            }\n        }\n    }\n    return defined($min) ?\
    \ [$min, $min_idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_index = undef;\n  \
    \  for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n           \
    \ if (!defined($min) || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    if (defined($min))\
    \ {\n        return [$min, $min_index];\n    } else {\n        return [];\n  \
    \  }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_idx = undef;\n    for\
    \ my $i (0..$#$arr) {\n        my $v = $arr->[$i];\n        if ($v % 2 == 0) {\n\
    \            if (defined $min) {\n                if ($v < $min) {\n         \
    \           $min = $v;\n                    $min_idx = $i;\n                }\n\
    \            } else {\n                $min = $v;\n                $min_idx =\
    \ $i;\n            }\n        }\n    }\n    if (defined $min) {\n        return\
    \ [$min, $min_idx];\n    } else {\n        return [];\n    }\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821224
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min_even = undef;\n    my $min_even_idx = undef;\n\
    \    for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n         \
    \   if (!defined($min_even) || $arr->[$i] < $min_even) {\n                $min_even\
    \ = $arr->[$i];\n                $min_even_idx = $i;\n            }\n        }\n\
    \    }\n    return defined($min_even) ? [$min_even, $min_even_idx] : [];\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821223
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# >>> pluck([4, 2, 3])\n# [2, 1]\n# Explanation: 2 has the\
    \ smallest even value, and 2 has the smallest index.\n# Example 2:\n# >>> pluck([1,\
    \ 2, 3])\n# [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n# Example 3:\n# >>> pluck([])\n# []\n# Example 4:\n# >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n# [0, 1]\n# Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
    # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\nsub pluck\
    \ {\n    my($arr) = @_;\n    my $min = undef;\n    my $min_index = undef;\n  \
    \  for my $i (0 .. $#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n           \
    \ if (!defined($min) || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n\
    \                $min_index = $i;\n            }\n        }\n    }\n    return\
    \ [$min, $min_index];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821224
