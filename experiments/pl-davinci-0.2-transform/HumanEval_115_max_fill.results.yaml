language: pl
name: HumanEval_115_max_fill
results:
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $col (@$row) {\n            $sum +=\
    \ $col;\n        }\n        $count += int($sum / $capacity);\n        $count +=\
    \ $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $total_fill = 0;\n    my $row_count =\
    \ scalar @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $fill_count\
    \ = 0;\n    for my $row (0..$row_count-1) {\n        my $fill_count = 0;\n   \
    \     for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col] ==\
    \ 1) {\n                $fill_count++;\n            }\n        }\n        if ($fill_count\
    \ > 0) {\n            $total_fill += int($fill_count / $capacity) + 1;\n     \
    \   }\n    }\n    return $total_fill;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $well (@$row) {\n            $sum +=\
    \ $well;\n        }\n        $count += $sum / $capacity;\n        $count += $sum\
    \ % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $row_sum = 0;\n \
    \   my $col_sum = 0;\n    for my $row (@$grid) {\n        for my $col (@$row)\
    \ {\n            $row_sum += $col;\n        }\n        $count += int($row_sum\
    \ / $capacity);\n        $row_sum = $row_sum % $capacity;\n    }\n    for my $col\
    \ (0..$col_count-1) {\n        for my $row (0..$row_count-1) {\n            $col_sum\
    \ += $grid->[$row][$col];\n        }\n        $count += int($col_sum / $capacity);\n\
    \        $col_sum = $col_sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max = 0;\n    my\
    \ $max_index = 0;\n    for my $i (0 .. $#{$grid}) {\n        for my $j (0 .. $#{$grid->[$i]})\
    \ {\n            if ($grid->[$i][$j] == 1) {\n                $count++;\n    \
    \        }\n        }\n        if ($count > $max) {\n            $max = $count;\n\
    \            $max_index = $i;\n        }\n        $count = 0;\n    }\n    my $max_fill\
    \ = $max * $capacity;\n    my $total = 0;\n    for my $i (0 .. $#{$grid}) {\n\
    \        for my $j (0 .. $#{$grid->[$i]}) {\n            if ($grid->[$i][$j] ==\
    \ 1) {\n                $total++;\n            }\n        }\n    }\n    return\
    \ $max_fill - $total;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $rows = scalar @$grid;\n\
    \    my $cols = scalar @{$grid->[0]};\n    my $max_height = 0;\n    for my $i\
    \ (0..$rows-1) {\n        for my $j (0..$cols-1) {\n            $max_height =\
    \ max($max_height, $grid->[$i][$j]);\n        }\n    }\n    for my $height (1..$max_height)\
    \ {\n        for my $i (0..$rows-1) {\n            for my $j (0..$cols-1) {\n\
    \                if ($grid->[$i][$j] >= $height) {\n                    $count++;\n\
    \                    $grid->[$i][$j] -= $capacity;\n                }\n      \
    \      }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Undefined subroutine &main::max called at /tmp/tmp25djs90h.pl line 30.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    foreach my $row (@$grid) {\n        my $height = 0;\n        foreach my $well\
    \ (@$row) {\n            $height++ if $well;\n        }\n        $max_height =\
    \ $height if $height > $max_height;\n    }\n    for (my $i = 0; $i < $max_height;\
    \ $i++) {\n        foreach my $row (@$grid) {\n            foreach my $well (@$row)\
    \ {\n                if ($well) {\n                    $well = 0;\n          \
    \          $count++;\n                }\n            }\n        }\n    }\n   \
    \ return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $well (@$row) {\n            $sum +=\
    \ $well;\n        }\n        $count += int($sum / $capacity);\n        $count\
    \ += $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $max_water = 0;\n\
    \    for my $row (0..$row_count-1) {\n        for my $col (0..$col_count-1) {\n\
    \            if ($grid->[$row][$col] == 1) {\n                $max_water = $row\
    \ if $row > $max_water;\n            }\n        }\n    }\n    for my $row (0..$max_water)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n            }\n        }\n  \
    \  }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $col (@$row) {\n            $sum +=\
    \ $col;\n        }\n        $count += int($sum / $capacity);\n        $count +=\
    \ $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    my $max_height_index = 0;\n    for my $i (0 .. $#{$grid}) {\n        my $height\
    \ = 0;\n        for my $j (0 .. $#{$grid->[$i]}) {\n            $height += $grid->[$i][$j];\n\
    \        }\n        if ($height > $max_height) {\n            $max_height = $height;\n\
    \            $max_height_index = $i;\n        }\n    }\n    for my $i (0 .. $#{$grid})\
    \ {\n        my $height = 0;\n        for my $j (0 .. $#{$grid->[$i]}) {\n   \
    \         $height += $grid->[$i][$j];\n        }\n        if ($i != $max_height_index)\
    \ {\n            $count += $max_height - $height;\n        }\n    }\n    return\
    \ $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n       \
    \ }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max = 0;\n    foreach\
    \ my $row (@$grid) {\n        my $sum = 0;\n        foreach my $well (@$row) {\n\
    \            $sum += $well;\n        }\n        $max = $sum if $sum > $max;\n\
    \    }\n    $count += $max;\n    $count += $capacity - 1;\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $row_index = 0;\n\
    \    my $col_index = 0;\n    my $row_max = 0;\n    my $col_max = 0;\n    my $row_max_index\
    \ = 0;\n    my $col_max_index = 0;\n    my $row_max_count = 0;\n    my $col_max_count\
    \ = 0;\n    my $row_max_index_count = 0;\n    my $col_max_index_count = 0;\n \
    \   my $row_max_index_count_max = 0;\n    my $col_max_index_count_max = 0;\n \
    \   my $row_max_index_count_max_index = 0;\n    my $col_max_index_count_max_index\
    \ = 0;\n    my $row_max_index_count_max_index_count = 0;\n    my $col_max_index_count_max_index_count\
    \ = 0;\n    my $row_max_index_count_max_index_count_max = 0;\n    my $col_max_index_count_max_index_count_max\
    \ = 0;\n    my $row_max_index_count_max_index_count_max_index = 0;\n    my $col_max_index_count_max_index_count_max_index\
    \ = 0;\n    my $row_max_index_count_max_index_count_max_index_count = 0;\n   \
    \ my $col_max_index_count_max_index_count_max_index_count = 0;\n    my $row_max_index_count_max_index_count_max_index_count_max\
    \ = 0;\n    my $col_max_index_count_max_index_count_max_index_count_max = 0;\n\
    \    my $row_max_index_count_max_index_count_max_index_count_max_index = 0;\n\
    \    my $col_max_index_count_max_index_count\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: '"use" not allowed in expression at /tmp/tmpn3dvpnn1.pl line 53, at end
    of line

    syntax error at /tmp/tmpn3dvpnn1.pl line 53, near "$col_max_index_count_max_index_count

    use Test::Deep"

    Missing right curly or square bracket at /tmp/tmpn3dvpnn1.pl line 80, at end of
    line

    syntax error at /tmp/tmpn3dvpnn1.pl line 80, at EOF

    Execution of /tmp/tmpn3dvpnn1.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                $grid->[$row][$col]\
    \ = 0;\n            }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $fill = 0;\n        for my $well (@$row) {\n            if ($well)\
    \ {\n                $fill++;\n            } else {\n                $count +=\
    \ $fill / $capacity;\n                $fill = 0;\n            }\n        }\n \
    \       $count += $fill / $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max = 0;\n    for\
    \ my $row (@$grid) {\n        my $sum = 0;\n        for my $col (@$row) {\n  \
    \          $sum += $col;\n        }\n        $max = $sum if $sum > $max;\n   \
    \ }\n    $count += $max;\n    $count += $capacity - 1;\n    return $count;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    foreach my $row (@$grid)\
    \ {\n        my $fill = 0;\n        foreach my $well (@$row) {\n            $fill\
    \ += $well;\n            if ($fill == $capacity) {\n                $count++;\n\
    \                $fill = 0;\n            }\n        }\n        $count += int($fill\
    \ / $capacity);\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $cell (@$row) {\n            $sum +=\
    \ $cell;\n        }\n        $count += int($sum / $capacity);\n        $count\
    \ += $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = @$grid;\n\
    \    my $col_count = @{$grid->[0]};\n    my $max_fill = $capacity * $col_count;\n\
    \    for my $row (@$grid) {\n        my $fill = 0;\n        for my $col (@$row)\
    \ {\n            $fill += $col;\n        }\n        if ($fill > $max_fill) {\n\
    \            $count += $fill - $max_fill;\n        }\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $col (@$row)\
    \ {\n            $height += $col;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $col (@$row) {\n            $height += $col;\n        }\n\
    \        $count += $max_height - $height;\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $max_fill = 0;\n    my $fill = 0;\n  \
    \  for my $row (@$grid) {\n        for my $well (@$row) {\n            if ($well)\
    \ {\n                $fill++;\n            } else {\n                $max_fill\
    \ = max($max_fill, $fill);\n                $fill = 0;\n            }\n      \
    \  }\n        $max_fill = max($max_fill, $fill);\n        $fill = 0;\n    }\n\
    \    return $max_fill * $capacity;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Undefined subroutine &main::max called at /tmp/tmpt_pb32zu.pl line 31.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $col (@$row) {\n            $sum +=\
    \ $col;\n        }\n        $count += int($sum / $capacity);\n        $count +=\
    \ $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        my $row_sum = 0;\n        for my $col (0..$col_count-1) {\n     \
    \       $row_sum += $grid->[$row][$col];\n        }\n        $count += int($row_sum\
    \ / $capacity);\n        $count += $row_sum % $capacity;\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012714
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max = 0;\n    my\
    \ $max_index = 0;\n    for my $i (0 .. $#{$grid}) {\n        for my $j (0 .. $#{$grid->[$i]})\
    \ {\n            if ($grid->[$i][$j] == 1) {\n                $count++;\n    \
    \        }\n        }\n        if ($count > $max) {\n            $max = $count;\n\
    \            $max_index = $i;\n        }\n        $count = 0;\n    }\n    my $total\
    \ = 0;\n    for my $i (0 .. $#{$grid}) {\n        for my $j (0 .. $#{$grid->[$i]})\
    \ {\n            if ($grid->[$i][$j] == 1) {\n                $total++;\n    \
    \        }\n        }\n    }\n    if ($total == 0) {\n        return 0;\n    }\n\
    \    my $result = 0;\n    my $current = 0;\n    for my $i (0 .. $#{$grid}) {\n\
    \        for my $j (0 .. $#{$grid->[$i]}) {\n            if ($grid->[$i][$j] ==\
    \ 1) {\n                $current++;\n            }\n        }\n        if ($current\
    \ == $max) {\n            $result += $max;\n            $current = 0;\n      \
    \  }\n        else {\n            $result += $current;\n            $current =\
    \ 0;\n        }\n    }\n    return $result;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                $grid->[$row][$col]\
    \ = 0;\n            }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $well (@$row) {\n            $sum +=\
    \ $well;\n        }\n        $count += $sum / $capacity;\n        $count += $sum\
    \ % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $rows = scalar @$grid;\n    my $cols =\
    \ scalar @{$grid->[0]};\n    my $max_fill = 0;\n    my $fill = 0;\n    for my\
    \ $row (@$grid) {\n        for my $col (@$row) {\n            $fill += $col;\n\
    \        }\n    }\n    $max_fill = $fill;\n    for my $row (@$grid) {\n      \
    \  for my $col (@$row) {\n            $fill -= $col;\n            $fill += $capacity;\n\
    \            $max_fill = $fill if $fill > $max_fill;\n        }\n    }\n    return\
    \ $max_fill;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $rows = scalar @$grid;\n\
    \    my $cols = scalar @{$grid->[0]};\n    my $max_row = 0;\n    my $max_col =\
    \ 0;\n    my $max_val = 0;\n    for my $row (0..$rows-1) {\n        for my $col\
    \ (0..$cols-1) {\n            if ($grid->[$row][$col] > $max_val) {\n        \
    \        $max_val = $grid->[$row][$col];\n                $max_row = $row;\n \
    \               $max_col = $col;\n            }\n        }\n    }\n    my $max_row_sum\
    \ = sum(@{$grid->[$max_row]});\n    my $max_col_sum = 0;\n    for my $row (0..$rows-1)\
    \ {\n        $max_col_sum += $grid->[$row][$max_col];\n    }\n    my $max_sum\
    \ = $max_row_sum > $max_col_sum ? $max_row_sum : $max_col_sum;\n    $count +=\
    \ $max_sum * $capacity;\n    for my $row (0..$rows-1) {\n        for my $col (0..$cols-1)\
    \ {\n            if ($row != $max_row && $col != $max_col) {\n               \
    \ $count += $grid->[$row][$col];\n            }\n        }\n    }\n    return\
    \ $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n       \
    \ }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Undefined subroutine &main::sum called at /tmp/tmp35271gmq.pl line 39.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $max_row = 0;\n \
    \   my $max_col = 0;\n    my $max_value = 0;\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ > $max_value) {\n                $max_value = $grid->[$row][$col];\n       \
    \         $max_row = $row;\n                $max_col = $col;\n            }\n\
    \        }\n    }\n    my $max_fill = $max_value * $capacity;\n    for my $row\
    \ (0..$row_count-1) {\n        for my $col (0..$col_count-1) {\n            $count\
    \ += $max_fill - $grid->[$row][$col];\n        }\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height += $well;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $well (@$row) {\n            $height += $well;\n      \
    \  }\n        $count += $max_height - $height;\n    }\n    return $count;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012714
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $times = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height += $well;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $well (@$row) {\n            $height += $well;\n      \
    \  }\n        $times += $max_height - $height;\n    }\n    return $times;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $i ($row+1..$row_count-1)\
    \ {\n                    $grid->[$i][$col] = 0;\n                }\n         \
    \   }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $i ($row+1..$row_count-1)\
    \ {\n                    if ($grid->[$i][$col] == 1) {\n                     \
    \   $count += $capacity;\n                    }\n                    else {\n\
    \                        last;\n                    }\n                }\n   \
    \         }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_water = 0;\n\
    \    for my $row (@$grid) {\n        my $water = 0;\n        for my $well (@$row)\
    \ {\n            $water += $well;\n        }\n        $max_water = $water if $water\
    \ > $max_water;\n    }\n    while ($max_water > 0) {\n        $count++;\n    \
    \    $max_water -= $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $rows = scalar @$grid;\n\
    \    my $cols = scalar @{$grid->[0]};\n    my $max_row = 0;\n    my $max_col =\
    \ 0;\n    my $max_row_count = 0;\n    my $max_col_count = 0;\n    for my $row\
    \ (0..$rows-1) {\n        my $row_count = 0;\n        for my $col (0..$cols-1)\
    \ {\n            if ($grid->[$row][$col] == 1) {\n                $row_count++;\n\
    \            }\n        }\n        if ($row_count > $max_row_count) {\n      \
    \      $max_row_count = $row_count;\n            $max_row = $row;\n        }\n\
    \    }\n    for my $col (0..$cols-1) {\n        my $col_count = 0;\n        for\
    \ my $row (0..$rows-1) {\n            if ($grid->[$row][$col] == 1) {\n      \
    \          $col_count++;\n            }\n        }\n        if ($col_count > $max_col_count)\
    \ {\n            $max_col_count = $col_count;\n            $max_col = $col;\n\
    \        }\n    }\n    if ($max_row_count > $max_col_count) {\n        for my\
    \ $col (0..$cols-1) {\n            if ($grid->[$max_row][$col] == 1) {\n     \
    \           $count++;\n            }\n        }\n    } else {\n        for my\
    \ $row (0..$rows-1) {\n            if ($grid->[$row][$max_col] == 1) {\n     \
    \           $count++;\n            }\n        }\n    }\n    return $count;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 0
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $i = 0;\n    while\
    \ ($i < scalar @$grid) {\n        my $j = 0;\n        while ($j < scalar @{$grid->[$i]})\
    \ {\n            if ($grid->[$i][$j] == 1) {\n                $count++;\n    \
    \            $j += $capacity;\n            }\n            else {\n           \
    \     $j++;\n            }\n        }\n        $i++;\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!
  timestamp: 1660012714
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $well (@$row) {\n            $sum +=\
    \ $well;\n        }\n        $count += $sum / $capacity;\n        $count += $sum\
    \ % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $row_max = 0;\n \
    \   my $col_max = 0;\n    for my $row (0..$row_count-1) {\n        for my $col\
    \ (0..$col_count-1) {\n            if ($grid->[$row][$col] == 1) {\n         \
    \       $row_max = $row if $row > $row_max;\n                $col_max = $col if\
    \ $col > $col_max;\n            }\n        }\n    }\n    for my $row (0..$row_max)\
    \ {\n        for my $col (0..$col_max) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n            }\n        }\n  \
    \  }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $i (0..$row_count-1)\
    \ {\n                    for my $j (0..$col_count-1) {\n                     \
    \   if ($grid->[$i][$j] == 1) {\n                            $grid->[$i][$j] =\
    \ 0;\n                        }\n                    }\n                }\n  \
    \          }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $col (@$row) {\n            $sum +=\
    \ $col;\n        }\n        $count += $sum / $capacity;\n        $count += 1 if\
    \ $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $water = 0;\n        for my $well (@$row) {\n            $water\
    \ += $well;\n            if ($water == $capacity) {\n                $count++;\n\
    \                $water = 0;\n            }\n        }\n        $count += int($water\
    \ / $capacity);\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                $grid->[$row][$col]\
    \ = 0;\n            }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $i ($row..$row_count-1)\
    \ {\n                    for my $j ($col..$col_count-1) {\n                  \
    \      if ($grid->[$i][$j] == 1) {\n                            $grid->[$i][$j]\
    \ = 0;\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $col (@$row)\
    \ {\n            $height += $col;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $height (1 .. $max_height) {\n   \
    \     for my $row (0 .. $row_count - 1) {\n            for my $col (0 .. $col_count\
    \ - 1) {\n                if ($grid->[$row][$col] >= $height) {\n            \
    \        $count++;\n                    $grid->[$row][$col] -= $capacity;\n  \
    \              }\n            }\n        }\n    }\n    return $count;\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n   \
    \     if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0,\
    \ 0, 0], [0, 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_row = scalar\
    \ @$grid;\n    my $max_col = scalar @{$grid->[0]};\n    for my $row (0..$max_row-1)\
    \ {\n        for my $col (0..$max_col-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $i ($row..$max_row-1)\
    \ {\n                    for my $j ($col..$max_col-1) {\n                    \
    \    $grid->[$i][$j] = 0;\n                    }\n                }\n        \
    \    }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $i ($row..$row_count-1)\
    \ {\n                    for my $j ($col..$col_count-1) {\n                  \
    \      $grid->[$i][$j] = 0;\n                    }\n                }\n      \
    \      }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: -1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $max_row = $row_count\
    \ - 1;\n    my $max_col = $col_count - 1;\n    my $row = 0;\n    my $col = 0;\n\
    \    my $direction = 'right';\n    while ($row >= 0 && $row <= $max_row && $col\
    \ >= 0 && $col <= $max_col) {\n        if ($grid->[$row][$col] == 1) {\n     \
    \       $grid->[$row][$col] = 0;\n            $count++;\n        }\n        if\
    \ ($direction eq 'right') {\n            if ($col == $max_col) {\n           \
    \     $direction = 'down';\n                $row++;\n            } else {\n  \
    \              $col++;\n            }\n        } elsif ($direction eq 'down')\
    \ {\n            if ($row == $max_row) {\n                $direction = 'left';\n\
    \                $col--;\n            } else {\n                $row++;\n    \
    \        }\n        } elsif ($direction eq 'left') {\n            if ($col ==\
    \ 0) {\n                $direction = 'up';\n                $row--;\n        \
    \    } else {\n                $col--;\n            }\n        } elsif ($direction\
    \ eq 'up') {\n            if ($row == 0) {\n                $direction = 'right';\n\
    \                $col++;\n            } else {\n                $row--;\n    \
    \        }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660012819
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $rows = scalar @$grid;\n    my $cols =\
    \ scalar @{$grid->[0]};\n    my $count = 0;\n    my $max = 0;\n    for my $row\
    \ (@$grid) {\n        for my $col (@$row) {\n            $max = $col if $col >\
    \ $max;\n        }\n    }\n    for my $i (0..$max) {\n        for my $j (0..$rows-1)\
    \ {\n            for my $k (0..$cols-1) {\n                if ($grid->[$j][$k]\
    \ > $i) {\n                    $count += $capacity;\n                }\n     \
    \       }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $row_idx = 0;\n \
    \   my $col_idx = 0;\n    while ($row_idx < $row_count) {\n        if ($grid->[$row_idx][$col_idx]\
    \ == 1) {\n            $grid->[$row_idx][$col_idx] = 0;\n            $count++;\n\
    \        }\n        $col_idx++;\n        if ($col_idx == $col_count) {\n     \
    \       $col_idx = 0;\n            $row_idx++;\n        }\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $cell (@$row)\
    \ {\n            $height += $cell;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $cell (@$row) {\n            $height += $cell;\n      \
    \  }\n        $count += $max_height - $height;\n    }\n    return $count;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $water = 0;\n        for my $well (@$row) {\n            $water\
    \ += $well;\n            if ($water == $capacity) {\n                $count++;\n\
    \                $water = 0;\n            }\n        }\n        $count += int($water\
    \ / $capacity);\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $max_row = 0;\n \
    \   my $max_col = 0;\n    for my $row (0..$row_count-1) {\n        for my $col\
    \ (0..$col_count-1) {\n            if ($grid->[$row][$col] == 1) {\n         \
    \       $max_row = $row if $row > $max_row;\n                $max_col = $col if\
    \ $col > $max_col;\n            }\n        }\n    }\n    for my $row (0..$max_row)\
    \ {\n        for my $col (0..$max_col) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n            }\n        }\n  \
    \  }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                $grid->[$row][$col]\
    \ = 0;\n            }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $rows = scalar @$grid;\n\
    \    my $cols = scalar @{$grid->[0]};\n    my $row_index = 0;\n    my $col_index\
    \ = 0;\n    while ($row_index < $rows) {\n        my $row = $grid->[$row_index];\n\
    \        my $col = $row->[$col_index];\n        if ($col == 1) {\n           \
    \ $count++;\n            $row->[$col_index] = 0;\n        }\n        $col_index++;\n\
    \        if ($col_index == $cols) {\n            $col_index = 0;\n           \
    \ $row_index++;\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $water = 0;\n        for my $unit (@$row) {\n            $water\
    \ += $unit;\n            if ($water == $capacity) {\n                $count++;\n\
    \                $water = 0;\n            }\n        }\n        $count += $water;\n\
    \    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012814
- exit_code: 0
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_row = scalar\
    \ @$grid;\n    my $max_col = scalar @{$grid->[0]};\n    for my $row (0..$max_row-1)\
    \ {\n        my $col = 0;\n        while ($col < $max_col) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                my $water = $capacity;\n                while ($water\
    \ > 0 && $col < $max_col) {\n                    $grid->[$row][$col] = 0;\n  \
    \                  $water--;\n                    $col++;\n                }\n\
    \                $count++;\n            }\n            else {\n              \
    \  $col++;\n            }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height += $well;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $well (@$row) {\n            $height += $well;\n      \
    \  }\n        $count += $max_height - $height;\n    }\n    return $count;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012714
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_row = scalar\
    \ @$grid;\n    my $max_col = scalar @{$grid->[0]};\n    for my $row (0..$max_row-1)\
    \ {\n        for my $col (0..$max_col-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $r ($row..$max_row-1)\
    \ {\n                    for my $c ($col..$max_col-1) {\n                    \
    \    if ($grid->[$r][$c] == 1) {\n                            $grid->[$r][$c]\
    \ = 0;\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $col (@$row) {\n            $sum +=\
    \ $col;\n        }\n        $count += int($sum / $capacity);\n        $count +=\
    \ $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $col (@$row) {\n            $sum +=\
    \ $col;\n        }\n        $count += $sum / $capacity;\n        $count += $sum\
    \ % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $row_index = 0;\n\
    \    my $col_index = 0;\n    my $row_max = 0;\n    my $col_max = 0;\n    while\
    \ ($row_index < $row_count) {\n        while ($col_index < $col_count) {\n   \
    \         if ($grid->[$row_index][$col_index] == 1) {\n                $count++;\n\
    \                $row_max = $row_index;\n                $col_max = $col_index;\n\
    \            }\n            $col_index++;\n        }\n        $col_index = 0;\n\
    \        $row_index++;\n    }\n    $row_index = 0;\n    $col_index = 0;\n    while\
    \ ($row_index < $row_count) {\n        while ($col_index < $col_count) {\n   \
    \         if ($grid->[$row_index][$col_index] == 1) {\n                $count\
    \ += abs($row_index - $row_max) + abs($col_index - $col_max);\n            }\n\
    \            $col_index++;\n        }\n        $col_index = 0;\n        $row_index++;\n\
    \    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row = 0;\n    my\
    \ $col = 0;\n    my $max_row = scalar @$grid;\n    my $max_col = scalar @{$grid->[0]};\n\
    \    my $max_fill = $capacity;\n    my $fill = 0;\n    while ($row < $max_row)\
    \ {\n        if ($grid->[$row][$col] == 1) {\n            $fill++;\n        }\n\
    \        if ($fill == $max_fill) {\n            $fill = 0;\n            $count++;\n\
    \        }\n        $col++;\n        if ($col == $max_col) {\n            $col\
    \ = 0;\n            $row++;\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $rows = @$grid;\n    my $cols = @{$grid->[0]};\n\
    \    my $total = 0;\n    my $count = 0;\n    for my $i (0..$rows-1) {\n      \
    \  for my $j (0..$cols-1) {\n            if ($grid->[$i][$j] == 1) {\n       \
    \         $total += $capacity;\n                $count++;\n            }\n   \
    \     }\n    }\n    return $total - $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                my $row_to_fill\
    \ = $row;\n                while ($row_to_fill > 0) {\n                    $row_to_fill--;\n\
    \                    $grid->[$row_to_fill][$col] = 1;\n                }\n   \
    \         }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $col (@$row) {\n            $sum +=\
    \ $col;\n        }\n        $count += int($sum / $capacity);\n        $count +=\
    \ $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $max_fill = 0;\n    for my $row (@$grid)\
    \ {\n        my $fill = 0;\n        for my $well (@$row) {\n            $fill\
    \ += $well;\n            if ($fill > $capacity) {\n                $max_fill++;\n\
    \                $fill = $well;\n            }\n        }\n    }\n    return $max_fill;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max = 0;\n    for\
    \ my $row (@$grid) {\n        $max = max($max, sum(@$row));\n    }\n    return\
    \ $max;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Undefined subroutine &main::sum called at /tmp/tmpr5p96748.pl line 27.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $well (@$row) {\n            $sum +=\
    \ $well;\n        }\n        $count += int($sum / $capacity);\n        $count\
    \ += $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $rows = scalar @$grid;\n    my $cols =\
    \ scalar @{$grid->[0]};\n    my $fill_count = 0;\n    my $bucket = 0;\n    for\
    \ my $row (0..$rows-1) {\n        for my $col (0..$cols-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $bucket++;\n                $fill_count++;\n      \
    \          if ($bucket == $capacity) {\n                    $bucket = 0;\n   \
    \             }\n            }\n        }\n    }\n    return $fill_count;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height += $well;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $level (1..$max_height) {\n      \
    \  my $row_count = 0;\n        for my $row (@$grid) {\n            my $well_count\
    \ = 0;\n            for my $well (@$row) {\n                $well_count += $well;\n\
    \            }\n            $row_count += int($well_count / $capacity);\n    \
    \    }\n        $count += $row_count;\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $i (0..$row_count-1)\
    \ {\n                    for my $j (0..$col_count-1) {\n                     \
    \   if ($grid->[$i][$j] == 1) {\n                            $grid->[$i][$j] =\
    \ 0;\n                        }\n                    }\n                }\n  \
    \          }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $col (@$row) {\n            $sum +=\
    \ $col;\n        }\n        $count += int($sum / $capacity);\n        $count +=\
    \ $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $col (@$row) {\n            $sum +=\
    \ $col;\n        }\n        $count += int($sum / $capacity);\n        $count +=\
    \ $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = @$grid;\n\
    \    my $col_count = @{$grid->[0]};\n    my $row_index = 0;\n    my $col_index\
    \ = 0;\n    while ($row_index < $row_count) {\n        if ($grid->[$row_index][$col_index]\
    \ == 1) {\n            $count++;\n            $grid->[$row_index][$col_index]\
    \ = 0;\n            $col_index++;\n            if ($col_index == $col_count) {\n\
    \                $col_index = 0;\n                $row_index++;\n            }\n\
    \        }\n        else {\n            $row_index++;\n        }\n    }\n    return\
    \ $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n       \
    \ }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_fill = 0;\n \
    \   my $max_fill_index = 0;\n    for my $i (0 .. $#{$grid}) {\n        my $fill\
    \ = 0;\n        for my $j (0 .. $#{$grid->[$i]}) {\n            $fill += $grid->[$i][$j];\n\
    \        }\n        if ($fill > $max_fill) {\n            $max_fill = $fill;\n\
    \            $max_fill_index = $i;\n        }\n    }\n    for my $i (0 .. $#{$grid})\
    \ {\n        my $fill = 0;\n        for my $j (0 .. $#{$grid->[$i]}) {\n     \
    \       $fill += $grid->[$i][$j];\n        }\n        if ($fill < $max_fill) {\n\
    \            $count += $max_fill - $fill;\n        }\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $i (0..$row_count-1)\
    \ {\n        for my $j (0..$col_count-1) {\n            if ($grid->[$i][$j] ==\
    \ 1) {\n                $count += $capacity;\n                for my $k (0..$i)\
    \ {\n                    for my $l (0..$j) {\n                        $grid->[$k][$l]\
    \ = 0;\n                    }\n                }\n            }\n        }\n \
    \   }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $col (@$row)\
    \ {\n            $height += $col;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $col (@$row) {\n            $height += $col;\n        }\n\
    \        $count += $max_height - $height;\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max = 0;\n    for\
    \ my $row (@$grid) {\n        my $sum = 0;\n        for my $col (@$row) {\n  \
    \          $sum += $col;\n        }\n        $max = $sum if $sum > $max;\n   \
    \ }\n    while ($max > 0) {\n        $count += $capacity;\n        $max -= $capacity;\n\
    \    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $max_fill = 0;\n    for my $row (@$grid)\
    \ {\n        my $fill = 0;\n        for my $well (@$row) {\n            $fill\
    \ += $well;\n            if ($fill > $capacity) {\n                $max_fill++;\n\
    \                $fill = $well;\n            }\n        }\n    }\n    return $max_fill;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    my $max_height_index = 0;\n    for my $i (0 .. $#{$grid}) {\n        my $height\
    \ = 0;\n        for my $j (0 .. $#{$grid->[$i]}) {\n            $height += $grid->[$i][$j];\n\
    \        }\n        if ($height > $max_height) {\n            $max_height = $height;\n\
    \            $max_height_index = $i;\n        }\n    }\n    for my $i (0 .. $#{$grid})\
    \ {\n        my $height = 0;\n        for my $j (0 .. $#{$grid->[$i]}) {\n   \
    \         $height += $grid->[$i][$j];\n        }\n        if ($i != $max_height_index)\
    \ {\n            $count += $max_height - $height;\n        }\n    }\n    return\
    \ $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n       \
    \ }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $row_max = 0;\n \
    \   my $col_max = 0;\n    for my $row (0..$row_count-1) {\n        for my $col\
    \ (0..$col_count-1) {\n            if ($grid->[$row][$col] == 1) {\n         \
    \       $row_max = $row if $row > $row_max;\n                $col_max = $col if\
    \ $col > $col_max;\n            }\n        }\n    }\n    for my $row (0..$row_max)\
    \ {\n        for my $col (0..$col_max) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n            }\n        }\n  \
    \  }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $rows = scalar @$grid;\n    my $cols =\
    \ scalar @{$grid->[0]};\n    my $count = 0;\n    for my $i (0..$rows-1) {\n  \
    \      for my $j (0..$cols-1) {\n            if ($grid->[$i][$j] == 1) {\n   \
    \             $count += $capacity;\n                for my $k (0..$rows-1) {\n\
    \                    $grid->[$k][$j] = 0;\n                }\n            }\n\
    \        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $max_fill = 0;\n    my $row_count = @$grid;\n\
    \    my $col_count = @{$grid->[0]};\n    my $row_index = 0;\n    my $col_index\
    \ = 0;\n    while ($row_index < $row_count) {\n        $col_index = 0;\n     \
    \   while ($col_index < $col_count) {\n            if ($grid->[$row_index][$col_index]\
    \ == 1) {\n                $max_fill += $capacity;\n                $col_index++;\n\
    \            } else {\n                $col_index++;\n            }\n        }\n\
    \        $row_index++;\n    }\n    return $max_fill;\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max = 0;\n    my\
    \ $max_index = 0;\n    for my $i (0 .. $#{$grid}) {\n        for my $j (0 .. $#{$grid->[$i]})\
    \ {\n            if ($grid->[$i][$j] == 1) {\n                $count++;\n    \
    \        }\n        }\n        if ($count > $max) {\n            $max = $count;\n\
    \            $max_index = $i;\n        }\n        $count = 0;\n    }\n    my $max_fill\
    \ = $max * $capacity;\n    my $total = 0;\n    for my $i (0 .. $#{$grid}) {\n\
    \        for my $j (0 .. $#{$grid->[$i]}) {\n            if ($grid->[$i][$j] ==\
    \ 1) {\n                $total++;\n            }\n        }\n    }\n    return\
    \ $max_fill - $total;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height += $well;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $i (0..$max_height) {\n        for\
    \ my $row (@$grid) {\n            for my $well (@$row) {\n                if ($well\
    \ > 0) {\n                    $well--;\n                    $count++;\n      \
    \          }\n            }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $fill = 0;\n        for my $col (@$row) {\n            $fill +=\
    \ $col;\n            if ($fill == $capacity) {\n                $count++;\n  \
    \              $fill = 0;\n            }\n        }\n        $count += int($fill\
    \ / $capacity);\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $row_height = 0;\n        for my $well\
    \ (@$row) {\n            $row_height += $well;\n        }\n        $max_height\
    \ = $row_height if $row_height > $max_height;\n    }\n    for my $row (@$grid)\
    \ {\n        my $row_height = 0;\n        for my $well (@$row) {\n           \
    \ $row_height += $well;\n        }\n        $count += $max_height - $row_height;\n\
    \    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $fill = 0;\n        for my $well (@$row) {\n            $fill\
    \ += $well;\n            if ($fill == $capacity) {\n                $count++;\n\
    \                $fill = 0;\n            }\n        }\n        $count += int($fill\
    \ / $capacity);\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $max_fill = 0;\n    my $num_rows = @$grid;\n\
    \    my $num_cols = @{$grid->[0]};\n    for my $row (0..$num_rows-1) {\n     \
    \   for my $col (0..$num_cols-1) {\n            if ($grid->[$row][$col] == 1)\
    \ {\n                $max_fill += $capacity;\n                for my $i (0..$num_rows-1)\
    \ {\n                    for my $j (0..$num_cols-1) {\n                      \
    \  if ($grid->[$i][$j] == 1) {\n                            $max_fill -= abs($i\
    \ - $row) + abs($j - $col);\n                        }\n                    }\n\
    \                }\n            }\n        }\n    }\n    return $max_fill;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                $grid->[$row][$col]\
    \ = 0;\n            }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $max_row = 0;\n \
    \   my $max_col = 0;\n    my $max_val = 0;\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ > $max_val) {\n                $max_val = $grid->[$row][$col];\n           \
    \     $max_row = $row;\n                $max_col = $col;\n            }\n    \
    \    }\n    }\n    for my $row (0..$row_count-1) {\n        for my $col (0..$col_count-1)\
    \ {\n            if ($grid->[$row][$col] == 1) {\n                $count += $capacity;\n\
    \            }\n        }\n    }\n    $count -= $capacity * $max_val;\n    return\
    \ $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n       \
    \ }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $num_rows = @$grid;\n    my $num_cols\
    \ = @{$grid->[0]};\n    my $num_buckets = 0;\n    my $num_wells = 0;\n    my $num_units\
    \ = 0;\n    for my $row (@$grid) {\n        for my $col (@$row) {\n          \
    \  $num_wells++ if $col;\n            $num_units += $col;\n        }\n    }\n\
    \    $num_buckets = int($num_units / $capacity);\n    $num_buckets++ if $num_units\
    \ % $capacity;\n    return $num_buckets * $num_wells;\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $i ($row..$row_count-1)\
    \ {\n                    for my $j ($col..$col_count-1) {\n                  \
    \      $grid->[$i][$j] = 0;\n                    }\n                }\n      \
    \      }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height++ if $well;\n        }\n        $max_height = $height\
    \ if $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $well (@$row) {\n            $height++ if $well;\n    \
    \    }\n        $count += $max_height - $height;\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $col (@$row)\
    \ {\n            $height += $col;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $col (@$row) {\n            $height += $col;\n        }\n\
    \        $count += $max_height - $height;\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $well (@$row) {\n            $sum +=\
    \ $well;\n        }\n        $count += int($sum / $capacity);\n        $count\
    \ += $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $rows = scalar @$grid;\n    my $cols =\
    \ scalar @{$grid->[0]};\n    my $max_water = 0;\n    for my $row (0..$rows-1)\
    \ {\n        for my $col (0..$cols-1) {\n            $max_water += $grid->[$row][$col];\n\
    \        }\n    }\n    my $buckets = int($max_water / $capacity);\n    my $remainder\
    \ = $max_water % $capacity;\n    return $buckets + ($remainder > 0 ? 1 : 0);\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012814
- exit_code: 0
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $col (@$row) {\n            $sum +=\
    \ $col;\n        }\n        $count += int($sum / $capacity);\n        $count +=\
    \ 1 if $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!
  timestamp: 1660012714
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $i ($row..$row_count-1)\
    \ {\n                    for my $j ($col..$col_count-1) {\n                  \
    \      $grid->[$i][$j] = 0;\n                    }\n                }\n      \
    \      }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $fill = 0;\n    my $max = 0;\n    for\
    \ my $row (@$grid) {\n        for my $well (@$row) {\n            $max += $well;\n\
    \        }\n    }\n    while ($fill < $max) {\n        $fill += $capacity;\n \
    \       for my $row (@$grid) {\n            for my $well (@$row) {\n         \
    \       if ($well) {\n                    $well--;\n                }\n      \
    \      }\n        }\n    }\n    return $fill;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max = 0;\n    for\
    \ my $row (@$grid) {\n        my $sum = 0;\n        for my $col (@$row) {\n  \
    \          $sum += $col;\n        }\n        $max = $sum if $sum > $max;\n   \
    \ }\n    $count += $max;\n    $count += $capacity - 1;\n    return $count;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $i (0..$row_count-1)\
    \ {\n        for my $j (0..$col_count-1) {\n            if ($grid->[$i][$j] ==\
    \ 1) {\n                $count += $capacity;\n                my $row_remaining\
    \ = $row_count - $i - 1;\n                my $col_remaining = $col_count - $j\
    \ - 1;\n                $count += $row_remaining if $row_remaining < $capacity;\n\
    \                $count += $col_remaining if $col_remaining < $capacity;\n   \
    \         }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $num_rows = scalar @$grid;\n    my $num_cols\
    \ = scalar @{$grid->[0]};\n    my $num_fill = 0;\n    my $row_idx = 0;\n    my\
    \ $col_idx = 0;\n    my $row_fill = 0;\n    my $col_fill = 0;\n    while ($row_idx\
    \ < $num_rows) {\n        $row_fill = 0;\n        $col_idx = 0;\n        while\
    \ ($col_idx < $num_cols) {\n            if ($grid->[$row_idx][$col_idx] == 1)\
    \ {\n                $row_fill += 1;\n            }\n            $col_idx += 1;\n\
    \        }\n        $num_fill += int($row_fill / $capacity);\n        $num_fill\
    \ += $row_fill % $capacity;\n        $row_idx += 1;\n    }\n    return $num_fill;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $n = @$grid;\n    my $m = @{$grid->[0]};\n\
    \    my $count = 0;\n    for my $i (0..$n-1) {\n        my $sum = 0;\n       \
    \ for my $j (0..$m-1) {\n            $sum += $grid->[$i][$j];\n        }\n   \
    \     $count += $sum / $capacity;\n        $count += $sum % $capacity;\n    }\n\
    \    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $cell (@$row) {\n            $sum +=\
    \ $cell;\n        }\n        $count += int($sum / $capacity);\n        $count\
    \ += $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height += $well;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $well (@$row) {\n            $height += $well;\n      \
    \  }\n        $count += $max_height - $height;\n    }\n    return $count;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012714
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height += $well;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $well (@$row) {\n            $height += $well;\n      \
    \  }\n        $count += $max_height - $height;\n    }\n    return $count;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012714
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $col (@$row) {\n            $sum +=\
    \ $col;\n        }\n        $count += $sum / $capacity;\n        $count += $sum\
    \ % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $cell (@$row)\
    \ {\n            if ($cell) {\n                $height++;\n            }\n   \
    \         else {\n                $count += $height;\n                $height\
    \ = 0;\n            }\n        }\n        $count += $height;\n        $max_height\
    \ = $height if $height > $max_height;\n    }\n    return $count - $max_height\
    \ * $capacity;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $fill = 0;\n        for my $well (@$row) {\n            $fill\
    \ += $well;\n            if ($fill == $capacity) {\n                $count++;\n\
    \                $fill = 0;\n            }\n        }\n        $count += int($fill\
    \ / $capacity);\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height += $well;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $level (1..$max_height) {\n      \
    \  for my $row (@$grid) {\n            my $height = 0;\n            for my $well\
    \ (@$row) {\n                $height += $well;\n                if ($height >=\
    \ $level) {\n                    $count++;\n                    last;\n      \
    \          }\n            }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    foreach my $row (@$grid) {\n        my $height = 0;\n        foreach my $col\
    \ (@$row) {\n            $height++ if $col;\n        }\n        $max_height =\
    \ $height if $height > $max_height;\n    }\n    for my $i (0..$max_height) {\n\
    \        for my $j (0..$#$grid) {\n            for my $k (0..$#$row) {\n     \
    \           if ($grid->[$j][$k]) {\n                    $grid->[$j][$k] = 0;\n\
    \                    $count++;\n                }\n            }\n        }\n\
    \    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max = 0;\n    my\
    \ $max_index = 0;\n    for my $i (0 .. $#{$grid}) {\n        for my $j (0 .. $#{$grid->[$i]})\
    \ {\n            if ($grid->[$i][$j] == 1) {\n                $count++;\n    \
    \        }\n        }\n        if ($count > $max) {\n            $max = $count;\n\
    \            $max_index = $i;\n        }\n        $count = 0;\n    }\n    my $total\
    \ = 0;\n    for my $i (0 .. $#{$grid}) {\n        for my $j (0 .. $#{$grid->[$i]})\
    \ {\n            if ($grid->[$i][$j] == 1) {\n                $total++;\n    \
    \        }\n        }\n    }\n    my $diff = $total - $max;\n    my $times = int($diff\
    \ / $capacity);\n    if ($diff % $capacity != 0) {\n        $times++;\n    }\n\
    \    return $times;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $well (@$row) {\n            $sum +=\
    \ $well;\n        }\n        $count += int($sum / $capacity);\n        $count\
    \ += $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $i (0..$row_count-1)\
    \ {\n        for my $j (0..$col_count-1) {\n            if ($grid->[$i][$j] ==\
    \ 1) {\n                $count += $capacity;\n                for my $k (0..$i)\
    \ {\n                    for my $l (0..$j) {\n                        $grid->[$k][$l]\
    \ = 0;\n                    }\n                }\n            }\n        }\n \
    \   }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_fill = 0;\n \
    \   my $max_fill_index = 0;\n    my $max_fill_count = 0;\n    my $max_fill_count_index\
    \ = 0;\n    my $max_fill_count_index_count = 0;\n    my $max_fill_count_index_count_index\
    \ = 0;\n    my $max_fill_count_index_count_index_count = 0;\n    my $max_fill_count_index_count_index_count_index\
    \ = 0;\n    my $max_fill_count_index_count_index_count_index_count = 0;\n    my\
    \ $max_fill_count_index_count_index_count_index_count_index = 0;\n    my $max_fill_count_index_count_index_count_index_count_index_count\
    \ = 0;\n    my $max_fill_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n    my $max_fill_count_index_count_index_count_index_count_index_count_index_count\
    \ = 0;\n    my $max_fill_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n    my $max_fill_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = 0;\n    my $max_fill_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n    my $max_fill_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = 0;\n    my $max_fill_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n    my $max_fill_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = 0;\n    my $max_\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: '"use" not allowed in expression at /tmp/tmpsxp3_kdb.pl line 45, at end
    of line

    syntax error at /tmp/tmpsxp3_kdb.pl line 45, near "$max_

    use Test::Deep"

    Missing right curly or square bracket at /tmp/tmpsxp3_kdb.pl line 72, at end of
    line

    syntax error at /tmp/tmpsxp3_kdb.pl line 72, at EOF

    Execution of /tmp/tmpsxp3_kdb.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $max_row = 0;\n \
    \   my $max_col = 0;\n    for my $row (0..$row_count-1) {\n        for my $col\
    \ (0..$col_count-1) {\n            if ($grid->[$row][$col] == 1) {\n         \
    \       $max_row = $row if $row > $max_row;\n                $max_col = $col if\
    \ $col > $max_col;\n            }\n        }\n    }\n    my $max_row_count = $max_row\
    \ + 1;\n    my $max_col_count = $max_col + 1;\n    for my $row (0..$max_row_count-1)\
    \ {\n        for my $col (0..$max_col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n            }\n        }\n  \
    \  }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $n = @$grid;\n    my $m = @{$grid->[0]};\n\
    \    my $count = 0;\n    for my $i (0..$n-1) {\n        for my $j (0..$m-1) {\n\
    \            if ($grid->[$i][$j] == 1) {\n                $count += $capacity;\n\
    \                for my $k ($i..$n-1) {\n                    $grid->[$k][$j] =\
    \ 0;\n                }\n            }\n        }\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                $grid->[$row][$col]\
    \ = 0;\n            }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $i (0..$row_count-1)\
    \ {\n                    for my $j (0..$col_count-1) {\n                     \
    \   if ($grid->[$i][$j] == 1) {\n                            $grid->[$i][$j] =\
    \ 0;\n                        }\n                    }\n                }\n  \
    \          }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $fill = 0;\n        for my $well (@$row) {\n            $fill\
    \ += $well;\n            if ($fill == $capacity) {\n                $count++;\n\
    \                $fill = 0;\n            }\n        }\n        $count += int($fill\
    \ / $capacity);\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $row_idx = 0;\n \
    \   my $col_idx = 0;\n    my $row_max = 0;\n    my $col_max = 0;\n    my $row_max_idx\
    \ = 0;\n    my $col_max_idx = 0;\n    my $row_max_count = 0;\n    my $col_max_count\
    \ = 0;\n    my $row_max_count_idx = 0;\n    my $col_max_count_idx = 0;\n    my\
    \ $row_max_count_idx_prev = 0;\n    my $col_max_count_idx_prev = 0;\n    my $row_max_count_prev\
    \ = 0;\n    my $col_max_count_prev = 0;\n    my $row_max_idx_prev = 0;\n    my\
    \ $col_max_idx_prev = 0;\n    my $row_max_prev = 0;\n    my $col_max_prev = 0;\n\
    \    my $row_idx_prev = 0;\n    my $col_idx_prev = 0;\n    my $row_count_prev\
    \ = 0;\n    my $col_count_prev = 0;\n    my $row_count_idx = 0;\n    my $col_count_idx\
    \ = 0;\n    my $row_count_idx_prev = 0;\n    my $col_count_idx_prev = 0;\n   \
    \ my $row_count_idx_prev_prev = 0;\n    my $col_count_idx_prev_prev = 0;\n   \
    \ my $row_count_idx_prev_prev_prev = 0;\n    my $col_count_idx_prev_prev_prev\
    \ = 0;\n    my $row_count_idx_prev_prev_prev_prev = 0;\n    my $col_count_idx_prev_prev_prev_prev\
    \ = 0;\n    my $row_count_idx_prev_\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1,\
    \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0,\
    \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: '"use" not allowed in expression at /tmp/tmpxg3z0ef8.pl line 60, at end
    of line

    syntax error at /tmp/tmpxg3z0ef8.pl line 60, near "$row_count_idx_prev_

    use Test::Deep"

    Missing right curly or square bracket at /tmp/tmpxg3z0ef8.pl line 87, at end of
    line

    syntax error at /tmp/tmpxg3z0ef8.pl line 87, at EOF

    Execution of /tmp/tmpxg3z0ef8.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $row_index = 0;\n\
    \    my $col_index = 0;\n    my $row_max = 0;\n    my $col_max = 0;\n    my $row_sum\
    \ = 0;\n    my $col_sum = 0;\n    my $row_max_index = 0;\n    my $col_max_index\
    \ = 0;\n    my $row_max_sum = 0;\n    my $col_max_sum = 0;\n    my $row_max_count\
    \ = 0;\n    my $col_max_count = 0;\n    my $row_max_index_count = 0;\n    my $col_max_index_count\
    \ = 0;\n    my $row_max_sum_count = 0;\n    my $col_max_sum_count = 0;\n    my\
    \ $row_max_index_sum = 0;\n    my $col_max_index_sum = 0;\n    my $row_max_index_sum_count\
    \ = 0;\n    my $col_max_index_sum_count = 0;\n    my $row_max_index_sum_count_count\
    \ = 0;\n    my $col_max_index_sum_count_count = 0;\n    my $row_max_index_sum_count_count_count\
    \ = 0;\n    my $col_max_index_sum_count_count_count = 0;\n    my $row_max_index_sum_count_count_count_count\
    \ = 0;\n    my $col_max_index_sum_count_count_count_count = 0;\n    my $row_max_index_sum_count_count_count_count_count\
    \ = 0;\n    my $col_max_index_sum_count_count_count_count_count = 0;\n    my $row_max_index_sum_count_count_count_count_count_count\
    \ = 0;\n    my $col_max_index_sum_count_count_count_count_count_count = 0;\n \
    \   my\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'No such class use at /tmp/tmppkolcsgk.pl line 58, near "my

    use"

    syntax error at /tmp/tmppkolcsgk.pl line 58, near "my

    use Test::Deep"

    Missing right curly or square bracket at /tmp/tmppkolcsgk.pl line 85, at end of
    line

    syntax error at /tmp/tmppkolcsgk.pl line 85, at EOF

    Execution of /tmp/tmppkolcsgk.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 0
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $rows = scalar @$grid;\n    my $cols =\
    \ scalar @{$grid->[0]};\n    my $count = 0;\n    for my $row (0..$rows-1) {\n\
    \        my $row_count = 0;\n        for my $col (0..$cols-1) {\n            if\
    \ ($grid->[$row][$col] == 1) {\n                $row_count++;\n            }\n\
    \        }\n        $count += int($row_count / $capacity);\n        if ($row_count\
    \ % $capacity) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_fill = 0;\n \
    \   my $max_fill_index = 0;\n    for my $i (0 .. $#{$grid}) {\n        for my\
    \ $j (0 .. $#{$grid->[$i]}) {\n            if ($grid->[$i][$j] == 1) {\n     \
    \           $count++;\n            }\n        }\n        if ($count > $max_fill)\
    \ {\n            $max_fill = $count;\n            $max_fill_index = $i;\n    \
    \    }\n        $count = 0;\n    }\n    return $max_fill * $capacity;\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n   \
    \     if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0,\
    \ 0, 0], [0, 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                $grid->[$row][$col]\
    \ = 0;\n            }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height += $well;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $level (1..$max_height) {\n      \
    \  for my $row (@$grid) {\n            for my $well (@$row) {\n              \
    \  if ($well > 0) {\n                    $well--;\n                    $count++;\n\
    \                }\n            }\n        }\n    }\n    return $count;\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n   \
    \     if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0,\
    \ 0, 0], [0, 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $max_fill = 0;\n    my $max_fill_count\
    \ = 0;\n    my $max_fill_row = 0;\n    my $max_fill_col = 0;\n    my $max_fill_row_count\
    \ = 0;\n    my $max_fill_col_count = 0;\n    my $max_fill_row_col_count = 0;\n\
    \    my $max_fill_row_col_count_count = 0;\n    my $max_fill_row_col_count_row\
    \ = 0;\n    my $max_fill_row_col_count_col = 0;\n    my $max_fill_row_col_count_row_count\
    \ = 0;\n    my $max_fill_row_col_count_col_count = 0;\n    my $max_fill_row_col_count_row_col_count\
    \ = 0;\n    my $max_fill_row_col_count_row_col_count_count = 0;\n    my $max_fill_row_col_count_row_col_count_row\
    \ = 0;\n    my $max_fill_row_col_count_row_col_count_col = 0;\n    my $max_fill_row_col_count_row_col_count_row_count\
    \ = 0;\n    my $max_fill_row_col_count_row_col_count_col_count = 0;\n    my $max_fill_row_col_count_row_col_count_row_col_count\
    \ = 0;\n    my $max_fill_row_col_count_row_col_count_row_col_count_count = 0;\n\
    \    my $max_fill_row_col_count_row_col_count_row_col_count_row = 0;\n    my $max_fill_row_col_count_row_col_count_row_col_count_col\
    \ = 0;\n    my $max_fill_row_col_count_row_col_count_row_col_count_row_count =\
    \ 0;\n    my $max_fill_row_col_count_row_col_count_row_col_count_col_count = 0;\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpxk2ekdyc.pl line 75, at
    end of line

    syntax error at /tmp/tmpxk2ekdyc.pl line 75, at EOF

    Execution of /tmp/tmpxk2ekdyc.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660012714
- exit_code: -1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $max_row = $row_count\
    \ - 1;\n    my $max_col = $col_count - 1;\n    my $row = 0;\n    my $col = 0;\n\
    \    my $direction = 'down';\n    while ($row >= 0 && $row <= $max_row && $col\
    \ >= 0 && $col <= $max_col) {\n        if ($grid->[$row][$col] == 1) {\n     \
    \       $grid->[$row][$col] = 0;\n            $count++;\n        }\n        if\
    \ ($direction eq 'down') {\n            if ($row == $max_row) {\n            \
    \    $direction = 'right';\n                $col++;\n            } else {\n  \
    \              $row++;\n            }\n        } elsif ($direction eq 'right')\
    \ {\n            if ($col == $max_col) {\n                $direction = 'up';\n\
    \                $row--;\n            } else {\n                $col++;\n    \
    \        }\n        } elsif ($direction eq 'up') {\n            if ($row == 0)\
    \ {\n                $direction = 'left';\n                $col--;\n         \
    \   } else {\n                $row--;\n            }\n        } elsif ($direction\
    \ eq 'left') {\n            if ($col == 0) {\n                $direction = 'down';\n\
    \                $row++;\n            } else {\n                $col--;\n    \
    \        }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660012819
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max = 0;\n    my\
    \ $max_index = 0;\n    my $max_count = 0;\n    my $max_count_index = 0;\n    for\
    \ my $i (0 .. $#{$grid}) {\n        for my $j (0 .. $#{$grid->[$i]}) {\n     \
    \       if ($grid->[$i][$j] == 1) {\n                $count++;\n            }\n\
    \        }\n        if ($count > $max) {\n            $max = $count;\n       \
    \     $max_index = $i;\n        }\n        if ($count > $max_count) {\n      \
    \      $max_count = $count;\n            $max_count_index = $i;\n        }\n \
    \       $count = 0;\n    }\n    if ($max_count > $capacity) {\n        return\
    \ $max_count_index + 1;\n    }\n    return $max_index + 1;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $well (@$row) {\n            $sum +=\
    \ $well;\n        }\n        $count += $sum / $capacity;\n        $count += $sum\
    \ % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_row = 0;\n  \
    \  my $max_col = 0;\n    my $max_val = 0;\n    my $row_count = scalar @$grid;\n\
    \    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ > $max_val) {\n                $max_val = $grid->[$row][$col];\n           \
    \     $max_row = $row;\n                $max_col = $col;\n            }\n    \
    \    }\n    }\n    for my $row (0..$row_count-1) {\n        for my $col (0..$col_count-1)\
    \ {\n            $count += $grid->[$row][$col];\n        }\n    }\n    $count\
    \ -= $max_val;\n    $count += $capacity;\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $row2\
    \ (0..$row_count-1) {\n                    for my $col2 (0..$col_count-1) {\n\
    \                        $grid->[$row2][$col2] = 0 if $grid->[$row2][$col2] ==\
    \ 1;\n                    }\n                }\n            }\n        }\n   \
    \ }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $well (@$row) {\n            $sum +=\
    \ $well;\n        }\n        $count += $sum / $capacity;\n        $count += $sum\
    \ % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $i (0..$row_count-1)\
    \ {\n                    for my $j (0..$col_count-1) {\n                     \
    \   if ($grid->[$i][$j] == 1) {\n                            $grid->[$i][$j] =\
    \ 0;\n                        }\n                    }\n                }\n  \
    \          }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $rows = @$grid;\n    my $cols = @{$grid->[0]};\n\
    \    my $max_fill = 0;\n    for my $row (0..$rows-1) {\n        for my $col (0..$cols-1)\
    \ {\n            if ($grid->[$row][$col] == 1) {\n                $max_fill +=\
    \ $capacity;\n                for my $i (0..$row) {\n                    for my\
    \ $j (0..$col) {\n                        $grid->[$i][$j] = 0;\n             \
    \       }\n                }\n            }\n        }\n    }\n    return $max_fill;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    foreach my $row (@$grid)\
    \ {\n        my $sum = 0;\n        foreach my $col (@$row) {\n            $sum\
    \ += $col;\n        }\n        $count += int($sum / $capacity);\n        $count\
    \ += $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $num_rows = scalar @$grid;\n    my $num_cols\
    \ = scalar @{$grid->[0]};\n    my $num_fill = 0;\n    for my $col (0..$num_cols-1)\
    \ {\n        my $num_water = 0;\n        for my $row (0..$num_rows-1) {\n    \
    \        $num_water += $grid->[$row][$col];\n        }\n        $num_fill += int($num_water\
    \ / $capacity);\n        $num_fill += $num_water % $capacity;\n    }\n    return\
    \ $num_fill;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $fill = 0;\n        for my $well (@$row) {\n            $fill\
    \ += $well;\n            if ($fill == $capacity) {\n                $count++;\n\
    \                $fill = 0;\n            }\n        }\n        $count += int($fill\
    \ / $capacity);\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $rows = scalar @$grid;\n    my $cols =\
    \ scalar @{$grid->[0]};\n    my $count = 0;\n    my $i = 0;\n    my $j = 0;\n\
    \    my $max_height = 0;\n    while ($i < $rows) {\n        $j = 0;\n        $max_height\
    \ = 0;\n        while ($j < $cols) {\n            if ($grid->[$i][$j] == 1) {\n\
    \                $max_height = $i + 1;\n            }\n            $j++;\n   \
    \     }\n        $count += $max_height;\n        $i++;\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $fill = 0;\n        for my $well (@$row) {\n            $fill\
    \ += $well;\n            if ($fill == $capacity) {\n                $count++;\n\
    \                $fill = 0;\n            }\n        }\n        $count += int($fill\
    \ / $capacity);\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $col (@$row)\
    \ {\n            if ($col) {\n                $height++;\n            }\n    \
    \        else {\n                $max_height = max($max_height, $height);\n  \
    \              $height = 0;\n            }\n        }\n        $max_height = max($max_height,\
    \ $height);\n    }\n    return $max_height * $capacity;\n}\nuse Test::Deep;\n\n\
    \nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Undefined subroutine &main::max called at /tmp/tmp_2w5wa6c.pl line 33.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $max_row = 0;\n \
    \   my $max_col = 0;\n    my $max_val = 0;\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ > $max_val) {\n                $max_val = $grid->[$row][$col];\n           \
    \     $max_row = $row;\n                $max_col = $col;\n            }\n    \
    \    }\n    }\n    for my $row (0..$row_count-1) {\n        for my $col (0..$col_count-1)\
    \ {\n            if ($grid->[$row][$col] > 0) {\n                $count += $capacity\
    \ - $grid->[$row][$col];\n            }\n        }\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $max_height = 0;\n\
    \    for my $row (0..$row_count-1) {\n        my $height = 0;\n        for my\
    \ $col (0..$col_count-1) {\n            $height += $grid->[$row][$col];\n    \
    \    }\n        $max_height = $height if $height > $max_height;\n    }\n    for\
    \ my $height (1..$max_height) {\n        for my $row (0..$row_count-1) {\n   \
    \         for my $col (0..$col_count-1) {\n                if ($grid->[$row][$col]\
    \ >= $height) {\n                    $count += $capacity;\n                  \
    \  $grid->[$row][$col] -= $capacity;\n                }\n            }\n     \
    \   }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1,\
    \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0,\
    \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: -1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $rows = @$grid;\n    my $cols = @{$grid->[0]};\n\
    \    my $max_fill = 0;\n    for my $row (0..$rows-1) {\n        for my $col (0..$cols-1)\
    \ {\n            if ($grid->[$row][$col] == 1) {\n                $max_fill +=\
    \ $capacity;\n                $grid->[$row][$col] = 0;\n                my $water\
    \ = $capacity;\n                while ($water > 0) {\n                    my $left\
    \ = $col - 1;\n                    my $right = $col + 1;\n                   \
    \ my $up = $row - 1;\n                    my $down = $row + 1;\n             \
    \       if ($left >= 0 && $grid->[$row][$left] == 1) {\n                     \
    \   $grid->[$row][$left] = 0;\n                        $water--;\n           \
    \         }\n                    if ($right < $cols && $grid->[$row][$right] ==\
    \ 1) {\n                        $grid->[$row][$right] = 0;\n                 \
    \       $water--;\n                    }\n                    if ($up >= 0 &&\
    \ $grid->[$up][$col] == 1) {\n                        $grid->[$up][$col] = 0;\n\
    \                        $water--;\n                    }\n                  \
    \  if ($down < $rows && $grid->[$down][$col] == 1) {\n                       \
    \ $grid->[$down][$col] = 0;\n                        $water--;\n             \
    \       }\n                }\n            }\n        }\n    }\n    return $max_fill;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660012819
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $row_count = scalar @$grid;\n    my $col_count\
    \ = scalar @{$grid->[0]};\n    my $count = 0;\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $i (0..$row_count-1)\
    \ {\n                    for my $j (0..$col_count-1) {\n                     \
    \   if ($grid->[$i][$j] == 1) {\n                            $grid->[$i][$j] =\
    \ 0;\n                        }\n                    }\n                }\n  \
    \          }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 0
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $row_index = 0;\n\
    \    my $col_index = 0;\n    while ($row_index < $row_count) {\n        my $row\
    \ = $grid->[$row_index];\n        while ($col_index < $col_count) {\n        \
    \    if ($row->[$col_index] == 1) {\n                $count++;\n             \
    \   $col_index += $capacity;\n            } else {\n                $col_index++;\n\
    \            }\n        }\n        $row_index++;\n        $col_index = 0;\n  \
    \  }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $well (@$row) {\n            $sum +=\
    \ $well;\n        }\n        $count += int($sum / $capacity);\n        $count\
    \ += $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $row_index = 0;\n\
    \    my $col_index = 0;\n    my $row_max = 0;\n    my $col_max = 0;\n    my $row_sum\
    \ = 0;\n    my $col_sum = 0;\n    my $row_max_index = 0;\n    my $col_max_index\
    \ = 0;\n    my $row_max_sum = 0;\n    my $col_max_sum = 0;\n    my $row_max_index_sum\
    \ = 0;\n    my $col_max_index_sum = 0;\n    my $row_max_index_sum_max = 0;\n \
    \   my $col_max_index_sum_max = 0;\n    my $row_max_index_sum_max_index = 0;\n\
    \    my $col_max_index_sum_max_index = 0;\n    my $row_max_index_sum_max_index_sum\
    \ = 0;\n    my $col_max_index_sum_max_index_sum = 0;\n    my $row_max_index_sum_max_index_sum_max\
    \ = 0;\n    my $col_max_index_sum_max_index_sum_max = 0;\n    my $row_max_index_sum_max_index_sum_max_index\
    \ = 0;\n    my $col_max_index_sum_max_index_sum_max_index = 0;\n    my $row_max_index_sum_max_index_sum_max_index_sum\
    \ = 0;\n    my $col_max_index_sum_max_index_sum_max_index_sum = 0;\n    my $row_max_index_sum_max_index_sum_max_index_sum_max\
    \ = 0;\n    my $col_max_index_sum_max_index_sum_max_index_sum_max = 0;\n    my\
    \ $row_max_index_sum_max_index_sum_max_index_sum_max_index\nuse Test::Deep;\n\n\
    \nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: '"use" not allowed in expression at /tmp/tmpw15t0_d_.pl line 54, at end
    of line

    syntax error at /tmp/tmpw15t0_d_.pl line 54, near "$row_max_index_sum_max_index_sum_max_index_sum_max_index

    use Test::Deep"

    Missing right curly or square bracket at /tmp/tmpw15t0_d_.pl line 81, at end of
    line

    syntax error at /tmp/tmpw15t0_d_.pl line 81, at EOF

    Execution of /tmp/tmpw15t0_d_.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height += $well;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $well (@$row) {\n            $height += $well;\n      \
    \  }\n        $count += $max_height - $height;\n    }\n    return $count;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012714
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    my $max_height_index = 0;\n    for my $i (0 .. $#{$grid}) {\n        my $height\
    \ = 0;\n        for my $j (0 .. $#{$grid->[$i]}) {\n            $height += $grid->[$i][$j];\n\
    \        }\n        if ($height > $max_height) {\n            $max_height = $height;\n\
    \            $max_height_index = $i;\n        }\n    }\n    for my $i (0 .. $#{$grid})\
    \ {\n        my $height = 0;\n        for my $j (0 .. $#{$grid->[$i]}) {\n   \
    \         $height += $grid->[$i][$j];\n        }\n        if ($i == $max_height_index)\
    \ {\n            $count += $height;\n        } else {\n            $count += $max_height\
    \ - $height;\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $i ($row..$row_count-1)\
    \ {\n                    for my $j ($col..$col_count-1) {\n                  \
    \      $grid->[$i][$j] = 0;\n                    }\n                }\n      \
    \      }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $well (@$row) {\n            $sum +=\
    \ $well;\n        }\n        $count += int($sum / $capacity);\n        $count\
    \ += $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $col (@$row) {\n            $sum +=\
    \ $col;\n        }\n        $count += $sum / $capacity;\n        $count += $sum\
    \ % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $i (0..$row_count-1)\
    \ {\n                    for my $j (0..$col_count-1) {\n                     \
    \   if ($grid->[$i][$j] == 1) {\n                            $grid->[$i][$j] =\
    \ 0;\n                        }\n                    }\n                }\n  \
    \          }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $row_height = 0;\n        for my $cell\
    \ (@$row) {\n            $row_height += $cell;\n        }\n        $max_height\
    \ = $row_height if $row_height > $max_height;\n    }\n    for my $row (@$grid)\
    \ {\n        my $row_height = 0;\n        for my $cell (@$row) {\n           \
    \ $row_height += $cell;\n        }\n        $count += $max_height - $row_height;\n\
    \    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $r (0..$row_count-1)\
    \ {\n                    for my $c (0..$col_count-1) {\n                     \
    \   if ($grid->[$r][$c] == 1) {\n                            $grid->[$r][$c] =\
    \ 0;\n                        }\n                    }\n                }\n  \
    \          }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012714
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                $grid->[$row][$col]\
    \ = 0;\n            }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $col (@$row) {\n            $sum +=\
    \ $col;\n        }\n        $count += int($sum / $capacity);\n        $count +=\
    \ $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max = 0;\n    for\
    \ my $row (@$grid) {\n        my $sum = 0;\n        for my $cell (@$row) {\n \
    \           $sum += $cell;\n        }\n        $max = $sum if $sum > $max;\n \
    \   }\n    $count += $max;\n    $count += $capacity - 1;\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $fill = 0;\n        for my $col (@$row) {\n            $fill +=\
    \ $col;\n            if ($fill == $capacity) {\n                $count++;\n  \
    \              $fill = 0;\n            }\n        }\n        $count += int($fill\
    \ / $capacity);\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            if ($well) {\n                $height++;\n            }\n   \
    \         else {\n                $max_height = max($max_height, $height);\n \
    \               $height = 0;\n            }\n        }\n        $max_height =\
    \ max($max_height, $height);\n    }\n    $count += $max_height / $capacity;\n\
    \    $count += $max_height % $capacity ? 1 : 0;\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Undefined subroutine &main::max called at /tmp/tmp0ro94sig.pl line 33.

    '
  stdout: ''
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $well (@$row) {\n            $sum +=\
    \ $well;\n        }\n        $count += int($sum / $capacity);\n        $count\
    \ += $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $col (@$row) {\n            $sum +=\
    \ $col;\n        }\n        $count += int($sum / $capacity);\n        $count +=\
    \ $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012713
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $row_index = 0;\n\
    \    my $col_index = 0;\n    my $row_index_max = $row_count - 1;\n    my $col_index_max\
    \ = $col_count - 1;\n    my $row_index_min = 0;\n    my $col_index_min = 0;\n\
    \    my $row_index_next = 0;\n    my $col_index_next = 0;\n    my $row_index_prev\
    \ = 0;\n    my $col_index_prev = 0;\n    my $row_index_next_max = 0;\n    my $col_index_next_max\
    \ = 0;\n    my $row_index_prev_max = 0;\n    my $col_index_prev_max = 0;\n   \
    \ my $row_index_next_min = 0;\n    my $col_index_next_min = 0;\n    my $row_index_prev_min\
    \ = 0;\n    my $col_index_prev_min = 0;\n    my $row_index_next_max_prev = 0;\n\
    \    my $col_index_next_max_prev = 0;\n    my $row_index_prev_max_prev = 0;\n\
    \    my $col_index_prev_max_prev = 0;\n    my $row_index_next_min_prev = 0;\n\
    \    my $col_index_next_min_prev = 0;\n    my $row_index_prev_min_prev = 0;\n\
    \    my $col_index_prev_min_prev = 0;\n    my $row_index_next_max_next = 0;\n\
    \    my $col_index_next_max_next = 0;\n    my $row_index_prev_max_next = 0;\n\
    \    my $col_index_prev_max_next = 0;\n    my $row_index_next_min_next = 0;\n\
    \    my $col_index_next_min_next = 0;\n    my $row_index_prev\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: '"use" not allowed in expression at /tmp/tmpn0hyvjih.pl line 60, at end
    of line

    syntax error at /tmp/tmpn0hyvjih.pl line 60, near "$row_index_prev

    use Test::Deep"

    Missing right curly or square bracket at /tmp/tmpn0hyvjih.pl line 87, at end of
    line

    syntax error at /tmp/tmpn0hyvjih.pl line 87, at EOF

    Execution of /tmp/tmpn0hyvjih.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 0
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $sum = 0;\n        for my $col (@$row) {\n            $sum +=\
    \ $col;\n        }\n        $count += int($sum / $capacity);\n        $count +=\
    \ 1 if $sum % $capacity;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!
  timestamp: 1660012714
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height += $well;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $well (@$row) {\n            $height += $well;\n      \
    \  }\n        $count += $max_height - $height;\n    }\n    return $count;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012714
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $rows = scalar @$grid;\n    my $cols =\
    \ scalar @{$grid->[0]};\n    my $water = 0;\n    for my $i (0..$rows-1) {\n  \
    \      for my $j (0..$cols-1) {\n            $water += $grid->[$i][$j];\n    \
    \    }\n    }\n    return 0 if $water == 0;\n    my $buckets = int($water / $capacity);\n\
    \    $buckets++ if $water % $capacity;\n    return $buckets;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $rows = scalar @$grid;\n    my $cols =\
    \ scalar @{$grid->[0]};\n    my $max_fill = 0;\n    my $fill = 0;\n    my $row\
    \ = 0;\n    my $col = 0;\n    while ($row < $rows) {\n        $col = 0;\n    \
    \    while ($col < $cols) {\n            if ($grid->[$row][$col] == 1) {\n   \
    \             $fill++;\n            }\n            $col++;\n        }\n      \
    \  $row++;\n    }\n    $max_fill = $fill;\n    $row = 0;\n    while ($row < $rows)\
    \ {\n        $col = 0;\n        while ($col < $cols) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $fill--;\n            }\n            else {\n     \
    \           $fill++;\n            }\n            if ($fill > $max_fill) {\n  \
    \              $max_fill = $fill;\n            }\n            $col++;\n      \
    \  }\n        $row++;\n    }\n    return $max_fill;\n}\nuse Test::Deep;\n\n\n\
    sub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = @$grid;\n\
    \    my $col_count = @{$grid->[0]};\n    my $row_index = 0;\n    my $col_index\
    \ = 0;\n    my $row_max = 0;\n    my $col_max = 0;\n    my $row_min = 0;\n   \
    \ my $col_min = 0;\n    my $row_sum = 0;\n    my $col_sum = 0;\n    my $row_max_index\
    \ = 0;\n    my $col_max_index = 0;\n    my $row_min_index = 0;\n    my $col_min_index\
    \ = 0;\n    my $row_max_count = 0;\n    my $col_max_count = 0;\n    my $row_min_count\
    \ = 0;\n    my $col_min_count = 0;\n    my $row_max_sum = 0;\n    my $col_max_sum\
    \ = 0;\n    my $row_min_sum = 0;\n    my $col_min_sum = 0;\n    my $row_max_index_count\
    \ = 0;\n    my $col_max_index_count = 0;\n    my $row_min_index_count = 0;\n \
    \   my $col_min_index_count = 0;\n    my $row_max_index_sum = 0;\n    my $col_max_index_sum\
    \ = 0;\n    my $row_min_index_sum = 0;\n    my $col_min_index_sum = 0;\n    my\
    \ $row_max_index_count_sum = 0;\n    my $col_max_index_count_sum = 0;\n    my\
    \ $row_min_index_count_sum = 0;\n    my $col_min_index_count_sum = 0;\n    my\
    \ $row_max_index_count_sum_sum = 0;\n    my $col_max_index_count_sum_sum = 0;\n\
    \    my $row_min_index_count_sum_sum = 0;\n    my $col_min_index_count_sum_sum\
    \ = 0;\n    my\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'No such class use at /tmp/tmp0upxlg56.pl line 64, near "my

    use"

    syntax error at /tmp/tmp0upxlg56.pl line 64, near "my

    use Test::Deep"

    Missing right curly or square bracket at /tmp/tmp0upxlg56.pl line 91, at end of
    line

    syntax error at /tmp/tmp0upxlg56.pl line 91, at EOF

    Execution of /tmp/tmp0upxlg56.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height++ if $well;\n        }\n        $max_height = $height\
    \ if $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $well (@$row) {\n            $height++ if $well;\n    \
    \    }\n        $count += $max_height - $height;\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 0
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $fill = 0;\n        for my $well (@$row) {\n            $fill\
    \ += $well;\n            if ($fill >= $capacity) {\n                $count++;\n\
    \                $fill = 0;\n            }\n        }\n        $count++ if $fill\
    \ > 0;\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1,\
    \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0,\
    \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $col (@$row)\
    \ {\n            $height += $col;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $col (@$row) {\n            $height += $col;\n        }\n\
    \        $count += $max_height - $height;\n    }\n    return $count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $rows = scalar @$grid;\n\
    \    my $cols = scalar @{$grid->[0]};\n    my $row_max = 0;\n    my $col_max =\
    \ 0;\n    for my $row (0..$rows-1) {\n        for my $col (0..$cols-1) {\n   \
    \         if ($grid->[$row][$col] == 1) {\n                $row_max = $row if\
    \ $row > $row_max;\n                $col_max = $col if $col > $col_max;\n    \
    \        }\n        }\n    }\n    for my $row (0..$row_max) {\n        for my\
    \ $col (0..$col_max) {\n            if ($grid->[$row][$col] == 1) {\n        \
    \        $count += $capacity;\n            }\n        }\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height += $well;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $well (@$row) {\n            $height += $well;\n      \
    \  }\n        $count += $max_height - $height;\n    }\n    return $count;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012714
- exit_code: 0
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $row_count = scalar @$grid;\n    my $col_count\
    \ = scalar @{$grid->[0]};\n    my $fill_count = 0;\n    for my $row (0..$row_count-1)\
    \ {\n        my $water_count = 0;\n        for my $col (0..$col_count-1) {\n \
    \           if ($grid->[$row][$col] == 1) {\n                $water_count++;\n\
    \            }\n        }\n        if ($water_count > 0) {\n            $fill_count\
    \ += int($water_count / $capacity);\n            $fill_count++ if $water_count\
    \ % $capacity > 0;\n        }\n    }\n    return $fill_count;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $max_fill = 0;\n    my $max_depth = 0;\n\
    \    my $row_count = scalar @$grid;\n    my $col_count = scalar @{$grid->[0]};\n\
    \    for my $row (0..$row_count-1) {\n        for my $col (0..$col_count-1) {\n\
    \            my $depth = 0;\n            my $fill = 0;\n            my $cell =\
    \ $grid->[$row][$col];\n            if ($cell) {\n                $depth = 1;\n\
    \                $fill = $capacity;\n                if ($row > 0) {\n       \
    \             my $above = $grid->[$row-1][$col];\n                    if ($above)\
    \ {\n                        $depth = $above + 1;\n                        $fill\
    \ = $depth * $capacity;\n                    }\n                }\n          \
    \      if ($col > 0) {\n                    my $left = $grid->[$row][$col-1];\n\
    \                    if ($left) {\n                        my $left_depth = $left\
    \ + 1;\n                        my $left_fill = $left_depth * $capacity;\n   \
    \                     if ($left_fill < $fill) {\n                            $depth\
    \ = $left_depth;\n                            $fill = $left_fill;\n          \
    \              }\n                    }\n                }\n                $grid->[$row][$col]\
    \ = $depth;\n                if ($fill > $max_fill) {\n                    $max_fill\
    \ = $fill;\n                }\n                if ($depth > $max_depth) {\n  \
    \                  $max_depth = $depth;\n                }\n            }\n  \
    \      }\n    }\n    return $max_fill;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $times = 0;\n    my $rows = @$grid;\n\
    \    my $cols = @{$grid->[0]};\n    my $sum = 0;\n    for my $i (0..$rows-1) {\n\
    \        for my $j (0..$cols-1) {\n            $sum += $grid->[$i][$j];\n    \
    \    }\n    }\n    if ($sum == 0) {\n        return 0;\n    }\n    $times = $sum\
    \ / $capacity;\n    if ($sum % $capacity != 0) {\n        $times++;\n    }\n \
    \   return $times;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                for my $i (0..$row_count-1)\
    \ {\n                    for my $j (0..$col_count-1) {\n                     \
    \   if ($grid->[$i][$j] == 1) {\n                            $grid->[$i][$j] =\
    \ 0;\n                        }\n                    }\n                }\n  \
    \          }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $rows = scalar @$grid;\n    my $cols =\
    \ scalar @{$grid->[0]};\n    my $count = 0;\n    for my $row (0..$rows-1) {\n\
    \        my $water = 0;\n        for my $col (0..$cols-1) {\n            $water\
    \ += $grid->[$row][$col];\n            if ($water > $capacity) {\n           \
    \     $count += $water - $capacity;\n                $water = $capacity;\n   \
    \         }\n        }\n    }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub\
    \ testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $max = 0;\n    for my $row (@$grid) {\n\
    \        my $sum = 0;\n        for my $col (@$row) {\n            $sum += $col;\n\
    \            $sum = $capacity if $sum > $capacity;\n        }\n        $max +=\
    \ $sum;\n    }\n    return $max;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1,\
    \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n  \
    \      exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0,\
    \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    my $row_index = 0;\n\
    \    my $col_index = 0;\n    while ($row_index < $row_count) {\n        my $row\
    \ = $grid->[$row_index];\n        while ($col_index < $col_count) {\n        \
    \    if ($row->[$col_index] == 1) {\n                $count += $capacity;\n  \
    \              $col_index++;\n            } else {\n                $col_index++;\n\
    \            }\n        }\n        $row_index++;\n        $col_index = 0;\n  \
    \  }\n    return $count;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n      \
    \  exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $fill = 0;\n    my $row_count = @$grid;\n\
    \    my $col_count = @{$grid->[0]};\n    for my $row (0..$row_count-1) {\n   \
    \     for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col] ==\
    \ 1) {\n                $fill += $capacity;\n                for my $r ($row..$row_count-1)\
    \ {\n                    for my $c ($col..$col_count-1) {\n                  \
    \      $grid->[$r][$c] = 0;\n                    }\n                }\n      \
    \      }\n        }\n    }\n    return $fill;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $num_rows = @$grid;\n    my $num_cols\
    \ = @{$grid->[0]};\n    my $num_buckets = $num_rows * $num_cols;\n    my $num_drops\
    \ = 0;\n    my $bucket_level = 0;\n    my $bucket_capacity = $capacity;\n    my\
    \ $bucket_contents = 0;\n    my $bucket_row = 0;\n    my $bucket_col = 0;\n  \
    \  my $bucket_row_max = $num_rows - 1;\n    my $bucket_col_max = $num_cols - 1;\n\
    \    my $bucket_row_min = 0;\n    my $bucket_col_min = 0;\n    my $bucket_row_inc\
    \ = 1;\n    my $bucket_col_inc = 1;\n    my $bucket_row_dir = 1;\n    my $bucket_col_dir\
    \ = 1;\n    my $bucket_row_dir_change = 0;\n    my $bucket_col_dir_change = 0;\n\
    \    my $bucket_row_dir_change_count = 0;\n    my $bucket_col_dir_change_count\
    \ = 0;\n    my $bucket_row_dir_change_max = $num_rows - 1;\n    my $bucket_col_dir_change_max\
    \ = $num_cols - 1;\n    my $bucket_row_dir_change_min = 0;\n    my $bucket_col_dir_change_min\
    \ = 0;\n    my $bucket_row_dir_change_inc = 1;\n    my $bucket_col_dir_change_inc\
    \ = 1;\n    my $bucket_row_dir_change_dir = 1;\n    my $bucket_col_dir_change_dir\
    \ = 1;\n    my $bucket_row_dir_change_dir_change = 0;\n    my $bucket_col_dir_change_dir_change\
    \ = 0;\n    my $bucket_row_dir_change_dir_change_count = 0;\n    my $bucket_col_dir\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: '"use" not allowed in expression at /tmp/tmp6biwno8q.pl line 57, at end
    of line

    syntax error at /tmp/tmp6biwno8q.pl line 57, near "$bucket_col_dir

    use Test::Deep"

    Missing right curly or square bracket at /tmp/tmp6biwno8q.pl line 84, at end of
    line

    syntax error at /tmp/tmp6biwno8q.pl line 84, at EOF

    Execution of /tmp/tmp6biwno8q.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = @$grid;\n\
    \    my $col_count = @{$grid->[0]};\n    my $row_sum = 0;\n    my $col_sum = 0;\n\
    \    for my $row (0..$row_count-1) {\n        $row_sum += sum(@{$grid->[$row]});\n\
    \    }\n    for my $col (0..$col_count-1) {\n        for my $row (0..$row_count-1)\
    \ {\n            $col_sum += $grid->[$row][$col];\n        }\n    }\n    $count\
    \ += $row_sum * $capacity;\n    $count += $col_sum * $capacity;\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Undefined subroutine &main::sum called at /tmp/tmpzbdghaav.pl line 30.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max = 0;\n    for\
    \ my $row (@$grid) {\n        my $sum = 0;\n        for my $col (@$row) {\n  \
    \          $sum += $col;\n        }\n        $max = $sum if $sum > $max;\n   \
    \ }\n    $count += $max;\n    $count += $capacity - 1;\n    return $count;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012713
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height += $well;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $well (@$row) {\n            $height += $well;\n      \
    \  }\n        $count += $max_height - $height;\n    }\n    return $count;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012714
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $max_fill = 0;\n    my $max_fill_count\
    \ = 0;\n    my $max_fill_row = 0;\n    my $max_fill_col = 0;\n    my $max_fill_row_count\
    \ = 0;\n    my $max_fill_col_count = 0;\n    my $max_fill_row_col_count = 0;\n\
    \    my $max_fill_row_col_count_count = 0;\n    my $max_fill_row_col_count_row\
    \ = 0;\n    my $max_fill_row_col_count_col = 0;\n    my $max_fill_row_col_count_row_count\
    \ = 0;\n    my $max_fill_row_col_count_col_count = 0;\n    my $max_fill_row_col_count_row_col_count\
    \ = 0;\n    my $max_fill_row_col_count_row_col_count_count = 0;\n    my $max_fill_row_col_count_row_col_count_row\
    \ = 0;\n    my $max_fill_row_col_count_row_col_count_col = 0;\n    my $max_fill_row_col_count_row_col_count_row_count\
    \ = 0;\n    my $max_fill_row_col_count_row_col_count_col_count = 0;\n    my $max_fill_row_col_count_row_col_count_row_col_count\
    \ = 0;\n    my $max_fill_row_col_count_row_col_count_row_col_count_count = 0;\n\
    \    my $max_fill_row_col_count_row_col_count_row_col_count_row = 0;\n    my $max_fill_row_col_count_row_col_count_row_col_count_col\
    \ = 0;\n    my $max_fill_row_col_count_row_col_count_row_col_count_row_count =\
    \ 0;\n    my $max_fill_row_col_count_row_col_count_row_col_count_col_count = 0;\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpxk2ekdyc.pl line 75, at
    end of line

    syntax error at /tmp/tmpxk2ekdyc.pl line 75, at EOF

    Execution of /tmp/tmpxk2ekdyc.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660012714
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $row_count = scalar\
    \ @$grid;\n    my $col_count = scalar @{$grid->[0]};\n    for my $row (0..$row_count-1)\
    \ {\n        for my $col (0..$col_count-1) {\n            if ($grid->[$row][$col]\
    \ == 1) {\n                $count += $capacity;\n                my $row_offset\
    \ = $row;\n                while ($row_offset < $row_count) {\n              \
    \      $grid->[$row_offset][$col] = 0;\n                    $row_offset++;\n \
    \               }\n            }\n        }\n    }\n    return $count;\n}\nuse\
    \ Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n   \
    \     if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0,\
    \ 0, 0], [0, 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012714
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $max_fill = 0;\n    my $max_fill_count\
    \ = 0;\n    my $max_fill_row = 0;\n    my $max_fill_col = 0;\n    my $max_fill_row_count\
    \ = 0;\n    my $max_fill_col_count = 0;\n    my $max_fill_row_col_count = 0;\n\
    \    my $max_fill_row_col_count_count = 0;\n    my $max_fill_row_col_count_row\
    \ = 0;\n    my $max_fill_row_col_count_col = 0;\n    my $max_fill_row_col_count_row_count\
    \ = 0;\n    my $max_fill_row_col_count_col_count = 0;\n    my $max_fill_row_col_count_row_col_count\
    \ = 0;\n    my $max_fill_row_col_count_row_col_count_count = 0;\n    my $max_fill_row_col_count_row_col_count_row\
    \ = 0;\n    my $max_fill_row_col_count_row_col_count_col = 0;\n    my $max_fill_row_col_count_row_col_count_row_count\
    \ = 0;\n    my $max_fill_row_col_count_row_col_count_col_count = 0;\n    my $max_fill_row_col_count_row_col_count_row_col_count\
    \ = 0;\n    my $max_fill_row_col_count_row_col_count_row_col_count_count = 0;\n\
    \    my $max_fill_row_col_count_row_col_count_row_col_count_row = 0;\n    my $max_fill_row_col_count_row_col_count_row_col_count_col\
    \ = 0;\n    my $max_fill_row_col_count_row_col_count_row_col_count_row_count =\
    \ 0;\n    my $max_fill_row_col_count_row_col_count_row_col_count_col_count = 0;\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: 'Missing right curly or square bracket at /tmp/tmpxk2ekdyc.pl line 75, at
    end of line

    syntax error at /tmp/tmpxk2ekdyc.pl line 75, at EOF

    Execution of /tmp/tmpxk2ekdyc.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660012714
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $rows = scalar @$grid;\n    my $cols =\
    \ scalar @{$grid->[0]};\n    my $total = 0;\n    for my $row (0..$rows-1) {\n\
    \        my $fill = 0;\n        for my $col (0..$cols-1) {\n            $fill\
    \ += $grid->[$row][$col];\n            if ($fill > $capacity) {\n            \
    \    $total += $fill - $capacity;\n                $fill = $capacity;\n      \
    \      }\n        }\n    }\n    return $total;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $max_height = 0;\n\
    \    for my $row (@$grid) {\n        my $height = 0;\n        for my $well (@$row)\
    \ {\n            $height += $well;\n        }\n        $max_height = $height if\
    \ $height > $max_height;\n    }\n    for my $row (@$grid) {\n        my $height\
    \ = 0;\n        for my $well (@$row) {\n            $height += $well;\n      \
    \  }\n        $count += $max_height - $height;\n    }\n    return $count;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012714
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $fill = 0;\n        for my $well (@$row) {\n            if ($well)\
    \ {\n                $fill++;\n            }\n            else {\n           \
    \     $count += $fill / $capacity;\n                $fill = 0;\n            }\n\
    \        }\n        $count += $fill / $capacity;\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    my $rows = scalar @$grid;\n\
    \    my $cols = scalar @{$grid->[0]};\n    my $max_row = 0;\n    my $max_col =\
    \ 0;\n    for my $row (0..$rows-1) {\n        for my $col (0..$cols-1) {\n   \
    \         if ($grid->[$row][$col] == 1) {\n                $max_row = $row if\
    \ $row > $max_row;\n                $max_col = $col if $col > $max_col;\n    \
    \        }\n        }\n    }\n    for my $row (0..$max_row) {\n        for my\
    \ $col (0..$max_col) {\n            if ($grid->[$row][$col] == 1) {\n        \
    \        $count += $capacity;\n            }\n        }\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $max_fill = 0;\n    my $max_fill_count\
    \ = 0;\n    my $row_count = @$grid;\n    my $col_count = @{$grid->[0]};\n    for\
    \ my $i (0..$row_count-1) {\n        for my $j (0..$col_count-1) {\n         \
    \   if ($grid->[$i][$j] == 1) {\n                $max_fill += $capacity;\n   \
    \             $max_fill_count++;\n            }\n        }\n    }\n    my $min_fill\
    \ = $max_fill_count;\n    my $min_fill_count = $max_fill_count;\n    for my $i\
    \ (0..$row_count-1) {\n        for my $j (0..$col_count-1) {\n            if ($grid->[$i][$j]\
    \ == 1) {\n                $min_fill -= $capacity;\n                $min_fill_count--;\n\
    \            }\n            if ($min_fill_count == 0) {\n                return\
    \ $min_fill;\n            }\n        }\n    }\n    return $max_fill;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $count = 0;\n    for my $row (@$grid)\
    \ {\n        my $fill = 0;\n        for my $well (@$row) {\n            if ($well)\
    \ {\n                $fill++;\n            }\n            else {\n           \
    \     $count += $fill / $capacity;\n                $fill = 0;\n            }\n\
    \        }\n        $count += $fill / $capacity;\n    }\n    return $count;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!
  timestamp: 1660012814
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $num_rows = scalar @$grid;\n    my $num_cols\
    \ = scalar @{$grid->[0]};\n    my $num_fill = 0;\n    my $row_idx = 0;\n    my\
    \ $col_idx = 0;\n    my $row_max = 0;\n    my $col_max = 0;\n    my $row_sum =\
    \ 0;\n    my $col_sum = 0;\n    my $row_fill = 0;\n    my $col_fill = 0;\n   \
    \ my $row_fill_count = 0;\n    my $col_fill_count = 0;\n    my $row_fill_count_max\
    \ = 0;\n    my $col_fill_count_max = 0;\n    my $row_fill_count_sum = 0;\n   \
    \ my $col_fill_count_sum = 0;\n    my $row_fill_count_sum_max = 0;\n    my $col_fill_count_sum_max\
    \ = 0;\n    my $row_fill_count_sum_max_idx = 0;\n    my $col_fill_count_sum_max_idx\
    \ = 0;\n    my $row_fill_count_sum_max_idx_max = 0;\n    my $col_fill_count_sum_max_idx_max\
    \ = 0;\n    my $row_fill_count_sum_max_idx_max_max = 0;\n    my $col_fill_count_sum_max_idx_max_max\
    \ = 0;\n    my $row_fill_count_sum_max_idx_max_max_max = 0;\n    my $col_fill_count_sum_max_idx_max_max_max\
    \ = 0;\n    my $row_fill_count_sum_max_idx_max_max_max_max = 0;\n    my $col_fill_count_sum_max_idx_max_max_max_max\
    \ = 0;\n    my $row_fill_count_sum_max_idx_max_max_max_max_max = 0;\n    my $col_fill_count_sum_max_id\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: '"use" not allowed in expression at /tmp/tmpfkyb0yzv.pl line 55, at end
    of line

    syntax error at /tmp/tmpfkyb0yzv.pl line 55, near "$col_fill_count_sum_max_id

    use Test::Deep"

    Missing right curly or square bracket at /tmp/tmpfkyb0yzv.pl line 82, at end of
    line

    syntax error at /tmp/tmpfkyb0yzv.pl line 82, at EOF

    Execution of /tmp/tmpfkyb0yzv.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 255
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $max_fill = 0;\n    my $max_fill_row =\
    \ 0;\n    my $max_fill_col = 0;\n    my $max_fill_row_count = 0;\n    my $max_fill_col_count\
    \ = 0;\n    my $max_fill_row_count_prev = 0;\n    my $max_fill_col_count_prev\
    \ = 0;\n    my $max_fill_row_count_prev_prev = 0;\n    my $max_fill_col_count_prev_prev\
    \ = 0;\n    my $max_fill_row_count_prev_prev_prev = 0;\n    my $max_fill_col_count_prev_prev_prev\
    \ = 0;\n    my $max_fill_row_count_prev_prev_prev_prev = 0;\n    my $max_fill_col_count_prev_prev_prev_prev\
    \ = 0;\n    my $max_fill_row_count_prev_prev_prev_prev_prev = 0;\n    my $max_fill_col_count_prev_prev_prev_prev_prev\
    \ = 0;\n    my $max_fill_row_count_prev_prev_prev_prev_prev_prev = 0;\n    my\
    \ $max_fill_col_count_prev_prev_prev_prev_prev_prev = 0;\n    my $max_fill_row_count_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    my $max_fill_col_count_prev_prev_prev_prev_prev_prev_prev = 0;\n \
    \   my $max_fill_row_count_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    my\
    \ $max_fill_col_count_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    my $max_fill_row_count_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    my $max_fill_col_count_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0;\n    my $max_fill_row_count_prev_prev_prev_\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&max_fill;\n        if(eq_deeply($candidate->([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([[0, 0, 0], [0,\
    \ 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n  \
    \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: '"use" not allowed in expression at /tmp/tmp554nz94s.pl line 48, at end
    of line

    syntax error at /tmp/tmp554nz94s.pl line 48, near "$max_fill_row_count_prev_prev_prev_

    use Test::Deep"

    Missing right curly or square bracket at /tmp/tmp554nz94s.pl line 75, at end of
    line

    syntax error at /tmp/tmp554nz94s.pl line 75, at EOF

    Execution of /tmp/tmp554nz94s.pl aborted due to compilation errors.

    '
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $total = 0;\n    my $rows = scalar @$grid;\n\
    \    my $cols = scalar @{$grid->[0]};\n    my $row_max = 0;\n    my $col_max =\
    \ 0;\n    for my $row (0..$rows-1) {\n        for my $col (0..$cols-1) {\n   \
    \         if ($grid->[$row][$col] == 1) {\n                $row_max = $row if\
    \ $row > $row_max;\n                $col_max = $col if $col > $col_max;\n    \
    \        }\n        }\n    }\n    my $row_fill = 0;\n    my $col_fill = 0;\n \
    \   for my $row (0..$row_max) {\n        for my $col (0..$col_max) {\n       \
    \     if ($grid->[$row][$col] == 1) {\n                $row_fill++;\n        \
    \        $col_fill++;\n            }\n        }\n    }\n    $total += $row_fill\
    \ * $capacity;\n    $total += $col_fill * $capacity;\n    return $total;\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n \
    \       if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
- exit_code: 1
  program: "# You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well\
    \ has a corresponding bucket that can be used to extract water from it, \n# and\
    \ all buckets have the same capacity.\n# Your task is to use the buckets to empty\
    \ the wells.\n# Output the number of times you need to lower the buckets.\n# Example\
    \ 1:\n# >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n# Example\
    \ 2:\n# >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)\n# 5\n# Example 3:\n# >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n# 0\n# Constraints:\n\
    # * all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
    \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n\
    \    my($grid, $capacity) = @_;\n    my $max_fill = 0;\n    for my $row (@$grid)\
    \ {\n        my $fill = 0;\n        for my $well (@$row) {\n            $fill\
    \ += $well;\n            if ($fill > $capacity) {\n                $max_fill++;\n\
    \                $fill = $well;\n            }\n        }\n    }\n    return $max_fill;\n\
    }\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
    \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
    \ if(eq_deeply($candidate->([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2),5)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([[0, 0, 0], [0, 0, 0]], 5),0)) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], 2),4)) {\n        print \"ok!\" }else{\n        exit\
    \ 1;\n        }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ 9),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660012814
