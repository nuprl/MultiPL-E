name: HumanEval_54_same_chars
language: pl
prompt: "# Check if two words have the same characters.\n# >>> same_chars(\"eabcdzzzz\"\
  , \"dddzzzzzzzddeddabc\")\n# 1\n# >>> same_chars(\"abcd\", \"dddddddabc\")\n# 1\n\
  # >>> same_chars(\"dddddddabc\", \"abcd\")\n# 1\n# >>> same_chars(\"eabcd\", \"\
  dddddddabc\")\n# \"\"\n# >>> same_chars(\"abcd\", \"dddddddabce\")\n# \"\"\n# >>>\
  \ same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n# \"\"\nsub same_chars {\n \
  \   my($s0, $s1) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&same_chars;\n\
  \        if(eq_deeply($candidate->(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"),1)) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcd\", \"dddddddabc\"),1)) {\n        print \"ok!\" }else{\n        exit 1;\n \
  \       }\n        if(eq_deeply($candidate->(\"dddddddabc\", \"abcd\"),1)) {\n \
  \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  eabcd\", \"dddddddabc\"),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"abcd\", \"dddddddabcf\"),\"\"))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  eabcdzzzz\", \"dddzzzzzzzddddabc\"),\"\")) {\n        print \"ok!\" }else{\n   \
  \     exit 1;\n        }\n        if(eq_deeply($candidate->(\"aabb\", \"aaccc\"\
  ),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @a0 = split //, $s0;\n    my @a1 = split //, $s1;\n    my %h0;\n\
    \    my %h1;\n    for my $c (@a0) {\n        $h0{$c}++;\n    }\n    for my $c\
    \ (@a1) {\n        $h1{$c}++;\n    }\n    for my $c (keys %h0) {\n        if (!exists\
    \ $h1{$c}) {\n            return \"\";\n        }\n        if ($h0{$c} != $h1{$c})\
    \ {\n            return \"\";\n        }\n    }\n    for my $c (keys %h1) {\n\
    \        if (!exists $h0{$c}) {\n            return \"\";\n        }\n       \
    \ if ($h1{$c} != $h0{$c}) {\n            return \"\";\n        }\n    }\n    return\
    \ 1;\n}", "    my @s0 = sort split //, $s0;\n    my @s1 = sort split //, $s1;\n\
    \    my $i = 0;\n    my $j = 0;\n    while ($i < @s0 && $j < @s1) {\n        if\
    \ ($s0[$i] eq $s1[$j]) {\n            $i++;\n            $j++;\n        } elsif\
    \ ($s0[$i] lt $s1[$j]) {\n            return \"\";\n        } else {\n       \
    \     $j++;\n        }\n    }\n    return $i == @s0 ? 1 : \"\";\n}", "    my @s0\
    \ = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_ => 1 }\
    \ @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    my $ret = 1;\n    for my $c (keys\
    \ %s0) {\n        if (!$s1{$c}) {\n            $ret = \"\";\n            last;\n\
    \        }\n    }\n    for my $c (keys %s1) {\n        if (!$s0{$c}) {\n     \
    \       $ret = \"\";\n            last;\n        }\n    }\n    return $ret;\n}",
  "    my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0;\n    my %s1;\n\
    \    for (@s0) {\n        $s0{$_}++;\n    }\n    for (@s1) {\n        $s1{$_}++;\n\
    \    }\n    for (keys %s0) {\n        if ($s0{$_} != $s1{$_}) {\n            return\
    \ \"\";\n        }\n    }\n    return 1;\n}", "    my %h0 = ();\n    my %h1 =\
    \ ();\n    for my $c (split //, $s0) {\n        $h0{$c}++;\n    }\n    for my\
    \ $c (split //, $s1) {\n        $h1{$c}++;\n    }\n    for my $c (keys %h0) {\n\
    \        return \"\" if !exists $h1{$c} || $h0{$c} != $h1{$c};\n    }\n    for\
    \ my $c (keys %h1) {\n        return \"\" if !exists $h0{$c} || $h0{$c} != $h1{$c};\n\
    \    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //,\
    \ $s1;\n    my %s0;\n    my %s1;\n    for my $c (@s0) {\n        $s0{$c}++;\n\
    \    }\n    for my $c (@s1) {\n        $s1{$c}++;\n    }\n    for my $c (keys\
    \ %s0) {\n        return \"\" if $s0{$c} != $s1{$c};\n    }\n    for my $c (keys\
    \ %s1) {\n        return \"\" if $s0{$c} != $s1{$c};\n    }\n    return 1;\n}",
  "    my @a0 = split //, $s0;\n    my @a1 = split //, $s1;\n    my %h0;\n    my %h1;\n\
    \    foreach my $c (@a0) {\n        $h0{$c}++;\n    }\n    foreach my $c (@a1)\
    \ {\n        $h1{$c}++;\n    }\n    foreach my $c (keys %h0) {\n        if (!defined($h1{$c})\
    \ || $h0{$c} != $h1{$c}) {\n            return \"\";\n        }\n    }\n    foreach\
    \ my $c (keys %h1) {\n        if (!defined($h0{$c}) || $h0{$c} != $h1{$c}) {\n\
    \            return \"\";\n        }\n    }\n    return 1;\n}", "    my @s0 =\
    \ split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_ => 1 } @s0;\n\
    \    my %s1 = map { $_ => 1 } @s1;\n    my @s0_only = grep { !$s1{$_} } @s0;\n\
    \    my @s1_only = grep { !$s0{$_} } @s1;\n    return @s0_only || @s1_only ? \"\
    \" : 1;\n}", "    my @a0 = split //, $s0;\n    my @a1 = split //, $s1;\n    my\
    \ %h0;\n    my %h1;\n    for (@a0) {\n        $h0{$_}++;\n    }\n    for (@a1)\
    \ {\n        $h1{$_}++;\n    }\n    for (keys %h0) {\n        if (!exists $h1{$_}\
    \ || $h0{$_} != $h1{$_}) {\n            return \"\";\n        }\n    }\n    return\
    \ 1;\n}", "    return \"\" if length($s0) != length($s1);\n    my %c0 = map {\
    \ $_ => 1 } split(//, $s0);\n    my %c1 = map { $_ => 1 } split(//, $s1);\n  \
    \  for my $c (keys %c0) {\n        return \"\" if !exists $c1{$c};\n    }\n  \
    \  return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n\
    \    my %s0;\n    my %s1;\n    for my $c (@s0) {\n        $s0{$c}++;\n    }\n\
    \    for my $c (@s1) {\n        $s1{$c}++;\n    }\n    for my $c (keys %s0) {\n\
    \        return \"\" if !exists $s1{$c} || $s0{$c} != $s1{$c};\n    }\n    for\
    \ my $c (keys %s1) {\n        return \"\" if !exists $s0{$c} || $s0{$c} != $s1{$c};\n\
    \    }\n    return 1;\n}", "    my @s0 = split(//, $s0);\n    my @s1 = split(//,\
    \ $s1);\n    my %s0 = ();\n    my %s1 = ();\n    foreach my $c (@s0) {\n     \
    \   $s0{$c}++;\n    }\n    foreach my $c (@s1) {\n        $s1{$c}++;\n    }\n\
    \    foreach my $c (keys %s0) {\n        if ($s0{$c} != $s1{$c}) {\n         \
    \   return \"\";\n        }\n    }\n    return 1;\n}", "    my %h0 = map { $_\
    \ => 1 } split //, $s0;\n    my %h1 = map { $_ => 1 } split //, $s1;\n    for\
    \ (keys %h0) {\n        return \"\" if !exists $h1{$_};\n    }\n    for (keys\
    \ %h1) {\n        return \"\" if !exists $h0{$_};\n    }\n    return 1;\n}", " \
    \   my @s0 = split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0 = map { $_\
    \ => 1 } @s0;\n    my %s1 = map { $_ => 1 } @s1;\n    my @s0_only = grep { !$s1{$_}\
    \ } @s0;\n    my @s1_only = grep { !$s0{$_} } @s1;\n    return @s0_only == 0 &&\
    \ @s1_only == 0 ? 1 : \"\";\n}", "    my @a0 = split(//, $s0);\n    my @a1 = split(//,\
    \ $s1);\n    my @a;\n    my $i;\n    my $j;\n    my $found;\n    my $result =\
    \ 1;\n    for ($i = 0; $i <= $#a0; $i++) {\n        $found = 0;\n        for ($j\
    \ = 0; $j <= $#a1; $j++) {\n            if ($a0[$i] eq $a1[$j]) {\n          \
    \      $found = 1;\n                splice(@a1, $j, 1);\n                last;\n\
    \            }\n        }\n        if (!$found) {\n            $result = \"\"\
    ;\n            last;\n        }\n    }\n    return $result;\n}", "    my @s0 =\
    \ split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0;\n    my %s1;\n    for\
    \ my $c (@s0) {\n        $s0{$c}++;\n    }\n    for my $c (@s1) {\n        $s1{$c}++;\n\
    \    }\n    for my $c (keys %s0) {\n        if ($s0{$c} != $s1{$c}) {\n      \
    \      return \"\";\n        }\n    }\n    return 1;\n}", "    my %c0;\n    for\
    \ my $c (split //, $s0) {\n        $c0{$c}++;\n    }\n    my %c1;\n    for my\
    \ $c (split //, $s1) {\n        $c1{$c}++;\n    }\n    for my $c (keys %c0) {\n\
    \        if (!exists $c1{$c} || $c0{$c} != $c1{$c}) {\n            return \"\"\
    ;\n        }\n    }\n    return 1;\n}", "    my @s0 = split //, $s0;\n    my @s1\
    \ = split //, $s1;\n    my %s0;\n    my %s1;\n    for my $c (@s0) {\n        $s0{$c}++;\n\
    \    }\n    for my $c (@s1) {\n        $s1{$c}++;\n    }\n    for my $c (keys\
    \ %s0) {\n        return \"\" if $s0{$c} != $s1{$c};\n    }\n    for my $c (keys\
    \ %s1) {\n        return \"\" if $s0{$c} != $s1{$c};\n    }\n    return 1;\n}",
  "    my @a0 = split(//, $s0);\n    my @a1 = split(//, $s1);\n    my %h0;\n    my\
    \ %h1;\n    for my $c (@a0) {\n        $h0{$c}++;\n    }\n    for my $c (@a1)\
    \ {\n        $h1{$c}++;\n    }\n    for my $c (keys %h0) {\n        if (!defined($h1{$c})\
    \ || $h0{$c} != $h1{$c}) {\n            return \"\";\n        }\n    }\n    for\
    \ my $c (keys %h1) {\n        if (!defined($h0{$c}) || $h0{$c} != $h1{$c}) {\n\
    \            return \"\";\n        }\n    }\n    return 1;\n}", "    my @s0 =\
    \ split //, $s0;\n    my @s1 = split //, $s1;\n    my %s0;\n    my %s1;\n    for\
    \ my $c (@s0) {\n        $s0{$c}++;\n    }\n    for my $c (@s1) {\n        $s1{$c}++;\n\
    \    }\n    for my $c (keys %s0) {\n        return \"\" if $s0{$c} != $s1{$c};\n\
    \    }\n    for my $c (keys %s1) {\n        return \"\" if $s0{$c} != $s1{$c};\n\
    \    }\n    return 1;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
