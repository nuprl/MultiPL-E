name: HumanEval_112_reverse_delete
language: pl
prompt: "# Task\n# We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n# then check if the result string is\
  \ palindrome.\n# A string is called palindrome if it reads the same backward as\
  \ forward.\n# You should return a tuple containing the result string and True/False\
  \ for the check.\n# Example\n# >>> reverse_delete(\"abcde\", \"ae\")\n# [\"bcd\"\
  , \"\"]\n# >>> reverse_delete(\"abcdef\", \"b\")\n# [\"acdef\", \"\"]\n# >>> reverse_delete(\"\
  abcdedcba\", \"ab\")\n# [\"cdedc\", 1]\nsub reverse_delete {\n    my($s, $c) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&reverse_delete;\n\
  \        if(eq_deeply($candidate->(\"abcde\", \"ae\"),[\"bcd\", \"\"])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdef\", \"b\"),[\"acdef\", \"\"])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"ab\"),[\"cdedc\"\
  , 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  dwik\", \"w\"),[\"dik\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"a\", \"a\"),[\"\", 1])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdedcba\", \"\"),[\"abcdedcba\", 1])) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"v\"),[\"\
  abcdedcba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"vabba\", \"v\"),[\"abba\", 1])) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  mamma\", \"mia\"),[\"\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map\
    \ { $_ => 1 } @c;\n    my @result = grep { !$c{$_} } @s;\n    my $result = join\
    \ '', @result;\n    my $palindrome = $result eq reverse $result;\n    return [$result,\
    \ $palindrome];\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join\
    \ '', grep { !$c{$_} } split //, $s;\n    return [$r, $r eq reverse $r];\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n}",
  "    my $r = reverse $s;\n    my $p = $s eq $r ? 1 : 0;\n    $s =~ s/[$c]//g;\n\
    \    $r = reverse $s;\n    $p = $s eq $r ? 1 : 0;\n    return [$s, $p];\n}", " \
    \   my $result = \"\";\n    my $is_palindrome = 1;\n    my %c_hash = map { $_\
    \ => 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!$c_hash{$char})\
    \ {\n            $result .= $char;\n        }\n    }\n    my $i = 0;\n    my $j\
    \ = length($result) - 1;\n    while ($i < $j) {\n        if (substr($result, $i,\
    \ 1) ne substr($result, $j, 1)) {\n            $is_palindrome = 0;\n         \
    \   last;\n        }\n        $i++;\n        $j--;\n    }\n    return [$result,\
    \ $is_palindrome];\n}", "    my @s = split //, $s;\n    my @c = split //, $c;\n\
    \    my @result;\n    my $flag = 0;\n    for my $i (0..$#s) {\n        for my\
    \ $j (0..$#c) {\n            if ($s[$i] eq $c[$j]) {\n                $flag =\
    \ 1;\n                last;\n            }\n        }\n        if ($flag == 0)\
    \ {\n            push @result, $s[$i];\n        }\n        $flag = 0;\n    }\n\
    \    my $result = join \"\", @result;\n    my $palindrome = 0;\n    if ($result\
    \ eq reverse $result) {\n        $palindrome = 1;\n    }\n    return [$result,\
    \ $palindrome];\n}", "    my @s = split //, $s;\n    my @c = split //, $c;\n \
    \   my @result;\n    foreach my $i (@s) {\n        my $flag = 0;\n        foreach\
    \ my $j (@c) {\n            if ($i eq $j) {\n                $flag = 1;\n    \
    \        }\n        }\n        if ($flag == 0) {\n            push @result, $i;\n\
    \        }\n    }\n    my $result = join \"\", @result;\n    my $palindrome =\
    \ 0;\n    if ($result eq reverse $result) {\n        $palindrome = 1;\n    }\n\
    \    return [$result, $palindrome];\n}", "    my @s = split //, $s;\n    my @c\
    \ = split //, $c;\n    my %c = map { $_ => 1 } @c;\n    my @r;\n    for my $i\
    \ (0 .. $#s) {\n        push @r, $s[$i] unless $c{$s[$i]};\n    }\n    my $r =\
    \ join '', @r;\n    my $p = $r eq reverse $r;\n    return [$r, $p];\n}", "   \
    \ my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash = map {$_ => 1}\
    \ split //, $c;\n    for my $char (split //, $s) {\n        if (!exists $c_hash{$char})\
    \ {\n            $result .= $char;\n        }\n    }\n    my $result_length =\
    \ length $result;\n    for (my $i = 0; $i < $result_length / 2; $i++) {\n    \
    \    if (substr($result, $i, 1) ne substr($result, $result_length - $i - 1, 1))\
    \ {\n            $is_palindrome = 0;\n            last;\n        }\n    }\n  \
    \  return [$result, $is_palindrome];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return [$r, $r eq reverse $r];\n}", "    my $result = $s;\n    $result =~\
    \ s/[$c]//g;\n    my $is_palindrome = $result eq reverse $result;\n    return\
    \ [$result, $is_palindrome];\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 1;\n    my %c_hash = map {$_ => 1} split //, $c;\n    for my $char (split\
    \ //, $s) {\n        if (!exists $c_hash{$char}) {\n            $result .= $char;\n\
    \        }\n    }\n    my $len = length $result;\n    for (my $i = 0; $i < $len\
    \ / 2; $i++) {\n        if (substr($result, $i, 1) ne substr($result, $len - $i\
    \ - 1, 1)) {\n            $is_palindrome = 0;\n            last;\n        }\n\
    \    }\n    return [$result, $is_palindrome];\n}", "    my $result = $s;\n   \
    \ $result =~ s/[$c]//g;\n    return [$result, $result eq reverse $result];\n}",
  "    my @s = split //, $s;\n    my @c = split //, $c;\n    my @result;\n    for\
    \ my $i (0..$#s) {\n        my $flag = 0;\n        for my $j (0..$#c) {\n    \
    \        if ($s[$i] eq $c[$j]) {\n                $flag = 1;\n               \
    \ last;\n            }\n        }\n        if ($flag == 0) {\n            push\
    \ @result, $s[$i];\n        }\n    }\n    my $result = join '', @result;\n   \
    \ my $palindrome = 0;\n    if ($result eq reverse $result) {\n        $palindrome\
    \ = 1;\n    }\n    return [$result, $palindrome];\n}", "    my $r = '';\n    my\
    \ $p = 0;\n    for my $i (0..length($s)-1) {\n        if (index($c, substr($s,\
    \ $i, 1)) == -1) {\n            $r .= substr($s, $i, 1);\n        }\n    }\n \
    \   for my $i (0..length($r)-1) {\n        if (substr($r, $i, 1) eq substr($r,\
    \ length($r)-1-$i, 1)) {\n            $p++;\n        }\n    }\n    return [$r,\
    \ $p == length($r)];\n}", "    my $res = $s;\n    $res =~ s/[$c]//g;\n    my $is_palindrome\
    \ = $res eq reverse $res;\n    return [$res, $is_palindrome];\n}", "    my @s\
    \ = split //, $s;\n    my @c = split //, $c;\n    my @result;\n    for my $i (0..$#s)\
    \ {\n        my $flag = 0;\n        for my $j (0..$#c) {\n            if ($s[$i]\
    \ eq $c[$j]) {\n                $flag = 1;\n                last;\n          \
    \  }\n        }\n        if ($flag == 0) {\n            push @result, $s[$i];\n\
    \        }\n    }\n    my $result = join \"\", @result;\n    my $palindrome =\
    \ 0;\n    if ($result eq reverse $result) {\n        $palindrome = 1;\n    }\n\
    \    return [$result, $palindrome];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return [$r, $r eq reverse $r];\n}", "    my $result = $s;\n    $result =~\
    \ s/[$c]//g;\n    return [$result, $result eq reverse $result];\n}", "    my $r\
    \ = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return [$r,\
    \ $p];\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
