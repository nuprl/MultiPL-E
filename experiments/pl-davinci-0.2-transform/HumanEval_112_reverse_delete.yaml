name: HumanEval_112_reverse_delete
language: pl
prompt: "# Task\n# We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n# then check if the result string is\
  \ palindrome.\n# A string is called palindrome if it reads the same backward as\
  \ forward.\n# You should return a tuple containing the result string and True/False\
  \ for the check.\n# Example\n# >>> reverse_delete(\"abcde\", \"ae\")\n# [\"bcd\"\
  , \"\"]\n# >>> reverse_delete(\"abcdef\", \"b\")\n# [\"acdef\", \"\"]\n# >>> reverse_delete(\"\
  abcdedcba\", \"ab\")\n# [\"cdedc\", 1]\nsub reverse_delete {\n    my($s, $c) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&reverse_delete;\n\
  \        if(eq_deeply($candidate->(\"abcde\", \"ae\"),[\"bcd\", \"\"])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdef\", \"b\"),[\"acdef\", \"\"])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"ab\"),[\"cdedc\"\
  , 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  dwik\", \"w\"),[\"dik\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"a\", \"a\"),[\"\", 1])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdedcba\", \"\"),[\"abcdedcba\", 1])) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"v\"),[\"\
  abcdedcba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"vabba\", \"v\"),[\"abba\", 1])) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  mamma\", \"mia\"),[\"\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n \
    \   return [$r, $r eq reverse $r];\n}", "    my $result = '';\n    my $check =\
    \ 1;\n    my %hash;\n    for my $char (split //, $c) {\n        $hash{$char} =\
    \ 1;\n    }\n    for my $char (split //, $s) {\n        if (!exists $hash{$char})\
    \ {\n            $result .= $char;\n        }\n    }\n    my $reverse = reverse\
    \ $result;\n    if ($result ne $reverse) {\n        $check = 0;\n    }\n    return\
    \ [$result, $check];\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r\
    \ = join '', grep { !$c{$_} } split //, $s;\n    return [$r, $r eq reverse $r];\n\
    }", "    my $res = '';\n    my $check = 1;\n    my %c = map { $_ => 1 } split\
    \ //, $c;\n    for my $ch (split //, $s) {\n        if (!$c{$ch}) {\n        \
    \    $res .= $ch;\n        }\n    }\n    my $len = length $res;\n    for my $i\
    \ (0..$len/2-1) {\n        if (substr($res, $i, 1) ne substr($res, $len-$i-1,\
    \ 1)) {\n            $check = 0;\n            last;\n        }\n    }\n    return\
    \ [$res, $check];\n}", "    my $r = join '', grep { index($c, $_) == -1 } split\
    \ //, $s;\n    return [$r, $r eq reverse $r];\n}", "    my $r = $s;\n    $r =~\
    \ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n}", "    my $r = $s;\n    $r\
    \ =~ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n}", "    my $r = $s;\n  \
    \  $r =~ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n}", "    my $r = join\
    \ '', grep { index($c, $_) == -1 } split //, $s;\n    return [$r, $r eq reverse\
    \ $r];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return [$r, $r eq reverse\
    \ $r];\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep\
    \ { !$c{$_} } split //, $s;\n    return [$r, $r eq reverse $r];\n}", "    my $result\
    \ = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome = $result eq reverse\
    \ $result;\n    return [$result, $is_palindrome];\n}", "    my @s = split //,\
    \ $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1 } @c;\n    my @r;\n\
    \    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless $c{$s[$i]};\n    }\n\
    \    my $r = join '', @r;\n    my $p = $r eq reverse $r;\n    return [$r, $p];\n\
    }", "    my $result = '';\n    my $check = 1;\n    my %c = map { $_ => 1 } split\
    \ //, $c;\n    for my $char (split //, $s) {\n        if (!$c{$char}) {\n    \
    \        $result .= $char;\n        }\n    }\n    my $rev = reverse $result;\n\
    \    if ($result ne $rev) {\n        $check = 0;\n    }\n    return [$result,\
    \ $check];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse\
    \ $r;\n    return [$r, $p];\n}", "    my $result = $s;\n    $result =~ s/[$c]//g;\n\
    \    my $is_palindrome = $result eq reverse $result;\n    return [$result, $is_palindrome];\n\
    }", "    my $result = '';\n    my $check = 0;\n    my %c_hash = map { $_ => 1\
    \ } split //, $c;\n    for my $char (split //, $s) {\n        if (!$c_hash{$char})\
    \ {\n            $result .= $char;\n        }\n    }\n    if ($result eq reverse\
    \ $result) {\n        $check = 1;\n    }\n    return [$result, $check];\n}", " \
    \   my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
    \ [$r, $p];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse\
    \ $r;\n    return [$r, $p];\n}", "    my $result = '';\n    my $palindrome = 1;\n\
    \    my %c = map {$_ => 1} split //, $c;\n    for my $char (split //, $s) {\n\
    \        if (!$c{$char}) {\n            $result .= $char;\n        }\n    }\n\
    \    for my $i (0..length($result)/2-1) {\n        if (substr($result, $i, 1)\
    \ ne substr($result, -$i-1, 1)) {\n            $palindrome = 0;\n            last;\n\
    \        }\n    }\n    return [$result, $palindrome];\n}", "    my $result = \"\
    \";\n    my $check = 1;\n    my %hash = map { $_ => 1 } split //, $c;\n    for\
    \ my $char (split //, $s) {\n        if (!$hash{$char}) {\n            $result\
    \ .= $char;\n        }\n    }\n    for my $i (0..length($result)/2) {\n      \
    \  if (substr($result, $i, 1) ne substr($result, -$i-1, 1)) {\n            $check\
    \ = 0;\n            last;\n        }\n    }\n    return [$result, $check];\n}",
  "    my $result = $s;\n    my $is_palindrome = 0;\n    my @chars = split(//, $c);\n\
    \    for my $char (@chars) {\n        $result =~ s/$char//g;\n    }\n    if ($result\
    \ eq reverse($result)) {\n        $is_palindrome = 1;\n    }\n    return [$result,\
    \ $is_palindrome];\n}", "    my @s = split //, $s;\n    my @c = split //, $c;\n\
    \    my @result;\n    for my $i (@s) {\n        if (!grep {$i eq $_} @c) {\n \
    \           push @result, $i;\n        }\n    }\n    my $result = join '', @result;\n\
    \    my $palindrome = $result eq reverse $result;\n    return [$result, $palindrome];\n\
    }", "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return\
    \ [$r, $r eq reverse $r];\n}", "    my $result = $s;\n    $result =~ s/[$c]//g;\n\
    \    my $is_palindrome = $result eq reverse $result;\n    return [$result, $is_palindrome];\n\
    }", "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome =\
    \ $result eq reverse $result;\n    return [$result, $is_palindrome];\n}", "  \
    \  my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1\
    \ } @c;\n    my @res = grep { !$c{$_} } @s;\n    my $res = join '', @res;\n  \
    \  my $is_palindrome = $res eq reverse $res;\n    return [$res, $is_palindrome];\n\
    }", "    my $r = '';\n    my $p = 1;\n    my %c = map { $_ => 1 } split //, $c;\n\
    \    for my $i (0 .. length($s) - 1) {\n        my $ch = substr($s, $i, 1);\n\
    \        if (!$c{$ch}) {\n            $r .= $ch;\n        }\n    }\n    for my\
    \ $i (0 .. length($r) - 1) {\n        my $ch = substr($r, $i, 1);\n        my\
    \ $ch2 = substr($r, length($r) - 1 - $i, 1);\n        if ($ch ne $ch2) {\n   \
    \         $p = 0;\n            last;\n        }\n    }\n    return [$r, $p];\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n\
    }", "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome =\
    \ $result eq reverse $result;\n    return [$result, $is_palindrome];\n}", "  \
    \  my $r = $s;\n    $r =~ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n}",
  "    my %hash;\n    my $result = \"\";\n    for my $char (split //, $c) {\n    \
    \    $hash{$char} = 1;\n    }\n    for my $char (split //, $s) {\n        $result\
    \ .= $char unless exists $hash{$char};\n    }\n    my $is_palindrome = $result\
    \ eq reverse $result;\n    return [$result, $is_palindrome];\n}", "    my $r =\
    \ $s;\n    $r =~ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n}", "    my $r\
    \ = join '', grep { index($c, $_) == -1 } split //, $s;\n    return [$r, $r eq\
    \ reverse $r];\n}", "    my %c = map {$_ => 1} split //, $c;\n    my $r = join\
    \ '', grep {!$c{$_}} split //, $s;\n    my $p = $r eq reverse $r;\n    return\
    \ [$r, $p];\n}", "    my @s = split //, $s;\n    my @c = split //, $c;\n    my\
    \ %c = map { $_ => 1 } @c;\n    my @r;\n    for my $i (@s) {\n        push @r,\
    \ $i unless $c{$i};\n    }\n    my $r = join '', @r;\n    my $p = $r eq reverse\
    \ $r;\n    return [$r, $p];\n}", "    my $r = join '', grep { index($c, $_) ==\
    \ -1 } split //, $s;\n    my $p = $r eq reverse $r;\n    return [$r, $p];\n}",
  "    my $result = \"\";\n    my $is_palindrome = 1;\n    my %c_hash = map { $_ =>\
    \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!$c_hash{$char})\
    \ {\n            $result .= $char;\n        }\n    }\n    my $len = length $result;\n\
    \    for (my $i = 0; $i < $len / 2; $i++) {\n        if (substr($result, $i, 1)\
    \ ne substr($result, $len - $i - 1, 1)) {\n            $is_palindrome = 0;\n \
    \           last;\n        }\n    }\n    return [$result, $is_palindrome];\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n}",
  "    my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash = map { $_ =>\
    \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!exists $c_hash{$char})\
    \ {\n            $result .= $char;\n        }\n    }\n    my $reverse_result =\
    \ reverse $result;\n    if ($result ne $reverse_result) {\n        $is_palindrome\
    \ = 0;\n    }\n    return [$result, $is_palindrome];\n}", "    my $result = $s;\n\
    \    $result =~ s/[$c]//g;\n    return [$result, $result eq reverse $result];\n\
    }", "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n    return\
    \ [$t, $t eq $r];\n}", "    my $r = join '', grep { index($c, $_) == -1 } split\
    \ //, $s;\n    return [$r, $r eq reverse $r];\n}", "    my $r = join '', grep\
    \ { index($c, $_) == -1 } split //, $s;\n    return [$r, $r eq reverse $r];\n}",
  "    my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash = map { $_ =>\
    \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!$c_hash{$char})\
    \ {\n            $result .= $char;\n        }\n    }\n    my $len = length $result;\n\
    \    for (my $i = 0; $i < $len / 2; $i++) {\n        if (substr($result, $i, 1)\
    \ ne substr($result, $len - $i - 1, 1)) {\n            $is_palindrome = 0;\n \
    \           last;\n        }\n    }\n    return [$result, $is_palindrome];\n}",
  "    my $result = '';\n    my $palindrome = 1;\n    my %hash = map { $_ => 1 } split\
    \ //, $c;\n    for my $char (split //, $s) {\n        if (!$hash{$char}) {\n \
    \           $result .= $char;\n        }\n    }\n    my $len = length $result;\n\
    \    for (my $i = 0; $i < $len / 2; $i++) {\n        if (substr($result, $i, 1)\
    \ ne substr($result, $len - $i - 1, 1)) {\n            $palindrome = 0;\n    \
    \        last;\n        }\n    }\n    return [$result, $palindrome];\n}", "  \
    \  my %h = map {$_ => 1} split //, $c;\n    my $r = join '', grep {!$h{$_}} split\
    \ //, $s;\n    my $p = $r eq reverse $r;\n    return [$r, $p];\n}", "    my %hash\
    \ = map { $_ => 1 } split //, $c;\n    my $res = join '', grep { !$hash{$_} }\
    \ split //, $s;\n    return [$res, $res eq reverse $res];\n}", "    my $r = join\
    \ '', grep { index($c, $_) == -1 } split //, $s;\n    return [$r, $r eq reverse\
    \ $r];\n}", "    my $result = $s;\n    $result =~ s/[$c]//g;\n    return ($result,\
    \ $result eq reverse $result);\n}", "    my $result = $s;\n    $result =~ s/[$c]//g;\n\
    \    return [$result, $result eq reverse $result];\n}", "    my $r = reverse $s;\n\
    \    my $t = $s;\n    $t =~ s/[$c]//g;\n    my $u = reverse $t;\n    return [$t,\
    \ $t eq $u];\n}", "    my %hash = map { $_ => 1 } split //, $c;\n    my $result\
    \ = join '', grep { !$hash{$_} } split //, $s;\n    return [$result, $result eq\
    \ reverse $result];\n}", "    my %hash = map { $_ => 1 } split //, $c;\n    my\
    \ $result = join '', grep { !$hash{$_} } split //, $s;\n    return [$result, $result\
    \ eq reverse $result];\n}", "    my $r = join '', grep { index($c, $_) == -1 }\
    \ split //, $s;\n    return [$r, $r eq reverse $r];\n}", "    my $r = join '',\
    \ grep { index($c, $_) == -1 } split //, $s;\n    return [$r, $r eq reverse $r];\n\
    }", "    my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash = map {\
    \ $_ => 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!$c_hash{$char})\
    \ {\n            $result .= $char;\n        }\n    }\n    my $len = length $result;\n\
    \    for (my $i = 0; $i < $len / 2; $i++) {\n        if (substr($result, $i, 1)\
    \ ne substr($result, $len - $i - 1, 1)) {\n            $is_palindrome = 0;\n \
    \           last;\n        }\n    }\n    return [$result, $is_palindrome];\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n}",
  "    my $t = $s;\n    $t =~ s/[$c]//g;\n    return [$t, $t eq reverse $t];\n}",
  "    my $result = '';\n    my $is_palindrome = 1;\n    my %c_hash = map { $_ =>\
    \ 1 } split //, $c;\n    for my $char (split //, $s) {\n        if (!exists $c_hash{$char})\
    \ {\n            $result .= $char;\n        }\n    }\n    for my $i (0 .. int(length($result)\
    \ / 2)) {\n        if (substr($result, $i, 1) ne substr($result, -$i - 1, 1))\
    \ {\n            $is_palindrome = 0;\n            last;\n        }\n    }\n  \
    \  return [$result, $is_palindrome];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    my $p = $r eq reverse $r;\n    return [$r, $p];\n}", "    my $result = $s;\n\
    \    $result =~ s/[$c]//g;\n    my $is_palindrome = $result eq reverse $result;\n\
    \    return [$result, $is_palindrome];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    my $p = $r eq reverse $r;\n    return [$r, $p];\n}", "    my $r = join('',\
    \ grep { index($c, $_) == -1 } split(//, $s));\n    return [$r, $r eq reverse($r)];\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n\
    }", "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return\
    \ [$r, $r eq reverse $r];\n}", "    my $r = join '', grep { index($c, $_) == -1\
    \ } split //, $s;\n    return [$r, $r eq reverse $r];\n}", "    my $result = '';\n\
    \    my $is_palindrome = 1;\n    my %c_hash = map { $_ => 1 } split //, $c;\n\
    \    for my $char (split //, $s) {\n        if (!exists $c_hash{$char}) {\n  \
    \          $result .= $char;\n        }\n    }\n    my $rev_result = reverse $result;\n\
    \    if ($result ne $rev_result) {\n        $is_palindrome = 0;\n    }\n    return\
    \ [$result, $is_palindrome];\n}", "    my $r = join '', grep { index($c, $_) ==\
    \ -1 } split //, $s;\n    my $p = $r eq reverse $r;\n    return [$r, $p];\n}",
  "    my $r = join('', grep { index($c, $_) < 0 } split('', $s));\n    return [$r,\
    \ $r eq reverse($r)];\n}", "    my $res = '';\n    my $is_palindrome = 0;\n  \
    \  my %c_hash = map { $_ => 1 } split //, $c;\n    for my $char (split //, $s)\
    \ {\n        if (!exists $c_hash{$char}) {\n            $res .= $char;\n     \
    \   }\n    }\n    if ($res eq reverse $res) {\n        $is_palindrome = 1;\n \
    \   }\n    return [$res, $is_palindrome];\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 1;\n    my %hash = map { $_ => 1 } split //, $c;\n    for my $char (split\
    \ //, $s) {\n        if (!$hash{$char}) {\n            $result .= $char;\n   \
    \     }\n    }\n    my $len = length $result;\n    for (my $i = 0; $i < $len /\
    \ 2; $i++) {\n        if (substr($result, $i, 1) ne substr($result, $len - $i\
    \ - 1, 1)) {\n            $is_palindrome = 0;\n            last;\n        }\n\
    \    }\n    return [$result, $is_palindrome];\n}", "    my %c = map { $_ => 1\
    \ } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //, $s;\n    return\
    \ [$r, $r eq reverse $r];\n}", "    my %c = map { $_ => 1 } split //, $c;\n  \
    \  my $r = join '', grep { !$c{$_} } split //, $s;\n    return [$r, $r eq reverse\
    \ $r];\n}", "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome\
    \ = $result eq reverse $result;\n    return [$result, $is_palindrome];\n}", " \
    \   my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return [$r,\
    \ $r eq reverse $r];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return [$r,\
    \ $r eq reverse $r];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return [$r,\
    \ $r eq reverse $r];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return [$r,\
    \ $r eq reverse $r];\n}", "    my %c = map { $_ => 1 } split //, $c;\n    my $r\
    \ = join '', grep { !$c{$_} } split //, $s;\n    return [$r, $r eq reverse $r];\n\
    }", "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return\
    \ [$r, $r eq reverse $r];\n}", "    my %hash = map { $_ => 1 } split //, $c;\n\
    \    my $result = join '', grep { !$hash{$_} } split //, $s;\n    return [$result,\
    \ $result eq reverse $result];\n}", "    my $result = $s;\n    $result =~ s/[$c]//g;\n\
    \    my $is_palindrome = $result eq reverse $result;\n    return ($result, $is_palindrome);\n\
    }", "    my @s = split //, $s;\n    my @c = split //, $c;\n    my @result;\n \
    \   for my $i (0..$#s) {\n        my $flag = 0;\n        for my $j (0..$#c) {\n\
    \            if ($s[$i] eq $c[$j]) {\n                $flag = 1;\n           \
    \     last;\n            }\n        }\n        if ($flag == 0) {\n           \
    \ push @result, $s[$i];\n        }\n    }\n    my $result = join '', @result;\n\
    \    my $check = 0;\n    if ($result eq reverse $result) {\n        $check = 1;\n\
    \    }\n    return [$result, $check];\n}", "    my $r = join(\"\", grep { index($c,\
    \ $_) == -1 } split(\"\", $s));\n    my $p = $r eq reverse($r);\n    return [$r,\
    \ $p];\n}", "    my $result = $s;\n    my $check = 0;\n    for my $char (split\
    \ //, $c) {\n        $result =~ s/$char//g;\n    }\n    if ($result eq reverse\
    \ $result) {\n        $check = 1;\n    }\n    return [$result, $check];\n}", " \
    \   my $res = \"\";\n    my $is_palindrome = 0;\n    my %hash = map { $_ => 1\
    \ } split //, $c;\n    for my $ch (split //, $s) {\n        $res .= $ch unless\
    \ $hash{$ch};\n    }\n    $is_palindrome = 1 if $res eq reverse $res;\n    return\
    \ [$res, $is_palindrome];\n}", "    my @s = split //, $s;\n    my @c = split //,\
    \ $c;\n    my %c = map { $_ => 1 } @c;\n    my @result = grep { !$c{$_} } @s;\n\
    \    my $result = join '', @result;\n    my $is_palindrome = $result eq reverse\
    \ $result;\n    return [$result, $is_palindrome];\n}", "    my $r = $s;\n    $r\
    \ =~ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n}", "    my $r = join '',\
    \ grep { index($c, $_) == -1 } split //, $s;\n    return [$r, $r eq reverse $r];\n\
    }", "    my @s = split //, $s;\n    my @c = split //, $c;\n    my @result;\n \
    \   for my $i (0..$#s) {\n        my $flag = 0;\n        for my $j (0..$#c) {\n\
    \            if ($s[$i] eq $c[$j]) {\n                $flag = 1;\n           \
    \     last;\n            }\n        }\n        if ($flag == 0) {\n           \
    \ push @result, $s[$i];\n        }\n    }\n    my $result = join '', @result;\n\
    \    my $palindrome = 0;\n    if ($result eq reverse $result) {\n        $palindrome\
    \ = 1;\n    }\n    return [$result, $palindrome];\n}", "    my $result = '';\n\
    \    my $check = 1;\n    my %hash = map { $_ => 1 } split //, $c;\n    for my\
    \ $char (split //, $s) {\n        $result .= $char unless $hash{$char};\n    }\n\
    \    for my $i (0 .. int(length($result) / 2)) {\n        if (substr($result,\
    \ $i, 1) ne substr($result, -$i - 1, 1)) {\n            $check = 0;\n        \
    \    last;\n        }\n    }\n    return [$result, $check];\n}", "    my %c =\
    \ map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_} } split //,\
    \ $s;\n    return [$r, $r eq reverse $r];\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 1;\n    my %hash = map { $_ => 1 } split //, $c;\n    for my $char (split\
    \ //, $s) {\n        if (!exists $hash{$char}) {\n            $result .= $char;\n\
    \        }\n    }\n    my $len = length $result;\n    for (my $i = 0; $i < $len\
    \ / 2; $i++) {\n        if (substr($result, $i, 1) ne substr($result, $len - $i\
    \ - 1, 1)) {\n            $is_palindrome = 0;\n            last;\n        }\n\
    \    }\n    return [$result, $is_palindrome];\n}", "    my $r = join '', grep\
    \ { index($c, $_) == -1 } split //, $s;\n    return [$r, $r eq reverse $r];\n}",
  "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return [$r,\
    \ $r eq reverse $r];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p =\
    \ $r eq reverse $r;\n    return [$r, $p];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    my $p = $r eq reverse $r;\n    return [$r, $p];\n}", "    my $result = '';\n\
    \    my $check = 1;\n    my %c_hash = map { $_ => 1 } split //, $c;\n    for my\
    \ $char (split //, $s) {\n        if (!exists $c_hash{$char}) {\n            $result\
    \ .= $char;\n        }\n    }\n    for my $i (0 .. int(length($result) / 2)) {\n\
    \        if (substr($result, $i, 1) ne substr($result, -$i - 1, 1)) {\n      \
    \      $check = 0;\n            last;\n        }\n    }\n    return [$result,\
    \ $check];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return [$r, $r eq\
    \ reverse $r];\n}", "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome\
    \ = $result eq reverse $result;\n    return [$result, $is_palindrome];\n}", " \
    \   my $r = reverse $s;\n    my $result = '';\n    my $is_palindrome = 1;\n  \
    \  for my $i (0..length($s)-1) {\n        my $char = substr($s, $i, 1);\n    \
    \    if (index($c, $char) == -1) {\n            $result .= $char;\n          \
    \  if (substr($r, $i, 1) ne $char) {\n                $is_palindrome = 0;\n  \
    \          }\n        }\n    }\n    return [$result, $is_palindrome];\n}", " \
    \   my $t = $s;\n    $t =~ s/[$c]//g;\n    my $r = reverse $t;\n    return [$t,\
    \ $t eq $r];\n}", "    my @s = split //, $s;\n    my @c = split //, $c;\n    my\
    \ %c = map { $_ => 1 } @c;\n    my @r;\n    for my $i (@s) {\n        push @r,\
    \ $i unless $c{$i};\n    }\n    my $r = join '', @r;\n    my $p = $r eq reverse\
    \ $r;\n    return [$r, $p];\n}", "    my $result = $s;\n    $result =~ s/[$c]//g;\n\
    \    return [$result, $result eq reverse $result];\n}", "    my $result = '';\n\
    \    my $is_palindrome = 1;\n    my %c_hash = map { $_ => 1 } split //, $c;\n\
    \    for my $char (split //, $s) {\n        if (!exists $c_hash{$char}) {\n  \
    \          $result .= $char;\n        }\n    }\n    my $len = length $result;\n\
    \    for (my $i = 0; $i < $len / 2; $i++) {\n        if (substr($result, $i, 1)\
    \ ne substr($result, $len - $i - 1, 1)) {\n            $is_palindrome = 0;\n \
    \           last;\n        }\n    }\n    return [$result, $is_palindrome];\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
    \ [$r, $p];\n}", "    my $r = '';\n    my $p = 1;\n    my %c = map {$_ => 1} split\
    \ //, $c;\n    for my $i (0..length($s)-1) {\n        my $ch = substr($s, $i,\
    \ 1);\n        if (!$c{$ch}) {\n            $r .= $ch;\n        }\n    }\n   \
    \ for my $i (0..length($r)-1) {\n        my $ch = substr($r, $i, 1);\n       \
    \ my $ch2 = substr($r, length($r)-$i-1, 1);\n        if ($ch ne $ch2) {\n    \
    \        $p = 0;\n            last;\n        }\n    }\n    return [$r, $p];\n}",
  "    my $result = '';\n    my $check = 1;\n    my %c = map { $_ => 1 } split //,\
    \ $c;\n    for my $char (split //, $s) {\n        if (!$c{$char}) {\n        \
    \    $result .= $char;\n        }\n    }\n    $check = 0 if $result ne reverse\
    \ $result;\n    return [$result, $check];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    my $p = $r eq reverse $r;\n    return [$r, $p];\n}", "    my %c = map {$_\
    \ => 1} split //, $c;\n    my $r = join '', grep {!$c{$_}} split //, $s;\n   \
    \ my $p = $r eq reverse $r;\n    return [$r, $p];\n}", "    my $r = $s;\n    $r\
    \ =~ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n}", "    my $r = $s;\n  \
    \  $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return [$r, $p];\n}",
  "    $s =~ s/[$c]//g;\n    my $rev = reverse $s;\n    return [$s, $s eq $rev];\n\
    }", "    my %c = map {$_ => 1} split //, $c;\n    my $res = join '', grep {!$c{$_}}\
    \ split //, $s;\n    return [$res, $res eq reverse $res];\n}", "    my @s = split\
    \ //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1 } @c;\n    my\
    \ @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless $c{$s[$i]};\n\
    \    }\n    my $r = join '', @r;\n    my $p = $r eq reverse $r;\n    return [$r,\
    \ $p];\n}", "    my $result = $s;\n    my $check = 0;\n    my @c = split //, $c;\n\
    \    for my $char (@c) {\n        $result =~ s/$char//g;\n    }\n    if ($result\
    \ eq reverse $result) {\n        $check = 1;\n    }\n    return [$result, $check];\n\
    }", "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return\
    \ [$r, $r eq reverse $r];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my\
    \ $p = $r eq reverse $r;\n    return [$r, $p];\n}", "    my $result = $s;\n  \
    \  $result =~ s/[$c]//g;\n    my $is_palindrome = $result eq reverse $result;\n\
    \    return [$result, $is_palindrome];\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 1;\n    my %c_hash = map { $_ => 1 } split //, $c;\n    for my $char (split\
    \ //, $s) {\n        if (!exists $c_hash{$char}) {\n            $result .= $char;\n\
    \        }\n    }\n    my $len = length $result;\n    for (my $i = 0; $i < $len\
    \ / 2; $i++) {\n        if (substr($result, $i, 1) ne substr($result, $len - $i\
    \ - 1, 1)) {\n            $is_palindrome = 0;\n            last;\n        }\n\
    \    }\n    return [$result, $is_palindrome];\n}", "    my @s = split //, $s;\n\
    \    my @c = split //, $c;\n    my %c = map { $_ => 1 } @c;\n    my @r;\n    for\
    \ my $x (@s) {\n        push @r, $x unless $c{$x};\n    }\n    my $r = join '',\
    \ @r;\n    my $p = $r eq reverse $r;\n    return [$r, $p];\n}", "    my $r = join\
    \ '', grep { index($c, $_) == -1 } split //, $s;\n    return [$r, $r eq reverse\
    \ $r];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return [$r, $r eq reverse\
    \ $r];\n}", "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c =\
    \ map { $_ => 1 } @c;\n    my @r;\n    for my $i (0 .. $#s) {\n        push @r,\
    \ $s[$i] unless $c{$s[$i]};\n    }\n    my $r = join '', @r;\n    my $p = $r eq\
    \ reverse $r;\n    return [$r, $p];\n}", "    my $result = $s;\n    $result =~\
    \ s/[$c]//g;\n    my $palindrome = $result eq reverse $result;\n    return [$result,\
    \ $palindrome];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq\
    \ reverse $r;\n    return [$r, $p];\n}", "    my @s = split //, $s;\n    my @c\
    \ = split //, $c;\n    my @result;\n    my $is_palindrome = 1;\n    for my $i\
    \ (0..$#s) {\n        my $is_deleted = 0;\n        for my $j (0..$#c) {\n    \
    \        if ($s[$i] eq $c[$j]) {\n                $is_deleted = 1;\n         \
    \       last;\n            }\n        }\n        if (!$is_deleted) {\n       \
    \     push @result, $s[$i];\n        }\n    }\n    for my $i (0..$#result/2) {\n\
    \        if ($result[$i] ne $result[$#result-$i]) {\n            $is_palindrome\
    \ = 0;\n            last;\n        }\n    }\n    return [join('', @result), $is_palindrome];\n\
    }", "    my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return\
    \ [$r, $r eq reverse $r];\n}", "    my $result = \"\";\n    my $palindrome = 1;\n\
    \    my %c_hash = map {$_ => 1} split(//, $c);\n    for my $char (split(//, $s))\
    \ {\n        if (!$c_hash{$char}) {\n            $result .= $char;\n        }\n\
    \    }\n    my $result_reverse = reverse($result);\n    if ($result ne $result_reverse)\
    \ {\n        $palindrome = 0;\n    }\n    return [$result, $palindrome];\n}",
  "    my $result = $s;\n    $result =~ s/[$c]//g;\n    return [$result, $result eq\
    \ reverse($result)];\n}", "    my $result = $s;\n    $result =~ s/[$c]//g;\n \
    \   my $is_palindrome = $result eq reverse $result;\n    return [$result, $is_palindrome];\n\
    }", "    my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
    \ } split //, $s;\n    my $p = $r eq reverse $r;\n    return [$r, $p];\n}", " \
    \   my $r = $s;\n    $r =~ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
    \ [$r, $p];\n}", "    my $r = reverse $s;\n    my $c_regex = join '|', split //,\
    \ $c;\n    $s =~ s/$c_regex//g;\n    $r =~ s/$c_regex//g;\n    return [$s, $s\
    \ eq $r];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse\
    \ $r;\n    return [$r, $p];\n}", "    my $r = '';\n    my $p = '';\n    my $i\
    \ = 0;\n    my $j = 0;\n    my $k = 0;\n    my $l = 0;\n    my $m = 0;\n    my\
    \ $n = 0;\n    my $o = 0;\n    my $p = 0;\n    my $q = 0;\n    my $r = 0;\n  \
    \  my $s = 0;\n    my $t = 0;\n    my $u = 0;\n    my $v = 0;\n    my $w = 0;\n\
    \    my $x = 0;\n    my $y = 0;\n    my $z = 0;\n    my $A = 0;\n    my $B = 0;\n\
    \    my $C = 0;\n    my $D = 0;\n    my $E = 0;\n    my $F = 0;\n    my $G = 0;\n\
    \    my $H = 0;\n    my $I = 0;\n    my $J = 0;\n    my $K = 0;\n    my $L = 0;\n\
    \    my $M = 0;\n    my $N = 0;\n    my $O = 0;\n    my $P = 0;\n    my $Q = 0;\n\
    \    my $R = 0;\n    my $S = 0;\n    my $T = 0;\n    my $U = 0;\n    my $V = 0;\n\
    \    my $W = 0;\n    my $X = 0;\n    my $Y = 0;\n    my $Z = 0;\n    my $a = 0;\n\
    \    my $b = 0;\n    my $c = 0;\n    my $d = 0;\n    my $e = 0;\n    my $f = 0;\n\
    \    my $g = 0;\n    my $h = 0;\n    my $i = 0;\n    my $j = 0;\n    my $k = 0;\n\
    \    my $l = 0;\n    my $m = 0;\n    my $n = 0;\n    my $o = 0;\n    my $p = 0;\n\
    \    my $q = 0;\n    my $r = 0;", "    my $result = $s;\n    $result =~ s/[$c]//g;\n\
    \    my $is_palindrome = $result eq reverse $result;\n    return [$result, $is_palindrome];\n\
    }", "    my $result = $s;\n    for my $char (split //, $c) {\n        $result\
    \ =~ s/$char//g;\n    }\n    my $is_palindrome = $result eq reverse $result;\n\
    \    return [$result, $is_palindrome];\n}", "    my $res = '';\n    for my $ch\
    \ (split //, $s) {\n        $res .= $ch unless $c =~ /$ch/;\n    }\n    return\
    \ [$res, $res eq reverse $res];\n}", "    my $r = join '', grep { index($c, $_)\
    \ == -1 } split //, $s;\n    my $p = $r eq reverse $r;\n    return [$r, $p];\n\
    }", "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_\
    \ => 1 } @c;\n    my @result = grep { !$c{$_} } @s;\n    my $result = join '',\
    \ @result;\n    my $is_palindrome = $result eq reverse $result;\n    return [$result,\
    \ $is_palindrome];\n}", "    my @s = split //, $s;\n    my @c = split //, $c;\n\
    \    my @r;\n    for my $i (@s) {\n        my $flag = 0;\n        for my $j (@c)\
    \ {\n            if ($i eq $j) {\n                $flag = 1;\n               \
    \ last;\n            }\n        }\n        push @r, $i unless $flag;\n    }\n\
    \    my $r = join \"\", @r;\n    my $p = 1;\n    for my $i (0..length($r)/2-1)\
    \ {\n        if (substr($r, $i, 1) ne substr($r, -$i-1, 1)) {\n            $p\
    \ = 0;\n            last;\n        }\n    }\n    return [$r, $p];\n}", "    my\
    \ @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1 } @c;\n\
    \    my @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless $c{$s[$i]};\n\
    \    }\n    my $r = join '', @r;\n    my $p = $r eq reverse $r;\n    return [$r,\
    \ $p];\n}", "    my $r = reverse $s;\n    my $t = $s;\n    $t =~ s/[$c]//g;\n\
    \    my $r_t = reverse $t;\n    return [$t, $r_t eq $t];\n}", "    my $r = $s;\n\
    \    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return [$r, $p];\n}",
  "    my $result = '';\n    my $palindrome = 1;\n    my %c = map { $_ => 1 } split\
    \ //, $c;\n    for my $char (split //, $s) {\n        if (!$c{$char}) {\n    \
    \        $result .= $char;\n        }\n    }\n    my $len = length $result;\n\
    \    for my $i (0 .. $len / 2 - 1) {\n        if (substr($result, $i, 1) ne substr($result,\
    \ $len - $i - 1, 1)) {\n            $palindrome = 0;\n            last;\n    \
    \    }\n    }\n    return [$result, $palindrome];\n}", "    my $r = join '', grep\
    \ { index($c, $_) == -1 } split //, $s;\n    return [$r, $r eq reverse $r];\n}",
  "    my @s = split //, $s;\n    my @c = split //, $c;\n    my @new_s;\n    my $is_palindrome\
    \ = 1;\n    foreach my $char (@s) {\n        if (grep {$_ eq $char} @c) {\n  \
    \          next;\n        }\n        push @new_s, $char;\n    }\n    my $new_s\
    \ = join '', @new_s;\n    my $new_s_reverse = reverse $new_s;\n    if ($new_s\
    \ ne $new_s_reverse) {\n        $is_palindrome = 0;\n    }\n    return [$new_s,\
    \ $is_palindrome];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r\
    \ eq reverse $r;\n    return [$r, $p];\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 1;\n    my %c_hash = map { $_ => 1 } split //, $c;\n    for my $char (split\
    \ //, $s) {\n        if (!exists $c_hash{$char}) {\n            $result .= $char;\n\
    \        }\n    }\n    my $reverse_result = reverse $result;\n    if ($result\
    \ ne $reverse_result) {\n        $is_palindrome = 0;\n    }\n    return [$result,\
    \ $is_palindrome];\n}", "    my $r = '';\n    my $p = 1;\n    my %c = map { $_\
    \ => 1 } split //, $c;\n    for my $i (0 .. length($s) - 1) {\n        my $ch\
    \ = substr($s, $i, 1);\n        if (!$c{$ch}) {\n            $r .= $ch;\n    \
    \    }\n    }\n    for my $i (0 .. length($r) - 1) {\n        my $ch = substr($r,\
    \ $i, 1);\n        my $ch2 = substr($r, length($r) - 1 - $i, 1);\n        if ($ch\
    \ ne $ch2) {\n            $p = 0;\n            last;\n        }\n    }\n    return\
    \ [$r, $p];\n}", "    my $r = join '', grep { index($c, $_) < 0 } split //, $s;\n\
    \    return [$r, $r eq reverse $r];\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 1;\n    my %chars = map { $_ => 1 } split //, $c;\n    for my $char (split\
    \ //, $s) {\n        if (!$chars{$char}) {\n            $result .= $char;\n  \
    \      }\n    }\n    my $len = length $result;\n    for my $i (0..$len/2-1) {\n\
    \        if (substr($result, $i, 1) ne substr($result, $len-$i-1, 1)) {\n    \
    \        $is_palindrome = 0;\n            last;\n        }\n    }\n    return\
    \ [$result, $is_palindrome];\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 1;\n    my %c_hash = map { $_ => 1 } split //, $c;\n    for my $char (split\
    \ //, $s) {\n        if (!exists $c_hash{$char}) {\n            $result .= $char;\n\
    \        }\n    }\n    for my $i (0 .. int(length($result) / 2)) {\n        if\
    \ (substr($result, $i, 1) ne substr($result, -$i - 1, 1)) {\n            $is_palindrome\
    \ = 0;\n            last;\n        }\n    }\n    return [$result, $is_palindrome];\n\
    }", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n  \
    \  return [$r, $p];\n}", "    my $re = join '', map { quotemeta } split //, $c;\n\
    \    $s =~ s/$re//g;\n    return [$s, $s eq reverse $s];\n}", "    my $t = $s;\n\
    \    $t =~ s/[$c]//g;\n    return [$t, $t eq reverse $t];\n}", "    my $res =\
    \ '';\n    my $check = 1;\n    my %hash = map { $_ => 1 } split //, $c;\n    for\
    \ my $i (0 .. length($s) - 1) {\n        my $char = substr($s, $i, 1);\n     \
    \   if (!$hash{$char}) {\n            $res .= $char;\n        }\n    }\n    for\
    \ my $i (0 .. length($res) - 1) {\n        my $char = substr($res, $i, 1);\n \
    \       my $rev_char = substr($res, length($res) - 1 - $i, 1);\n        if ($char\
    \ ne $rev_char) {\n            $check = 0;\n            last;\n        }\n   \
    \ }\n    return [$res, $check];\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 1;\n    my %c_hash = map { $_ => 1 } split //, $c;\n    for my $char (split\
    \ //, $s) {\n        if (!exists $c_hash{$char}) {\n            $result .= $char;\n\
    \        }\n    }\n    my $len = length $result;\n    for (my $i = 0; $i < $len\
    \ / 2; $i++) {\n        if (substr($result, $i, 1) ne substr($result, $len - $i\
    \ - 1, 1)) {\n            $is_palindrome = 0;\n            last;\n        }\n\
    \    }\n    return [$result, $is_palindrome];\n}", "    my $r = $s;\n    $r =~\
    \ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return ($r, $p);\n}", "    my\
    \ $res = '';\n    my $check = 1;\n    my %h = map {$_ => 1} split //, $c;\n  \
    \  for (split //, $s) {\n        $res .= $_ unless $h{$_};\n    }\n    $check\
    \ = 0 if $res ne reverse $res;\n    return [$res, $check];\n}", "    my $result\
    \ = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome = $result eq reverse\
    \ $result;\n    return [$result, $is_palindrome];\n}", "    my $r = $s;\n    $r\
    \ =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return [$r, $p];\n}", "  \
    \  my %c = map { $_ => 1 } split //, $c;\n    my $r = join '', grep { !$c{$_}\
    \ } split //, $s;\n    my $p = $r eq reverse $r;\n    return [$r, $p];\n}", " \
    \   my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome = $result\
    \ eq reverse $result;\n    return [$result, $is_palindrome];\n}", "    my $r =\
    \ $s;\n    $r =~ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n}", "    my $result\
    \ = $s;\n    for my $char (split //, $c) {\n        $result =~ s/$char//g;\n \
    \   }\n    my $is_palindrome = $result eq reverse $result;\n    return [$result,\
    \ $is_palindrome];\n}", "    my $result = '';\n    my $check = 1;\n    my %c =\
    \ map { $_ => 1 } split //, $c;\n    for my $char (split //, $s) {\n        $result\
    \ .= $char unless $c{$char};\n    }\n    $check = 0 if $result ne reverse $result;\n\
    \    return [$result, $check];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n \
    \   return [$r, $r eq reverse $r];\n}", "    my @s = split //, $s;\n    my @c\
    \ = split //, $c;\n    my %c = map { $_ => 1 } @c;\n    my @r;\n    for my $i\
    \ (@s) {\n        push @r, $i unless $c{$i};\n    }\n    my $r = join '', @r;\n\
    \    my $p = $r eq reverse $r;\n    return [$r, $p];\n}", "    my $r = join '',\
    \ grep { index($c, $_) == -1 } split //, $s;\n    return [$r, $r eq reverse $r];\n\
    }", "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome =\
    \ $result eq reverse $result;\n    return [$result, $is_palindrome];\n}", "  \
    \  my $r = $s;\n    $r =~ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n}",
  "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return\
    \ [$r, $p];\n}", "    my @s = split //, $s;\n    my @c = split //, $c;\n    my\
    \ @result;\n    for my $i (0..$#s) {\n        my $found = 0;\n        for my $j\
    \ (0..$#c) {\n            if ($s[$i] eq $c[$j]) {\n                $found = 1;\n\
    \                last;\n            }\n        }\n        push @result, $s[$i]\
    \ unless $found;\n    }\n    my $result = join '', @result;\n    my $palindrome\
    \ = $result eq reverse $result;\n    return [$result, $palindrome];\n}", "   \
    \ my $r = join '', grep { index($c, $_) == -1 } split //, $s;\n    return [$r,\
    \ $r eq reverse $r];\n}", "    my $result = '';\n    my $is_palindrome = 1;\n\
    \    my %c_hash = map {$_ => 1} split //, $c;\n    for my $char (split //, $s)\
    \ {\n        if (!$c_hash{$char}) {\n            $result .= $char;\n        }\n\
    \    }\n    my $result_reverse = reverse $result;\n    if ($result ne $result_reverse)\
    \ {\n        $is_palindrome = 0;\n    }\n    return [$result, $is_palindrome];\n\
    }", "    my %c = map { $_ => 1 } split //, $c;\n    my @s = split //, $s;\n  \
    \  my @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless $c{$s[$i]};\n\
    \    }\n    my $r = join '', @r;\n    return [$r, $r eq reverse $r];\n}", "  \
    \  my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_ => 1\
    \ } @c;\n    my @r;\n    for my $i (0 .. $#s) {\n        push @r, $s[$i] unless\
    \ $c{$s[$i]};\n    }\n    my $r = join '', @r;\n    my $p = $r eq reverse $r;\n\
    \    return [$r, $p];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p =\
    \ $r eq reverse $r;\n    return [$r, $p];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n\
    \    return [$r, $r eq reverse $r];\n}", "    my $r = '';\n    my $p = 1;\n  \
    \  for my $i (0..length($s)-1) {\n        my $ch = substr($s, $i, 1);\n      \
    \  if (index($c, $ch) == -1) {\n            $r .= $ch;\n        }\n    }\n   \
    \ for my $i (0..length($r)-1) {\n        my $ch = substr($r, $i, 1);\n       \
    \ my $ch2 = substr($r, length($r)-$i-1, 1);\n        if ($ch ne $ch2) {\n    \
    \        $p = 0;\n            last;\n        }\n    }\n    return [$r, $p];\n}",
  "    my $r = '';\n    my $p = 1;\n    my %c = map { $_ => 1 } split //, $c;\n  \
    \  for my $i (0 .. length($s) - 1) {\n        my $ch = substr($s, $i, 1);\n  \
    \      if (!$c{$ch}) {\n            $r .= $ch;\n        }\n    }\n    for my $i\
    \ (0 .. length($r) - 1) {\n        my $ch1 = substr($r, $i, 1);\n        my $ch2\
    \ = substr($r, length($r) - 1 - $i, 1);\n        if ($ch1 ne $ch2) {\n       \
    \     $p = 0;\n            last;\n        }\n    }\n    return [$r, $p];\n}",
  "    my $result = $s;\n    $result =~ s/[$c]//g;\n    my $is_palindrome = $result\
    \ eq reverse $result;\n    return [$result, $is_palindrome];\n}", "    my $r =\
    \ $s;\n    $r =~ s/[$c]//g;\n    return [$r, $r eq reverse $r];\n}", "    my $r\
    \ = reverse $s;\n    my $t = $s;\n    $t =~ s/$c//g;\n    my $u = $t;\n    $u\
    \ =~ s/\\s//g;\n    my $v = $u;\n    $v =~ s/\\s//g;\n    my $w = $v;\n    $w\
    \ =~ s/\\s//g;\n    my $x = $w;\n    $x =~ s/\\s//g;\n    my $y = $x;\n    $y\
    \ =~ s/\\s//g;\n    my $z = $y;\n    $z =~ s/\\s//g;\n    my $a = $z;\n    $a\
    \ =~ s/\\s//g;\n    my $b = $a;\n    $b =~ s/\\s//g;\n    my $d = $b;\n    $d\
    \ =~ s/\\s//g;\n    my $e = $d;\n    $e =~ s/\\s//g;\n    my $f = $e;\n    $f\
    \ =~ s/\\s//g;\n    my $g = $f;\n    $g =~ s/\\s//g;\n    my $h = $g;\n    $h\
    \ =~ s/\\s//g;\n    my $i = $h;\n    $i =~ s/\\s//g;\n    my $j = $i;\n    $j\
    \ =~ s/\\s//g;\n    my $k = $j;\n    $k =~ s/\\s//g;\n    my $l = $k;\n    $l\
    \ =~ s/\\s//g;\n    my $m = $l;\n    $m =~ s/\\s//g;\n    my $n = $m;\n    $n\
    \ =~ s/\\s//g;\n    my $o = $n;\n    $o =~ s/\\s//g;\n    my $p = $o;\n    $p\
    \ =~ s/\\s//g;\n    my $q = $p;\n    $q =~ s/\\s", "    my $r = $s;\n    $r =~\
    \ s/[$c]//g;\n    my $p = $r eq reverse $r;\n    return [$r, $p];\n}", "    my\
    \ %hash = map { $_ => 1 } split //, $c;\n    my $res = join '', grep { !$hash{$_}\
    \ } split //, $s;\n    return [$res, $res eq reverse $res];\n}", "    my $r =\
    \ join '', grep { index($c, $_) == -1 } split //, $s;\n    return [$r, $r eq reverse\
    \ $r];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq reverse\
    \ $r;\n    return [$r, $p];\n}", "    my $result = '';\n    my $is_palindrome\
    \ = 1;\n    my %c_hash = map {$_ => 1} split //, $c;\n    for my $char (split\
    \ //, $s) {\n        if (!$c_hash{$char}) {\n            $result .= $char;\n \
    \       }\n    }\n    my $len = length $result;\n    for (my $i = 0; $i < $len\
    \ / 2; $i++) {\n        if (substr($result, $i, 1) ne substr($result, $len - $i\
    \ - 1, 1)) {\n            $is_palindrome = 0;\n            last;\n        }\n\
    \    }\n    return [$result, $is_palindrome];\n}", "    my @s = split //, $s;\n\
    \    my @c = split //, $c;\n    my %c = map { $_ => 1 } @c;\n    my @r;\n    for\
    \ my $i (0 .. $#s) {\n        push @r, $s[$i] unless $c{$s[$i]};\n    }\n    my\
    \ $r = join '', @r;\n    my $p = $r eq reverse $r;\n    return [$r, $p];\n}",
  "    my $r = join '', grep { index($c, $_) < 0 } split //, $s;\n    my $p = $r eq\
    \ reverse $r;\n    return [$r, $p];\n}", "    my @s = split //, $s;\n    my @c\
    \ = split //, $c;\n    my @result;\n    for my $i (0..$#s) {\n        my $flag\
    \ = 0;\n        for my $j (0..$#c) {\n            if ($s[$i] eq $c[$j]) {\n  \
    \              $flag = 1;\n                last;\n            }\n        }\n \
    \       if ($flag == 0) {\n            push @result, $s[$i];\n        }\n    }\n\
    \    my $result = join \"\", @result;\n    my $palindrome = 0;\n    if ($result\
    \ eq reverse $result) {\n        $palindrome = 1;\n    }\n    return [$result,\
    \ $palindrome];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    my $p = $r eq\
    \ reverse $r;\n    return [$r, $p];\n}", "    my $r = join '', grep { index($c,\
    \ $_) < 0 } split //, $s;\n    my $p = $r eq reverse $r;\n    return [$r, $p];\n\
    }", "    my @s = split //, $s;\n    my @c = split //, $c;\n    my %c = map { $_\
    \ => 1 } @c;\n    my @r;\n    for my $i (0 .. $#s) {\n        if (!$c{$s[$i]})\
    \ {\n            push @r, $s[$i];\n        }\n    }\n    my $r = join '', @r;\n\
    \    my $p = 1;\n    for my $i (0 .. $#r / 2) {\n        if ($r[$i] ne $r[$#r\
    \ - $i]) {\n            $p = 0;\n            last;\n        }\n    }\n    return\
    \ [$r, $p];\n}", "    my $r = $s;\n    $r =~ s/[$c]//g;\n    return [$r, $r eq\
    \ reverse $r];\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
