name: HumanEval_78_hex_key
language: pl
prompt: "# You have been tasked to write a function that receives \n# a hexadecimal\
  \ number as a string and counts the number of hexadecimal \n# digits that are primes\
  \ (prime number, or a prime, is a natural number \n# greater than 1 that is not\
  \ a product of two smaller natural numbers).\n# Hexadecimal digits are 0, 1, 2,\
  \ 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n# Prime numbers are 2, 3, 5, 7, 11, 13,\
  \ 17,...\n# So you have to determine a number of the following digits: 2, 3, 5,\
  \ 7, \n# B (=decimal 11), D (=decimal 13).\n# Note: you may assume the input is\
  \ always correct or empty string, \n# and symbols A,B,C,D,E,F are always uppercase.\n\
  # Examples:\n# >>> hex_key(\"AB\")\n# 1\n# >>> hex_key(\"1077E\")\n# 2\n# >>> hex_key(\"\
  ABED1A33\")\n# 4\n# >>> hex_key(\"123456789ABCDEF0\")\n# 6\n# >>> hex_key(\"2020\"\
  )\n# 2\nsub hex_key {\n    my($num) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&hex_key;\n\
  \        if(eq_deeply($candidate->(\"AB\"),1)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1077E\"),2)) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  ABED1A33\"),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n  \
  \      if(eq_deeply($candidate->(\"2020\"),2)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"123456789ABCDEF0\"\
  ),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  112233445566778899AABBCCDDEEFF00\"),12)) {\n        print \"ok!\" }else{\n     \
  \   exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @nums = split //, $num;\n    my $count = 0;\n    my %primes\
    \ = (\n        2 => 1,\n        3 => 1,\n        5 => 1,\n        7 => 1,\n  \
    \      11 => 1,\n        13 => 1,\n    );\n    foreach my $n (@nums) {\n     \
    \   if (exists $primes{$n}) {\n            $count++;\n        }\n    }\n    return\
    \ $count;\n}", "    my $count = 0;\n    my @primes = qw(2 3 5 7 B D);\n    my\
    \ %primes = map { $_ => 1 } @primes;\n    for my $digit (split //, $num) {\n \
    \       $count++ if exists $primes{$digit};\n    }\n    return $count;\n}", " \
    \   my $count = 0;\n    my @primes = qw(2 3 5 7 B D);\n    my %primes = map {$_\
    \ => 1} @primes;\n    for my $i (0..length($num)-1) {\n        my $digit = substr($num,\
    \ $i, 1);\n        $count++ if exists $primes{$digit};\n    }\n    return $count;\n\
    }", "    my $count = 0;\n    my @primes = qw(2 3 5 7 B D);\n    my @digits = split(//,\
    \ $num);\n    foreach my $digit (@digits) {\n        if (grep {$_ eq $digit} @primes)\
    \ {\n            $count++;\n        }\n    }\n    return $count;\n}", "    my\
    \ $count = 0;\n    my @primes = qw(2 3 5 7 B D);\n    my %primes = map { $_ =>\
    \ 1 } @primes;\n    for my $i (0 .. length($num) - 1) {\n        my $digit = substr($num,\
    \ $i, 1);\n        $count++ if exists $primes{$digit};\n    }\n    return $count;\n\
    }", "    my $count = 0;\n    my @primes = (2, 3, 5, 7, 11, 13);\n    my %primes\
    \ = map { $_ => 1 } @primes;\n    my @digits = split //, $num;\n    for my $digit\
    \ (@digits) {\n        if ($primes{$digit}) {\n            $count++;\n       \
    \ }\n    }\n    return $count;\n}", "    my $count = 0;\n    my @primes = qw(2\
    \ 3 5 7 B D);\n    my @digits = split(//, $num);\n    foreach my $digit (@digits)\
    \ {\n        if (grep {$_ eq $digit} @primes) {\n            $count++;\n     \
    \   }\n    }\n    return $count;\n}", "    my $count = 0;\n    my @primes = (2,\
    \ 3, 5, 7, 11, 13);\n    my %primes = map { $_ => 1 } @primes;\n    my @digits\
    \ = split //, $num;\n    for my $digit (@digits) {\n        $count++ if exists\
    \ $primes{$digit};\n    }\n    return $count;\n}", "    my $count = 0;\n    my\
    \ @primes = (2, 3, 5, 7, 11, 13);\n    my @hex = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11, 12, 13, 14, 15);\n    my %hex = map { $hex[$_] => $_ } 0 .. $#hex;\n\
    \    my @digits = split //, $num;\n    foreach my $digit (@digits) {\n       \
    \ if (grep { $hex{$_} eq $digit } @primes) {\n            $count++;\n        }\n\
    \    }\n    return $count;\n}", "    my $count = 0;\n    my @primes = qw(2 3 5\
    \ 7 B D);\n    my @nums = split(//, $num);\n    foreach my $n (@nums) {\n    \
    \    if (grep {$_ eq $n} @primes) {\n            $count++;\n        }\n    }\n\
    \    return $count;\n}", "    my $count = 0;\n    my @primes = (2, 3, 5, 7, 11,\
    \ 13);\n    my %hex = (\n        0 => 0, 1 => 1, 2 => 2, 3 => 3, 4 => 4, 5 =>\
    \ 5, 6 => 6, 7 => 7,\n        8 => 8, 9 => 9, A => 10, B => 11, C => 12, D =>\
    \ 13, E => 14, F => 15\n    );\n    my @digits = split(//, $num);\n    foreach\
    \ my $digit (@digits) {\n        if (grep {$_ == $hex{$digit}} @primes) {\n  \
    \          $count++;\n        }\n    }\n    return $count;\n}", "    my $count\
    \ = 0;\n    my @primes = qw(2 3 5 7 B D);\n    my @digits = split //, $num;\n\
    \    foreach my $digit (@digits) {\n        if (grep {$_ eq $digit} @primes) {\n\
    \            $count++;\n        }\n    }\n    return $count;\n}", "    my $count\
    \ = 0;\n    my @primes = qw(2 3 5 7 B D);\n    my @digits = split(//, $num);\n\
    \    foreach my $digit (@digits) {\n        if (grep {$_ eq $digit} @primes) {\n\
    \            $count++;\n        }\n    }\n    return $count;\n}", "    my $count\
    \ = 0;\n    my @hex = split(//, $num);\n    for my $h (@hex) {\n        if ($h\
    \ =~ /[2357BD]/) {\n            $count++;\n        }\n    }\n    return $count;\n\
    }", "    my $count = 0;\n    my @hex = split(//, $num);\n    foreach my $hex (@hex)\
    \ {\n        if ($hex eq '2' || $hex eq '3' || $hex eq '5' || $hex eq '7' || $hex\
    \ eq 'B' || $hex eq 'D') {\n            $count++;\n        }\n    }\n    return\
    \ $count;\n}", "    my $count = 0;\n    my @hex = (0,1,2,3,4,5,6,7,8,9,'A','B','C','D','E','F');\n\
    \    my @prime = (2,3,5,7,11,13);\n    my @num = split(//,$num);\n    foreach\
    \ my $n (@num) {\n        foreach my $p (@prime) {\n            if ($n eq $p)\
    \ {\n                $count++;\n            }\n        }\n    }\n    return $count;\n\
    }", "    my $count = 0;\n    my @hex = split(//, $num);\n    foreach my $hex (@hex)\
    \ {\n        if ($hex =~ /[2357BD]/) {\n            $count++;\n        }\n   \
    \ }\n    return $count;\n}", "    my @primes = qw(2 3 5 7 B D);\n    my $count\
    \ = 0;\n    for my $i (0..length($num)-1) {\n        my $c = substr($num, $i,\
    \ 1);\n        for my $p (@primes) {\n            if ($c eq $p) {\n          \
    \      $count++;\n                last;\n            }\n        }\n    }\n   \
    \ return $count;\n}", "    my $count = 0;\n    my @primes = qw(2 3 5 7 B D);\n\
    \    my @digits = split //, $num;\n    foreach my $digit (@digits) {\n       \
    \ if (grep {$_ eq $digit} @primes) {\n            $count++;\n        }\n    }\n\
    \    return $count;\n}", "    my $count = 0;\n    my @hex = split(//, $num);\n\
    \    foreach my $hex (@hex) {\n        if ($hex =~ /[2357BD]/) {\n           \
    \ $count++;\n        }\n    }\n    return $count;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
