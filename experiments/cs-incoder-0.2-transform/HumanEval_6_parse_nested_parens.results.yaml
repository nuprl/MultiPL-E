language: cs
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        long level = 0;\n        bool inParen =\
    \ false;\n        foreach (char c in paren_string) {\n            if (c == '(')\
    \ {\n                inParen = true;\n                stack.Add(level);\n    \
    \            level++;\n            } else if (c == ')') {\n                inParen\
    \ = false;\n                level--;\n                if (level == 0)\n      \
    \              levels.Add(stack.Last());\n            } else if (c == ' ') {\n\
    \                if (inParen)\n                    level--;\n            }\n \
    \       }\n        return levels;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpmae860w8.cs(22,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> max_levels = new List<long>();\n       \
    \ Stack<long> levels = new Stack<long>();\n        bool in_paren = false;\n  \
    \      foreach (char c in paren_string) {\n            if (c == '(') {\n     \
    \           in_paren = true;\n                levels.Push(1);\n            } else\
    \ if (c == ')') {\n                in_paren = false;\n                long level\
    \ = levels.Pop();\n                if (level > max_levels.Last()) {\n        \
    \            max_levels.Add(level);\n                }\n            } else if\
    \ (in_paren) {\n                levels.Push(level + 1);\n            }\n     \
    \   }\n        return max_levels;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp55s_sqv7.cs(29,29): error CS0103: The name ''level'' does not exist in
    the current context

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        long level = 0;\n        bool inParen =\
    \ false;\n        foreach (char c in paren_string) {\n            if (c == '(')\
    \ {\n                inParen = true;\n                stack.Add(level);\n    \
    \            level++;\n            } else if (c == ')') {\n                inParen\
    \ = false;\n                level -= stack.Pop();\n            } else if (inParen)\
    \ {\n                level += 1;\n            }\n        }\n        levels.Add(level);\n\
    \        return levels;\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp4unn2rb_.cs(22,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> max_levels = new List<long>();\n       \
    \ Stack<long> levels = new Stack<long>();\n        long level = 0;\n        bool\
    \ inParen = false;\n        bool inBrace = false;\n        bool inBracket = false;\n\
    \        bool inBraceOrBracket = false;\n        bool inBraceOrBracketOrParen\
    \ = false;\n        bool inBraceOrBracketOrParenOrBrace = false;\n        bool\
    \ inBraceOrBracketOrParenOrBraceOrBracket = false;\n        bool inBraceOrBracketOrParenOrBraceOrBracketOrParen\
    \ = false;\n        bool inBraceOrBracketOrParenOrBraceOrBracketOrParenOrBrace\
    \ = false;\n        bool inBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracket\
    \ = false;\n        bool inBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParen\
    \ = false;\n        bool inBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParenOrBrace\
    \ = false;\n        bool inBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracket\
    \ = false;\n        bool inBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParen\
    \ = false;\n        bool inBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParenOrBrace\
    \ = false;\n        bool inBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracket\
    \ = false;\n        bool inBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParen\
    \ = false;\n        bool inBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParen\
    \ = false;\n        bool inBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParenOrBraceOrBracketOrParen\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpdc8zr386.cs(36,129): error CS1002: ; expected

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> result = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        StringBuilder sb = new StringBuilder();\n\
    \        bool inside_group = false;\n        foreach (char c in paren_string)\
    \ {\n            if (c == '(') {\n                inside_group = true;\n     \
    \           sb.Append(c);\n            }\n            else if (c == ')') {\n \
    \               inside_group = false;\n                long level = 0;\n     \
    \           while (!stack.IsEmpty) {\n                    level++;\n         \
    \           stack.Pop();\n                }\n                result.Add(level);\n\
    \                sb.Append(c);\n            }\n            else if (inside_group)\
    \ {\n                sb.Append(c);\n            }\n        }\n        result.Add(sb.Length);\n\
    \        return result;\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp27gh8rot.cs(27,31): error CS1061: ''Stack<long>'' does not contain a definition
    for ''IsEmpty'' and no accessible extension method ''IsEmpty'' accepting a first
    argument of type ''Stack<long>'' could be found (are you missing a using directive
    or an assembly reference?)

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        StringBuilder sb = new StringBuilder();\n\
    \        bool in_paren = false;\n        bool in_group = false;\n        bool\
    \ in_group_open = false;\n        bool in_group_close = false;\n        bool in_group_open2\
    \ = false;\n        bool in_group_close2 = false;\n        bool in_group_open3\
    \ = false;\n        bool in_group_close3 = false;\n        bool in_group_open4\
    \ = false;\n        bool in_group_close4 = false;\n        bool in_group_open5\
    \ = false;\n        bool in_group_close5 = false;\n        bool in_group_open6\
    \ = false;\n        bool in_group_close6 = false;\n        bool in_group_open7\
    \ = false;\n        bool in_group_close7 = false;\n        bool in_group_open8\
    \ = false;\n        bool in_group_close8 = false;\n        bool in_group_open9\
    \ = false;\n        bool in_group_close9 = false;\n        bool in_group_open10\
    \ = false;\n        bool in_group_close10 = false;\n        bool in_group_open11\
    \ = false;\n        bool in_group_close11 = false;\n        bool in_group_open12\
    \ = false;\n        bool in_group_close12 = false;\n        bool in_group_open13\
    \ = false;\n        bool in_group_close13 = false;\n        bool in_group_open14\
    \ = false;\n        bool in_group_close14 = false;\n        bool in_group_open15\
    \ = false;\n        bool in_group_close15 = false;\n        bool in_group_open16\
    \ = false;\n        bool in_group_close16 = false;\n        bool in_group_open17\
    \ = false;\n        bool in_group_close17 = false;\n        bool in_group_open18\
    \ = false;\n        bool in_group_close18 = false;\n        bool in_group_open19\
    \ = false;\n        bool in_group_close19 = false;\n        bool in_group_open20\
    \ = false;\n        bool in_group_close20 = false;\n        bool in_group_open21\
    \ = false;\n        bool in_group_close21 = false;\n        bool in_group_open22\
    \ = false;\n        bool in_group_close22 = false;\n        bool in_group_open23\
    \ = false;\n        bool in_group_close23 = false;\n        bool in_group_open24\
    \ = false;\n        bool in_group_close24 = false;\n        bool in_group_open25\
    \ = false;\n        bool in_group_close25 = false;\n        bool in_group_open26\
    \ = false;\n        bool in_group_close26 = false;\n        bool in_group_open27\
    \ = false;\n        bool in_group_close27 = false;\n        bool in_group_open28\
    \ = false;\n        bool in_group_close28 = false;\n        bool in_group_open29\
    \ = false;\n        bool in_group_close29 = false;\n        bool in_group_open\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpc7yz6cxi.cs(78,27): error CS1002: ; expected

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> max_levels = new List<long>();\n       \
    \ Stack<long> levels = new Stack<long>();\n        bool in_paren = false;\n  \
    \      bool in_group = false;\n        bool in_group2 = false;\n        bool in_group3\
    \ = false;\n        bool in_group4 = false;\n        bool in_group5 = false;\n\
    \        bool in_group6 = false;\n        bool in_group7 = false;\n        bool\
    \ in_group8 = false;\n        bool in_group9 = false;\n        bool in_group10\
    \ = false;\n        bool in_group11 = false;\n        bool in_group12 = false;\n\
    \        bool in_group13 = false;\n        bool in_group14 = false;\n        bool\
    \ in_group15 = false;\n        bool in_group16 = false;\n        bool in_group17\
    \ = false;\n        bool in_group18 = false;\n        bool in_group19 = false;\n\
    \        bool in_group20 = false;\n        bool in_group21 = false;\n        bool\
    \ in_group22 = false;\n        bool in_group23 = false;\n        bool in_group24\
    \ = false;\n        bool in_group25 = false;\n        bool in_group26 = false;\n\
    \        bool in_group27 = false;\n        bool in_group28 = false;\n        bool\
    \ in_group29 = false;\n        bool in_group30 = false;\n        bool in_group31\
    \ = false;\n        bool in_group32 = false;\n        bool in_group33 = false;\n\
    \        bool in_group34 = false;\n        bool in_group35 = false;\n        bool\
    \ in_group36 = false;\n        bool in_group37 = false;\n        bool in_group38\
    \ = false;\n        bool in_group39 = false;\n        bool in_group40 = false;\n\
    \        bool in_group41 = false;\n        bool in_group42 = false;\n        bool\
    \ in_group43 = false;\n        bool in_group44 = false;\n        bool in_group45\
    \ = false;\n        bool in_group46 = false;\n        bool in_group47 = false;\n\
    \        bool in_group48 = false;\n        bool in_group49 = false;\n        bool\
    \ in_group50 = false;\n        bool in_group51 = false;\n        bool in_group52\
    \ = false;\n        bool in_group53 = false;\n        bool in_group54 = false;\n\
    \        bool in_group55 = false;\n        bool in_group56 = false;\n        bool\
    \ in_group57 = false;\n        bool in_group58 = false;\n        bool in_group59\
    \ = false;\n        bool in_group60 = false;\n        bool in_group61 = false;\n\
    \        bool in_group62 = false;\n        bool in_group63 = false;\n        bool\
    \ in_group64 = false;\n        bool in_group65 = false;\n        bool in_group66\
    \ = false;\n        bool in_group67 = false;\n        bool \n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp90pebf_1.cs(85,13): error CS1001: Identifier expected

    /tmp/tmp90pebf_1.cs(85,13): error CS1002: ; expected

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> result = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        foreach (char c in paren_string) {\n   \
    \         if (c == '(') {\n                stack.Add(0);\n            } else if\
    \ (c == ')') {\n                long max_level = stack.Peek();\n             \
    \   if (max_level > result.Count) {\n                    result.AddRange(Enumerable.Repeat(max_level,\
    \ max_level));\n                }\n                stack.Pop();\n            }\
    \ else {\n                long level = stack.Peek();\n                stack.Pop();\n\
    \                result.Add(level + 1);\n            }\n        }\n        return\
    \ result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpubp4nknl.cs(19,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpubp4nknl.cs(23,66): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        // Initialize a stack to store all levels of nesting.\n\
    \        Stack<long> levels = new Stack<long>();\n        // Initialize a dictionary\
    \ to store all levels of nesting indexed by their depth.\n        Dictionary<long,\
    \ long> level_index = new Dictionary<long, long>();\n        // Initialize a dictionary\
    \ to store all levels of nesting indexed by their depth.\n        Dictionary<long,\
    \ long> level_index_reverse = new Dictionary<long, long>();\n        // Initialize\
    \ a dictionary to store all levels of nesting indexed by their depth.\n      \
    \  Dictionary<long, long> level_index_reverse2 = new Dictionary<long, long>();\n\
    \        // Initialize a dictionary to store all levels of nesting indexed by\
    \ their depth.\n        Dictionary<long, long> level_index_reverse3 = new Dictionary<long,\
    \ long>();\n        // Initialize a dictionary to store all levels of nesting\
    \ indexed by their depth.\n        Dictionary<long, long> level_index_reverse4\
    \ = new Dictionary<long, long>();\n        // Initialize a dictionary to store\
    \ all levels of nesting indexed by their depth.\n        Dictionary<long, long>\
    \ level_index_reverse5 = new Dictionary<long, long>();\n        // Initialize\
    \ a dictionary to store all levels of nesting indexed by their depth.\n      \
    \  Dictionary<long, long> level_index_reverse6 = new Dictionary<long, long>();\n\
    \        // Initialize a dictionary to store all levels of nesting indexed by\
    \ their depth.\n        Dictionary<long, long> level_index_reverse7 = new Dictionary<long,\
    \ long>();\n        // Initialize a dictionary to store all levels of nesting\
    \ indexed by their depth.\n        Dictionary<long, long> level_index_reverse8\
    \ = new Dictionary<long, long>();\n        // Initialize a dictionary to store\
    \ all levels of nesting indexed by their depth.\n        Dictionary<long, long>\
    \ level_index_reverse9 = new Dictionary<long, long>();\n        // Initialize\
    \ a dictionary to store all levels of nesting indexed by their depth.\n      \
    \  Dictionary<long, long> level_index_reverse10 = new Dictionary<long, long>();\n\
    \        // Initialize a dictionary to store all levels of nesting indexed by\
    \ their depth.\n        Dictionary<long, long> level_index_reverse11 = new Dictionary<long,\
    \ long>();\n        // Initialize a dictionary to store all levels of nesting\
    \ indexed by their depth.\n        Dictionary<long, long> level_index_reverse12\
    \ = new Dictionary<long, long>();\n        // Initialize a dictionary to store\
    \ all levels of nesting indexed by their depth.\n        Dictionary<long, long>\
    \ level_index_reverse13 = new Dictionary<long, long>();\n        // Initialize\
    \ a dictionary to store all levels of nesting indexed by their depth\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp0hyzquuj.cs(14,30): error CS0161: ''Problem.ParseNestedParens(string)'':
    not all code paths return a value

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> result = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        StringBuilder sb = new StringBuilder();\n\
    \        bool in_paren = false;\n        bool in_brace = false;\n        bool\
    \ in_brace2 = false;\n        bool in_brace3 = false;\n        bool in_brace4\
    \ = false;\n        bool in_brace5 = false;\n        bool in_brace6 = false;\n\
    \        bool in_brace7 = false;\n        bool in_brace8 = false;\n        bool\
    \ in_brace9 = false;\n        bool in_brace10 = false;\n        bool in_brace11\
    \ = false;\n        bool in_brace12 = false;\n        bool in_brace13 = false;\n\
    \        bool in_brace14 = false;\n        bool in_brace15 = false;\n        bool\
    \ in_brace16 = false;\n        bool in_brace17 = false;\n        bool in_brace18\
    \ = false;\n        bool in_brace19 = false;\n        bool in_brace20 = false;\n\
    \        bool in_brace21 = false;\n        bool in_brace22 = false;\n        bool\
    \ in_brace23 = false;\n        bool in_brace24 = false;\n        bool in_brace25\
    \ = false;\n        bool in_brace26 = false;\n        bool in_brace27 = false;\n\
    \        bool in_brace28 = false;\n        bool in_brace29 = false;\n        bool\
    \ in_brace30 = false;\n        bool in_brace31 = false;\n        bool in_brace32\
    \ = false;\n        bool in_brace33 = false;\n        bool in_brace34 = false;\n\
    \        bool in_brace35 = false;\n        bool in_brace36 = false;\n        bool\
    \ in_brace37 = false;\n        bool in_brace38 = false;\n        bool in_brace39\
    \ = false;\n        bool in_brace40 = false;\n        bool in_brace41 = false;\n\
    \        bool in_brace42 = false;\n        bool in_brace43 = false;\n        bool\
    \ in_brace44 = false;\n        bool in_brace45 = false;\n        bool in_brace46\
    \ = false;\n        bool in_brace47 = false;\n        bool in_brace48 = false;\n\
    \        bool in_brace49 = false;\n        bool in_brace50 = false;\n        bool\
    \ in_brace51 = false;\n        bool in_brace52 = false;\n        bool in_brace53\
    \ = false;\n        bool in_brace54 = false;\n        bool in_brace55 = false;\n\
    \        bool in_brace56 = false;\n        bool in_brace57 = false;\n        bool\
    \ in_brace58 = false;\n        bool in_brace59 = false;\n        bool in_brace60\
    \ = false;\n        bool in_brace61 = false;\n        bool in_brace62 = false;\n\
    \        bool in_brace63 = false;\n        bool in_brace64 = false;\n        bool\
    \ in_brace65 = false;\n        bool in_brace66 = false;\n        \n    }\n   \
    \ public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpj573v1lc.cs(18,14): warning CS0219: The variable ''in_paren'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(19,14): warning CS0219: The variable ''in_brace'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(20,14): warning CS0219: The variable ''in_brace2'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(21,14): warning CS0219: The variable ''in_brace3'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(22,14): warning CS0219: The variable ''in_brace4'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(23,14): warning CS0219: The variable ''in_brace5'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(24,14): warning CS0219: The variable ''in_brace6'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(25,14): warning CS0219: The variable ''in_brace7'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(26,14): warning CS0219: The variable ''in_brace8'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(27,14): warning CS0219: The variable ''in_brace9'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(28,14): warning CS0219: The variable ''in_brace10'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(29,14): warning CS0219: The variable ''in_brace11'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(30,14): warning CS0219: The variable ''in_brace12'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(31,14): warning CS0219: The variable ''in_brace13'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(32,14): warning CS0219: The variable ''in_brace14'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(33,14): warning CS0219: The variable ''in_brace15'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(34,14): warning CS0219: The variable ''in_brace16'' is assigned
    but its value is never used

    /tmp/tmpj573v1lc.cs(35,14): warning CS0219: The variable ''in_br'
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> max_levels = new List<long>();\n       \
    \ Stack<long> levels = new Stack<long>();\n        bool in_paren = false;\n  \
    \      foreach (char c in paren_string) {\n            if (c == '(') {\n     \
    \           in_paren = true;\n                levels.Push(1);\n            } else\
    \ if (c == ')') {\n                in_paren = false;\n                long level\
    \ = levels.Pop();\n                if (level > max_levels.Last()) {\n        \
    \            max_levels.Add(level);\n                }\n            } else if\
    \ (in_paren) {\n                levels.Push(level + 1);\n            }\n     \
    \   }\n        return max_levels;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp55s_sqv7.cs(29,29): error CS0103: The name ''level'' does not exist in
    the current context

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> result = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        long level = 0;\n        foreach (char c\
    \ in paren_string) {\n            if (c == '(') {\n                stack.Add(level);\n\
    \                level++;\n            } else if (c == ')') {\n              \
    \  level--;\n                if (level == 0)\n                    result.Add(stack.Pop());\n\
    \            }\n        }\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpen6gekib.cs(20,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>();\n        Stack<long>\
    \ levels_stack = new Stack<long>();\n        string current_level = \"\";\n  \
    \      bool in_paren = false;\n        foreach (char c in paren_string) {\n  \
    \          if (c == '(') {\n                if (in_paren) {\n                \
    \    levels_stack.Push(current_level);\n                    in_paren = false;\n\
    \                }\n                else {\n                    in_paren = true;\n\
    \                }\n            }\n            else if (c == ')') {\n        \
    \        if (in_paren) {\n                    levels_stack.Pop();\n          \
    \          in_paren = false;\n                }\n                else {\n    \
    \                in_paren = true;\n                }\n            }\n        \
    \    else if (in_paren) {\n                current_level += c;\n            }\n\
    \            else {\n                levels_stack.Push(current_level);\n     \
    \           current_level = \"\";\n            }\n        }\n        if (levels_stack.Count\
    \ > 0) {\n            levels_stack.Pop();\n        }\n        levels.AddRange(levels_stack);\n\
    \        return levels;\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp7ozxvkk9.cs(22,39): error CS1503: Argument 1: cannot convert from ''string''
    to ''long''

    /tmp/tmp7ozxvkk9.cs(42,35): error CS1503: Argument 1: cannot convert from ''string''
    to ''long''

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        bool in_paren = false;\n        long level\
    \ = 0;\n        foreach (char c in paren_string) {\n            if (c == '(')\
    \ {\n                in_paren = true;\n                stack.Add(level);\n   \
    \         } else if (c == ')') {\n                in_paren = false;\n        \
    \        level = (long)Math.Max(stack.Pop(), level);\n            } else if (in_paren)\
    \ {\n                level++;\n            }\n            levels.Add(level);\n\
    \        }\n        return levels;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpxs8bwong.cs(22,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659798134
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        foreach (char c in paren_string) {\n   \
    \         if (c == '(') {\n                stack.Push(1);\n            } else\
    \ if (c == ')') {\n                long level = stack.Pop();\n               \
    \ while (level > 0) {\n                    levels.Add(level);\n              \
    \      level--;\n                }\n            }\n        }\n        return levels;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <1d4cc19a040841a9be113df7d44dca21>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <1d4cc19a040841a9be113df7d44dca21>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659798023
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> result = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        foreach (char c in paren_string) {\n   \
    \         if (c == '(') {\n                stack.Add(0);\n            } else if\
    \ (c == ')') {\n                long level = stack.Pop();\n                if\
    \ (level > result.Count) {\n                    result.AddRange(Enumerable.Range(0,\
    \ level).Select(i => 0L));\n                }\n                result.Add(level);\n\
    \            }\n        }\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L,\
    \ (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\"\
    )).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
    \ long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpmpfju6ww.cs(19,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpmpfju6ww.cs(23,57): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        StringBuilder sb = new StringBuilder();\n\
    \        foreach (char c in paren_string) {\n            if (c == '(') {\n   \
    \             stack.Add(0);\n            } else if (c == ')') {\n            \
    \    long level = stack.Pop();\n                while (level > 0) {\n        \
    \            levels.Add(level);\n                    level--;\n              \
    \  }\n            } else if (c == '(') {\n                stack.Add(1);\n    \
    \        } else if (c == ')') {\n                long level = stack.Pop();\n \
    \               while (level > 0) {\n                    levels.Add(level);\n\
    \                    level--;\n                }\n            } else if (c ==\
    \ '[') {\n                stack.Add(2);\n            } else if (c == ']') {\n\
    \                long level = stack.Pop();\n                while (level > 0)\
    \ {\n                    levels.Add(level);\n                    level--;\n  \
    \              }\n            } else if (c == '{') {\n                stack.Add(3);\n\
    \            } else if (c == '}') {\n                long level = stack.Pop();\n\
    \                while (level > 0) {\n                    levels.Add(level);\n\
    \                    level--;\n                }\n            }\n            sb.Append(c);\n\
    \        }\n        long level = stack.Pop();\n        while (level > 0) {\n \
    \           levels.Add(level);\n            level--;\n        }\n        return\
    \ levels;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp21wtm5n2.cs(20,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmp21wtm5n2.cs(22,22): error CS0136: A local or parameter named ''level''
    cannot be declared in this scope because that name is used in an enclosing local
    scope to define a local or parameter

    /tmp/tmp21wtm5n2.cs(28,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmp21wtm5n2.cs(30,22): error CS0136: A local or parameter named ''level''
    cannot be declared in this scope because that name is used in an enclosing local
    scope to define a local or parameter

    /tmp/tmp21wtm5n2.cs(36,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmp21wtm5n2.cs(38,22): error CS0136: A local or parameter named ''level''
    cannot be declared in this scope because that name is used in an enclosing local
    scope to define a local or parameter

    /tmp/tmp21wtm5n2.cs(44,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmp21wtm5n2.cs(46,22): error CS0136: A local or parameter named ''level''
    cannot be declared in this scope because that name is used in an enclosing local
    scope to define a local or parameter

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        long level = 0;\n        bool in_paren =\
    \ false;\n        foreach (char c in paren_string) {\n            if (c == '(')\
    \ {\n                in_paren = true;\n                stack.Add(level);\n   \
    \         } else if (c == ')') {\n                in_paren = false;\n        \
    \        level = (long)Math.Max(stack.Pop(), level);\n            } else if (c\
    \ == ' ') {\n                level++;\n            } else if (c == '(') {\n  \
    \              level++;\n            } else if (c == ')') {\n                level--;\n\
    \            }\n        }\n        levels.Add(level);\n        return levels;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
    (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
    \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
    \ (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new\
    \ List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpjf3uc6f8.cs(22,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    /tmp/tmpjf3uc6f8.cs(18,14): warning CS0219: The variable ''in_paren'' is assigned
    but its value is never used

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> levels = new List<long>();\n        Stack<long>\
    \ stack = new Stack<long>();\n        StringBuilder sb = new StringBuilder();\n\
    \        bool in_paren = false;\n        foreach (char c in paren_string) {\n\
    \            if (c == '(') {\n                in_paren = true;\n             \
    \   stack.Add(0);\n            }\n            if (c == ')') {\n              \
    \  in_paren = false;\n                long level = stack.Pop();\n            \
    \    while (level > 0) {\n                    level--;\n                    stack.Push(level);\n\
    \                }\n            }\n            if (in_paren) {\n             \
    \   sb.Append(c);\n            }\n        }\n        string s = sb.ToString();\n\
    \        char[] chars = s.ToCharArray();\n        List<long> result = new List<long>();\n\
    \        foreach (char c in chars) {\n            if (c == '(') {\n          \
    \      result.Add(0);\n            }\n            if (c == ')') {\n          \
    \      long level = stack.Pop();\n                while (level > 0) {\n      \
    \              level--;\n                    stack.Push(level);\n            \
    \    }\n            }\n            result.Add(result.Last() + 1);\n        }\n\
    \        return result;\n    }\n    public static void Main(string[] args) {\n\
    \    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\")).Equals((new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"\
    () (()) ((())) (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"(()(())((())))\"\
    )).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpsrtf1css.cs(22,23): error CS1061: ''Stack<long>'' does not contain a definition
    for ''Add'' and no accessible extension method ''Add'' accepting a first argument
    of type ''Stack<long>'' could be found (are you missing a using directive or an
    assembly reference?)

    '
  timestamp: 1659798134
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string\
    \ paren_string) {\n        List<long> max_levels = new List<long>();\n       \
    \ Stack<long> levels = new Stack<long>();\n        bool in_paren = false;\n  \
    \      foreach (char c in paren_string) {\n            if (c == '(') {\n     \
    \           in_paren = true;\n                levels.Push(1);\n            } else\
    \ if (c == ')') {\n                in_paren = false;\n                long level\
    \ = levels.Pop();\n                if (level > max_levels.Last()) {\n        \
    \            max_levels.Add(level);\n                }\n            } else if\
    \ (in_paren) {\n                levels.Push(levels.Pop() + 1);\n            }\n\
    \        }\n        return max_levels;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(ParseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))));\n\
    \    Debug.Assert(ParseNestedParens((\"() (()) ((())) (((())))\")).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(ParseNestedParens((\"\
    (()(())((())))\")).Equals((new List<long>(new long[]{(long)4L}))));\n    }\n\n\
    }\n"
  status: OK
  stderr: "\nUnhandled Exception:\nSystem.InvalidOperationException: Sequence contains\
    \ no elements\n  at System.Linq.Enumerable.Last[TSource] (System.Collections.Generic.IEnumerable`1[T]\
    \ source) [0x00010] in <e540098dd111461e919c5863f6975c29>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00054] in <23388d07fc644a2ea7210e949382189c>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <23388d07fc644a2ea7210e949382189c>:0\
    \ \n[ERROR] FATAL UNHANDLED EXCEPTION: System.InvalidOperationException: Sequence\
    \ contains no elements\n  at System.Linq.Enumerable.Last[TSource] (System.Collections.Generic.IEnumerable`1[T]\
    \ source) [0x00010] in <e540098dd111461e919c5863f6975c29>:0 \n  at Problem.ParseNestedParens\
    \ (System.String paren_string) [0x00054] in <23388d07fc644a2ea7210e949382189c>:0\
    \ \n  at Problem.Main (System.String[] args) [0x00001] in <23388d07fc644a2ea7210e949382189c>:0\
    \ \n"
  stdout: ''
  timestamp: 1659798135
