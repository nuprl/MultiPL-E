language: cs
name: HumanEval_116_sort_array
results:
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            else\
    \ if (i == 0L) {\n                zeros++;\n            }\n            else {\n\
    \                if (ones > zeros) {\n                    max = i;\n         \
    \       }\n                else {\n                    max = zeros;\n        \
    \        }\n            }\n        }\n        List<long> res = new List<long>();\n\
    \        foreach (long i in arr) {\n            if (i == 1L) {\n             \
    \   res.Add(i);\n            }\n            else if (i == 0L) {\n            \
    \    res.Add(max);\n            }\n            else {\n                if (ones\
    \ > zeros) {\n                    res.Add(i);\n                }\n           \
    \     else {\n                    res.Add(max);\n                }\n         \
    \   }\n        }\n        return res;\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <9ea1d621897348a49366b95d78a0afb3>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <9ea1d621897348a49366b95d78a0afb3>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659795182
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones * max;\n        long zerosMax = zeros * max;\n        long maxOnesMax\
    \ = onesMax * max;\n        long maxZerosMax = zerosMax * max;\n        long maxOnesZeros\
    \ = ones * zerosMax;\n        long maxZerosOnes = zeros * onesMax;\n        long\
    \ maxOnesZerosMax = onesMax * zerosMax;\n        long maxZerosOnesMax = zerosMax\
    \ * onesMax;\n        long maxOnesZerosZeros = ones * zerosMax * zerosMax;\n \
    \       long maxZerosOnesZeros = zerosMax * onesMax * zerosMax;\n        long\
    \ maxOnesZerosZerosMax = onesMax * zerosMax * zerosMax;\n        long maxZerosOnesZerosMax\
    \ = zerosMax * onesMax * zerosMax;\n        long maxOnesZerosZerosZeros = ones\
    \ * zerosMax * zerosMax * zerosMax;\n        long maxZerosOnesZerosZeros = zerosMax\
    \ * onesMax * zerosMax * zerosMax;\n        long maxOnesZerosZerosZerosMax = onesMax\
    \ * zerosMax * zerosMax * zerosMax;\n        long maxZerosOnesZerosZerosMax =\
    \ zerosMax * onesMax * zerosMax * zerosMax;\n        long maxOnesZerosZerosZerosZeros\
    \ = ones * zerosMax * zerosMax * zerosMax * zerosMax;\n        long maxZerosOnesZerosZerosZeros\
    \ = zerosMax * onesMax * zerosMax * zerosMax * zerosMax;\n        long maxOnesZerosZerosZerosZerosMax\
    \ = onesMax * zerosMax * zerosMax * zerosMax * zerosMax;\n        long maxZerosOnesZerosZerosZerosMax\
    \ = zerosMax * onesMax * zerosMax * zerosMax * zerosMax;\n        long max\n \
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpj5wy75q0.cs(54,17): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: -1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            long onesMax =\
    \ ones;\n            long zerosMax = zeros;\n            while (onesMax > zerosMax)\
    \ {\n                result.Add(max);\n                zerosMax--;\n         \
    \   }\n            while (zerosMax < onesMax) {\n                result.Add(max);\n\
    \                onesMax--;\n            }\n        }\n        else {\n      \
    \      long zerosMax = zeros;\n            long onesMax = ones;\n            while\
    \ (zerosMax < onesMax) {\n                result.Add(max);\n                zerosMax--;\n\
    \            }\n            while (onesMax < zerosMax) {\n                result.Add(max);\n\
    \                onesMax--;\n            }\n        }\n        return result;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Timeout
  stderr: ''
  stdout: None
  timestamp: 1659795187
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long n in arr) {\n     \
    \       ones += n;\n            zeros += (long)Math.Abs(n);\n            if (n\
    \ > max) {\n                max = n;\n            }\n        }\n        long onesMax\
    \ = ones;\n        long zerosMax = zeros;\n        long onesMin = ones;\n    \
    \    long zerosMin = zeros;\n        long onesCurr = ones;\n        long zerosCurr\
    \ = zeros;\n        long onesNext = ones;\n        long zerosNext = zeros;\n \
    \       long onesPrev = ones;\n        long zerosPrev = zeros;\n        long onesCurrPrev\
    \ = ones;\n        long zerosCurrPrev = zeros;\n        long onesNextPrev = ones;\n\
    \        long zerosNextPrev = zeros;\n        long onesPrevPrev = ones;\n    \
    \    long zerosPrevPrev = zeros;\n        long onesNextNext = ones;\n        long\
    \ zerosNextNext = zeros;\n        long onesPrevNext = ones;\n        long zerosPrevNext\
    \ = zeros;\n        long onesPrevNextPrev = ones;\n        long zerosPrevNextPrev\
    \ = zeros;\n        long onesPrevNextNext = ones;\n        long zerosPrevNextNext\
    \ = zeros;\n        long onesPrevNextNextPrev = ones;\n        long zerosPrevNextNextPrev\
    \ = zeros;\n        long onesPrevNextNextNext = ones;\n        long zerosPrevNextNextNext\
    \ = zeros;\n        long onesPrevNextNextNextPrev = ones;\n        long zerosPrevNextNextNextPrev\
    \ = zeros;\n        long onesPrevNextNextNextNext = ones;\n        long zerosPrevNextNextNextNext\
    \ = zeros;\n        long onesPrevNextNextNextNextPrev = ones;\n        long zerosPrevNextNextNextNextPrev\
    \ = zeros;\n        long onesPrevNextNextNextNextNext = ones;\n        long zerosPrevNextNextNextNextNext\
    \ = zeros;\n        long onesPrevNextNextNextNextNextPrev = ones;\n        long\
    \ zerosPrevNextNextNextNextNextPrev = zeros;\n        long onesPrevNextNextNextNextNextNext\
    \ = ones;\n        long zerosPrevNextNextNextNextNextNext = zeros;\n        long\
    \ onesPrevNextNextNextNextNextNextPrev = ones;\n        long zerosPrevNextNextNextNextNextNextPrev\
    \ = zeros;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpdwiuc2_u.cs(19,30): error CS0161: ''Problem.SortArray(List<long>)'': not
    all code paths return a value

    '
  timestamp: 1659795182
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   }\n            else if (i == 0L) {\n                zeros++;\n           \
    \ }\n            else {\n                max = Math.Max(max, i);\n           \
    \     min = Math.Min(min, i);\n            }\n        }\n        long onesCount\
    \ = 0;\n        long zerosCount = 0;\n        long maxCount = 0;\n        long\
    \ minCount = 0;\n        foreach (long i in arr) {\n            if (i == 1L) {\n\
    \                onesCount++;\n            }\n            else if (i == 0L) {\n\
    \                zerosCount++;\n            }\n            else {\n          \
    \      maxCount = Math.Max(maxCount, i);\n                minCount = Math.Min(minCount,\
    \ i);\n            }\n        }\n        long onesDecimal = 0;\n        long zerosDecimal\
    \ = 0;\n        long maxDecimal = 0;\n        long minDecimal = 0;\n        foreach\
    \ (long i in arr) {\n            if (i == 1L) {\n                onesDecimal++;\n\
    \            }\n            else if (i == 0L) {\n                zerosDecimal++;\n\
    \            }\n            else {\n                maxDecimal = Math.Max(maxDecimal,\
    \ i);\n                minDecimal = Math.Min(minDecimal, i);\n            }\n\
    \        }\n        long onesDecimalCount = 0;\n        long zerosDecimalCount\
    \ = 0;\n        long maxDecimalCount = 0;\n        long minDecimalCount = 0;\n\
    \        foreach (long i in arr) {\n            if (i == 1L) {\n             \
    \   onesDecimalCount++;\n            }\n            else if (i == 0L) {\n    \
    \            zerosDecimalCount++;\n            }\n            else {\n       \
    \         maxDecimalCount = Math.Max(maxDecimalCount, i);\n                minDecimalCount\
    \ = Math.Min(minDecimalCount, i);\n            }\n        }\n        long onesDecimalDecimal\
    \ = 0;\n        long zerosDecimalDecimal = 0;\n        long maxDecimalDecimal\
    \ = 0;\n        long minDecimalDecimal = 0;\n        foreach (long i in arr) {\n\
    \            if (i == 1L) {\n                onesDecimalDecimal++;\n         \
    \   }\n            else if (i == 0L) {\n                zerosDecimalDecimal++;\n\
    \            }\n            else {\n                maxDecimalDecimal = Math.Max(maxDecimalDecimal,\
    \ i);\n                minDecimalDecimal = Math.Min(minDecimalDecimal, i);\n \
    \           }\n        }\n        long onesDecimalDecimalCount = 0;\n        long\
    \ zerosDecimalDecimalCount = 0;\n        long maxDecimalDecimalCount = 0;\n  \
    \      long minDecimalDecimalCount = 0;\n        foreach (long i in arr) {\n \
    \           if (i == 1L) {\n                onesDecimalDecimalCount++;\n     \
    \       }\n            else if (i == 0L) {\n                zerosDecimalDecimalCount++;\n\
    \    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp8ktnflrt.cs(111,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp8ktnflrt.cs(122,2): error CS1513: } expected

    '
  timestamp: 1659795181
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            else\
    \ if (i == 0L) {\n                zeros++;\n            }\n            else {\n\
    \                if (ones > zeros) {\n                    max = i;\n         \
    \       }\n                else {\n                    max = i;\n            \
    \    }\n            }\n        }\n        List<long> result = new List<long>();\n\
    \        foreach (long i in arr) {\n            if (i == 1L) {\n             \
    \   result.Add(i);\n            }\n            else if (i == 0L) {\n         \
    \       result.Add(i);\n            }\n            else {\n                if\
    \ (ones > zeros) {\n                    result.Add(max);\n                }\n\
    \                else {\n                    result.Add(max);\n              \
    \  }\n            }\n        }\n        return result;\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <67ff08d3c8d042a492a2ba4447a0adb9>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <67ff08d3c8d042a492a2ba4447a0adb9>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659795182
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ n in arr) {\n            if (n == 1L) {\n                ones++;\n         \
    \   }\n            if (n == 0L) {\n                zeros++;\n            }\n \
    \           if (n > max) {\n                max = n;\n            }\n        \
    \    if (n < min) {\n                min = n;\n            }\n        }\n    \
    \    List<long> result = new List<long>();\n        if (ones > zeros) {\n    \
    \        result.Add(min);\n            result.AddRange(arr.Where(n => n == min).OrderBy(n\
    \ => n).Take(ones - 1));\n            result.AddRange(arr.Where(n => n == max).OrderBy(n\
    \ => n).Take(zeros - 1));\n        }\n        if (zeros > ones) {\n          \
    \  result.AddRange(arr.Where(n => n == max).OrderBy(n => n).Take(zeros - 1));\n\
    \            result.Add(max);\n            result.AddRange(arr.Where(n => n ==\
    \ min).OrderBy(n => n).Take(ones - 1));\n        }\n        if (ones > zeros)\
    \ {\n            result.AddRange(arr.Where(n => n == min).OrderBy(n => n).Take(ones\
    \ - 1));\n            result.AddRange(arr.Where(n => n == max).OrderBy(n => n).Take(zeros\
    \ - 1));\n        }\n        if (zeros > ones) {\n            result.AddRange(arr.Where(n\
    \ => n == min).OrderBy(n => n).Take(zeros - 1));\n            result.AddRange(arr.Where(n\
    \ => n == max).OrderBy(n => n).Take(ones - 1));\n        }\n        if (ones >\
    \ zeros) {\n            result.AddRange(arr.Where(n => n == min).OrderBy(n =>\
    \ n).Take(ones - 1));\n            result.AddRange(arr.Where(n => n == max).OrderBy(n\
    \ => n).Take(zeros - 1));\n        }\n        if (zeros > ones) {\n          \
    \  result.AddRange(arr.Where(n => n == min).OrderBy(n => n).Take(zeros - 1));\n\
    \            result.AddRange(arr.Where(n => n == max).OrderBy(n => n).Take(ones\
    \ - 1));\n        }\n        if (ones > zeros) {\n            result.AddRange(arr.Where(n\
    \ => n == min).OrderBy(n => n).Take(ones - 1));\n            result.AddRange(arr.Where(n\
    \ => n == max).OrderBy(n => n).Take(zeros - 1));\n        }\n        if (zeros\
    \ > ones) {\n            result.AddRange(arr.Where(n => n == min).OrderBy(n =>\
    \ n).Take(zeros - 1));\n            result.AddRange(arr.Where(n => n == \n   \
    \ }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpitv8i5zv.cs(71,48): error CS1525: Invalid expression term ''}''

    /tmp/tmpitv8i5zv.cs(71,48): error CS1026: ) expected

    /tmp/tmpitv8i5zv.cs(71,48): error CS1002: ; expected

    /tmp/tmpitv8i5zv.cs(73,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpitv8i5zv.cs(84,2): error CS1513: } expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   } else {\n                zeros++;\n            }\n            if (max < i)\
    \ {\n                max = i;\n            }\n            if (min > i) {\n   \
    \             min = i;\n            }\n        }\n        List<long> result =\
    \ new List<long>();\n        if (ones > zeros) {\n            result.Add(min);\n\
    \            result.AddRange(arr.Where(i => i == min).OrderBy(i => i).Take(ones\
    \ - 1).ToList());\n            result.Add(max);\n            result.AddRange(arr.Where(i\
    \ => i == max).OrderBy(i => i).Take(zeros - 1).ToList());\n        } else {\n\
    \            result.Add(max);\n            result.AddRange(arr.Where(i => i ==\
    \ max).OrderBy(i => i).Take(zeros - 1).ToList());\n            result.Add(min);\n\
    \            result.AddRange(arr.Where(i => i == min).OrderBy(i => i).Take(ones\
    \ - 1).ToList());\n        }\n        return result;\n    }\n    public static\
    \ void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpz_rcbk0_.cs(40,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpz_rcbk0_.cs(42,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpz_rcbk0_.cs(45,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpz_rcbk0_.cs(47,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659795182
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        foreach (long i in arr)\
    \ {\n            if (i == 1L) {\n                ones++;\n            }\n    \
    \        if (i == 0L) {\n                zeros++;\n            }\n        }\n\
    \        if (ones > zeros) {\n            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2,\
    \ Convert.ToInt64(Math.Log10(i))))));\n        } else {\n            result.AddRange(arr.OrderBy(i\
    \ => Convert.ToInt64(Math.Pow(2, Convert.ToInt64(Math.Log10(i))))));\n       \
    \ }\n        return result;\n    }\n    public static void Main(string[] args)\
    \ {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <db79d416f0ff472386acda17aa7e8686>:0 \n\nUnhandled Exception:\n\
    System.OverflowException: Arithmetic operation resulted in an overflow.\n  at\
    \ (wrapper managed-to-native) System.Object.__icall_wrapper___emul_fconv_to_ovf_i8(double)\n\
    \  at System.Convert.ToInt64 (System.Double value) [0x00006] in <aa5dff9b31c64fce86559bbbf6cd364f>:0\
    \ \n  at Problem+<>c.<SortArray>b__0_1 (System.Int64 i) [0x00010] in <db79d416f0ff472386acda17aa7e8686>:0\
    \ \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys (TElement[]\
    \ elements, System.Int32 count) [0x00010] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.EnumerableSorter`1[TElement].ComputeMap (TElement[] elements,\
    \ System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at\
    \ System.Linq.EnumerableSorter`1[TElement].Sort (TElement[] elements, System.Int32\
    \ count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.OrderedEnumerable`1[TElement].SortedMap\
    \ (System.Linq.Buffer`1[TElement] buffer) [0x00006] in <e540098dd111461e919c5863f6975c29>:0\
    \ \n  at System.Linq.OrderedEnumerable`1+<GetEnumerator>d__3[TElement].MoveNext\
    \ () [0x0003d] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Collections.Generic.List`1[T].AddEnumerable\
    \ (System.Collections."
  stdout: ''
  timestamp: 1659795182
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long maxOnes = 0;\n        long maxZeros = 0;\n        long\
    \ maxOnesCount = 0;\n        long maxZerosCount = 0;\n        long maxOnesCount2\
    \ = 0;\n        long maxZerosCount2 = 0;\n        long maxOnesCount3 = 0;\n  \
    \      long maxZerosCount3 = 0;\n        long maxOnesCount4 = 0;\n        long\
    \ maxZerosCount4 = 0;\n        long maxOnesCount5 = 0;\n        long maxZerosCount5\
    \ = 0;\n        long maxOnesCount6 = 0;\n        long maxZerosCount6 = 0;\n  \
    \      long maxOnesCount7 = 0;\n        long maxZerosCount7 = 0;\n        long\
    \ maxOnesCount8 = 0;\n        long maxZerosCount8 = 0;\n        long maxOnesCount9\
    \ = 0;\n        long maxZerosCount9 = 0;\n        long maxOnesCount10 = 0;\n \
    \       long maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n        long\
    \ maxZerosCount11 = 0;\n        long maxOnesCount12 = 0;\n        long maxZerosCount12\
    \ = 0;\n        long maxOnesCount13 = 0;\n        long maxZerosCount13 = 0;\n\
    \        long maxOnesCount14 = 0;\n        long maxZerosCount14 = 0;\n       \
    \ long maxOnesCount15 = 0;\n        long maxZerosCount15 = 0;\n        long maxOnesCount16\
    \ = 0;\n        long maxZerosCount16 = 0;\n        long maxOnesCount17 = 0;\n\
    \        long maxZerosCount17 = 0;\n        long maxOnesCount18 = 0;\n       \
    \ long maxZerosCount18 = 0;\n        long maxOnesCount19 = 0;\n        long maxZerosCount19\
    \ = 0;\n        long maxOnesCount20 = 0;\n        long maxZerosCount20 = 0;\n\
    \        long maxOnesCount21 = 0;\n        long maxZerosCount21 = 0;\n       \
    \ long maxOnesCount22 = 0;\n        long maxZerosCount22 = 0;\n        long maxOnesCount23\
    \ = 0;\n        long maxZerosCount23 = 0;\n        long maxOnesCount24 = 0;\n\
    \        long maxZerosCount24 = 0;\n        long maxOnesCount25 = 0;\n       \
    \ long maxZerosCount25 = 0;\n        long maxOnesCount26 = 0;\n        long maxZerosCount26\
    \ = 0;\n        long maxOnesCount\n    }\n    public static void Main(string[]\
    \ args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,\
    \ (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpesxj2l0z.cs(76,26): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            else\
    \ if (i == 0L) {\n                zeros++;\n            }\n            else {\n\
    \                if (ones > zeros) {\n                    max = i;\n         \
    \       }\n                else {\n                    max = i;\n            \
    \    }\n            }\n        }\n        List<long> result = new List<long>();\n\
    \        foreach (long i in arr) {\n            if (i == 1L) {\n             \
    \   result.Add(i);\n            }\n            else if (i == 0L) {\n         \
    \       result.Add(max);\n            }\n            else {\n                if\
    \ (ones > zeros) {\n                    result.Add(i);\n                }\n  \
    \              else {\n                    result.Add(max);\n                }\n\
    \            }\n        }\n        return result;\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <0bd52788d3fa4921b8ca24301cdbdfac>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <0bd52788d3fa4921b8ca24301cdbdfac>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659795182
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            result.Add(max);\n\
    \            result.AddRange(arr.Where(i => i == max).OrderBy(i => Math.Abs(Convert.ToInt64(Math.Pow(2,\
    \ Convert.ToInt64(Math.Log10(i)))))).ToList());\n            result.AddRange(arr.Where(i\
    \ => i == max).OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt64(Math.Log10(i)))).ToString()).ToList());\n\
    \        }\n        if (zeros > ones) {\n            result.AddRange(arr.Where(i\
    \ => i == max).OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt64(Math.Log10(i)))).ToString()).ToList());\n\
    \            result.Add(max);\n            result.AddRange(arr.Where(i => i ==\
    \ max).OrderBy(i => Math.Abs(Convert.ToInt64(Math.Pow(2, Convert.ToInt64(Math.Log10(i)))))).ToList());\n\
    \        }\n        if (ones == zeros) {\n            result.AddRange(arr.Where(i\
    \ => i == max).OrderBy(i => Math.Abs(Convert.ToInt64(Math.Pow(2, Convert.ToInt64(Math.Log10(i)))))).ToList());\n\
    \            result.AddRange(arr.Where(i => i == max).OrderBy(i => Convert.ToInt64(Math.Pow(2,\
    \ Convert.ToInt64(Math.Log10(i)))).ToString()).ToList());\n        }\n       \
    \ return result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String\
    \ message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <4b037eb33fe94807a6a477497077119f>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n\
    \  at System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.TraceInternal.Assert\
    \ (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.Debug.Assert (System.Boolean condition) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at Problem.Main (System.String[]\
    \ args) [0x00000] in <4b037eb33fe94807a6a477497077119f>:0 \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0\
    \ \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]\
    \ in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail\
    \ (System.String "
  stdout: ''
  timestamp: 1659795182
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = arr.Sum(x => x &\
    \ 1L);\n        long zeros = arr.Sum(x => x & 0L);\n        if (ones == zeros)\
    \ {\n            return arr.OrderBy(x => x).ToList();\n        }\n        long\
    \ onesDecimal = ones / Math.Pow(10, arr.Count);\n        long zerosDecimal = zeros\
    \ / Math.Pow(10, arr.Count);\n        long onesDecimalDecimal = onesDecimal /\
    \ Math.Pow(10, arr.Count - 1);\n        long zerosDecimalDecimal = zerosDecimal\
    \ / Math.Pow(10, arr.Count - 1);\n        long onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / Math.Pow(10, arr.Count - 2);\n        long zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / Math.Pow(10, arr.Count - 2);\n        long onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / Math.Pow(10, arr.Count - 3);\n        long zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / Math.Pow(10, arr.Count - 3);\n        long onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / Math.Pow(10, arr.Count - 4);\n        long\
    \ zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / Math.Pow(10, arr.Count - 4);\n        long onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / Math.Pow(10, arr.Count -\
    \ 5);\n        long zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / Math.Pow(10, arr.Count - 5);\n        long onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / Math.Pow(10,\
    \ arr.Count - 6);\n        long zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / Math.Pow(10,\
    \ arr.Count - 6);\n        long onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / Math.Pow(10, arr.Count - 7);\n        long zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / Math.Pow(10,\
    \ arr.Count - 7);\n        long onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / Math.Pow(10, arr.Count - 8);\n        long zerosDecimalDecimalDecimal\n  \
    \  }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp9zcurs_f.cs(42,40): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   }\n            if (i == 0L) {\n                zeros++;\n            }\n \
    \           if (i > max) {\n                max = i;\n            }\n        \
    \    if (i < min) {\n                min = i;\n            }\n        }\n    \
    \    long onesMax = ones * max;\n        long zerosMax = zeros * max;\n      \
    \  long onesMin = ones * min;\n        long zerosMin = zeros * min;\n        long\
    \ onesMaxMin = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n  \
    \      long onesMinMin = onesMin * min;\n        long zerosMinMin = zerosMin *\
    \ min;\n        long onesMaxMinMin = onesMaxMin * min;\n        long zerosMaxMinMin\
    \ = zerosMaxMin * min;\n        long onesMinMinMin = onesMinMin * min;\n     \
    \   long zerosMinMinMin = zerosMinMin * min;\n        long onesMaxMinMinMin =\
    \ onesMaxMinMin * min;\n        long zerosMaxMinMin = zerosMaxMin * min;\n   \
    \     long onesMinMinMinMin = onesMinMinMin * min;\n        long zerosMinMinMin\
    \ = zerosMinMinMin * min;\n        long onesMaxMinMinMin = onesMaxMinMinMin *\
    \ min;\n        long zerosMaxMinMin = zerosMaxMinMin * min;\n        long onesMinMinMinMin\
    \ = onesMinMinMinMin * min;\n        long zerosMinMinMin = zerosMinMinMin * min;\n\
    \        long onesMaxMinMinMin = onesMaxMinMinMin * min;\n        long zerosMaxMinMin\
    \ = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMinMin *\
    \ min;\n        long zerosMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin\
    \ = onesMaxMinMinMin * min;\n        long zerosMaxMinMin = zerosMaxMinMin * min;\n\
    \        long onesMinMinMinMin = onesMinMinMinMin * min;\n        long zerosMinMinMin\
    \ = zerosMinMinMin * min;\n        long onesMaxMinMinMin = onesMaxMin\n    }\n\
    \    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpwgdkbfrg.cs(66,43): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        List<long> result\
    \ = new List<long>();\n        if (ones > zeros) {\n            long temp = 0;\n\
    \            long temp2 = 0;\n            long temp3 = 0;\n            long temp4\
    \ = 0;\n            long temp5 = 0;\n            long temp6 = 0;\n           \
    \ long temp7 = 0;\n            long temp8 = 0;\n            long temp9 = 0;\n\
    \            long temp10 = 0;\n            long temp11 = 0;\n            long\
    \ temp12 = 0;\n            long temp13 = 0;\n            long temp14 = 0;\n  \
    \          long temp15 = 0;\n            long temp16 = 0;\n            long temp17\
    \ = 0;\n            long temp18 = 0;\n            long temp19 = 0;\n         \
    \   long temp20 = 0;\n            long temp21 = 0;\n            long temp22 =\
    \ 0;\n            long temp23 = 0;\n            long temp24 = 0;\n           \
    \ long temp25 = 0;\n            long temp26 = 0;\n            long temp27 = 0;\n\
    \            long temp28 = 0;\n            long temp29 = 0;\n            long\
    \ temp30 = 0;\n            long temp31 = 0;\n            long temp32 = 0;\n  \
    \          long temp33 = 0;\n            long temp34 = 0;\n            long temp35\
    \ = 0;\n            long temp36 = 0;\n            long temp37 = 0;\n         \
    \   long temp38 = 0;\n            long temp39 = 0;\n            long temp40 =\
    \ 0;\n            long temp41 = 0;\n            long temp42 = 0;\n           \
    \ long temp43 = 0;\n            long temp44 = 0;\n            long temp45 = 0;\n\
    \            long temp46 = 0;\n            long temp47 = 0;\n            long\
    \ temp48 = 0;\n            long temp49 = 0;\n            long temp50 = 0;\n  \
    \          long temp51 = 0;\n            long temp52 = 0;\n            long temp53\
    \ = 0;\n            long temp54 = 0;\n            long temp55 = 0;\n         \
    \   long temp56 = 0;\n            long temp57 = 0;\n            long temp58 =\
    \ 0;\n            long temp59 = 0;\n            long temp60 = 0;\n           \
    \ long temp61 = 0;\n            long temp62 = 0;\n            long temp63 = 0;\n\
    \            long temp64 = 0;\n            long temp65 = 0;\n            long\
    \ temp66 = 0;\n            long temp67 = 0;\n            long temp68 = 0;\n  \
    \          long temp69 = 0;\n            long temp70 = 0;\n            long temp71\
    \ = 0;\n            long temp72 = 0;\n            long temp73 = 0;\n         \
    \   long temp\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
    \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L,\
    \ (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L,\
    \ (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new\
    \ List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpjzxj1fet.cs(109,22): error CS1002: ; expected

    /tmp/tmpjzxj1fet.cs(111,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpjzxj1fet.cs(122,2): error CS1513: } expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   }\n            if (i == 0L) {\n                zeros++;\n            }\n \
    \           if (i > max) {\n                max = i;\n            }\n        \
    \    if (i < min) {\n                min = i;\n            }\n        }\n    \
    \    long onesMax = ones * max;\n        long onesMin = ones * min;\n        long\
    \ zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long\
    \ onesDiff = onesMax - onesMin;\n        long zerosDiff = zerosMax - zerosMin;\n\
    \        long onesDiffMin = onesMax - onesMin;\n        long onesDiffMax = onesMax\
    \ - onesMin;\n        long zerosDiffMin = zerosMax - zerosMin;\n        long zerosDiffMax\
    \ = zerosMax - zerosMin;\n        long onesDiffMinMax = onesMax - onesMin;\n \
    \       long onesDiffMaxMin = onesMax - onesMin;\n        long zerosDiffMinMax\
    \ = zerosMax - zerosMin;\n        long zerosDiffMaxMin = zerosMax - zerosMin;\n\
    \        long onesDiffMinMaxMin = onesMax - onesMin;\n        long onesDiffMaxMinMin\
    \ = onesMax - onesMin;\n        long zerosDiffMinMaxMin = zerosMax - zerosMin;\n\
    \        long zerosDiffMaxMinMin = zerosMax - zerosMin;\n        long onesDiffMinMaxMinMin\
    \ = onesMax - onesMin;\n        long onesDiffMaxMinMin = onesMax - onesMin;\n\
    \        long zerosDiffMinMaxMin = zerosMax - zerosMin;\n        long zerosDiffMaxMinMin\
    \ = zerosMax - zerosMin;\n        long onesDiffMinMaxMinMin = onesMax - onesMin;\n\
    \        long onesDiffMaxMinMin = onesMax - onesMin;\n        long zerosDiffMinMaxMin\
    \ = zerosMax - zerosMin;\n        long zerosDiffMaxMinMin = zerosMax - zerosMin;\n\
    \        long onesDiffMinMaxMinMin = onesMax - onesMin;\n        long onesDiffMaxMinMin\
    \ = onesMax - onesMin;\n        long zerosDiffMinMaxMin = zerosMa\n    }\n   \
    \ public static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpv0untxxb.cs(66,42): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long maxOnes = 0;\n        long maxZeros = 0;\n        long\
    \ max = 0;\n        long min = 0;\n        foreach (long i in arr) {\n       \
    \     if (i == 1L) {\n                ones++;\n                if (ones > maxOnes)\
    \ maxOnes = ones;\n                if (ones < min) min = ones;\n            }\
    \ else if (i == 0L) {\n                zeros++;\n                if (zeros > maxZeros)\
    \ maxZeros = zeros;\n                if (zeros < min) min = zeros;\n         \
    \   } else {\n                long bin = Convert.ToString(i, 2);\n           \
    \     long binLen = bin.Length;\n                long binOnes = bin.Count(x =>\
    \ x == '1');\n                long binZeros = bin.Count(x => x == '0');\n    \
    \            if (binOnes > maxOnes) maxOnes = binOnes;\n                if (binZeros\
    \ > maxZeros) maxZeros = binZeros;\n                if (binOnes < min) min = binOnes;\n\
    \                if (binZeros < min) min = binZeros;\n            }\n        }\n\
    \        long onesDiff = maxOnes - ones;\n        long zerosDiff = maxZeros -\
    \ zeros;\n        long diff = onesDiff > zerosDiff ? onesDiff : zerosDiff;\n \
    \       if (diff == 0) return arr;\n        long onesDiff2 = diff / 2;\n     \
    \   long zerosDiff2 = diff % 2;\n        long diff2 = onesDiff2 > zerosDiff2 ?\
    \ onesDiff2 : zerosDiff2;\n        long onesDiff3 = diff2 / 3;\n        long zerosDiff3\
    \ = diff2 % 3;\n        long diff3 = onesDiff3 > zerosDiff3 ? onesDiff3 : zerosDiff3;\n\
    \        long onesDiff4 = diff3 / 4;\n        long zerosDiff4 = diff3 % 4;\n \
    \       long diff4 = onesDiff4 > zerosDiff4 ? onesDiff4 : zerosDiff4;\n      \
    \  long onesDiff5 = diff4 / 5;\n        long zerosDiff5 = diff4 % 5;\n       \
    \ long diff5 = onesDiff5 > zerosDiff5 ? onesDiff5 : zerosDiff5;\n        long\
    \ onesDiff6 = diff5 / 6;\n        long zerosDiff6 = diff5 % 6;\n        long diff6\
    \ = onesDiff6 > zerosDiff6 ? onesDiff6 : zerosDiff6;\n        long onesDiff7 =\
    \ diff6 / 7;\n        long zerosDiff7 = diff6 % 7;\n        long diff7 = onesDiff7\
    \ > zerosDiff7 ? one\n    }\n    public static void Main(string[] args) {\n  \
    \  Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,\
    \ (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmptl7g8ewr.cs(67,50): error CS1003: Syntax error, '':'' expected

    /tmp/tmptl7g8ewr.cs(67,50): error CS1525: Invalid expression term ''}''

    /tmp/tmptl7g8ewr.cs(67,50): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        foreach (long i in arr) {\n     \
    \       if (i == 1L) {\n                ones++;\n            }\n            if\
    \ (i == 0L) {\n                zeros++;\n            }\n            if (i > max)\
    \ {\n                max = i;\n            }\n        }\n        long onesMax\
    \ = ones * max;\n        long zerosMax = zeros * max;\n        long onesMin =\
    \ ones * max;\n        long zerosMin = zeros * max;\n        long onesMaxMin =\
    \ onesMax * max;\n        long zerosMaxMin = zerosMax * max;\n        long onesMinMin\
    \ = onesMin * max;\n        long zerosMinMin = zerosMin * max;\n        long onesMaxMinMin\
    \ = onesMaxMin * max;\n        long zerosMaxMinMin = zerosMaxMin * max;\n    \
    \    long onesMinMinMin = onesMinMin * max;\n        long zerosMinMinMin = zerosMinMin\
    \ * max;\n        long onesMaxMinMinMin = onesMaxMinMin * max;\n        long zerosMaxMinMinMin\
    \ = zerosMaxMinMin * max;\n        long onesMinMinMinMin = onesMinMinMin * max;\n\
    \        long zerosMinMinMinMin = zerosMinMinMin * max;\n        long onesMaxMinMinMin\
    \ = onesMaxMinMin * max;\n        long zerosMaxMinMinMin = zerosMaxMinMin * max;\n\
    \        long onesMinMinMinMin = onesMinMinMin * max;\n        long zerosMinMinMinMin\
    \ = zerosMinMinMin * max;\n        long onesMaxMinMinMin = onesMaxMinMin * max;\n\
    \        long zerosMaxMinMinMin = zerosMaxMinMin * max;\n        long onesMinMinMinMin\
    \ = onesMinMinMin * max;\n        long zerosMinMinMinMin = zerosMinMinMin * max;\n\
    \        long onesMaxMinMinMin = onesMaxMinMin * max;\n        long zerosMaxMinMinMin\
    \ = zerosMaxMinMin * max;\n        long onesMinMinMinMin = onesMinMinMin * max;\n\
    \        long zerosMinMinMinMin = zerosMinMinMin * max;\n        long onesMaxMinMinMin\
    \ = onesMaxMinMin * max;\n        long zerosMaxMinMinMin = \n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkw9jx13g.cs(63,33): error CS1525: Invalid expression term ''}''

    /tmp/tmpkw9jx13g.cs(63,33): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        List<long> result = new List<long>();\n\
    \        long ones = 0;\n        long zeros = 0;\n        foreach (long n in arr)\
    \ {\n            if (n == 1L) {\n                ones++;\n            }\n    \
    \        if (n == 0L) {\n                zeros++;\n            }\n        }\n\
    \        if (ones > zeros) {\n            long temp;\n            long temp2;\n\
    \            long temp3;\n            long temp4;\n            long temp5;\n \
    \           long temp6;\n            long temp7;\n            long temp8;\n  \
    \          long temp9;\n            long temp10;\n            long temp11;\n \
    \           long temp12;\n            long temp13;\n            long temp14;\n\
    \            long temp15;\n            long temp16;\n            long temp17;\n\
    \            long temp18;\n            long temp19;\n            long temp20;\n\
    \            long temp21;\n            long temp22;\n            long temp23;\n\
    \            long temp24;\n            long temp25;\n            long temp26;\n\
    \            long temp27;\n            long temp28;\n            long temp29;\n\
    \            long temp30;\n            long temp31;\n            long temp32;\n\
    \            long temp33;\n            long temp34;\n            long temp35;\n\
    \            long temp36;\n            long temp37;\n            long temp38;\n\
    \            long temp39;\n            long temp40;\n            long temp41;\n\
    \            long temp42;\n            long temp43;\n            long temp44;\n\
    \            long temp45;\n            long temp46;\n            long temp47;\n\
    \            long temp48;\n            long temp49;\n            long temp50;\n\
    \            long temp51;\n            long temp52;\n            long temp53;\n\
    \            long temp54;\n            long temp55;\n            long temp56;\n\
    \            long temp57;\n            long temp58;\n            long temp59;\n\
    \            long temp60;\n            long temp61;\n            long temp62;\n\
    \            long temp63;\n            long temp64;\n            long temp65;\n\
    \            long temp66;\n            long temp67;\n            long temp68;\n\
    \            long temp69;\n            long temp70;\n            long temp71;\n\
    \            long temp72;\n            long temp73;\n            long temp74;\n\
    \            long temp75;\n            long temp76;\n            long temp77;\n\
    \            long temp78;\n            long temp79\n    }\n    public static void\
    \ Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkdxoe8ss.cs(110,24): error CS1002: ; expected

    /tmp/tmpkdxoe8ss.cs(112,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpkdxoe8ss.cs(123,2): error CS1513: } expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\n\
    class Problem {\n    // In this Kata, you have to sort an array of non-negative\
    \ integers according to\n    // number of ones in their binary representation\
    \ in ascending order.\n    // For similar number of ones, sort based on decimal\
    \ value.\n    // It must be implemented like this:\n    // >>> SortArray((new\
    \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L})))\n\
    \    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \    // >>> SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
    \ (long)-5L, (long)-6L})))\n    // (new List<long>(new long[]{(long)-6L, (long)-5L,\
    \ (long)-4L, (long)-3L, (long)-2L}))\n    // >>> SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new\
    \ long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L}))\n    public static\
    \ List<long> SortArray(List<long> arr) {\n        long ones = 0;\n        long\
    \ zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach (long\
    \ i in arr) {\n            if (i == 1L) {\n                ones++;\n         \
    \   }\n            if (i == 0L) {\n                zeros++;\n            }\n \
    \           if (i > max) {\n                max = i;\n            }\n        \
    \    if (i < min) {\n                min = i;\n            }\n        }\n    \
    \    long onesMax = ones * max;\n        long zerosMax = zeros * max;\n      \
    \  long onesMin = ones * min;\n        long zerosMin = zeros * min;\n        long\
    \ onesMaxMin = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n  \
    \      long onesMinMin = onesMin * min;\n        long zerosMinMin = zerosMin *\
    \ min;\n        long onesMaxMinMin = onesMaxMin * min;\n        long zerosMaxMinMin\
    \ = zerosMaxMin * min;\n        long onesMinMinMin = onesMinMin * min;\n     \
    \   long zerosMinMinMin = zerosMinMin * min;\n        long onesMaxMinMinMin =\
    \ onesMaxMinMin * min;\n        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n\
    \        long onesMinMinMinMin = onesMinMinMin * min;\n        long zerosMinMinMinMin\
    \ = zerosMinMinMin * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n\
    \        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n        long onesMinMinMinMin\
    \ = onesMinMinMin * min;\n        long zerosMinMinMinMin = zerosMinMinMin * min;\n\
    \        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin\
    \ = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n\
    \        long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin\
    \ = onesMaxMinMin * min;\n        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n\
    \        long onesMinMinMinMin = onesMinMinMin * min;\n        long zerosMinMinMinMin\
    \ = zerosMinMinMin * min;\n        long onesMaxMinMinMin = one\n    }\n    public\
    \ static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new\
    \ List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new\
    \ List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L,\
    \ (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new\
    \ List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,\
    \ (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,\
    \ (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L,\
    \ (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L,\
    \ (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
    \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
    \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n\
    \    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
    \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
    \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
    \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpcbs11snl.cs(66,36): error CS1002: ; expected

    '
  timestamp: 1659795181
