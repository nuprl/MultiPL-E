language: cs
name: HumanEval_116_sort_array
results:
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            else if (i == 0L) {\n                zeros++;\n            }\n
    \           else {\n                if (ones > zeros) {\n                    max
    = i;\n                }\n                else {\n                    max = zeros;\n
    \               }\n            }\n        }\n        List<long> res = new List<long>();\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                res.Add(i);\n
    \           }\n            else if (i == 0L) {\n                res.Add(max);\n
    \           }\n            else {\n                if (ones > zeros) {\n                    res.Add(i);\n
    \               }\n                else {\n                    res.Add(max);\n
    \               }\n            }\n        }\n        return res;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <9ea1d621897348a49366b95d78a0afb3>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <9ea1d621897348a49366b95d78a0afb3>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659795182
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    maxOnesMax = onesMax * max;\n        long maxZerosMax = zerosMax * max;\n        long
    maxOnesZeros = ones * zerosMax;\n        long maxZerosOnes = zeros * onesMax;\n
    \       long maxOnesZerosMax = onesMax * zerosMax;\n        long maxZerosOnesMax
    = zerosMax * onesMax;\n        long maxOnesZerosZeros = ones * zerosMax * zerosMax;\n
    \       long maxZerosOnesZeros = zerosMax * onesMax * zerosMax;\n        long
    maxOnesZerosZerosMax = onesMax * zerosMax * zerosMax;\n        long maxZerosOnesZerosMax
    = zerosMax * onesMax * zerosMax;\n        long maxOnesZerosZerosZeros = ones *
    zerosMax * zerosMax * zerosMax;\n        long maxZerosOnesZerosZeros = zerosMax
    * onesMax * zerosMax * zerosMax;\n        long maxOnesZerosZerosZerosMax = onesMax
    * zerosMax * zerosMax * zerosMax;\n        long maxZerosOnesZerosZerosMax = zerosMax
    * onesMax * zerosMax * zerosMax;\n        long maxOnesZerosZerosZerosZeros = ones
    * zerosMax * zerosMax * zerosMax * zerosMax;\n        long maxZerosOnesZerosZerosZeros
    = zerosMax * onesMax * zerosMax * zerosMax * zerosMax;\n        long maxOnesZerosZerosZerosZerosMax
    = onesMax * zerosMax * zerosMax * zerosMax * zerosMax;\n        long maxZerosOnesZerosZerosZerosMax
    = zerosMax * onesMax * zerosMax * zerosMax * zerosMax;\n        long max\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpj5wy75q0.cs(54,17): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: -1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            long
    onesMax = ones;\n            long zerosMax = zeros;\n            while (onesMax
    > zerosMax) {\n                result.Add(max);\n                zerosMax--;\n
    \           }\n            while (zerosMax < onesMax) {\n                result.Add(max);\n
    \               onesMax--;\n            }\n        }\n        else {\n            long
    zerosMax = zeros;\n            long onesMax = ones;\n            while (zerosMax
    < onesMax) {\n                result.Add(max);\n                zerosMax--;\n
    \           }\n            while (onesMax < zerosMax) {\n                result.Add(max);\n
    \               onesMax--;\n            }\n        }\n        return result;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Timeout
  stderr: ''
  stdout: None
  timestamp: 1659795187
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long n in arr) {\n            ones += n;\n            zeros +=
    (long)Math.Abs(n);\n            if (n > max) {\n                max = n;\n            }\n
    \       }\n        long onesMax = ones;\n        long zerosMax = zeros;\n        long
    onesMin = ones;\n        long zerosMin = zeros;\n        long onesCurr = ones;\n
    \       long zerosCurr = zeros;\n        long onesNext = ones;\n        long zerosNext
    = zeros;\n        long onesPrev = ones;\n        long zerosPrev = zeros;\n        long
    onesCurrPrev = ones;\n        long zerosCurrPrev = zeros;\n        long onesNextPrev
    = ones;\n        long zerosNextPrev = zeros;\n        long onesPrevPrev = ones;\n
    \       long zerosPrevPrev = zeros;\n        long onesNextNext = ones;\n        long
    zerosNextNext = zeros;\n        long onesPrevNext = ones;\n        long zerosPrevNext
    = zeros;\n        long onesPrevNextPrev = ones;\n        long zerosPrevNextPrev
    = zeros;\n        long onesPrevNextNext = ones;\n        long zerosPrevNextNext
    = zeros;\n        long onesPrevNextNextPrev = ones;\n        long zerosPrevNextNextPrev
    = zeros;\n        long onesPrevNextNextNext = ones;\n        long zerosPrevNextNextNext
    = zeros;\n        long onesPrevNextNextNextPrev = ones;\n        long zerosPrevNextNextNextPrev
    = zeros;\n        long onesPrevNextNextNextNext = ones;\n        long zerosPrevNextNextNextNext
    = zeros;\n        long onesPrevNextNextNextNextPrev = ones;\n        long zerosPrevNextNextNextNextPrev
    = zeros;\n        long onesPrevNextNextNextNextNext = ones;\n        long zerosPrevNextNextNextNextNext
    = zeros;\n        long onesPrevNextNextNextNextNextPrev = ones;\n        long
    zerosPrevNextNextNextNextNextPrev = zeros;\n        long onesPrevNextNextNextNextNextNext
    = ones;\n        long zerosPrevNextNextNextNextNextNext = zeros;\n        long
    onesPrevNextNextNextNextNextNextPrev = ones;\n        long zerosPrevNextNextNextNextNextNextPrev
    = zeros;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpdwiuc2_u.cs(19,30): error CS0161: ''Problem.SortArray(List<long>)'': not
    all code paths return a value

    '
  timestamp: 1659795182
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            else if (i == 0L) {\n
    \               zeros++;\n            }\n            else {\n                max
    = Math.Max(max, i);\n                min = Math.Min(min, i);\n            }\n
    \       }\n        long onesCount = 0;\n        long zerosCount = 0;\n        long
    maxCount = 0;\n        long minCount = 0;\n        foreach (long i in arr) {\n
    \           if (i == 1L) {\n                onesCount++;\n            }\n            else
    if (i == 0L) {\n                zerosCount++;\n            }\n            else
    {\n                maxCount = Math.Max(maxCount, i);\n                minCount
    = Math.Min(minCount, i);\n            }\n        }\n        long onesDecimal =
    0;\n        long zerosDecimal = 0;\n        long maxDecimal = 0;\n        long
    minDecimal = 0;\n        foreach (long i in arr) {\n            if (i == 1L) {\n
    \               onesDecimal++;\n            }\n            else if (i == 0L) {\n
    \               zerosDecimal++;\n            }\n            else {\n                maxDecimal
    = Math.Max(maxDecimal, i);\n                minDecimal = Math.Min(minDecimal,
    i);\n            }\n        }\n        long onesDecimalCount = 0;\n        long
    zerosDecimalCount = 0;\n        long maxDecimalCount = 0;\n        long minDecimalCount
    = 0;\n        foreach (long i in arr) {\n            if (i == 1L) {\n                onesDecimalCount++;\n
    \           }\n            else if (i == 0L) {\n                zerosDecimalCount++;\n
    \           }\n            else {\n                maxDecimalCount = Math.Max(maxDecimalCount,
    i);\n                minDecimalCount = Math.Min(minDecimalCount, i);\n            }\n
    \       }\n        long onesDecimalDecimal = 0;\n        long zerosDecimalDecimal
    = 0;\n        long maxDecimalDecimal = 0;\n        long minDecimalDecimal = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                onesDecimalDecimal++;\n
    \           }\n            else if (i == 0L) {\n                zerosDecimalDecimal++;\n
    \           }\n            else {\n                maxDecimalDecimal = Math.Max(maxDecimalDecimal,
    i);\n                minDecimalDecimal = Math.Min(minDecimalDecimal, i);\n            }\n
    \       }\n        long onesDecimalDecimalCount = 0;\n        long zerosDecimalDecimalCount
    = 0;\n        long maxDecimalDecimalCount = 0;\n        long minDecimalDecimalCount
    = 0;\n        foreach (long i in arr) {\n            if (i == 1L) {\n                onesDecimalDecimalCount++;\n
    \           }\n            else if (i == 0L) {\n                zerosDecimalDecimalCount++;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp8ktnflrt.cs(111,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp8ktnflrt.cs(122,2): error CS1513: } expected

    '
  timestamp: 1659795181
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            else if (i == 0L) {\n                zeros++;\n            }\n
    \           else {\n                if (ones > zeros) {\n                    max
    = i;\n                }\n                else {\n                    max = i;\n
    \               }\n            }\n        }\n        List<long> result = new List<long>();\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                result.Add(i);\n
    \           }\n            else if (i == 0L) {\n                result.Add(i);\n
    \           }\n            else {\n                if (ones > zeros) {\n                    result.Add(max);\n
    \               }\n                else {\n                    result.Add(max);\n
    \               }\n            }\n        }\n        return result;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <67ff08d3c8d042a492a2ba4447a0adb9>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <67ff08d3c8d042a492a2ba4447a0adb9>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659795182
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long n in arr) {\n            if (n ==
    1L) {\n                ones++;\n            }\n            if (n == 0L) {\n                zeros++;\n
    \           }\n            if (n > max) {\n                max = n;\n            }\n
    \           if (n < min) {\n                min = n;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            result.Add(min);\n
    \           result.AddRange(arr.Where(n => n == min).OrderBy(n => n).Take(ones
    - 1));\n            result.AddRange(arr.Where(n => n == max).OrderBy(n => n).Take(zeros
    - 1));\n        }\n        if (zeros > ones) {\n            result.AddRange(arr.Where(n
    => n == max).OrderBy(n => n).Take(zeros - 1));\n            result.Add(max);\n
    \           result.AddRange(arr.Where(n => n == min).OrderBy(n => n).Take(ones
    - 1));\n        }\n        if (ones > zeros) {\n            result.AddRange(arr.Where(n
    => n == min).OrderBy(n => n).Take(ones - 1));\n            result.AddRange(arr.Where(n
    => n == max).OrderBy(n => n).Take(zeros - 1));\n        }\n        if (zeros >
    ones) {\n            result.AddRange(arr.Where(n => n == min).OrderBy(n => n).Take(zeros
    - 1));\n            result.AddRange(arr.Where(n => n == max).OrderBy(n => n).Take(ones
    - 1));\n        }\n        if (ones > zeros) {\n            result.AddRange(arr.Where(n
    => n == min).OrderBy(n => n).Take(ones - 1));\n            result.AddRange(arr.Where(n
    => n == max).OrderBy(n => n).Take(zeros - 1));\n        }\n        if (zeros >
    ones) {\n            result.AddRange(arr.Where(n => n == min).OrderBy(n => n).Take(zeros
    - 1));\n            result.AddRange(arr.Where(n => n == max).OrderBy(n => n).Take(ones
    - 1));\n        }\n        if (ones > zeros) {\n            result.AddRange(arr.Where(n
    => n == min).OrderBy(n => n).Take(ones - 1));\n            result.AddRange(arr.Where(n
    => n == max).OrderBy(n => n).Take(zeros - 1));\n        }\n        if (zeros >
    ones) {\n            result.AddRange(arr.Where(n => n == min).OrderBy(n => n).Take(zeros
    - 1));\n            result.AddRange(arr.Where(n => n == \n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpitv8i5zv.cs(71,48): error CS1525: Invalid expression term ''}''

    /tmp/tmpitv8i5zv.cs(71,48): error CS1026: ) expected

    /tmp/tmpitv8i5zv.cs(71,48): error CS1002: ; expected

    /tmp/tmpitv8i5zv.cs(73,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpitv8i5zv.cs(84,2): error CS1513: } expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            } else {\n                zeros++;\n
    \           }\n            if (max < i) {\n                max = i;\n            }\n
    \           if (min > i) {\n                min = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            result.Add(min);\n
    \           result.AddRange(arr.Where(i => i == min).OrderBy(i => i).Take(ones
    - 1).ToList());\n            result.Add(max);\n            result.AddRange(arr.Where(i
    => i == max).OrderBy(i => i).Take(zeros - 1).ToList());\n        } else {\n            result.Add(max);\n
    \           result.AddRange(arr.Where(i => i == max).OrderBy(i => i).Take(zeros
    - 1).ToList());\n            result.Add(min);\n            result.AddRange(arr.Where(i
    => i == min).OrderBy(i => i).Take(ones - 1).ToList());\n        }\n        return
    result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpz_rcbk0_.cs(40,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpz_rcbk0_.cs(42,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpz_rcbk0_.cs(45,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpz_rcbk0_.cs(47,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659795182
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long zeros = 0;\n        foreach (long i in arr) {\n            if (i
    == 1L) {\n                ones++;\n            }\n            if (i == 0L) {\n
    \               zeros++;\n            }\n        }\n        if (ones > zeros)
    {\n            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt64(Math.Log10(i))))));\n
    \       } else {\n            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2,
    Convert.ToInt64(Math.Log10(i))))));\n        }\n        return result;\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <db79d416f0ff472386acda17aa7e8686>:0
    \n\nUnhandled Exception:\nSystem.OverflowException: Arithmetic operation resulted
    in an overflow.\n  at (wrapper managed-to-native) System.Object.__icall_wrapper___emul_fconv_to_ovf_i8(double)\n
    \ at System.Convert.ToInt64 (System.Double value) [0x00006] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem+<>c.<SortArray>b__0_1 (System.Int64 i) [0x00010] in <db79d416f0ff472386acda17aa7e8686>:0
    \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys (TElement[] elements,
    System.Int32 count) [0x00010] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.EnumerableSorter`1[TElement].ComputeMap
    (TElement[] elements, System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0
    \n  at System.Linq.EnumerableSorter`1[TElement].Sort (TElement[] elements, System.Int32
    count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.OrderedEnumerable`1[TElement].SortedMap
    (System.Linq.Buffer`1[TElement] buffer) [0x00006] in <e540098dd111461e919c5863f6975c29>:0
    \n  at System.Linq.OrderedEnumerable`1+<GetEnumerator>d__3[TElement].MoveNext
    () [0x0003d] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Collections.Generic.List`1[T].AddEnumerable
    (System.Collections."
  stdout: ''
  timestamp: 1659795182
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long maxOnes
    = 0;\n        long maxZeros = 0;\n        long maxOnesCount = 0;\n        long
    maxZerosCount = 0;\n        long maxOnesCount2 = 0;\n        long maxZerosCount2
    = 0;\n        long maxOnesCount3 = 0;\n        long maxZerosCount3 = 0;\n        long
    maxOnesCount4 = 0;\n        long maxZerosCount4 = 0;\n        long maxOnesCount5
    = 0;\n        long maxZerosCount5 = 0;\n        long maxOnesCount6 = 0;\n        long
    maxZerosCount6 = 0;\n        long maxOnesCount7 = 0;\n        long maxZerosCount7
    = 0;\n        long maxOnesCount8 = 0;\n        long maxZerosCount8 = 0;\n        long
    maxOnesCount9 = 0;\n        long maxZerosCount9 = 0;\n        long maxOnesCount10
    = 0;\n        long maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n        long
    maxZerosCount11 = 0;\n        long maxOnesCount12 = 0;\n        long maxZerosCount12
    = 0;\n        long maxOnesCount13 = 0;\n        long maxZerosCount13 = 0;\n        long
    maxOnesCount14 = 0;\n        long maxZerosCount14 = 0;\n        long maxOnesCount15
    = 0;\n        long maxZerosCount15 = 0;\n        long maxOnesCount16 = 0;\n        long
    maxZerosCount16 = 0;\n        long maxOnesCount17 = 0;\n        long maxZerosCount17
    = 0;\n        long maxOnesCount18 = 0;\n        long maxZerosCount18 = 0;\n        long
    maxOnesCount19 = 0;\n        long maxZerosCount19 = 0;\n        long maxOnesCount20
    = 0;\n        long maxZerosCount20 = 0;\n        long maxOnesCount21 = 0;\n        long
    maxZerosCount21 = 0;\n        long maxOnesCount22 = 0;\n        long maxZerosCount22
    = 0;\n        long maxOnesCount23 = 0;\n        long maxZerosCount23 = 0;\n        long
    maxOnesCount24 = 0;\n        long maxZerosCount24 = 0;\n        long maxOnesCount25
    = 0;\n        long maxZerosCount25 = 0;\n        long maxOnesCount26 = 0;\n        long
    maxZerosCount26 = 0;\n        long maxOnesCount\n    }\n    public static void
    Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpesxj2l0z.cs(76,26): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            else if (i == 0L) {\n                zeros++;\n            }\n
    \           else {\n                if (ones > zeros) {\n                    max
    = i;\n                }\n                else {\n                    max = i;\n
    \               }\n            }\n        }\n        List<long> result = new List<long>();\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                result.Add(i);\n
    \           }\n            else if (i == 0L) {\n                result.Add(max);\n
    \           }\n            else {\n                if (ones > zeros) {\n                    result.Add(i);\n
    \               }\n                else {\n                    result.Add(max);\n
    \               }\n            }\n        }\n        return result;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <0bd52788d3fa4921b8ca24301cdbdfac>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <0bd52788d3fa4921b8ca24301cdbdfac>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659795182
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            result.Add(max);\n
    \           result.AddRange(arr.Where(i => i == max).OrderBy(i => Math.Abs(Convert.ToInt64(Math.Pow(2,
    Convert.ToInt64(Math.Log10(i)))))).ToList());\n            result.AddRange(arr.Where(i
    => i == max).OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt64(Math.Log10(i)))).ToString()).ToList());\n
    \       }\n        if (zeros > ones) {\n            result.AddRange(arr.Where(i
    => i == max).OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt64(Math.Log10(i)))).ToString()).ToList());\n
    \           result.Add(max);\n            result.AddRange(arr.Where(i => i ==
    max).OrderBy(i => Math.Abs(Convert.ToInt64(Math.Pow(2, Convert.ToInt64(Math.Log10(i)))))).ToList());\n
    \       }\n        if (ones == zeros) {\n            result.AddRange(arr.Where(i
    => i == max).OrderBy(i => Math.Abs(Convert.ToInt64(Math.Pow(2, Convert.ToInt64(Math.Log10(i)))))).ToList());\n
    \           result.AddRange(arr.Where(i => i == max).OrderBy(i => Convert.ToInt64(Math.Pow(2,
    Convert.ToInt64(Math.Log10(i)))).ToString()).ToList());\n        }\n        return
    result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <4b037eb33fe94807a6a477497077119f>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <4b037eb33fe94807a6a477497077119f>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659795182
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones == zeros) {\n            return arr.OrderBy(x =>
    x).ToList();\n        }\n        long onesDecimal = ones / Math.Pow(10, arr.Count);\n
    \       long zerosDecimal = zeros / Math.Pow(10, arr.Count);\n        long onesDecimalDecimal
    = onesDecimal / Math.Pow(10, arr.Count - 1);\n        long zerosDecimalDecimal
    = zerosDecimal / Math.Pow(10, arr.Count - 1);\n        long onesDecimalDecimalDecimal
    = onesDecimalDecimal / Math.Pow(10, arr.Count - 2);\n        long zerosDecimalDecimalDecimal
    = zerosDecimalDecimal / Math.Pow(10, arr.Count - 2);\n        long onesDecimalDecimalDecimalDecimal
    = onesDecimalDecimalDecimal / Math.Pow(10, arr.Count - 3);\n        long zerosDecimalDecimalDecimalDecimal
    = zerosDecimalDecimalDecimal / Math.Pow(10, arr.Count - 3);\n        long onesDecimalDecimalDecimalDecimalDecimal
    = onesDecimalDecimalDecimalDecimal / Math.Pow(10, arr.Count - 4);\n        long
    zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal /
    Math.Pow(10, arr.Count - 4);\n        long onesDecimalDecimalDecimalDecimalDecimalDecimal
    = onesDecimalDecimalDecimalDecimalDecimalDecimal / Math.Pow(10, arr.Count - 5);\n
    \       long zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal
    / Math.Pow(10, arr.Count - 5);\n        long onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / Math.Pow(10,
    arr.Count - 6);\n        long zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / Math.Pow(10,
    arr.Count - 6);\n        long onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal /
    Math.Pow(10, arr.Count - 7);\n        long zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / Math.Pow(10,
    arr.Count - 7);\n        long onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    / Math.Pow(10, arr.Count - 8);\n        long zerosDecimalDecimalDecimal\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp9zcurs_f.cs(42,40): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMin = ones * min;\n        long zerosMin = zeros * min;\n        long onesMaxMin
    = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n        long onesMinMin
    = onesMin * min;\n        long zerosMinMin = zerosMin * min;\n        long onesMaxMinMin
    = onesMaxMin * min;\n        long zerosMaxMinMin = zerosMaxMin * min;\n        long
    onesMinMinMin = onesMinMin * min;\n        long zerosMinMinMin = zerosMinMin *
    min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMin
    = zerosMaxMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n        long
    zerosMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin = onesMaxMinMinMin
    * min;\n        long zerosMaxMinMin = zerosMaxMinMin * min;\n        long onesMinMinMinMin
    = onesMinMinMinMin * min;\n        long zerosMinMinMin = zerosMinMinMin * min;\n
    \       long onesMaxMinMinMin = onesMaxMinMinMin * min;\n        long zerosMaxMinMin
    = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMinMin * min;\n
    \       long zerosMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin
    = onesMaxMinMinMin * min;\n        long zerosMaxMinMin = zerosMaxMinMin * min;\n
    \       long onesMinMinMinMin = onesMinMinMinMin * min;\n        long zerosMinMinMin
    = zerosMinMinMin * min;\n        long onesMaxMinMinMin = onesMaxMin\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpwgdkbfrg.cs(66,43): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            long
    temp = 0;\n            long temp2 = 0;\n            long temp3 = 0;\n            long
    temp4 = 0;\n            long temp5 = 0;\n            long temp6 = 0;\n            long
    temp7 = 0;\n            long temp8 = 0;\n            long temp9 = 0;\n            long
    temp10 = 0;\n            long temp11 = 0;\n            long temp12 = 0;\n            long
    temp13 = 0;\n            long temp14 = 0;\n            long temp15 = 0;\n            long
    temp16 = 0;\n            long temp17 = 0;\n            long temp18 = 0;\n            long
    temp19 = 0;\n            long temp20 = 0;\n            long temp21 = 0;\n            long
    temp22 = 0;\n            long temp23 = 0;\n            long temp24 = 0;\n            long
    temp25 = 0;\n            long temp26 = 0;\n            long temp27 = 0;\n            long
    temp28 = 0;\n            long temp29 = 0;\n            long temp30 = 0;\n            long
    temp31 = 0;\n            long temp32 = 0;\n            long temp33 = 0;\n            long
    temp34 = 0;\n            long temp35 = 0;\n            long temp36 = 0;\n            long
    temp37 = 0;\n            long temp38 = 0;\n            long temp39 = 0;\n            long
    temp40 = 0;\n            long temp41 = 0;\n            long temp42 = 0;\n            long
    temp43 = 0;\n            long temp44 = 0;\n            long temp45 = 0;\n            long
    temp46 = 0;\n            long temp47 = 0;\n            long temp48 = 0;\n            long
    temp49 = 0;\n            long temp50 = 0;\n            long temp51 = 0;\n            long
    temp52 = 0;\n            long temp53 = 0;\n            long temp54 = 0;\n            long
    temp55 = 0;\n            long temp56 = 0;\n            long temp57 = 0;\n            long
    temp58 = 0;\n            long temp59 = 0;\n            long temp60 = 0;\n            long
    temp61 = 0;\n            long temp62 = 0;\n            long temp63 = 0;\n            long
    temp64 = 0;\n            long temp65 = 0;\n            long temp66 = 0;\n            long
    temp67 = 0;\n            long temp68 = 0;\n            long temp69 = 0;\n            long
    temp70 = 0;\n            long temp71 = 0;\n            long temp72 = 0;\n            long
    temp73 = 0;\n            long temp\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpjzxj1fet.cs(109,22): error CS1002: ; expected

    /tmp/tmpjzxj1fet.cs(111,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpjzxj1fet.cs(122,2): error CS1513: } expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long onesMin = ones * min;\n        long
    zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long onesDiff
    = onesMax - onesMin;\n        long zerosDiff = zerosMax - zerosMin;\n        long
    onesDiffMin = onesMax - onesMin;\n        long onesDiffMax = onesMax - onesMin;\n
    \       long zerosDiffMin = zerosMax - zerosMin;\n        long zerosDiffMax =
    zerosMax - zerosMin;\n        long onesDiffMinMax = onesMax - onesMin;\n        long
    onesDiffMaxMin = onesMax - onesMin;\n        long zerosDiffMinMax = zerosMax -
    zerosMin;\n        long zerosDiffMaxMin = zerosMax - zerosMin;\n        long onesDiffMinMaxMin
    = onesMax - onesMin;\n        long onesDiffMaxMinMin = onesMax - onesMin;\n        long
    zerosDiffMinMaxMin = zerosMax - zerosMin;\n        long zerosDiffMaxMinMin = zerosMax
    - zerosMin;\n        long onesDiffMinMaxMinMin = onesMax - onesMin;\n        long
    onesDiffMaxMinMin = onesMax - onesMin;\n        long zerosDiffMinMaxMin = zerosMax
    - zerosMin;\n        long zerosDiffMaxMinMin = zerosMax - zerosMin;\n        long
    onesDiffMinMaxMinMin = onesMax - onesMin;\n        long onesDiffMaxMinMin = onesMax
    - onesMin;\n        long zerosDiffMinMaxMin = zerosMax - zerosMin;\n        long
    zerosDiffMaxMinMin = zerosMax - zerosMin;\n        long onesDiffMinMaxMinMin =
    onesMax - onesMin;\n        long onesDiffMaxMinMin = onesMax - onesMin;\n        long
    zerosDiffMinMaxMin = zerosMa\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpv0untxxb.cs(66,42): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long maxOnes
    = 0;\n        long maxZeros = 0;\n        long max = 0;\n        long min = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \               if (ones > maxOnes) maxOnes = ones;\n                if (ones
    < min) min = ones;\n            } else if (i == 0L) {\n                zeros++;\n
    \               if (zeros > maxZeros) maxZeros = zeros;\n                if (zeros
    < min) min = zeros;\n            } else {\n                long bin = Convert.ToString(i,
    2);\n                long binLen = bin.Length;\n                long binOnes =
    bin.Count(x => x == '1');\n                long binZeros = bin.Count(x => x ==
    '0');\n                if (binOnes > maxOnes) maxOnes = binOnes;\n                if
    (binZeros > maxZeros) maxZeros = binZeros;\n                if (binOnes < min)
    min = binOnes;\n                if (binZeros < min) min = binZeros;\n            }\n
    \       }\n        long onesDiff = maxOnes - ones;\n        long zerosDiff = maxZeros
    - zeros;\n        long diff = onesDiff > zerosDiff ? onesDiff : zerosDiff;\n        if
    (diff == 0) return arr;\n        long onesDiff2 = diff / 2;\n        long zerosDiff2
    = diff % 2;\n        long diff2 = onesDiff2 > zerosDiff2 ? onesDiff2 : zerosDiff2;\n
    \       long onesDiff3 = diff2 / 3;\n        long zerosDiff3 = diff2 % 3;\n        long
    diff3 = onesDiff3 > zerosDiff3 ? onesDiff3 : zerosDiff3;\n        long onesDiff4
    = diff3 / 4;\n        long zerosDiff4 = diff3 % 4;\n        long diff4 = onesDiff4
    > zerosDiff4 ? onesDiff4 : zerosDiff4;\n        long onesDiff5 = diff4 / 5;\n
    \       long zerosDiff5 = diff4 % 5;\n        long diff5 = onesDiff5 > zerosDiff5
    ? onesDiff5 : zerosDiff5;\n        long onesDiff6 = diff5 / 6;\n        long zerosDiff6
    = diff5 % 6;\n        long diff6 = onesDiff6 > zerosDiff6 ? onesDiff6 : zerosDiff6;\n
    \       long onesDiff7 = diff6 / 7;\n        long zerosDiff7 = diff6 % 7;\n        long
    diff7 = onesDiff7 > zerosDiff7 ? one\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmptl7g8ewr.cs(67,50): error CS1003: Syntax error, '':'' expected

    /tmp/tmptl7g8ewr.cs(67,50): error CS1525: Invalid expression term ''}''

    /tmp/tmptl7g8ewr.cs(67,50): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMin = ones * max;\n        long zerosMin = zeros * max;\n        long onesMaxMin
    = onesMax * max;\n        long zerosMaxMin = zerosMax * max;\n        long onesMinMin
    = onesMin * max;\n        long zerosMinMin = zerosMin * max;\n        long onesMaxMinMin
    = onesMaxMin * max;\n        long zerosMaxMinMin = zerosMaxMin * max;\n        long
    onesMinMinMin = onesMinMin * max;\n        long zerosMinMinMin = zerosMinMin *
    max;\n        long onesMaxMinMinMin = onesMaxMinMin * max;\n        long zerosMaxMinMinMin
    = zerosMaxMinMin * max;\n        long onesMinMinMinMin = onesMinMinMin * max;\n
    \       long zerosMinMinMinMin = zerosMinMinMin * max;\n        long onesMaxMinMinMin
    = onesMaxMinMin * max;\n        long zerosMaxMinMinMin = zerosMaxMinMin * max;\n
    \       long onesMinMinMinMin = onesMinMinMin * max;\n        long zerosMinMinMinMin
    = zerosMinMinMin * max;\n        long onesMaxMinMinMin = onesMaxMinMin * max;\n
    \       long zerosMaxMinMinMin = zerosMaxMinMin * max;\n        long onesMinMinMinMin
    = onesMinMinMin * max;\n        long zerosMinMinMinMin = zerosMinMinMin * max;\n
    \       long onesMaxMinMinMin = onesMaxMinMin * max;\n        long zerosMaxMinMinMin
    = zerosMaxMinMin * max;\n        long onesMinMinMinMin = onesMinMinMin * max;\n
    \       long zerosMinMinMinMin = zerosMinMinMin * max;\n        long onesMaxMinMinMin
    = onesMaxMinMin * max;\n        long zerosMaxMinMinMin = \n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkw9jx13g.cs(63,33): error CS1525: Invalid expression term ''}''

    /tmp/tmpkw9jx13g.cs(63,33): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long zeros = 0;\n        foreach (long n in arr) {\n            if (n
    == 1L) {\n                ones++;\n            }\n            if (n == 0L) {\n
    \               zeros++;\n            }\n        }\n        if (ones > zeros)
    {\n            long temp;\n            long temp2;\n            long temp3;\n
    \           long temp4;\n            long temp5;\n            long temp6;\n            long
    temp7;\n            long temp8;\n            long temp9;\n            long temp10;\n
    \           long temp11;\n            long temp12;\n            long temp13;\n
    \           long temp14;\n            long temp15;\n            long temp16;\n
    \           long temp17;\n            long temp18;\n            long temp19;\n
    \           long temp20;\n            long temp21;\n            long temp22;\n
    \           long temp23;\n            long temp24;\n            long temp25;\n
    \           long temp26;\n            long temp27;\n            long temp28;\n
    \           long temp29;\n            long temp30;\n            long temp31;\n
    \           long temp32;\n            long temp33;\n            long temp34;\n
    \           long temp35;\n            long temp36;\n            long temp37;\n
    \           long temp38;\n            long temp39;\n            long temp40;\n
    \           long temp41;\n            long temp42;\n            long temp43;\n
    \           long temp44;\n            long temp45;\n            long temp46;\n
    \           long temp47;\n            long temp48;\n            long temp49;\n
    \           long temp50;\n            long temp51;\n            long temp52;\n
    \           long temp53;\n            long temp54;\n            long temp55;\n
    \           long temp56;\n            long temp57;\n            long temp58;\n
    \           long temp59;\n            long temp60;\n            long temp61;\n
    \           long temp62;\n            long temp63;\n            long temp64;\n
    \           long temp65;\n            long temp66;\n            long temp67;\n
    \           long temp68;\n            long temp69;\n            long temp70;\n
    \           long temp71;\n            long temp72;\n            long temp73;\n
    \           long temp74;\n            long temp75;\n            long temp76;\n
    \           long temp77;\n            long temp78;\n            long temp79\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkdxoe8ss.cs(110,24): error CS1002: ; expected

    /tmp/tmpkdxoe8ss.cs(112,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpkdxoe8ss.cs(123,2): error CS1513: } expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMin = ones * min;\n        long zerosMin = zeros * min;\n        long onesMaxMin
    = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n        long onesMinMin
    = onesMin * min;\n        long zerosMinMin = zerosMin * min;\n        long onesMaxMinMin
    = onesMaxMin * min;\n        long zerosMaxMinMin = zerosMaxMin * min;\n        long
    onesMinMinMin = onesMinMin * min;\n        long zerosMinMinMin = zerosMinMin *
    min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin
    = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n
    \       long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin
    = onesMaxMinMin * min;\n        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n
    \       long onesMinMinMinMin = onesMinMinMin * min;\n        long zerosMinMinMinMin
    = zerosMinMinMin * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n
    \       long zerosMaxMinMinMin = zerosMaxMinMin * min;\n        long onesMinMinMinMin
    = onesMinMinMin * min;\n        long zerosMinMinMinMin = zerosMinMinMin * min;\n
    \       long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin
    = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n
    \       long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin
    = one\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpcbs11snl.cs(66,36): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones > zeros) {\n            return arr.OrderBy(x =>
    BitConverter.ToInt64(BitConverter.GetBytes(x), 0))\n                .ThenBy(x
    => BitConverter.ToInt64(BitConverter.GetBytes(x), 1))\n                .ToList();\n
    \       }\n        return arr.OrderBy(x => BitConverter.ToInt64(BitConverter.GetBytes(x),
    1))\n            .ThenBy(x => BitConverter.ToInt64(BitConverter.GetBytes(x), 0))\n
    \           .ToList();\n    }\n    public static void Main(string[] args) {\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.ArgumentException: Destination array is
    not long enough to copy all the items in the collection. Check array index and
    length.\nParameter name: value\n  at System.BitConverter.ToInt64 (System.Byte[]
    value, System.Int32 startIndex) [0x00021] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem+<>c.<SortArray>b__0_3 (System.Int64 x) [0x00006] in <636261b4b3314c978afb178eef8072b2>:0
    \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys (TElement[] elements,
    System.Int32 count) [0x00010] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys
    (TElement[] elements, System.Int32 count) [0x00040] in <e540098dd111461e919c5863f6975c29>:0
    \n  at System.Linq.EnumerableSorter`1[TElement].ComputeMap (TElement[] elements,
    System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.EnumerableSorter`1[TElement].Sort
    (TElement[] elements, System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0
    \n  at System.Linq.OrderedEnumerable`1[TElement].SortedMap (System.Linq.Buffer`1[TElement]
    buffer) [0x00006] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.OrderedEnumerable`1[TElement].ToList
    () [0x0001f] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.Enumerable.ToList[TSource]
    (System.Collections.Generic.IEnumerable`1[T] source) [0x0001f] in <e540098dd111461e919c5863f6975c29>:0
    \n  at Problem.SortArray (System.Collections.Generic.List`1[T] arr) [0x0009f]
    in <636261b4b3314c978afb178eef8072b2>:0 \n  at Problem.Main (System.String[] args)
    [0x00017] in <636261b4b3314c978afb178eef8072b2>:0 \n[ERROR] FATAL UNHANDLED EXCEPTION:
    System.ArgumentException: Destination array is not long enough to copy all the
    items in the collection. Check array index and length.\nParameter name: value\n
    \ at System.BitConverter.ToInt64 (System.Byte[] value, System.Int32 startIndex)
    [0x00021] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem+<>c.<SortArray>b__0_3
    (System.Int64 x) [0x00006] in <636261b4b3314c978afb178eef807"
  stdout: ''
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1);\n        if (ones == 0) return
    arr;\n        long zeros = arr.Sum(x => ~x);\n        long maxOnes = arr.Max(x
    => x & 1);\n        long maxZeros = arr.Max(x => ~x);\n        long maxOnesZeros
    = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long
    maxZeroOnes = maxZeros - ones;\n        long maxZeroZeros = maxZeros - zeros;\n
    \       long maxOnesOnesZeros = maxOnesOnes - maxZeroOnes;\n        long maxOnesOnesOnes
    = maxOnesOnes - ones - maxZeroOnes;\n        long maxOnesOnesOnesZeros = maxOnesOnesOnes
    - ones - maxOnesOnesOnes;\n        long maxOnesOnesOnesOnes = maxOnesOnesOnes
    - ones - maxOnesOnesOnesZeros - maxOnesOnesOnesOnes;\n        long maxOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnes - ones - maxOnesOnesOnesZeros - maxOnesOnesOnesOnes - maxOnesOnesOnesOnesZeros
    - maxOnesOnesOnesOnesOnes;\n        long maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnes
    - ones - maxOnesOnesOnesZeros - maxOnesOnesOnesOnes - maxOnesOnesOnesOnesZeros
    - maxOnesOnesOnesOnesOnes - maxOnesOnesOnesOnesOnesZeros - maxOnesOnesOnesOnesOnesOnes;\n
    \       long maxOnesOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesOnes - ones - maxOnesOnesOnesZeros
    - maxOnesOnesOnesOnes - maxOnesOnesOnesOnesZeros - maxOnesOnesOnesOnesOnes - maxOnesOnesOnesOnesOnesZeros
    - maxOnesOnesOnesOnesOnesOnesZeros - maxOnesOnesOnesOnesOnesOnesOnes;\n        long
    maxOnesOnesOnesOnesOnesOnesZeros = maxOnesOnesOnes\n    }\n    public static void
    Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp6bp0w71b.cs(36,64): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long n in arr) {\n            ones += n;\n            zeros -=
    n;\n            if (ones > max) {\n                max = ones;\n            }\n
    \           if (zeros > max) {\n                max = zeros;\n            }\n
    \       }\n        long onesMax = 0;\n        long zerosMax = 0;\n        long
    maxMax = 0;\n        foreach (long n in arr) {\n            onesMax += n;\n            zerosMax
    -= n;\n            if (onesMax < maxMax) {\n                maxMax = onesMax;\n
    \           }\n            if (zerosMax < maxMax) {\n                maxMax =
    zerosMax;\n            }\n        }\n        long onesMaxMax = 0;\n        long
    zerosMaxMax = 0;\n        long maxMaxMax = 0;\n        foreach (long n in arr)
    {\n            onesMaxMax += n;\n            zerosMaxMax -= n;\n            if
    (onesMaxMax < maxMaxMax) {\n                maxMaxMax = onesMaxMax;\n            }\n
    \           if (zerosMaxMax < maxMaxMax) {\n                maxMaxMax = zerosMaxMax;\n
    \           }\n        }\n        long onesMaxMaxMax = 0;\n        long zerosMaxMaxMax
    = 0;\n        long maxMaxMaxMax = 0;\n        foreach (long n in arr) {\n            onesMaxMaxMax
    += n;\n            zerosMaxMaxMax -= n;\n            if (onesMaxMaxMax < maxMaxMaxMax)
    {\n                maxMaxMaxMax = onesMaxMaxMax;\n            }\n            if
    (zerosMaxMaxMax < maxMaxMaxMax) {\n                maxMaxMaxMax = zerosMaxMaxMax;\n
    \           }\n        }\n        long onesMaxMaxMaxMax = 0;\n        long zerosMaxMaxMaxMax
    = 0;\n        long maxMaxMaxMaxMax = 0;\n        foreach (long n in arr) {\n            onesMaxMaxMaxMax
    += n;\n            zerosMaxMaxMaxMax -= n;\n            if (onesMaxMaxMaxMax <
    maxMaxMaxMaxMax) {\n                maxMaxMaxMaxMax = onesMaxMaxMaxMax;\n            }\n
    \           if (zerosMaxMaxMaxMax < maxMaxMaxMaxMax) {\n                maxMaxMaxMaxMax
    = zerosMaxMaxMaxMax;\n            }\n        }\n        long onesMaxMaxMaxMax
    = 0;\n        long zerosMaxMaxMaxMax = 0;\n        long maxMaxMaxMaxMax = 0;\n
    \       foreach (long n in arr) {\n            onesMaxMaxMaxMax += n;\n            zerosMaxMaxMaxMax
    -= n;\n            if (ones\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpk5r8v_6v.cs(91,21): error CS1026: ) expected

    /tmp/tmpk5r8v_6v.cs(91,21): error CS1525: Invalid expression term ''}''

    /tmp/tmpk5r8v_6v.cs(91,21): error CS1002: ; expected

    /tmp/tmpk5r8v_6v.cs(93,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpk5r8v_6v.cs(104,2): error CS1513: } expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            result.Add(min);\n
    \           result.AddRange(arr.Where(i => i == min).OrderBy(i => Math.Abs(i -
    min)).Take(ones));\n            result.Add(max);\n            result.AddRange(arr.Where(i
    => i == max).OrderBy(i => Math.Abs(i - max)).Take(ones));\n        }\n        else
    {\n            result.Add(max);\n            result.AddRange(arr.Where(i => i
    == max).OrderBy(i => Math.Abs(i - max)).Take(zeros));\n            result.Add(min);\n
    \           result.AddRange(arr.Where(i => i == min).OrderBy(i => Math.Abs(i -
    min)).Take(zeros));\n        }\n        return result;\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpzmpedp7x.cs(41,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpzmpedp7x.cs(43,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpzmpedp7x.cs(47,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpzmpedp7x.cs(49,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        if (ones == 0) return
    arr;\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = arr.Max(x
    => x & 1L);\n        long maxZeros = arr.Max(x => x & 0L);\n        long maxOnesZeros
    = maxOnes - maxZeros;\n        long maxOnesOnes = maxOnes - ones;\n        long
    maxOnesZeroOnes = maxOnesZeros - ones;\n        long maxOnesOnesZeros = maxOnesOnes
    - ones;\n        long maxOnesOnesOnes = maxOnesOnes - ones;\n        long maxOnesZeroZeroOnes
    = maxOnesZeroZeros - ones;\n        long maxOnesOnesZeroZeros = maxOnesOnesZeros
    - ones;\n        long maxOnesOnesOnesZeros = maxOnesOnesOnes - ones;\n        long
    maxOnesZeroZeroOnesOnes = maxOnesZeroZeroOnes - ones;\n        long maxOnesOnesZeroZeroOnes
    = maxOnesOnesZeroZeros - ones;\n        long maxOnesOnesOnesZeroZeros = maxOnesOnesOnesZeros
    - ones;\n        long maxOnesZeroZeroOnesOnesZeros = maxOnesZeroZeroOnesOnesZeros
    - ones;\n        long maxOnesOnesZeroZeroOnesOnes = maxOnesOnesZeroZeroOnesOnes
    - ones;\n        long maxOnesZeroZeroOnesOnesOnesZeros = maxOnesZeroZeroOnesOnesOnesZeros
    - ones;\n        long maxOnesOnesZeroZeroOnesOnesZeros = maxOnesOnesZeroZeroOnesOnesZeros
    - ones;\n        long maxOnesZeroZeroOnesOnesOnesZeros = maxOnesOnesZeroZeroOnesOnesOnesZeros
    - ones;\n        long maxOnesOnesZeroZeroOnesOnesOnesZeros = maxOnesZeroZeroOnesOnesOnesOnesZeros
    - ones;\n        long maxOnesZeroZeroOnesOnesOnesOnesZeros = maxOnesOnesZeroZeroOnesOnesOnesZeros
    - ones;\n        long maxOnesOnesZeroZeroOnesOnesOnesOnesZero\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpsua2tp5f.cs(43,53): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones == zeros) {\n            return arr.OrderBy(x =>
    x).ToList();\n        }\n        long maxOnes = arr.Max(x => x & 1L);\n        long
    maxZeros = arr.Max(x => x & 0L);\n        long maxOnesDigit = Convert.ToInt64(Math.Pow(10,
    maxOnes - 1));\n        long maxZerosDigit = Convert.ToInt64(Math.Pow(10, maxZeros
    - 1));\n        long maxOnesDigit2 = Convert.ToInt64(Math.Pow(10, maxOnes - 2));\n
    \       long maxZerosDigit2 = Convert.ToInt64(Math.Pow(10, maxZeros - 2));\n        long
    maxOnesDigit3 = Convert.ToInt64(Math.Pow(10, maxOnes - 3));\n        long maxZerosDigit3
    = Convert.ToInt64(Math.Pow(10, maxZeros - 3));\n        long maxOnesDigit4 = Convert.ToInt64(Math.Pow(10,
    maxOnes - 4));\n        long maxZerosDigit4 = Convert.ToInt64(Math.Pow(10, maxZeros
    - 4));\n        long maxOnesDigit5 = Convert.ToInt64(Math.Pow(10, maxOnes - 5));\n
    \       long maxZerosDigit5 = Convert.ToInt64(Math.Pow(10, maxZeros - 5));\n        long
    maxOnesDigit6 = Convert.ToInt64(Math.Pow(10, maxOnes - 6));\n        long maxZerosDigit6
    = Convert.ToInt64(Math.Pow(10, maxZeros - 6));\n        long maxOnesDigit7 = Convert.ToInt64(Math.Pow(10,
    maxOnes - 7));\n        long maxZerosDigit7 = Convert.ToInt64(Math.Pow(10, maxZeros
    - 7));\n        long maxOnesDigit8 = Convert.ToInt64(Math.Pow(10, maxOnes - 8));\n
    \       long maxZerosDigit8 = Convert.ToInt64(Math.Pow(10, maxZeros - 8));\n        long
    maxOnesDigit9 = Convert.ToInt64(Math.Pow(10, maxOnes - 9));\n        long maxZerosDigit9
    = Convert.ToInt64(Math.Pow(10, maxZeros - 9));\n        long maxOnesDigit10 =
    Convert.ToInt64(Math.Pow(10, maxOnes - 10));\n        long maxZerosDigit10 = Convert.ToInt64(Math.Pow(10,
    maxZeros - 10));\n        long maxOnes\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp9f21nfok.cs(47,21): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMax2 = onesMax * onesMax;\n        long zerosMax2 = zerosMax * zerosMax;\n
    \       long onesMax3 = onesMax2 * onesMax;\n        long zerosMax3 = zerosMax2
    * zerosMax;\n        long onesMax4 = onesMax3 * onesMax;\n        long zerosMax4
    = zerosMax3 * zerosMax;\n        long onesMax5 = onesMax4 * onesMax;\n        long
    zerosMax5 = zerosMax4 * zerosMax;\n        long onesMax6 = onesMax5 * onesMax;\n
    \       long zerosMax6 = zerosMax5 * zerosMax;\n        long onesMax7 = onesMax6
    * onesMax;\n        long zerosMax7 = zerosMax6 * zerosMax;\n        long onesMax8
    = onesMax7 * onesMax;\n        long zerosMax8 = zerosMax7 * zerosMax;\n        long
    onesMax9 = onesMax8 * onesMax;\n        long zerosMax9 = zerosMax8 * zerosMax;\n
    \       long onesMax10 = onesMax9 * onesMax;\n        long zerosMax10 = zerosMax9
    * zerosMax;\n        long onesMax11 = onesMax10 * onesMax;\n        long zerosMax11
    = zerosMax10 * zerosMax;\n        long onesMax12 = onesMax11 * onesMax;\n        long
    zerosMax12 = zerosMax11 * zerosMax;\n        long onesMax13 = onesMax12 * onesMax;\n
    \       long zerosMax13 = zerosMax12 * zerosMax;\n        long onesMax14 = onesMax13
    * onesMax;\n        long zerosMax14 = zerosMax13 * zerosMax;\n        long onesMax15
    = onesMax14 * onesMax;\n        long zerosMax15 = zerosMax14 * zerosMax;\n        long
    onesMax16 = onesMax15 * onesMax;\n        long zerosMax16 = zerosMax15 * zerosMax;\n
    \       long \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpe4coxiz3.cs(66,13): error CS1001: Identifier expected

    /tmp/tmpe4coxiz3.cs(66,13): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x >> 1);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x >> 1);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesOnesZeros = maxOnesOnes - maxZeros;\n
    \       long maxOnesOnesOnes = maxOnesOnes - ones;\n        long maxOnesOnesOnesZeros
    = maxOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnes = maxOnesOnesOnes
    - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnes - maxZeros;\n
    \       long maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnes - ones;\n        long
    maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesZeros - maxZeros;\n        long
    maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnesOnes =
    maxOnesOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnes
    = maxOnesOnesOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes
    = maxOnesOnesOnesOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnesOnes\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpv15qx5lo.cs(40,80): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        if (ones == 0) return
    arr;\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = ones;\n
    \       long maxZeros = zeros;\n        long maxDiff = maxOnes - maxZeros;\n        long
    maxDiffIndex = arr.FindIndex(x => x > maxDiff);\n        long maxDiffValue = arr[maxDiffIndex];\n
    \       long maxDiffValueIndex = arr.FindIndex(x => x == maxDiffValue);\n        long
    maxDiffValueIndex2 = arr.FindIndex(x => x == maxDiffValue + 1);\n        long
    maxDiffValueIndex3 = arr.FindIndex(x => x == maxDiffValue + 2);\n        long
    maxDiffValueIndex4 = arr.FindIndex(x => x == maxDiffValue + 3);\n        long
    maxDiffValueIndex5 = arr.FindIndex(x => x == maxDiffValue + 4);\n        long
    maxDiffValueIndex6 = arr.FindIndex(x => x == maxDiffValue + 5);\n        long
    maxDiffValueIndex7 = arr.FindIndex(x => x == maxDiffValue + 6);\n        long
    maxDiffValueIndex8 = arr.FindIndex(x => x == maxDiffValue + 7);\n        long
    maxDiffValueIndex9 = arr.FindIndex(x => x == maxDiffValue + 8);\n        long
    maxDiffValueIndex10 = arr.FindIndex(x => x == maxDiffValue + 9);\n        long
    maxDiffValueIndex11 = arr.FindIndex(x => x == maxDiffValue + 10);\n        long
    maxDiffValueIndex12 = arr.FindIndex(x => x == maxDiffValue + 11);\n        long
    maxDiffValueIndex13 = arr.FindIndex(x => x == maxDiffValue + 12);\n        long
    maxDiffValueIndex14 = arr.FindIndex(x => x == maxDiffValue + 13);\n        long
    maxDiffValueIndex15 = arr.FindIndex(x => x == maxDiffValue + 14);\n        long
    maxDiffValueIndex16 = arr.FindIndex(x => x == maxDiffValue + 15);\n        long
    maxDiffValueIndex17 = arr.FindIndex(x => x == maxDiffValue + 16);\n        long
    maxDiffValueIndex18 = arr.FindIndex(x => x == maxDiffValue + 17);\n        long
    maxDiffValueIndex19 = arr.FindIndex(x => x == maxDiffValue + 18);\n        long
    maxDiffValueIndex20 = arr.FindIndex(x => x == maxDiffValue + 19);\n        long
    maxDiffValueIndex21 = arr.FindIndex(x => x == maxDiffValue + 20);\n        long
    maxDiffValueIndex22 = arr.FindIndex(\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpws6nsd8q.cs(49,50): error CS1026: ) expected

    /tmp/tmpws6nsd8q.cs(49,50): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long maxOnes
    = 0;\n        long maxZeros = 0;\n        foreach (long i in arr) {\n            ones
    += i;\n            zeros += (long)Math.Abs(i);\n            if (i > maxOnes) {\n
    \               maxOnes = i;\n            }\n            if (i < maxZeros) {\n
    \               maxZeros = i;\n            }\n        }\n        long onesMax
    = maxOnes;\n        long zerosMax = maxZeros;\n        long maxOnesMax = maxOnes;\n
    \       long maxZerosMax = maxZeros;\n        long maxOnesMin = maxOnes;\n        long
    maxZerosMin = maxZeros;\n        long maxOnesMaxMin = maxOnes;\n        long maxZerosMaxMin
    = maxZeros;\n        long maxOnesMaxMinMin = maxOnes;\n        long maxZerosMaxMinMin
    = maxZeros;\n        long maxOnesMaxMinMinMin = maxOnes;\n        long maxZerosMaxMinMinMin
    = maxZeros;\n        long maxOnesMaxMinMinMinMin = maxOnes;\n        long maxZerosMaxMinMinMinMin
    = maxZeros;\n        long maxOnesMaxMinMinMinMin = maxOnes;\n        long maxZerosMaxMinMinMinMin
    = maxZeros;\n        long maxOnesMaxMinMinMinMin = maxOnes;\n        long maxZerosMaxMinMinMinMin
    = maxZeros;\n        long maxOnesMaxMinMinMinMin = maxOnes;\n        long maxZerosMaxMinMinMinMin
    = maxZeros;\n        long maxOnesMaxMinMinMinMin = maxOnes;\n        long maxZerosMaxMinMinMinMin
    = maxZeros;\n        long maxOnesMaxMinMinMinMin = maxOnes;\n        long maxZerosMaxMinMinMinMin
    = maxZeros;\n        long maxOnesMaxMinMinMinMin = maxOnes;\n        long maxZerosMaxMinMinMinMin
    = maxZeros;\n        long maxOnesMaxMinMinMinMin = maxOnes;\n        long maxZerosMaxMinMinMinMin
    = maxZeros;\n        long maxOnesMaxMinMinMinMin = maxOnes;\n        \n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpydetjdu2.cs(48,14): error CS0128: A local variable or function named ''maxOnesMaxMinMinMinMin''
    is already defined in this scope

    /tmp/tmpydetjdu2.cs(49,14): error CS0128: A local variable or function named ''maxZerosMaxMinMinMinMin''
    is already defined in this scope

    /tmp/tmpydetjdu2.cs(50,14): error CS0128: A local variable or function named ''maxOnesMaxMinMinMinMin''
    is already defined in this scope

    /tmp/tmpydetjdu2.cs(51,14): error CS0128: A local variable or function named ''maxZerosMaxMinMinMinMin''
    is already defined in this scope

    /tmp/tmpydetjdu2.cs(52,14): error CS0128: A local variable or function named ''maxOnesMaxMinMinMinMin''
    is already defined in this scope

    /tmp/tmpydetjdu2.cs(53,14): error CS0128: A local variable or function named ''maxZerosMaxMinMinMinMin''
    is already defined in this scope

    /tmp/tmpydetjdu2.cs(54,14): error CS0128: A local variable or function named ''maxOnesMaxMinMinMinMin''
    is already defined in this scope

    /tmp/tmpydetjdu2.cs(55,14): error CS0128: A local variable or function named ''maxZerosMaxMinMinMinMin''
    is already defined in this scope

    /tmp/tmpydetjdu2.cs(56,14): error CS0128: A local variable or function named ''maxOnesMaxMinMinMinMin''
    is already defined in this scope

    /tmp/tmpydetjdu2.cs(57,14): error CS0128: A local variable or function named ''maxZerosMaxMinMinMinMin''
    is already defined in this scope

    /tmp/tmpydetjdu2.cs(58,14): error CS0128: A local variable or function named ''maxOnesMaxMinMinMinMin''
    is already defined in this scope

    /tmp/tmpydetjdu2.cs(59,14): error CS0128: A local variable or function named ''maxZerosMaxMinMinMinMin''
    is already defined in this scope

    /tmp/tmpydetjdu2.cs(60,14): error CS0128: A local variable or function named ''maxOnesMaxMinMinMinMin''
    is already defined in this scope

    /tmp/tmpydetjdu2.cs(61,14): error CS0128: A local variable or function named ''maxZerosMaxMinMinMinMin''
    is already defined in this scope

    /tmp/tmpydetjdu2.cs(62,1'
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long num in arr) {\n            if (num
    == 1) {\n                ones++;\n            }\n            if (num == 0) {\n
    \               zeros++;\n            }\n            if (num > max) {\n                max
    = num;\n            }\n            if (num < min) {\n                min = num;\n
    \           }\n        }\n        long onesMax = ones * max;\n        long onesMin
    = ones * min;\n        long zerosMax = zeros * max;\n        long zerosMin = zeros
    * min;\n        long maxOnes = ones * max;\n        long maxZeros = zeros * max;\n
    \       long minOnes = ones * min;\n        long minZeros = zeros * min;\n        long
    maxOnesMax = onesMax * max;\n        long maxOnesMin = onesMin * max;\n        long
    maxZerosMax = zerosMax * max;\n        long maxZerosMin = zerosMin * max;\n        long
    minOnesMax = onesMax * min;\n        long minOnesMin = onesMin * min;\n        long
    minZerosMax = zerosMax * min;\n        long minZerosMin = zerosMin * min;\n        long
    maxOnesMaxMin = onesMax * min;\n        long maxOnesMinMax = onesMin * max;\n
    \       long maxZerosMaxMin = zerosMax * min;\n        long maxZerosMinMax = zerosMin
    * max;\n        long minOnesMaxMin = onesMax * min;\n        long minOnesMinMax
    = onesMin * min;\n        long minZerosMaxMin = zerosMax * min;\n        long
    minZerosMinMax = zerosMin * min;\n        long maxOnesMaxMinMinMax = onesMax *
    min;\n        long maxOnesMinMaxMinMax = onesMin * max;\n        long maxZerosMaxMinMax
    = zerosMax * min;\n        long maxZerosMinMaxMinMax = zerosMin * max;\n        long
    minOnesMaxMinMax = onesMax * min;\n        long minOnesMinMaxMinMax = onesMin
    * min;\n        long minZerosMaxMinMax = zerosMax * min;\n        long minZ\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpalcyxc4a.cs(69,18): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            else if (i == 0L) {\n
    \               zeros++;\n            }\n            else {\n                if
    (ones > zeros) {\n                    max = i;\n                }\n                else
    {\n                    min = i;\n                }\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            result.Add(min);\n
    \           result.AddRange(arr.Where(i => i != min).OrderBy(i => Math.Abs(i -
    min)).Take(ones - 1).ToList());\n        }\n        else {\n            result.Add(max);\n
    \           result.AddRange(arr.Where(i => i != max).OrderBy(i => Math.Abs(i -
    max)).Take(zeros - 1).ToList());\n        }\n        return result;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpq42tmvuh.cs(43,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpq42tmvuh.cs(47,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones < zeros) {\n            arr = arr.OrderBy(x => x).ThenBy(x
    => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(Math.Abs(x))))));\n
    \       } else {\n            arr = arr.OrderByDescending(x => x).ThenByDescending(x
    => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(Math.Abs(x))))));\n
    \       }\n        return arr;\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpro9lbpjn.cs(23,19): error CS0266: Cannot implicitly convert type ''System.Linq.IOrderedEnumerable<long>''
    to ''System.Collections.Generic.List<long>''. An explicit conversion exists (are
    you missing a cast?)

    /tmp/tmpro9lbpjn.cs(25,19): error CS0266: Cannot implicitly convert type ''System.Linq.IOrderedEnumerable<long>''
    to ''System.Collections.Generic.List<long>''. An explicit conversion exists (are
    you missing a cast?)

    '
  timestamp: 1659823604
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            else if (i == 0L) {\n                zeros++;\n            }\n
    \           else {\n                if (ones > zeros) {\n                    max
    = i;\n                }\n                else {\n                    max = zeros;\n
    \               }\n            }\n        }\n        List<long> result = new List<long>();\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                result.Add(i);\n
    \           }\n            else if (i == 0L) {\n                result.Add(max);\n
    \           }\n            else {\n                if (ones > zeros) {\n                    result.Add(i);\n
    \               }\n                else {\n                    result.Add(max);\n
    \               }\n            }\n        }\n        return result;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <6f83d4ce7c504acdb39aa8054970e114>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <6f83d4ce7c504acdb39aa8054970e114>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x >> 1);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x >> 1);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesZeroOnes = maxOnes - zeros;\n
    \       long maxOnesOnesZeros = maxOnes - ones - zeros;\n        long maxOnesOnesOnes
    = maxOnes - ones - ones;\n        long maxOnesOnesOnesZeros = maxOnes - ones -
    ones - zeros;\n        long maxOnesOnesOnesOnes = maxOnes - ones - ones - ones;\n
    \       long maxOnesOnesOnesOnesZeros = maxOnes - ones - ones - ones - zeros;\n
    \       long maxOnesOnesOnesOnesOnes = maxOnes - ones - ones - ones - ones;\n
    \       long maxOnesOnesOnesOnesOnesZeros = maxOnes - ones - ones - ones - ones
    - zeros;\n        long maxOnesOnesOnesOnesOnesOnes = maxOnes - ones - ones - ones
    - ones - ones;\n        long maxOnesOnesOnesOnesOnesZeros = maxOnes - ones - ones
    - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes =
    maxOnes - ones - ones - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros
    = maxOnes - ones - ones - ones - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes
    = maxOnes - ones - ones - ones - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros
    = maxOnes - ones - ones - ones - ones - ones - ones - ones - zeros;\n        long
    maxOnesOnesOnesOnesOnesOnesOnesOnes = maxOnes - ones - ones - ones - ones - ones
    - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesOnesOnes\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp50hhzm3t.cs(41,45): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            ones +=
    i;\n            zeros -= i;\n            if (ones > max) {\n                max
    = ones;\n            }\n            if (zeros > min) {\n                min =
    zeros;\n            }\n        }\n        List<long> result = new List<long>();\n
    \       foreach (long i in arr) {\n            if (i == 1) {\n                result.Add(i);\n
    \           }\n            else if (i == 0) {\n                result.Add(-i);\n
    \           }\n            else {\n                result.Add(min + ((max - min)
    * ((long)Math.Pow(2, (int)(Math.Log10(i - min)))));\n            }\n        }\n
    \       return result;\n    }\n    public static void Main(string[] args) {\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp7hcq32oq.cs(43,97): error CS1026: ) expected

    '
  timestamp: 1659823604
- exit_code: -1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            long
    onesMax = ones;\n            long zerosMax = zeros;\n            while (onesMax
    < zerosMax) {\n                result.Add(max);\n                onesMax--;\n
    \               zerosMax--;\n            }\n            while (zerosMax < onesMax)
    {\n                result.Add(max);\n                zerosMax--;\n                onesMax--;\n
    \           }\n        }\n        else {\n            long zerosMax = zeros;\n
    \           long onesMax = ones;\n            while (zerosMax < onesMax) {\n                result.Add(max);\n
    \               zerosMax--;\n                onesMax--;\n            }\n            while
    (onesMax < zerosMax) {\n                result.Add(max);\n                onesMax--;\n
    \               zerosMax--;\n            }\n        }\n        return result;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Timeout
  stderr: ''
  stdout: None
  timestamp: 1659823609
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            result.Add(max);\n
    \           result.AddRange(arr.Where(i => i == max).OrderBy(i => i).Take(ones));\n
    \       }\n        if (zeros > ones) {\n            result.AddRange(arr.Where(i
    => i == max).OrderBy(i => i).Take(zeros));\n        }\n        if (ones == zeros)
    {\n            result.AddRange(arr);\n        }\n        return result;\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpgwzpgmjc.cs(37,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpgwzpgmjc.cs(40,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        if (arr.Count == 0) return arr;\n        long ones = arr.Sum(x
    => x & 1);\n        if (ones == 0) return arr;\n        long maxOnes = arr.Max(x
    => x & 1);\n        long maxOnesIndex = arr.FindIndex(x => x & 1 == maxOnes);\n
    \       long maxOnesValue = (maxOnesIndex == arr.Count - 1) ? arr.Max() : arr[maxOnesIndex
    + 1];\n        long maxOnesValueIndex = arr.FindIndex(x => x & 1 == maxOnesValue);\n
    \       long maxOnesValueValue = (maxOnesValueIndex == arr.Count - 1) ? arr.Max()
    : arr[maxOnesValueIndex + 1];\n        long maxOnesValueValueIndex = arr.FindIndex(x
    => x & 1 == maxOnesValueValue);\n        long maxOnesValueValueValue = (maxOnesValueValueIndex
    == arr.Count - 1) ? arr.Max() : arr[maxOnesValueValueIndex + 1];\n        long
    maxOnesValueValueValueIndex = arr.FindIndex(x => x & 1 == maxOnesValueValueValue);\n
    \       long maxOnesValueValueValue = (maxOnesValueValueValueIndex == arr.Count
    - 1) ? arr.Max() : arr[maxOnesValueValueValueIndex + 1];\n        long maxOnesValueValueValueIndex
    = arr.FindIndex(x => x & 1 == maxOnesValueValueValue);\n        long maxOnesValueValueValue
    = (maxOnesValueValueValueIndex == arr.Count - 1) ? arr.Max() : arr[maxOnesValueValueValueIndex
    + 1];\n        long maxOnesValueValueValueIndex = arr.FindIndex(x => x & 1 ==
    maxOnesValueValueValue);\n        long maxOnesValueValueValue = (maxOnesValueValueValueIndex
    == arr.Count - 1) ? arr.Max() : arr[maxOnesValueValueValueIndex + 1];\n        long
    maxOnesValueValueValueIndex = arr.FindIndex(x => x & 1 == maxOnesValueValueValue);\n
    \       long maxOnesValueValueValue = (maxOnesValueValueValueIndex == arr.Count
    - 1) ? arr.Max() : arr[maxOnesValueValueValueIndex + 1];\n        long maxOnesValueValueValueIndex
    = arr.FindIndex(x => x & 1 == maxOnesValueValueValue);\n        long maxOnesValueValueValue
    = (maxOnesValueValueValueIndex == arr.Count - 1) ? arr.Max() : arr[maxOnesValueValueValueIndex
    + 1];\n        long maxOnesValueValueValueIndex = arr.FindIndex(x => x \n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpoxt598jz.cs(40,64): error CS1026: ) expected

    /tmp/tmpoxt598jz.cs(40,64): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesZeroOnes = maxOnesZeros - ones;\n
    \       long maxOnesOnesZeros = maxOnesOnes - ones;\n        long maxOnesZeroOnesOnes
    = maxOnesZeroOnes - ones;\n        long maxOnesOnesZeroOnes = maxOnesOnesZeros
    - ones;\n        long maxOnesZeroOnesOnesZeros = maxOnesZeroOnesOnes - ones;\n
    \       long maxOnesOnesZeroOnesOnesZeros = maxOnesOnesZeroOnesOnes - ones;\n
    \       long maxOnesZeroOnesOnesOnesZeros = maxOnesZeroOnesOnesOnes - ones;\n
    \       long maxOnesOnesZeroOnesOnesOnesZeros = maxOnesOnesZeroOnesOnesOnes -
    ones;\n        long maxOnesZeroOnesOnesOnesOnesZeros = maxOnesZeroOnesOnesOnesOnes
    - ones;\n        long maxOnesOnesZeroOnesOnesOnesOnesZeros = maxOnesOnesZeroOnesOnesOnesOnesZeros
    - ones;\n        long maxOnesZeroOnesOnesOnesOnesOnesZeros = maxOnesZeroOnesOnesOnesOnesOnesZeros
    - ones;\n        long maxOnesOnesZeroOnesOnesOnesOnesZeros = maxOnesOnesZeroOnesOnesOnesOnesZeros
    - ones;\n        long maxOnesZeroOnesOnesOnesOnesOnesOnesZeros = maxOnesZeroOnesOnesOnesOnesOnesOnesZeros
    - ones;\n        long maxOnesOnesZeroOnesOnesOnesOnesOnesZeros = maxOnesOnesZeroOnesOnesOnesOnesOnesZeros
    - ones;\n        long maxOnesZeroOnesOnesOnesOnesOnesOne\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpe12ct420.cs(40,48): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       if (ones > zeros) {\n            arr.Sort((x, y) => Compare(ones, zeros,
    x, y));\n        }\n        if (zeros > ones) {\n            arr.Sort((x, y) =>
    Compare(zeros, ones, x, y));\n        }\n        return arr;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp1w6johub.cs(35,32): error CS0103: The name ''Compare'' does not exist
    in the current context

    /tmp/tmp1w6johub.cs(38,32): error CS0103: The name ''Compare'' does not exist
    in the current context

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long maxOnes
    = 0;\n        long maxZeros = 0;\n        foreach (long i in arr) {\n            if
    (i == 1L) {\n                ones++;\n                if (ones > maxOnes) {\n
    \                   maxOnes = ones;\n                }\n            } else {\n
    \               zeros++;\n                if (zeros > maxZeros) {\n                    maxZeros
    = zeros;\n                }\n            }\n        }\n        List<long> result
    = new List<long>();\n        long onesCount = 0;\n        long zerosCount = 0;\n
    \       long maxOnesCount = 0;\n        long maxZerosCount = 0;\n        foreach
    (long i in arr) {\n            if (i == 1L) {\n                onesCount++;\n
    \               if (onesCount > maxOnesCount) {\n                    maxOnesCount
    = onesCount;\n                }\n            } else {\n                zerosCount++;\n
    \               if (zerosCount > maxZerosCount) {\n                    maxZerosCount
    = zerosCount;\n                }\n            }\n        }\n        long maxOnesCount2
    = maxOnesCount / 2;\n        long maxZerosCount2 = maxZerosCount / 2;\n        long
    maxOnesCount3 = maxOnesCount / 3;\n        long maxZerosCount3 = maxZerosCount
    / 3;\n        long maxOnesCount4 = maxOnesCount / 4;\n        long maxZerosCount4
    = maxZerosCount / 4;\n        long maxOnesCount5 = maxOnesCount / 5;\n        long
    maxZerosCount5 = maxZerosCount / 5;\n        long maxOnesCount6 = maxOnesCount
    / 6;\n        long maxZerosCount6 = maxZerosCount / 6;\n        long maxOnesCount7
    = maxOnesCount / 7;\n        long maxZerosCount7 = maxZerosCount / 7;\n        long
    maxOnesCount8 = maxOnesCount / 8;\n        long maxZerosCount8 = maxZerosCount
    / 8;\n        long maxOnesCount9 = maxOnesCount / 9;\n        long maxZerosCount9
    = maxZerosCount / 9;\n        long maxOnesCount10 = maxOnesCount / 10;\n        long
    maxZerosCount10 = maxZerosCount / 10;\n        long maxOnesCount11 = maxOnesCount
    / 11;\n        long maxZerosCount11 = maxZerosCount / 11;\n        long maxOnesCount12
    = maxOnesCount / 12;\n\n    }\n    public static void Main(string[] args) {\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpbypn5jhu.cs(19,30): error CS0161: ''Problem.SortArray(List<long>)'': not
    all code paths return a value

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long n in arr) {\n            if (n == 1L) {\n                ones++;\n
    \           }\n            if (n == 0L) {\n                zeros++;\n            }\n
    \           if (n > max) {\n                max = n;\n            }\n        }\n
    \       long onesMax = ones > zeros ? ones : zeros;\n        long zerosMax = zeros
    > ones ? zeros : ones;\n        long onesMin = ones < zeros ? ones : zeros;\n
    \       long zerosMin = zeros < ones ? zeros : ones;\n        long onesAvg = (ones
    + zeros) / 2;\n        long zerosAvg = (zeros + ones) / 2;\n        long onesDev
    = Math.Sqrt(Math.Pow(onesAvg, 2));\n        long zerosDev = Math.Sqrt(Math.Pow(zerosAvg,
    2));\n        long onesDeviation = Math.Abs(onesDev - onesAvg);\n        long
    zerosDeviation = Math.Abs(zerosDev - zerosAvg);\n        long onesDeviationDev
    = Math.Abs(onesDev - onesAvg * onesAvg);\n        long zerosDeviationDev = Math.Abs(zerosDev
    - zerosAvg * zerosAvg);\n        long onesDeviationDevAvg = Math.Abs(onesDev -
    onesAvg * onesAvg * onesAvg);\n        long zerosDeviationDevAvg = Math.Abs(zerosDev
    - zerosAvg * zerosAvg * zerosAvg);\n        long onesDeviationDevAvgAbs = Math.Abs(onesDev
    - onesAvg * onesAvg * onesAvg * onesAvg);\n        long zerosDeviationDevAvgAbs
    = Math.Abs(zerosDev - zerosAvg * zerosAvg * zerosAvg * zerosAvg);\n        long
    onesDeviationDevAvgAbsDev = Math.Abs(onesDev - onesAvg * onesAvg * onesAvg * onesAvg
    * onesAvg);\n        long zerosDeviationDevAvgAbsDev = Math.Abs(zerosDev - zerosAvg
    * zerosAvg * zerosAvg * zerosAvg * zerosAvg);\n        long onesDeviationDevAvgAbsDevAvg
    = Math.Abs(onesDev - onesAvg * onesAvg * onesAvg * onesAvg * onesAvg * onesAvg);\n
    \       long zerosDeviationDevAvgAbsDevAvg = \n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpp2tb87dp.cs(53,45): error CS1525: Invalid expression term ''}''

    /tmp/tmpp2tb87dp.cs(53,45): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMax2 = onesMax * onesMax;\n        long zerosMax2 = zerosMax * zerosMax;\n
    \       long onesMax3 = onesMax2 * onesMax;\n        long zerosMax3 = zerosMax2
    * zerosMax;\n        long onesMax4 = onesMax3 * onesMax;\n        long zerosMax4
    = zerosMax3 * zerosMax;\n        long onesMax5 = onesMax4 * onesMax;\n        long
    zerosMax5 = zerosMax4 * zerosMax;\n        long onesMax6 = onesMax5 * onesMax;\n
    \       long zerosMax6 = zerosMax5 * zerosMax;\n        long onesMax7 = onesMax6
    * onesMax;\n        long zerosMax7 = zerosMax6 * zerosMax;\n        long onesMax8
    = onesMax7 * onesMax;\n        long zerosMax8 = zerosMax7 * zerosMax;\n        long
    onesMax9 = onesMax8 * onesMax;\n        long zerosMax9 = zerosMax8 * zerosMax;\n
    \       long onesMax10 = onesMax9 * onesMax;\n        long zerosMax10 = zerosMax9
    * zerosMax;\n        long onesMax11 = onesMax10 * onesMax;\n        long zerosMax11
    = zerosMax10 * zerosMax;\n        long onesMax12 = onesMax11 * onesMax;\n        long
    zerosMax12 = zerosMax11 * zerosMax;\n        long onesMax13 = onesMax12 * onesMax;\n
    \       long zerosMax13 = zerosMax12 * zerosMax;\n        long onesMax14 = onesMax13
    * onesMax;\n        long zerosMax14 = zerosMax13 * zerosMax;\n        long onesMax15
    = onesMax14 * onesMax;\n        long zerosMax15 = zerosMax14 * zerosMax;\n        long
    onesMax16 = onesMax15 * onesMax;\n        long zerosMax16 = zerosMax15 * zerosMax;\n
    \       long \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpe4coxiz3.cs(66,13): error CS1001: Identifier expected

    /tmp/tmpe4coxiz3.cs(66,13): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesOnesZeros = maxOnesOnes - maxZeros;\n
    \       long maxOnesOnesOnes = maxOnesOnes - ones;\n        long maxOnesOnesOnesZeros
    = maxOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnes = maxOnesOnesOnes
    - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnes - maxZeros;\n
    \       long maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnes - ones;\n        long
    maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesZeros - maxZeros;\n        long
    maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesOnes - ones;\n        long maxOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesZeros - maxZeros;\n        long maxOnesOnesOnesOnesOnes =
    maxOnesOnesOnesOnesOnes - ones;\n        long maxOnesOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesOnesZeros
    - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesOnesOnes
    - ones;\n        long maxOnesOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesOnesZeros
    - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesOnesOnes
    - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesOnesOnesZeros
    - maxZeros;\n        long maxOne\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmptv8perqa.cs(41,20): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones;\n        long zerosMax = zeros;\n        long maxMax
    = max;\n        long onesMin = ones;\n        long zerosMin = zeros;\n        long
    maxMin = max;\n        long onesMaxMin = ones;\n        long zerosMaxMin = zeros;\n
    \       long maxMaxMin = max;\n        long onesMinMax = ones;\n        long zerosMinMax
    = zeros;\n        long maxMinMax = max;\n        long onesMaxMinMax = ones;\n
    \       long zerosMaxMinMax = zeros;\n        long maxMaxMinMax = max;\n        long
    onesMinMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n        long maxMinMaxMax
    = max;\n        long onesMaxMinMaxMax = ones;\n        long zerosMaxMinMaxMax
    = zeros;\n        long maxMaxMinMaxMax = max;\n        long onesMinMaxMaxMax =
    ones;\n        long zerosMinMaxMaxMax = zeros;\n        long maxMinMaxMaxMax =
    max;\n        long onesMaxMinMaxMax = ones;\n        long zerosMinMaxMaxMax =
    zeros;\n        long maxMaxMinMaxMax = max;\n        long onesMinMaxMaxMaxMax
    = ones;\n        long zerosMinMaxMaxMax = zeros;\n        long maxMinMaxMaxMax
    = max;\n        long onesMaxMinMaxMaxMax = ones;\n        long zerosMinMaxMaxMax
    = zeros;\n        long maxMaxMinMaxMax = max;\n        long onesMinMaxMaxMaxMax
    = ones;\n        long zerosMinMaxMaxMax = zeros;\n        long maxMinMaxMaxMax
    = max;\n        long onesMaxMinMaxMaxMax = ones;\n        long zerosMinMaxMaxMax
    = zeros;\n        long maxMaxMinMaxMax = max;\n        long onesMinMaxMaxMaxMax
    = ones;\n        long zerosMinMaxMaxMax = zeros;\n        long maxMinMaxMaxMax
    = max;\n        long onesMaxMinMax\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpa4egemda.cs(76,27): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesTwos = maxOnes - twos;\n        long
    maxOnesThrees = maxOnes - threes;\n        long maxOnesFours = maxOnes - fours;\n
    \       long maxOnesFives = maxOnes - fives;\n        long maxOnesSixes = maxOnes
    - sixes;\n        long maxOnesSevens = maxOnes - sevens;\n        long maxOnesEights
    = maxOnes - eights;\n        long maxOnesNines = maxOnes - nines;\n        long
    maxOnesTens = maxOnes - tens;\n        long maxOnesElevens = maxOnes - elevens;\n
    \       long maxOnesTwelves = maxOnes - twelves;\n        long maxOnesThirteens
    = maxOnes - thirteens;\n        long maxOnesFourteens = maxOnes - fourteens;\n
    \       long maxOnesFifteens = maxOnes - fifteens;\n        long maxOnesSixteens
    = maxOnes - sixteens;\n        long maxOnesSeventeens = maxOnes - seventeens;\n
    \       long maxOnesEighteens = maxOnes - eighteens;\n        long maxOnesNineteens
    = maxOnes - nineteens;\n        long maxOnesTwenty = maxOnes - twenty;\n        long
    maxOnesThirty = maxOnes - thirty;\n        long maxOnesFourty = maxOnes - fourty;\n
    \       long maxOnesFifty = maxOnes - fifty;\n        long maxOnesSixty = maxOnes
    - sixty;\n        long maxOnesSeventy = maxOnes - seventy;\n        long maxOnesEighty
    = maxOnes - eighty;\n        long maxOnesNinety = maxOnes - ninety;\n        long
    maxOnesOne = maxOnes - one;\n        long maxOnesTwo = maxOnes - \n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpud40m3kv.cs(53,36): error CS1525: Invalid expression term ''}''

    /tmp/tmpud40m3kv.cs(53,36): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long n in arr) {\n            if (n == 1L) {\n                ones++;\n
    \           } else if (n == 0L) {\n                zeros++;\n            } else
    {\n                max = Math.Max(max, n);\n            }\n        }\n        List<long>
    result = new List<long>();\n        if (ones > zeros) {\n            long onesMax
    = ones;\n            long zerosMax = zeros;\n            long maxMax = max;\n
    \           while (onesMax < zerosMax && maxMax < maxMax) {\n                result.Add(maxMax);\n
    \               maxMax--;\n            }\n            while (onesMax < zerosMax
    && maxMax < maxMax) {\n                result.Add(zerosMax);\n                zerosMax--;\n
    \           }\n            while (onesMax < zerosMax && maxMax < maxMax) {\n                result.Add(onesMax);\n
    \               onesMax--;\n            }\n        } else {\n            long
    zerosMax = zeros;\n            long onesMax = ones;\n            long maxMax =
    max;\n            while (zerosMax < onesMax && maxMax < maxMax) {\n                result.Add(maxMax);\n
    \               maxMax--;\n            }\n            while (zerosMax < onesMax
    && maxMax < maxMax) {\n                result.Add(onesMax);\n                onesMax--;\n
    \           }\n            while (zerosMax < onesMax && maxMax < maxMax) {\n                result.Add(zerosMax);\n
    \               zerosMax--;\n            }\n        }\n        return result;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b70bfcb3e6174d3b94229f3b0e8a8f85>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b70bfcb3e6174d3b94229f3b0e8a8f85>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            result.Add(min);\n
    \           result.AddRange(arr.Where(i => i == min).OrderBy(i => i).Take(ones));\n
    \           result.AddRange(arr.Where(i => i == max).OrderBy(i => i).Take(zeros));\n
    \       }\n        else if (zeros > ones) {\n            result.AddRange(arr.Where(i
    => i == max).OrderBy(i => i).Take(zeros));\n            result.Add(min);\n            result.AddRange(arr.Where(i
    => i == min).OrderBy(i => i).Take(ones));\n        }\n        else {\n            result.AddRange(arr.Where(i
    => i == max).OrderBy(i => i).Take(zeros));\n            result.AddRange(arr.Where(i
    => i == min).OrderBy(i => i).Take(ones));\n        }\n        return result;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpb87f7_x3.cs(41,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpb87f7_x3.cs(42,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpb87f7_x3.cs(45,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpb87f7_x3.cs(47,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpb87f7_x3.cs(50,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpb87f7_x3.cs(51,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMin = ones * max;\n        long zerosMin = zeros * max;\n        long onesMaxMin
    = onesMax * max;\n        long zerosMaxMin = zerosMax * max;\n        long onesMinMin
    = onesMin * max;\n        long zerosMinMin = zerosMin * max;\n        long onesMaxMinMin
    = onesMaxMin * max;\n        long zerosMaxMinMin = zerosMaxMin * max;\n        long
    onesMinMinMin = onesMinMin * max;\n        long zerosMinMinMin = zerosMinMin *
    max;\n        long onesMaxMinMinMin = onesMaxMinMin * max;\n        long zerosMaxMinMinMin
    = zerosMaxMinMin * max;\n        long onesMinMinMinMin = onesMinMinMin * max;\n
    \       long zerosMinMinMinMin = zerosMinMinMin * max;\n        long onesMaxMinMinMin
    = onesMaxMinMin * max;\n        long zerosMaxMinMinMin = zerosMaxMinMin * max;\n
    \       long onesMinMinMinMin = onesMinMinMin * max;\n        long zerosMinMinMinMin
    = zerosMinMinMin * max;\n        long onesMaxMinMinMin = onesMaxMinMin * max;\n
    \       long zerosMaxMinMinMin = zerosMaxMinMin * max;\n        long onesMinMinMinMin
    = onesMinMinMin * max;\n        long zerosMinMinMinMin = zerosMinMinMin * max;\n
    \       long onesMaxMinMinMin = onesMaxMinMin * max;\n        long zerosMaxMinMinMin
    = zerosMaxMinMin * max;\n        long onesMinMinMinMin = onesMinMinMin * max;\n
    \       long zerosMinMinMinMin = zerosMinMinMin * max;\n        long onesMaxMinMinMin
    = onesMaxMinMin * max;\n        long zerosMaxMinMinMin = \n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkw9jx13g.cs(63,33): error CS1525: Invalid expression term ''}''

    /tmp/tmpkw9jx13g.cs(63,33): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesZeroOnes = maxOnes - zeros;\n
    \       long maxOnesOnesZeros = maxOnes - ones - zeros;\n        long maxOnesOnesOnes
    = maxOnes - ones - ones;\n        long maxOnesOnesOnesZeros = maxOnes - ones -
    ones - zeros;\n        long maxOnesOnesOnesOnes = maxOnes - ones - ones - ones;\n
    \       long maxOnesOnesOnesOnesZeros = maxOnes - ones - ones - ones - zeros;\n
    \       long maxOnesOnesOnesOnesOnes = maxOnes - ones - ones - ones - ones;\n
    \       long maxOnesOnesOnesOnesOnesZeros = maxOnes - ones - ones - ones - ones
    - zeros;\n        long maxOnesOnesOnesOnesOnesOnes = maxOnes - ones - ones - ones
    - ones - ones;\n        long maxOnesOnesOnesOnesOnesZeros = maxOnes - ones - ones
    - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes =
    maxOnes - ones - ones - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros
    = maxOnes - ones - ones - ones - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes
    = maxOnes - ones - ones - ones - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros
    = maxOnes - ones - ones - ones - ones - ones - ones - ones - zeros;\n        long
    maxOnesOnesOnesOnesOnesOnesOnesOnes = maxOnes - ones - ones - ones - ones - ones
    - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnes\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpidy3tkb5.cs(41,37): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMin = ones * min - max;\n        long zerosMin = zeros * min - max;\n        long
    onesDiff = onesMax - onesMin;\n        long zerosDiff = zerosMax - zerosMin;\n
    \       long onesMaxDiff = onesMax - onesMax;\n        long zerosMaxDiff = zerosMax
    - zerosMax;\n        long onesMinDiff = onesMin - onesMax;\n        long zerosMinDiff
    = zerosMin - zerosMax;\n        long onesDiffDiff = onesDiff - onesDiffDiff;\n
    \       long zerosDiffDiff = zerosDiff - zerosDiffDiff;\n        long onesMaxDiffDiff
    = onesMaxDiff - onesMaxDiff;\n        long zerosMaxDiffDiff = zerosMaxDiff - zerosMaxDiffDiff;\n
    \       long onesMinDiffDiff = onesMinDiff - onesMinDiffDiff;\n        long zerosMinDiffDiff
    = zerosMinDiff - zerosMinDiffDiff;\n        long onesDiffDiffDiff = onesDiffDiff
    - onesDiffDiffDiff;\n        long zerosDiffDiffDiff = zerosDiffDiff - zerosDiffDiffDiff;\n
    \       long onesMaxDiffDiffDiff = onesMaxDiffDiff - onesMaxDiffDiff;\n        long
    zerosMaxDiffDiffDiff = zerosMaxDiffDiff - zerosMaxDiffDiffDiff;\n        long
    onesMinDiffDiffDiff = onesMinDiffDiff - onesMinDiffDiffDiff;\n        long zerosMinDiffDiffDiff
    = zerosMinDiffDiff - zerosMinDiffDiffDiff;\n        long onesDiffDiffDiffDiff
    = onesDiffDiffDiff - onesDiffDiffDiffDiff;\n        long zerosDiffDiffDiffDiff
    = zerosDiffDiffDiff - zerosDiffDiffDiffDiff;\n        long onesMaxDiffDiffDiffDiff
    = onesMaxDiffDiffDiff - onesMaxDiffDiffDiff;\n        long zerosMaxDiffDiffDiffDiff
    = zerosMaxDiffDiff\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpi7zj1hci.cs(59,57): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            ones += i;\n            zeros -=
    i;\n            if (ones > max) {\n                max = ones;\n            }\n
    \           if (zeros > max) {\n                max = zeros;\n            }\n
    \       }\n        List<long> res = new List<long>();\n        foreach (long i
    in arr) {\n            if (i == 1) {\n                res.Add(i);\n            }\n
    \       }\n        foreach (long i in arr) {\n            if (i == 0) {\n                res.Add(i);\n
    \           }\n        }\n        long onesCount = 0;\n        long zerosCount
    = 0;\n        foreach (long i in res) {\n            onesCount += i;\n            zerosCount
    -= i;\n            if (onesCount > max) {\n                max = onesCount;\n
    \           }\n            if (zerosCount > max) {\n                max = zerosCount;\n
    \           }\n        }\n        long maxCount = 0;\n        foreach (long i
    in res) {\n            maxCount += i;\n        }\n        long maxCountOnes =
    0;\n        long maxCountZeros = 0;\n        foreach (long i in res) {\n            if
    (i == 1) {\n                maxCountOnes += i;\n            }\n            if
    (i == 0) {\n                maxCountZeros += i;\n            }\n        }\n        long
    maxCountOnesCount = 0;\n        long maxCountZerosCount = 0;\n        foreach
    (long i in res) {\n            if (i == 1) {\n                maxCountOnesCount
    += i;\n            }\n            if (i == 0) {\n                maxCountZerosCount
    += i;\n            }\n        }\n        long maxCountOnesCountZeros = 0;\n        long
    maxCountZerosCountOnes = 0;\n        foreach (long i in res) {\n            if
    (i == 1) {\n                maxCountOnesCountZeros += i;\n            }\n            if
    (i == 0) {\n                maxCountZerosCountOnes += i;\n            }\n        }\n
    \       long maxCountOnesCountZerosCount = 0;\n        long maxCountZerosCountOnesCount
    = 0;\n        foreach (long i in res) {\n            if (i == 1) {\n                maxCountOnesCountZerosCount
    += i;\n            }\n            if (i == 0) {\n                maxCountZerosCountOnesCount
    += i;\n            }\n        }\n        long maxCountOnesCountZerosCountOnes
    = 0;\n        long maxCountZerosCountOnesCountOnes = 0;\n        foreach (long
    i in res) {\n            if (i == 1) {\n                maxCountOnesCountZerosCountOnes
    += i;\n            }\n            if (i == 0) {\n                maxCountZerosCountOnesCountOnes
    += i;\n            }\n        }\n\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpknypzp1a.cs(19,30): error CS0161: ''Problem.SortArray(List<long>)'': not
    all code paths return a value

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones > zeros) {\n            return arr.OrderBy(x =>
    Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(Math.Abs(x))))));\n        }
    else {\n            return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(Math.Abs(x))))));\n
    \       }\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpsmd4ju09.cs(23,20): error CS0266: Cannot implicitly convert type ''System.Linq.IOrderedEnumerable<long>''
    to ''System.Collections.Generic.List<long>''. An explicit conversion exists (are
    you missing a cast?)

    /tmp/tmpsmd4ju09.cs(25,20): error CS0266: Cannot implicitly convert type ''System.Linq.IOrderedEnumerable<long>''
    to ''System.Collections.Generic.List<long>''. An explicit conversion exists (are
    you missing a cast?)

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           } else if (i == 0L) {\n                zeros++;\n            } else
    {\n                max = Math.Max(max, i);\n            }\n        }\n        List<long>
    res = new List<long>();\n        if (ones > zeros) {\n            long onesMax
    = Convert.ToInt64(Math.Pow(2, ones));\n            long zerosMax = Convert.ToInt64(Math.Pow(2,
    zeros));\n            long onesMin = Convert.ToInt64(Math.Pow(2, ones - 1));\n
    \           long zerosMin = Convert.ToInt64(Math.Pow(2, zeros - 1));\n            long
    onesMax2 = Convert.ToInt64(Math.Pow(2, ones - 2));\n            long zerosMax2
    = Convert.ToInt64(Math.Pow(2, zeros - 2));\n            long onesMin2 = Convert.ToInt64(Math.Pow(2,
    ones - 3));\n            long zerosMin2 = Convert.ToInt64(Math.Pow(2, zeros -
    3));\n            long onesMax3 = Convert.ToInt64(Math.Pow(2, ones - 4));\n            long
    zerosMax3 = Convert.ToInt64(Math.Pow(2, zeros - 4));\n            long onesMin3
    = Convert.ToInt64(Math.Pow(2, ones - 5));\n            long zerosMin3 = Convert.ToInt64(Math.Pow(2,
    zeros - 5));\n            long onesMax4 = Convert.ToInt64(Math.Pow(2, ones - 6));\n
    \           long zerosMax4 = Convert.ToInt64(Math.Pow(2, zeros - 6));\n            long
    onesMin4 = Convert.ToInt64(Math.Pow(2, ones - 7));\n            long zerosMin4
    = Convert.ToInt64(Math.Pow(2, zeros - 7));\n            long onesMax5 = Convert.ToInt64(Math.Pow(2,
    ones - 8));\n            long zerosMax5 = Convert.ToInt64(Math.Pow(2, zeros -
    8));\n            long onesMin5 = Convert.ToInt64(Math.Pow(2, ones - 9));\n            long
    zerosMin5 = Convert.ToInt64(Math.Pow(2, zeros - 9));\n            long onesMax6
    = Convert.ToInt64(Math.Pow(2, ones - 10));\n            long zerosMax6 = Convert.ToInt64(Math.Pow(2,
    zeros - 10));\n            long onesMin6 = Convert.ToInt64(Math.Pow(2, ones -
    11));\n            long zerosMin6 = Convert.ToInt64(Math.Pow(2, zeros - 11));\n
    \           long one\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpssne658a.cs(58,21): error CS1002: ; expected

    /tmp/tmpssne658a.cs(60,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpssne658a.cs(71,2): error CS1513: } expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long onesMin = ones * min;\n        long
    zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long maxOnes
    = ones * max;\n        long maxZeros = zeros * max;\n        long minOnes = ones
    * min;\n        long minZeros = zeros * min;\n        long maxOnesMin = onesMin
    * max;\n        long maxOnesMax = onesMax * max;\n        long maxZerosMin = zerosMin
    * max;\n        long maxZerosMax = zerosMax * max;\n        long minOnesMin =
    onesMin * min;\n        long minOnesMax = onesMax * min;\n        long minZerosMin
    = zerosMin * min;\n        long minZerosMax = zerosMax * min;\n        long maxOnesMaxMin
    = onesMax * max * min;\n        long maxOnesMaxMax = onesMax * max * max;\n        long
    maxZerosMaxMin = zerosMax * max * min;\n        long maxZerosMaxMax = zerosMax
    * max * max;\n        long minOnesMaxMin = onesMax * min * min;\n        long
    minOnesMaxMax = onesMax * min * max;\n        long minZerosMaxMin = zerosMax *
    min * min;\n        long minZerosMaxMax = zerosMax * min * max;\n        long
    maxOnesMinMin = onesMin * min * min;\n        long maxOnesMinMax = onesMin * min
    * max;\n        long maxZerosMinMin = zerosMin * min * min;\n        long maxZerosMinMax
    = zerosMin * min * max;\n        long minOnesMinMin = onesMin * min * min;\n        long
    minOnesMinMax = onesMin * min * max;\n        long minZ\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpz836v8t2.cs(68,18): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long zeros = 0;\n        foreach (long i in arr) {\n            if (i
    == 1L) {\n                ones++;\n            }\n            if (i == 0L) {\n
    \               zeros++;\n            }\n        }\n        if (ones > zeros)
    {\n            long onesCount = 0;\n            long zerosCount = 0;\n            long
    maxOnesCount = ones;\n            long maxZerosCount = zeros;\n            long
    maxOnesCountInResult = 0;\n            long maxZerosCountInResult = 0;\n            long
    maxOnesCountInArr = 0;\n            long maxZerosCountInArr = 0;\n            foreach
    (long i in arr) {\n                if (i == 1L) {\n                    onesCount++;\n
    \               }\n                if (i == 0L) {\n                    zerosCount++;\n
    \               }\n                if (onesCount > maxOnesCount) {\n                    maxOnesCount
    = onesCount;\n                    maxOnesCountInResult = i;\n                }\n
    \               if (zerosCount > maxZerosCount) {\n                    maxZerosCount
    = zerosCount;\n                    maxZerosCountInResult = i;\n                }\n
    \               if (onesCount == maxOnesCount) {\n                    if (zerosCount
    == maxZerosCount) {\n                        maxOnesCountInArr = i;\n                        maxZerosCountInArr
    = i;\n                    }\n                    else {\n                        if
    (maxOnesCountInArr < maxOnesCountInResult) {\n                            maxOnesCountInArr
    = i;\n                        }\n                        else {\n                            maxOnesCountInResult
    = i;\n                        }\n                    }\n                }\n                if
    (zerosCount == maxZerosCount) {\n                    if (maxZerosCountInArr <
    maxZerosCountInResult) {\n                        maxZerosCountInArr = i;\n                    }\n
    \                   else {\n                        maxZerosCountInResult = i;\n
    \                   }\n                }\n            }\n            long maxOnesCountInResultInArr
    = maxOnesCountInArr;\n            long maxZerosCountInResultInArr = maxZerosCountInArr;\n
    \           long maxOnesCountInArrInResult = maxOnesCountInResult;\n            long
    maxZerosCountInArrInResult = maxZerosCountInResult;\n            long maxOnesCountInResultInResult
    = maxOnesCountInResult;\n            long maxZerosCountInResultInResult = maxZerosCountInResult;\n\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpb367qni3.cs(86,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpb367qni3.cs(97,2): error CS1513: } expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           } else if (i == 0L) {\n                zeros++;\n            } else
    {\n                max = Math.Max(max, i);\n            }\n        }\n        List<long>
    result = new List<long>();\n        if (ones > zeros) {\n            result.AddRange(arr.OrderBy(i
    => Convert.ToInt64(Math.Pow(2, Convert.ToInt64(Math.Log(max, 2))))).ToList());\n
    \       } else {\n            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2,
    Convert.ToInt64(Math.Log(max, 2))))).Reverse().ToList());\n        }\n        return
    result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <ec22572d3222470bbebecbb8c7800690>:0
    \n\nUnhandled Exception:\nSystem.OverflowException: Arithmetic operation resulted
    in an overflow.\n  at (wrapper managed-to-native) System.Object.__icall_wrapper___emul_fconv_to_ovf_i8(double)\n
    \ at System.Convert.ToInt64 (System.Double value) [0x00006] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem+<>c__DisplayClass0_0.<SortArray>b__1 (System.Int64 i) [0x0001e]
    in <ec22572d3222470bbebecbb8c7800690>:0 \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys
    (TElement[] elements, System.Int32 count) [0x00010] in <e540098dd111461e919c5863f6975c29>:0
    \n  at System.Linq.EnumerableSorter`1[TElement].ComputeMap (TElement[] elements,
    System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.EnumerableSorter`1[TElement].Sort
    (TElement[] elements, System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0
    \n  at System.Linq.OrderedEnumerable`1[TElement].SortedMap (System.Linq.Buffer`1[TElement]
    buffer) [0x00006] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.OrderedEnumerable`1[TElement].ToList
    () [0x0001f] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.Enumerable.ToList[TSource]
    (System.Collections.Generic.IEnumerable"
  stdout: ''
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long num in arr) {\n            if (num == 1) ones++;\n            else
    if (num == 0) zeros++;\n            else if (num > max) max = num;\n        }\n
    \       long onesMax = ones;\n        long zerosMax = zeros;\n        long maxMax
    = max;\n        long onesMin = ones;\n        long zerosMin = zeros;\n        long
    maxMin = max;\n        long onesMaxMin = ones;\n        long zerosMaxMin = zeros;\n
    \       long maxMaxMin = max;\n        long onesMinMax = ones;\n        long zerosMinMax
    = zeros;\n        long maxMinMax = max;\n        long onesMaxMinMax = ones;\n
    \       long zerosMaxMinMax = zeros;\n        long maxMaxMinMax = max;\n        long
    onesMinMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n        long maxMinMaxMax
    = max;\n        long onesMaxMinMaxMax = ones;\n        long zerosMaxMinMaxMax
    = zeros;\n        long maxMaxMinMaxMax = max;\n        long onesMinMaxMaxMax =
    ones;\n        long zerosMinMaxMaxMax = zeros;\n        long maxMinMaxMaxMax =
    max;\n        long onesMaxMinMaxMax = ones;\n        long zerosMinMaxMaxMax =
    zeros;\n        long maxMaxMinMaxMax = max;\n        long onesMinMaxMaxMaxMax
    = ones;\n        long zerosMinMaxMaxMax = zeros;\n        long maxMinMaxMaxMax
    = max;\n        long onesMaxMinMaxMaxMax = ones;\n        long zerosMinMaxMaxMax
    = zeros;\n        long maxMaxMinMaxMax = max;\n        long onesMinMaxMaxMaxMax
    = ones;\n        long zerosMinMaxMaxMax = zeros;\n        long maxMinMaxMaxMax
    = max;\n        long onesMaxMinMaxMaxMax = ones;\n        long zerosMinMaxMaxMax
    = zeros;\n        long maxMaxMinMaxMax = max;\n        long onesMinMaxMaxMaxMax
    = ones;\n        long zerosMinMaxMaxMax = zeros;\n        long maxMinMaxMaxMax
    = max;\n        long onesMaxMinMaxMaxMax = ones;\n        long zeros\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp95yv8rkr.cs(71,19): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones > zeros) {\n            long tmp = ones;\n            ones
    = zeros;\n            zeros = tmp;\n        }\n        long max = arr.Max();\n
    \       long min = arr.Min();\n        long mid = (max + min) / 2;\n        long
    midOnes = arr.Sum(x => x & 1L);\n        long midZeros = arr.Sum(x => x & 0L);\n
    \       if (midOnes > midZeros) {\n            long tmp = midOnes;\n            midOnes
    = midZeros;\n            midZeros = tmp;\n        }\n        long midMax = arr.Max();\n
    \       long midMin = arr.Min();\n        long midMid = (midMax + midMin) / 2;\n
    \       long midMidOnes = arr.Sum(x => x & 1L);\n        long midMidZeros = arr.Sum(x
    => x & 0L);\n        if (midMidOnes > midMidZeros) {\n            long tmp = midMidOnes;\n
    \           midMidOnes = midMidZeros;\n            midMidZeros = tmp;\n        }\n
    \       long midMidMax = arr.Max();\n        long midMidMin = arr.Min();\n        long
    midMidMid = (midMidMax + midMidMin) / 2;\n        long midMidMidOnes = arr.Sum(x
    => x & 1L);\n        long midMidMidZeros = arr.Sum(x => x & 0L);\n        if (midMidMidOnes
    > midMidMidZeros) {\n            long tmp = midMidMidOnes;\n            midMidMidOnes
    = midMidMidZeros;\n            midMidMidZeros = tmp;\n        }\n        long
    midMidMidMax = arr.Max();\n        long midMidMidMin = arr.Min();\n        long
    midMidMidMid = (midMidMidMax + midMidMidMin) / 2;\n        long midMidMidOnes
    = arr.Sum(x => x & 1L);\n        long midMidMidZeros = arr.Sum(x => x & 0L);\n
    \       if (midMidMidOnes > midMidMidZeros) {\n            long tmp = midMidMidOnes;\n
    \           midMidMidOnes = midMidMidZeros;\n            midMidMidZeros = tmp;\n
    \       }\n        long midMidMidMax = arr.Max();\n        long midMidMidMin =
    arr.Min\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp0ok20z4b.cs(68,36): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        long onesCount = 0;\n        long
    zerosCount = 0;\n        long maxCount = 0;\n        foreach (long i in arr) {\n
    \           if (i == 1L) {\n                onesCount++;\n            }\n            if
    (i == 0L) {\n                zerosCount++;\n            }\n            if (i >
    max) {\n                maxCount = i;\n            }\n        }\n        if (onesCount
    > zerosCount) {\n            result.Add(max);\n            result.AddRange(arr.Where(i
    => i != 1L).OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt64(Math.Log10(i))))));\n
    \       }\n        else if (zerosCount > onesCount) {\n            result.AddRange(arr.Where(i
    => i != 0L).OrderBy(i => Convert.ToInt64(Math.Pow(2, Convert.ToInt64(Math.Log10(i))))));\n
    \       }\n        else {\n            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2,
    Convert.ToInt64(Math.Log10(i))))));\n        }\n        return result;\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <152dd15da589479ea81075e21385a265>:0
    \n\nUnhandled Exception:\nSystem.OverflowException: Arithmetic operation resulted
    in an overflow.\n  at (wrapper managed-to-native) System.Object.__icall_wrapper___emul_fconv_to_ovf_i8(double)\n
    \ at System.Convert.ToInt64 (System.Double value) [0x00006] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem+<>c.<SortArray>b__0_4 (System.Int64 i) [0x00010] in <152dd15da589479ea81075e21385a265>:0
    \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys (TElement[] elements,
    System.Int32 count) [0x00010] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.EnumerableSorter`1[TElement].ComputeMap
    (TElement[] elements, System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0
    \n  at System.Linq.EnumerableSorter`1[TElement].Sort (TElement[] elements, System.Int32
    count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.OrderedEnumerable`1[TElement].SortedMap
    (System.Linq.Buffer`1[TElement] buffer) [0x00006] in <e540098dd111461e919c5863f6975c29>:0
    \n  at System.Linq.OrderedEnumerable`1+<GetEnumerator>d__3[TElement].MoveNext
    () [0x0003d] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Collections.Generic.List`1[T].AddEnumerable
    (System.Collections."
  stdout: ''
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            result.Add(min);\n
    \           result.AddRange(arr.Where(i => i == min).OrderBy(i => Math.Abs(i -
    min)).Take(ones - 1));\n            result.Add(max);\n            result.AddRange(arr.Where(i
    => i == max).OrderBy(i => Math.Abs(i - max)).Take(zeros - 1));\n        } else
    {\n            result.Add(max);\n            result.AddRange(arr.Where(i => i
    == max).OrderBy(i => Math.Abs(i - max)).Take(zeros - 1));\n            result.Add(min);\n
    \           result.AddRange(arr.Where(i => i == min).OrderBy(i => Math.Abs(i -
    min)).Take(ones - 1));\n        }\n        return result;\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpj8en3268.cs(41,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpj8en3268.cs(43,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpj8en3268.cs(46,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpj8en3268.cs(48,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long zeros = 0;\n        long max = 0;\n        foreach (long i in arr)
    {\n            ones += i;\n            zeros -= i;\n            if (ones > max)
    {\n                max = ones;\n            }\n            if (zeros > max) {\n
    \               max = zeros;\n            }\n        }\n        long onesMax =
    max;\n        long zerosMax = max;\n        long maxOnes = 0;\n        long maxZeros
    = 0;\n        long maxOnesMax = 0;\n        long maxZerosMax = 0;\n        long
    maxOnesMaxOnes = 0;\n        long maxZerosMaxZeros = 0;\n        long maxOnesMaxOnesMax
    = 0;\n        long maxZerosMaxZerosMax = 0;\n        long maxOnesMaxOnesMaxZeros
    = 0;\n        long maxZerosMaxZerosMaxZeros = 0;\n        long maxOnesMaxOnesMaxZerosMax
    = 0;\n        long maxZerosMaxZerosMaxZerosMax = 0;\n        foreach (long i in
    arr) {\n            onesMax += i;\n            zerosMax -= i;\n            if
    (onesMax > maxOnesMax) {\n                maxOnesMax = onesMax;\n            }\n
    \           if (zerosMax > maxZerosMax) {\n                maxZerosMax = zerosMax;\n
    \           }\n            if (onesMax < maxOnesMaxOnes) {\n                maxOnesMaxOnes
    = onesMax;\n            }\n            if (zerosMax < maxZerosMaxZeros) {\n                maxZerosMaxZeros
    = zerosMax;\n            }\n            if (onesMax < maxOnesMaxOnesMax) {\n                maxOnesMaxOnesMax
    = onesMax;\n            }\n            if (zerosMax < maxZerosMaxZerosMax) {\n
    \               maxZerosMaxZerosMax = zerosMax;\n            }\n            if
    (onesMax < maxOnesMaxOnesMaxZerosMax) {\n                maxOnesMaxOnesMaxZeros
    = onesMax;\n            }\n            if (zerosMax < maxZerosMaxZerosMaxZerosMax)
    {\n                maxZerosMaxZerosMaxZeros = zerosMax;\n            }\n            if
    (onesMax < maxOnesMaxOnesMaxZerosMaxZerosMax) {\n                maxOnesMaxOnesMaxZerosMax
    = onesMax;\n\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpfi_j_58q.cs(79,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpfi_j_58q.cs(90,2): error CS1513: } expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            long
    onesMax = ones;\n            long zerosMax = zeros;\n            long onesMin
    = ones;\n            long zerosMin = zeros;\n            while (onesMax - zerosMax
    < max) {\n                onesMax++;\n                zerosMax++;\n            }\n
    \           while (zerosMax - onesMax < max) {\n                zerosMax++;\n
    \               onesMax++;\n            }\n            while (onesMin - zerosMin
    < max) {\n                onesMin--;\n                zerosMin--;\n            }\n
    \           while (zerosMin - onesMin < max) {\n                zerosMin--;\n
    \               onesMin--;\n            }\n            while (onesMax - zerosMax
    < max) {\n                onesMax++;\n                zerosMax++;\n            }\n
    \           while (zerosMax - onesMax < max) {\n                zerosMax++;\n
    \               onesMax++;\n            }\n            while (onesMin - zerosMin
    < max) {\n                onesMin--;\n                zerosMin--;\n            }\n
    \           while (zerosMin - onesMin < max) {\n                zerosMin--;\n
    \               onesMin--;\n            }\n            while (onesMax - zerosMax
    < max) {\n                onesMax++;\n                zerosMax++;\n            }\n
    \           while (zerosMax - onesMax < max) {\n                zerosMax++;\n
    \               onesMax++;\n            }\n            while (onesMin - zerosMin
    < max) {\n                onesMin--;\n                zerosMin--;\n            }\n
    \           while (zerosMin - onesMin < max) {\n                zerosMin--;\n
    \               onesMin--;\n            }\n            while (onesMax - zerosMax
    < max) {\n                onesMax++;\n                zerosMax++;\n            }\n
    \           while (zerosMax - onesMax < max) {\n                zerosMax++;\n
    \               onesMax++;\n            }\n            while (onesMin - zerosMin
    < max) {\n                onesMin--;\n                zerosMin--;\n            }\n
    \           while (zerosMin - onesMin < max) {\n                zerosMin--;\n
    \               onesMin--;\n            }\n            while (\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpnb794nnz.cs(104,20): error CS1525: Invalid expression term ''}''

    /tmp/tmpnb794nnz.cs(104,20): error CS1026: ) expected

    /tmp/tmpnb794nnz.cs(104,20): error CS1002: ; expected

    /tmp/tmpnb794nnz.cs(106,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpnb794nnz.cs(117,2): error CS1513: } expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones > zeros) {\n            return arr.OrderBy(x =>
    Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(x))))).ToList();\n        }\n
    \       return arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(x))))).ThenBy(x
    => x).ToList();\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <19fb0b7f657d4fc8916cd8411600b169>:0
    \n\nUnhandled Exception:\nSystem.OverflowException: Value was either too large
    or too small for an Int32.\n  at System.Convert.ToInt32 (System.Double value)
    [0x0007a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem+<>c.<SortArray>b__0_2
    (System.Int64 x) [0x00010] in <19fb0b7f657d4fc8916cd8411600b169>:0 \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys
    (TElement[] elements, System.Int32 count) [0x00010] in <e540098dd111461e919c5863f6975c29>:0
    \n  at System.Linq.EnumerableSorter`1[TElement].ComputeMap (TElement[] elements,
    System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.EnumerableSorter`1[TElement].Sort
    (TElement[] elements, System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0
    \n  at System.Linq.OrderedEnumerable`1[TElement].SortedMap (System.Linq.Buffer`1[TElement]
    buffer) [0x00006] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.OrderedEnumerable`1[TElement].ToList
    () [0x0001f] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.Enumerable.ToList[TSource]
    (System.Collections.Generic.IEnumerable`1[T] source) [0x0001f] in <e540098dd111461e919c5863f6975c29>:0
    \n  at Problem.SortArray (System.Colle"
  stdout: ''
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        if (arr.Count == 0) return arr;\n        long ones = arr.Sum(x
    => x & 1L);\n        long zeros = arr.Sum(x => x >> 1);\n        if (ones == 0)
    return arr;\n        if (zeros == 0) return arr.OrderBy(x => x).ToList();\n        long
    maxOnes = ones;\n        long maxZeros = zeros;\n        long maxDiff = maxOnes
    - maxZeros;\n        long minOnes = maxOnes - 1;\n        long minZeros = maxZeros
    - 1;\n        long minDiff = minOnes - minZeros;\n        long diff = 0;\n        long
    onesCount = 0;\n        long zerosCount = 0;\n        long diffCount = 0;\n        long
    maxDiffCount = 0;\n        long minDiffCount = 0;\n        long maxDiffCount2
    = 0;\n        long minDiffCount2 = 0;\n        long maxDiffCount3 = 0;\n        long
    minDiffCount3 = 0;\n        long maxDiffCount4 = 0;\n        long minDiffCount4
    = 0;\n        long maxDiffCount5 = 0;\n        long minDiffCount5 = 0;\n        long
    maxDiffCount6 = 0;\n        long minDiffCount6 = 0;\n        long maxDiffCount7
    = 0;\n        long minDiffCount7 = 0;\n        long maxDiffCount8 = 0;\n        long
    minDiffCount8 = 0;\n        long maxDiffCount9 = 0;\n        long minDiffCount9
    = 0;\n        long maxDiffCount10 = 0;\n        long minDiffCount10 = 0;\n        long
    maxDiffCount11 = 0;\n        long minDiffCount11 = 0;\n        long maxDiffCount12
    = 0;\n        long minDiffCount12 = 0;\n        long maxDiffCount13 = 0;\n        long
    minDiffCount13 = 0;\n        long maxDiffCount14 = 0;\n        long minDiffCount14
    = 0;\n        long maxDiffCount15 = 0;\n        long minDiffCount15 = 0;\n        long
    maxDiffCount16 = 0;\n        long minDiffCount16 = 0;\n        long maxDiffCount17
    = 0;\n        long minDiffCount17 = 0;\n        long maxDiffCount18 = 0;\n        long
    minDiffCount18 = 0;\n        long maxDiffCount19 = 0;\n        long minDiffCount19
    = 0;\n        long maxDiffCount20 = 0;\n        long minDiffCount20 = 0;\n        long
    maxDiffCount21 = 0;\n        long minDiffCount21 = 0;\n        long maxDiffCount22
    = 0;\n        long minDiffCount22 = 0;\n        long maxDiffCount23 = 0;\n        long
    minDiffCount23 = 0;\n        long maxDiffCount24\n    }\n    public static void
    Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpxv0da3bd.cs(81,28): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long zeros = 0;\n        long maxOnes = 0;\n        long maxZeros = 0;\n
    \       long maxOnesCount = 0;\n        long maxZerosCount = 0;\n        foreach
    (long i in arr) {\n            if (i == 1L) {\n                ones++;\n                if
    (ones > maxOnes) {\n                    maxOnes = ones;\n                    maxOnesCount
    = maxOnes;\n                }\n            }\n            if (i == 0L) {\n                zeros++;\n
    \               if (zeros > maxZeros) {\n                    maxZeros = zeros;\n
    \                   maxZerosCount = maxZeros;\n                }\n            }\n
    \       }\n        long maxOnesDecimal = maxOnes / maxOnesCount;\n        long
    maxZerosDecimal = maxZeros / maxZerosCount;\n        long maxOnesDecimalDecimal
    = maxOnesDecimal / maxOnesCount;\n        long maxZerosDecimalDecimal = maxZerosDecimal
    / maxZerosCount;\n        long maxOnesDecimalDecimalDecimal = maxOnesDecimalDecimal
    / maxOnesCount;\n        long maxZerosDecimalDecimalDecimal = maxZerosDecimalDecimal
    / maxZerosCount;\n        long maxOnesDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimal
    / maxOnesCount;\n        long maxZerosDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimal
    / maxZerosCount;\n        long maxOnesDecimalDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimalDecimal
    / maxOnesCount;\n        long maxZerosDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimal
    / maxZerosCount;\n        long maxOnesDecimalDecimalDecimalDecimalDecimalDecimal
    = maxOnesDecimalDecimalDecimalDecimalDecimalDecimal / maxOnesCount;\n        long
    maxZerosDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimal
    / maxZerosCount;\n        long maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / maxOnesCount;\n
    \       long maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    / maxZer\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkg7p_acl.cs(56,140): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesOnesZeros = maxOnesOnes - maxZeros;\n
    \       long maxOnesOnesOnes = maxOnesOnes - ones;\n        long maxOnesOnesOnesZeros
    = maxOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnes = maxOnesOnesOnes
    - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnes - maxZeros;\n
    \       long maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnes - ones;\n        long
    maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesZeros - maxZeros;\n        long
    maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnesOnes =
    maxOnesOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnes
    = maxOnesOnesOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnes
    = maxOnesOnesOnesOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnesOnesOnes\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpzzrtf5vu.cs(40,80): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        if (ones == 0) return
    arr;\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxOnesIndex
    = arr.FindIndex(x => x == maxOnes);\n        long maxOnesIndex2 = arr.FindIndex(x
    => x == maxOnesIndex);\n        long maxOnesIndex3 = arr.FindIndex(x => x == maxOnesIndex2);\n
    \       long maxOnesIndex4 = arr.FindIndex(x => x == maxOnesIndex3);\n        long
    maxOnesIndex5 = arr.FindIndex(x => x == maxOnesIndex4);\n        long maxOnesIndex6
    = arr.FindIndex(x => x == maxOnesIndex5);\n        long maxOnesIndex7 = arr.FindIndex(x
    => x == maxOnesIndex6);\n        long maxOnesIndex8 = arr.FindIndex(x => x ==
    maxOnesIndex7);\n        long maxOnesIndex9 = arr.FindIndex(x => x == maxOnesIndex8);\n
    \       long maxOnesIndex10 = arr.FindIndex(x => x == maxOnesIndex9);\n        long
    maxOnesIndex11 = arr.FindIndex(x => x == maxOnesIndex10);\n        long maxOnesIndex12
    = arr.FindIndex(x => x == maxOnesIndex11);\n        long maxOnesIndex13 = arr.FindIndex(x
    => x == maxOnesIndex12);\n        long maxOnesIndex14 = arr.FindIndex(x => x ==
    maxOnesIndex13);\n        long maxOnesIndex15 = arr.FindIndex(x => x == maxOnesIndex14);\n
    \       long maxOnesIndex16 = arr.FindIndex(x => x == maxOnesIndex15);\n        long
    maxOnesIndex17 = arr.FindIndex(x => x == maxOnesIndex16);\n        long maxOnesIndex18
    = arr.FindIndex(x => x == maxOnesIndex17);\n        long maxOnesIndex19 = arr.FindIndex(x
    => x == maxOnesIndex18);\n        long maxOnesIndex20 = arr.FindIndex(x => x ==
    maxOnesIndex19);\n        long maxOnesIndex21 = arr.FindIndex(x => x == maxOnesIndex20);\n
    \       long maxOnesIndex22 = arr.FindIndex(x => x == maxOnesIndex21);\n        long
    maxOnesIndex23 = arr.FindIndex(x => x == maxOnesIndex22);\n        long maxOnesIndex24
    = arr.FindIndex(x => x == maxOnesIndex23);\n        long maxOne\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpbv6qn68c.cs(47,20): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           } else if (i == 0L) {\n                zeros++;\n            } else
    {\n                max = Math.Max(max, i);\n            }\n        }\n        List<long>
    result = new List<long>();\n        if (ones > zeros) {\n            long onesMax
    = ones;\n            long zerosMax = zeros;\n            while (onesMax < zerosMax)
    {\n                result.Add(max);\n                onesMax++;\n                zerosMax--;\n
    \           }\n            while (zerosMax < onesMax) {\n                result.Add(max);\n
    \               zerosMax++;\n                onesMax--;\n            }\n        }
    else {\n            long zerosMax = zeros;\n            long onesMax = ones;\n
    \           while (zerosMax < onesMax) {\n                result.Add(max);\n                zerosMax++;\n
    \               onesMax--;\n            }\n            while (onesMax < zerosMax)
    {\n                result.Add(max);\n                onesMax++;\n                zerosMax--;\n
    \           }\n        }\n        return result;\n    }\n    public static void
    Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <c9258ce9dc8a495abc695314c406194b>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <c9258ce9dc8a495abc695314c406194b>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823606
- exit_code: -1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long n in arr) {\n            if (n == 1L) {\n                ones++;\n
    \           }\n            if (n == 0L) {\n                zeros++;\n            }\n
    \           if (n > max) {\n                max = n;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            long
    onesMax = ones;\n            long zerosMax = zeros;\n            while (onesMax
    > zerosMax) {\n                result.Add(max);\n                zerosMax--;\n
    \           }\n            while (zerosMax > onesMax) {\n                result.Add(max);\n
    \               onesMax--;\n            }\n        }\n        else {\n            long
    zerosMax = zeros;\n            long onesMax = ones;\n            while (zerosMax
    > onesMax) {\n                result.Add(max);\n                zerosMax--;\n
    \           }\n            while (onesMax > zerosMax) {\n                result.Add(max);\n
    \               onesMax--;\n            }\n        }\n        return result;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Timeout
  stderr: ''
  stdout: None
  timestamp: 1659823610
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long maxOnes
    = 0;\n        long maxZeros = 0;\n        long maxOnesCount = 0;\n        long
    maxZerosCount = 0;\n        long maxOnesCount2 = 0;\n        long maxZerosCount2
    = 0;\n        long maxOnesCount3 = 0;\n        long maxZerosCount3 = 0;\n        long
    maxOnesCount4 = 0;\n        long maxZerosCount4 = 0;\n        long maxOnesCount5
    = 0;\n        long maxZerosCount5 = 0;\n        long maxOnesCount6 = 0;\n        long
    maxZerosCount6 = 0;\n        long maxOnesCount7 = 0;\n        long maxZerosCount7
    = 0;\n        long maxOnesCount8 = 0;\n        long maxZerosCount8 = 0;\n        long
    maxOnesCount9 = 0;\n        long maxZerosCount9 = 0;\n        long maxOnesCount10
    = 0;\n        long maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n        long
    maxZerosCount11 = 0;\n        long maxOnesCount12 = 0;\n        long maxZerosCount12
    = 0;\n        long maxOnesCount13 = 0;\n        long maxZerosCount13 = 0;\n        long
    maxOnesCount14 = 0;\n        long maxZerosCount14 = 0;\n        long maxOnesCount15
    = 0;\n        long maxZerosCount15 = 0;\n        long maxOnesCount16 = 0;\n        long
    maxZerosCount16 = 0;\n        long maxOnesCount17 = 0;\n        long maxZerosCount17
    = 0;\n        long maxOnesCount18 = 0;\n        long maxZerosCount18 = 0;\n        long
    maxOnesCount19 = 0;\n        long maxZerosCount19 = 0;\n        long maxOnesCount20
    = 0;\n        long maxZerosCount20 = 0;\n        long maxOnesCount21 = 0;\n        long
    maxZerosCount21 = 0;\n        long maxOnesCount22 = 0;\n        long maxZerosCount22
    = 0;\n        long maxOnesCount23 = 0;\n        long maxZerosCount23 = 0;\n        long
    maxOnesCount24 = 0;\n        long maxZerosCount24 = 0;\n        long maxOnesCount25
    = 0;\n        long maxZerosCount25 = 0;\n        long maxOnesCount26 = 0;\n        long
    maxZerosCount26 = 0;\n        long maxOnesCount\n    }\n    public static void
    Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpesxj2l0z.cs(76,26): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes + maxZeros;\n        long
    maxOnesOnes = maxOnes - maxZeros;\n        long maxOnesTwos = maxOnes - maxOnesOnes;\n
    \       long maxOnesThrees = maxOnes - maxOnesTwos;\n        long maxOnesFours
    = maxOnes - maxOnesThrees;\n        long maxOnesFives = maxOnes - maxOnesFours;\n
    \       long maxOnesSixes = maxOnes - maxOnesFives;\n        long maxOnesSevens
    = maxOnes - maxOnesSixes;\n        long maxOnesEights = maxOnes - maxOnesSevens;\n
    \       long maxOnesNines = maxOnes - maxOnesEights;\n        long maxOnesTens
    = maxOnes - maxOnesNines;\n        long maxOnesElevens = maxOnes - maxOnesTens;\n
    \       long maxOnesTwelves = maxOnes - maxOnesElevens;\n        long maxOnesThirteens
    = maxOnes - maxOnesTwelves;\n        long maxOnesFourteens = maxOnes - maxOnesThirteens;\n
    \       long maxOnesFifteens = maxOnes - maxOnesFourteens;\n        long maxOnesSixteens
    = maxOnes - maxOnesFifteens;\n        long maxOnesSeventeens = maxOnes - maxOnesSixteens;\n
    \       long maxOnesEighteens = maxOnes - maxOnesSeventeens;\n        long maxOnesNineteens
    = maxOnes - maxOnesEighteens;\n        long maxOnesTwenty = maxOnes - maxOnesNineteens;\n
    \       long maxOnesTwentyOnes = maxOnes - maxOnesTwenty;\n        long maxOnesTwentyTwos
    = maxOnes - maxOnesTwentyOnes;\n        long maxOnesTwentyThrees = maxOnes - maxOnesTwentyTwos;\n
    \       long maxOnesTwenty\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpq9pesn_q.cs(48,27): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long maxOnes
    = 0;\n        long maxZeros = 0;\n        long maxOnesCount = 0;\n        long
    maxZerosCount = 0;\n        long maxOnesCount2 = 0;\n        long maxZerosCount2
    = 0;\n        long maxOnesCount3 = 0;\n        long maxZerosCount3 = 0;\n        long
    maxOnesCount4 = 0;\n        long maxZerosCount4 = 0;\n        long maxOnesCount5
    = 0;\n        long maxZerosCount5 = 0;\n        long maxOnesCount6 = 0;\n        long
    maxZerosCount6 = 0;\n        long maxOnesCount7 = 0;\n        long maxZerosCount7
    = 0;\n        long maxOnesCount8 = 0;\n        long maxZerosCount8 = 0;\n        long
    maxOnesCount9 = 0;\n        long maxZerosCount9 = 0;\n        long maxOnesCount10
    = 0;\n        long maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n        long
    maxZerosCount11 = 0;\n        long maxOnesCount12 = 0;\n        long maxZerosCount12
    = 0;\n        long maxOnesCount13 = 0;\n        long maxZerosCount13 = 0;\n        long
    maxOnesCount14 = 0;\n        long maxZerosCount14 = 0;\n        long maxOnesCount15
    = 0;\n        long maxZerosCount15 = 0;\n        long maxOnesCount16 = 0;\n        long
    maxZerosCount16 = 0;\n        long maxOnesCount17 = 0;\n        long maxZerosCount17
    = 0;\n        long maxOnesCount18 = 0;\n        long maxZerosCount18 = 0;\n        long
    maxOnesCount19 = 0;\n        long maxZerosCount19 = 0;\n        long maxOnesCount20
    = 0;\n        long maxZerosCount20 = 0;\n        long maxOnesCount21 = 0;\n        long
    maxZerosCount21 = 0;\n        long maxOnesCount22 = 0;\n        long maxZerosCount22
    = 0;\n        long maxOnesCount23 = 0;\n        long maxZerosCount23 = 0;\n        long
    maxOnesCount24 = 0;\n        long maxZerosCount24 = 0;\n        long maxOnesCount25
    = 0;\n        long maxZerosCount25 = 0;\n        long maxOnesCount26 = 0;\n        long
    maxZerosCount26 = 0;\n        long maxOnesCount\n    }\n    public static void
    Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpesxj2l0z.cs(76,26): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        long onesCount = 0;\n        long
    zerosCount = 0;\n        long maxCount = 0;\n        foreach (long i in arr) {\n
    \           if (i == 1L) {\n                onesCount++;\n            }\n            if
    (i == 0L) {\n                zerosCount++;\n            }\n            if (i >
    max) {\n                maxCount = i;\n            }\n        }\n        if (onesCount
    > zerosCount) {\n            result.Add(maxCount);\n            result.AddRange(arr.Where(i
    => i == maxCount).OrderBy(i => Math.Abs(i - maxCount)));\n        }\n        else
    if (zerosCount > onesCount) {\n            result.AddRange(arr.Where(i => i ==
    maxCount).OrderBy(i => Math.Abs(i - maxCount)));\n            result.Add(maxCount);\n
    \       }\n        else {\n            result.AddRange(arr.Where(i => i == maxCount).OrderBy(i
    => Math.Abs(i - maxCount)));\n        }\n        return result;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <57c9eef5244f40228ea5356170cfe9e3>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <57c9eef5244f40228ea5356170cfe9e3>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones;\n        long zerosMax = zeros;\n        long maxMax
    = max;\n        long onesMin = ones;\n        long zerosMin = zeros;\n        long
    maxMin = max;\n        long onesMaxMin = onesMax;\n        long zerosMaxMin =
    zerosMax;\n        long maxMaxMin = maxMax;\n        long onesMinMin = onesMin;\n
    \       long zerosMinMin = zerosMin;\n        long maxMinMin = maxMin;\n        long
    onesMaxMinMin = onesMaxMin;\n        long zerosMaxMinMin = zerosMaxMin;\n        long
    maxMaxMinMin = maxMaxMin;\n        long onesMinMinMin = onesMinMin;\n        long
    zerosMinMinMin = zerosMinMin;\n        long maxMinMinMin = maxMinMinMin;\n        long
    onesMaxMinMinMin = onesMaxMinMin;\n        long zerosMaxMinMinMin = zerosMaxMinMin;\n
    \       long maxMaxMinMinMin = maxMaxMinMin;\n        long onesMinMinMinMin =
    onesMinMinMin;\n        long zerosMinMinMinMin = zerosMinMinMin;\n        long
    maxMinMinMinMin = maxMinMinMinMin;\n        long onesMaxMinMinMinMin = onesMaxMinMinMin;\n
    \       long zerosMaxMinMinMinMin = zerosMaxMinMinMin;\n        long maxMaxMinMinMinMin
    = maxMaxMinMinMinMin;\n        long onesMinMinMinMinMin = onesMinMinMinMin;\n
    \       long zerosMinMinMinMin = zerosMinMinMinMin;\n        long maxMinMinMinMin
    = maxMinMinMinMin;\n        long onesMaxMinMinMinMin = onesMaxMinMinMin;\n        long
    zerosMaxMinMinMinMin = zerosMaxMinMinMinMin;\n        long maxMaxMinMinMinMin
    = maxMaxMinMinMinMin;\n        long onesMinMinMinMinMin = onesMinMinMinMin;\n
    \       long zeros\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpyqor2m24.cs(68,19): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long zeros = 0;\n        long max = 0;\n        long min = 0;\n        foreach
    (long i in arr) {\n            if (i == 1L) {\n                ones++;\n            }\n
    \           if (i == 0L) {\n                zeros++;\n            }\n            if
    (i > max) {\n                max = i;\n            }\n            if (i < min)
    {\n                min = i;\n            }\n        }\n        long onesMax =
    ones * max;\n        long onesMin = ones * min;\n        long zerosMax = zeros
    * max;\n        long zerosMin = zeros * min;\n        long onesMinMax = onesMin
    * max;\n        long onesMaxMin = onesMax * min;\n        long zerosMinMax = zerosMin
    * max;\n        long zerosMaxMin = zerosMax * min;\n        long onesMinMaxMin
    = onesMinMax * min;\n        long onesMaxMinMin = onesMaxMin * min;\n        long
    zerosMinMaxMin = zerosMinMax * min;\n        long zerosMaxMinMin = zerosMaxMin
    * min;\n        long onesMinMaxMinMin = onesMinMaxMin * min;\n        long onesMaxMinMin
    = onesMaxMinMin * min;\n        long zerosMinMaxMin = zerosMinMaxMin * min;\n
    \       long zerosMaxMinMin = zerosMaxMinMin * min;\n        long onesMinMaxMinMin
    = onesMinMaxMinMin * min;\n        long onesMaxMinMin = onesMaxMinMin * min;\n
    \       long zerosMinMaxMin = zerosMinMaxMin * min;\n        long zerosMaxMinMin
    = zerosMaxMinMin * min;\n        long onesMinMaxMinMin = onesMinMaxMinMin * min;\n
    \       long onesMaxMinMin = onesMaxMinMin * min;\n        long zerosMinMaxMin
    = zerosMinMaxMin * min;\n        long zerosMaxMinMin = zerosMaxMinMin * min;\n
    \       long onesMinMaxMinMin = onesMinMaxMinMin * min;\n        long onesMaxMinMin
    = onesMaxMinMin * min;\n        long zerosMinMaxMin = zerosMinMaxMin * min;\n
    \       long zerosMaxMinMin = zerosMaxMinMin * min;\n        long onesMinMaxMinMin
    = \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpfw9g_qdf.cs(67,32): error CS1525: Invalid expression term ''}''

    /tmp/tmpfw9g_qdf.cs(67,32): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long n in arr) {\n            if (n == 1L) {\n                ones++;\n
    \           }\n            if (n == 0L) {\n                zeros++;\n            }\n
    \           if (n > max) {\n                max = n;\n            }\n        }\n
    \       long onesMax = ones > zeros ? ones : zeros;\n        long zerosMax = zeros
    > ones ? zeros : ones;\n        long maxMax = max > onesMax ? max : onesMax;\n
    \       long maxMin = max < zerosMax ? max : zerosMax;\n        long minMax =
    min > maxMax ? min : maxMax;\n        long minMin = min < maxMin ? min : maxMin;\n
    \       long minMinMin = minMin > maxMin ? minMin : maxMin;\n        long minMinMinMin
    = minMinMin > maxMin ? minMinMin : maxMinMin;\n        long minMinMinMinMin =
    minMinMinMin > maxMin ? minMinMinMin : maxMinMinMin;\n        long minMinMinMinMinMin
    = minMinMinMinMin > maxMin ? minMinMinMinMin : maxMinMinMinMinMin;\n        long
    minMinMinMinMinMin = minMinMinMinMin > maxMin ? minMinMinMinMinMin : maxMinMinMinMinMinMin;\n
    \       long minMinMinMinMinMin = minMinMinMinMinMin > maxMin ? minMinMinMinMinMinMin
    : maxMinMinMinMinMinMinMin;\n        long minMinMinMinMinMin = minMinMinMinMinMin
    > maxMin ? minMinMinMinMinMinMin : maxMinMinMinMinMinMinMin;\n        long minMinMinMinMinMin
    = minMinMinMinMinMinMin > maxMin ? minMinMinMinMinMinMin : maxMinMinMinMinMinMinMin;\n
    \       long minMinMinMinMinMin = minMinMinMinMinMinMin > maxMin ? minMinMinMinMinMinMin
    : maxMinMinMinMinMinMinMin;\n        long minMinMinMinMinMin = minMinMinMinMinMinMin
    > maxMin ? minMinMinMinMinMinMin : maxMinMinMinMinMinMinMin;\n        long minMinMinMinMin
    = minMinMinMinMinMin > maxMin ? minMinMinMinMinMin : maxMinMinMinMinMinMin;\n\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpv5sqaji4.cs(38,23): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmpv5sqaji4.cs(38,38): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmpv5sqaji4.cs(39,23): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmpv5sqaji4.cs(39,38): error CS0103: The name ''min'' does not exist in the
    current context

    /tmp/tmpv5sqaji4.cs(41,62): error CS0103: The name ''maxMinMin'' does not exist
    in the current context

    /tmp/tmpv5sqaji4.cs(42,71): error CS0103: The name ''maxMinMinMin'' does not exist
    in the current context

    /tmp/tmpv5sqaji4.cs(43,80): error CS0103: The name ''maxMinMinMinMinMin'' does
    not exist in the current context

    /tmp/tmpv5sqaji4.cs(44,14): error CS0128: A local variable or function named ''minMinMinMinMinMin''
    is already defined in this scope

    /tmp/tmpv5sqaji4.cs(44,83): error CS0103: The name ''maxMinMinMinMinMinMin'' does
    not exist in the current context

    /tmp/tmpv5sqaji4.cs(45,14): error CS0128: A local variable or function named ''minMinMinMinMinMin''
    is already defined in this scope

    /tmp/tmpv5sqaji4.cs(45,65): error CS0103: The name ''minMinMinMinMinMinMin'' does
    not exist in the current context

    /tmp/tmpv5sqaji4.cs(45,89): error CS0103: The name ''maxMinMinMinMinMinMinMin''
    does not exist in the current context

    /tmp/tmpv5sqaji4.cs(46,14): error CS0128: A local variable or function named ''minMinMinMinMinMin''
    is already defined in this scope

    /tmp/tmpv5sqaji4.cs(46,65): error CS0103: The name ''minMinMinMinMinMinMin'' does
    not exist in the current context

    /tmp/tmpv5sqaji4.cs(46,89): error CS0103: The name ''maxMinMinMinMinMinMinMin''
    does not exist in the current context

    /tmp/tmpv5sqaji4.cs(47,14): error CS0128: A local variable or function named ''minMinMinMinMinMin''
    is already defined in this scope

    /tmp/tmpv5sqaji4.cs(47,35): error CS0103: The name ''minMinMinMinMinMinMin'' does
    not exist in the current context

    /tmp/tmpv5sqaji4.c'
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMax2 = onesMax * onesMax;\n        long zerosMax2 = zerosMax * zerosMax;\n
    \       long onesMax3 = onesMax2 * onesMax;\n        long zerosMax3 = zerosMax2
    * zerosMax;\n        long onesMax4 = onesMax3 * onesMax;\n        long zerosMax4
    = zerosMax3 * zerosMax;\n        long onesMax5 = onesMax4 * onesMax;\n        long
    zerosMax5 = zerosMax4 * zerosMax;\n        long onesMax6 = onesMax5 * onesMax;\n
    \       long zerosMax6 = zerosMax5 * zerosMax;\n        long onesMax7 = onesMax6
    * onesMax;\n        long zerosMax7 = zerosMax6 * zerosMax;\n        long onesMax8
    = onesMax7 * onesMax;\n        long zerosMax8 = zerosMax7 * zerosMax;\n        long
    onesMax9 = onesMax8 * onesMax;\n        long zerosMax9 = zerosMax8 * zerosMax;\n
    \       long onesMax10 = onesMax9 * onesMax;\n        long zerosMax10 = zerosMax9
    * zerosMax;\n        long onesMax11 = onesMax10 * onesMax;\n        long zerosMax11
    = zerosMax10 * zerosMax;\n        long onesMax12 = onesMax11 * onesMax;\n        long
    zerosMax12 = zerosMax11 * zerosMax;\n        long onesMax13 = onesMax12 * onesMax;\n
    \       long zerosMax13 = zerosMax12 * zerosMax;\n        long onesMax14 = onesMax13
    * onesMax;\n        long zerosMax14 = zerosMax13 * zerosMax;\n        long onesMax15
    = onesMax14 * onesMax;\n        long zerosMax15 = zerosMax14 * zerosMax;\n        long
    onesMax16 = onesMax15 * onesMax;\n        long zerosMax16 = zerosMax15 * zerosMax;\n
    \       long \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpe4coxiz3.cs(66,13): error CS1001: Identifier expected

    /tmp/tmpe4coxiz3.cs(66,13): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i == max) {\n                max = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            long
    onesMax = Convert.ToInt64(Math.Pow(2, ones));\n            long zerosMax = Convert.ToInt64(Math.Pow(2,
    zeros));\n            long onesMin = Convert.ToInt64(Math.Pow(2, ones - 1));\n
    \           long zerosMin = Convert.ToInt64(Math.Pow(2, zeros - 1));\n            long
    onesMaxMin = Convert.ToInt64(Math.Pow(2, onesMax - 1));\n            long zerosMaxMin
    = Convert.ToInt64(Math.Pow(2, zerosMax - 1));\n            long onesMinMin = Convert.ToInt64(Math.Pow(2,
    onesMin - 1));\n            long zerosMinMin = Convert.ToInt64(Math.Pow(2, zerosMin
    - 1));\n            long onesMaxMinMin = Convert.ToInt64(Math.Pow(2, onesMaxMin
    - 1));\n            long zerosMaxMinMin = Convert.ToInt64(Math.Pow(2, zerosMaxMin
    - 1));\n            long onesMinMinMin = Convert.ToInt64(Math.Pow(2, onesMinMin
    - 1));\n            long zerosMinMinMin = Convert.ToInt64(Math.Pow(2, zerosMinMin
    - 1));\n            long onesMaxMinMinMin = Convert.ToInt64(Math.Pow(2, onesMaxMinMin
    - 1));\n            long zerosMaxMinMinMin = Convert.ToInt64(Math.Pow(2, zerosMaxMinMin
    - 1));\n            long onesMinMinMinMin = Convert.ToInt64(Math.Pow(2, onesMinMinMin
    - 1));\n            long zerosMinMinMinMin = Convert.ToInt64(Math.Pow(2, zerosMinMinMin
    - 1));\n            long onesMaxMinMinMin = Convert.ToInt64(Math.Pow(2, onesMaxMinMinMin
    - 1));\n            long zerosMaxMinMinMin = Convert.ToInt64(Math.Pow(2, zerosMaxMinMinMin
    - 1));\n            long onesMinMinMinMin = Convert.ToInt64(Math.Pow(2, onesMinMinMinMin
    - 1));\n            long zerosMinMinMinMin = Convert.ToInt64(Math.Pow(2, zerosMinMinMinMin
    - 1));\n            long ones\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpyaafvggw.cs(56,22): error CS1002: ; expected

    /tmp/tmpyaafvggw.cs(58,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpyaafvggw.cs(69,2): error CS1513: } expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long onesMin = ones * min;\n        long
    zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long onesMinMax
    = onesMin * max;\n        long onesMaxMin = onesMax * min;\n        long zerosMinMax
    = zerosMin * max;\n        long zerosMaxMin = zerosMax * min;\n        long onesMaxMinMax
    = onesMaxMin * max;\n        long onesMinMaxMin = onesMinMax * min;\n        long
    zerosMinMaxMin = zerosMinMax * min;\n        long zerosMaxMinMin = zerosMaxMin
    * min;\n        long onesMaxMinMaxMin = onesMaxMinMax * min;\n        long onesMinMaxMinMin
    = onesMinMaxMin * min;\n        long zerosMinMaxMin = zerosMinMaxMin * min;\n
    \       long zerosMaxMinMin = zerosMaxMinMin * min;\n        long onesMaxMinMaxMin
    = onesMaxMinMaxMin * min;\n        long onesMinMaxMinMin = onesMinMaxMinMin *
    min;\n        long zerosMinMaxMin = zerosMinMaxMin * min;\n        long zerosMaxMinMin
    = zerosMaxMinMin * min;\n        long onesMaxMinMaxMin = onesMaxMinMaxMin * min;\n
    \       long onesMinMaxMinMin = onesMinMaxMinMin * min;\n        long zerosMinMaxMin
    = zerosMinMaxMin * min;\n        long zerosMaxMinMin = zerosMaxMinMin * min;\n
    \       long onesMaxMinMaxMin = onesMaxMinMaxMin * min;\n        long onesMinMaxMinMin
    = onesMinMaxMinMin * min;\n        long zerosMinMaxMin = zerosMinMaxMin * min;\n
    \       long zerosMaxMinMin = zerosMaxMinMin * min;\n        long onesMaxMinMaxMin
    = onesMax\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpwtmv190d.cs(66,40): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones == zeros) {\n            return arr.OrderBy(x =>
    x).ToList();\n        }\n        long maxOnes = arr.Max(x => x & 1L);\n        long
    maxZeros = arr.Max(x => x & 0L);\n        long maxOnesCount = arr.Count(x => x
    & 1L);\n        long maxZerosCount = arr.Count(x => x & 0L);\n        long maxOnesCount2
    = arr.Count(x => x & 1L);\n        long maxZerosCount2 = arr.Count(x => x & 0L);\n
    \       long maxOnesCount3 = arr.Count(x => x & 1L);\n        long maxZerosCount3
    = arr.Count(x => x & 0L);\n        long maxOnesCount4 = arr.Count(x => x & 1L);\n
    \       long maxZerosCount4 = arr.Count(x => x & 0L);\n        long maxOnesCount5
    = arr.Count(x => x & 1L);\n        long maxZerosCount5 = arr.Count(x => x & 0L);\n
    \       long maxOnesCount6 = arr.Count(x => x & 1L);\n        long maxZerosCount6
    = arr.Count(x => x & 0L);\n        long maxOnesCount7 = arr.Count(x => x & 1L);\n
    \       long maxZerosCount7 = arr.Count(x => x & 0L);\n        long maxOnesCount8
    = arr.Count(x => x & 1L);\n        long maxZerosCount8 = arr.Count(x => x & 0L);\n
    \       long maxOnesCount9 = arr.Count(x => x & 1L);\n        long maxZerosCount9
    = arr.Count(x => x & 0L);\n        long maxOnesCount10 = arr.Count(x => x & 1L);\n
    \       long maxZerosCount10 = arr.Count(x => x & 0L);\n        long maxOnesCount11
    = arr.Count(x => x & 1L);\n        long maxZerosCount11 = arr.Count(x => x & 0L);\n
    \       long maxOnesCount12 = arr.Count(x => x & 1L);\n        long maxZerosCount12
    = arr.Count(x => x & 0L);\n        long maxOnesCount13 = arr.Count(x => x \n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpmgjub4cl.cs(51,47): error CS1026: ) expected

    /tmp/tmpmgjub4cl.cs(51,47): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           } else if (i == 0L) {\n                zeros++;\n            } else
    {\n                max = Math.Max(max, i);\n            }\n        }\n        List<long>
    result = new List<long>();\n        if (ones > zeros) {\n            foreach (long
    i in arr) {\n                if (i == 1L) {\n                    result.Add(i);\n
    \               } else if (i == 0L) {\n                    result.Add(0L);\n                }
    else {\n                    result.Add(max);\n                }\n            }\n
    \       } else {\n            foreach (long i in arr) {\n                if (i
    == 1L) {\n                    result.Add(0L);\n                } else if (i ==
    0L) {\n                    result.Add(i);\n                } else {\n                    result.Add(max);\n
    \               }\n            }\n        }\n        return result;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <f046261f87714d768691382cfad1d87e>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <f046261f87714d768691382cfad1d87e>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMin = ones * max;\n        long zerosMin = zeros * max;\n        long onesMaxMin
    = onesMax * max;\n        long zerosMaxMin = zerosMax * max;\n        long onesMinMin
    = onesMin * max;\n        long zerosMinMin = zerosMin * max;\n        long onesMaxMinMin
    = onesMaxMin * max;\n        long zerosMaxMinMin = zerosMaxMin * max;\n        long
    onesMinMinMin = onesMinMin * max;\n        long zerosMinMinMin = zerosMinMin *
    max;\n        long onesMaxMinMinMin = onesMaxMinMin * max;\n        long zerosMaxMinMinMin
    = zerosMaxMinMin * max;\n        long onesMinMinMinMin = onesMinMinMin * max;\n
    \       long zerosMinMinMinMin = zerosMinMinMin * max;\n        long onesMaxMinMinMin
    = onesMaxMinMin * max;\n        long zerosMaxMinMinMin = zerosMaxMinMin * max;\n
    \       long onesMinMinMinMin = onesMinMinMin * max;\n        long zerosMinMinMinMin
    = zerosMinMinMin * max;\n        long onesMaxMinMinMin = onesMaxMinMin * max;\n
    \       long zerosMaxMinMinMin = zerosMaxMinMin * max;\n        long onesMinMinMinMin
    = onesMinMinMin * max;\n        long zerosMinMinMinMin = zerosMinMinMin * max;\n
    \       long onesMaxMinMinMin = onesMaxMinMin * max;\n        long zerosMaxMinMinMin
    = zerosMaxMinMin * max;\n        long onesMinMinMinMin = onesMinMinMin * max;\n
    \       long zerosMinMinMinMin = zerosMinMinMin * max;\n        long onesMaxMinMinMin
    = onesMaxMinMin * max;\n        long zerosMaxMinMinMin = \n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkw9jx13g.cs(63,33): error CS1525: Invalid expression term ''}''

    /tmp/tmpkw9jx13g.cs(63,33): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMin = ones * max;\n        long zerosMin = zeros * max;\n        long onesMaxMin
    = onesMax * max;\n        long zerosMaxMin = zerosMax * max;\n        long onesMinMax
    = onesMin * max;\n        long zerosMinMax = zerosMin * max;\n        long onesMaxMinMax
    = onesMaxMin * max;\n        long zerosMaxMinMax = zerosMaxMin * max;\n        long
    onesMinMaxMinMax = onesMinMax * max;\n        long zerosMinMaxMinMax = zerosMinMax
    * max;\n        long onesMinMaxMinMaxMin = onesMinMax * max;\n        long zerosMinMaxMinMaxMin
    = zerosMinMax * max;\n        long onesMinMaxMinMaxMinMax = onesMinMax * max;\n
    \       long zerosMinMaxMinMaxMinMax = zerosMinMax * max;\n        long onesMinMaxMinMaxMinMaxMin
    = onesMinMax * max;\n        long zerosMinMaxMinMaxMinMaxMin = zerosMinMax * max;\n
    \       long onesMinMaxMinMaxMinMaxMinMax = onesMinMax * max;\n        long zerosMinMaxMinMaxMinMaxMinMax
    = zerosMinMax * max;\n        long onesMinMaxMinMaxMinMaxMinMaxMin = onesMinMax
    * max;\n        long zerosMinMaxMinMaxMinMaxMinMaxMin = zerosMinMax * max;\n        long
    onesMinMaxMinMaxMinMaxMinMaxMinMax = onesMinMax * max;\n        long zerosMinMaxMinMaxMinMaxMinMaxMinMax
    = zerosMinMax * max;\n        long onesMinMaxMinMaxMinMaxMinMaxMinMaxMin = onesMinMax
    * max;\n        long zerosMinMaxMinMaxMinMaxMinMaxMinMaxMin = zerosMinMax * max;\n
    \       long onesMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpavn78kcq.cs(60,54): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long zeros = 0;\n        long max = 0;\n        foreach (long i in arr)
    {\n            if (i == 1L) {\n                ones++;\n            }\n            else
    if (i == 0L) {\n                zeros++;\n            }\n            else {\n
    \               if (ones > zeros) {\n                    result.Add(i);\n                }\n
    \               else {\n                    result.Add(0L);\n                }\n
    \           }\n        }\n        max = Math.Max(ones, zeros);\n        if (ones
    > zeros) {\n            foreach (long i in arr) {\n                if (i == 1L)
    {\n                    ones--;\n                }\n                else if (i
    == 0L) {\n                    zeros--;\n                }\n                else
    {\n                    if (ones > zeros) {\n                        result.Add(i);\n
    \                   }\n                    else {\n                        result.Add(0L);\n
    \                   }\n                }\n            }\n        }\n        if
    (ones > zeros) {\n            foreach (long i in arr) {\n                if (i
    == 1L) {\n                    ones--;\n                }\n                else
    if (i == 0L) {\n                    zeros--;\n                }\n                else
    {\n                    if (ones > zeros) {\n                        result.Add(i);\n
    \                   }\n                    else {\n                        result.Add(0L);\n
    \                   }\n                }\n            }\n        }\n        if
    (ones > zeros) {\n            foreach (long i in arr) {\n                if (i
    == 1L) {\n                    ones--;\n                }\n                else
    if (i == 0L) {\n                    zeros--;\n                }\n                else
    {\n                    if (ones > zeros) {\n                        result.Add(i);\n
    \                   }\n                    else {\n                        result.Add(0L);\n
    \                   }\n                }\n            }\n        }\n        if
    (ones > zeros) {\n            foreach (long i in arr) {\n                if (i
    == 1L) {\n                    ones--;\n                }\n                else
    if (i == 0L) {\n                    zeros--;\n                }\n                else
    {\n                    if (ones > zeros) {\n                        result.Add(i);\n
    \                   }\n                    else {\n                        result.Add(0L);\n
    \                   }\n                }\n            }\n        }\n        if
    (ones > zeros) {\n            foreach (long i in arr) {\n                if (i
    == 1L) {\n                    ones--;\n                }\n                else
    if (i == 0L) {\n                    zeros--;\n                }\n                else
    {\n                    if (ones > zeros) {\n                        result.Add(i);\n
    \                   }\n                    else {\n                        result.Add(0L);\n
    \                   }\n                }\n            }\n        }\n        if
    (ones > zeros) {\n            foreach (long i in arr) {\n                if (i
    == 1L) {\n                    ones--;\n                }\n                else
    if (i == 0L) {\n                    zeros--;\n                }\n                else
    {\n                    if (ones > zeros) {\n\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpqmb3x029.cs(143,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpqmb3x029.cs(154,2): error CS1513: } expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        if (ones == 0L) {\n
    \           return arr;\n        }\n        long zeros = arr.Sum(x => x & 0L);\n
    \       long maxOnes = ones;\n        long maxZeros = zeros;\n        long maxDiff
    = maxOnes - maxZeros;\n        long minDiff = maxZeros - maxOnes;\n        long
    diff = maxDiff;\n        long minDiff = maxDiff;\n        long maxDiff = maxOnes
    - maxZeros;\n        long minDiff = maxZeros - maxOnes;\n        long diff = maxDiff;\n
    \       long minDiff = maxDiff;\n        long maxDiff = maxOnes - maxZeros;\n
    \       long minDiff = maxZeros - maxOnes;\n        long diff = maxDiff;\n        long
    minDiff = maxDiff;\n        long maxDiff = maxOnes - maxZeros;\n        long minDiff
    = maxZeros - maxOnes;\n        long diff = maxDiff;\n        long minDiff = maxDiff;\n
    \       long maxDiff = maxOnes - maxZeros;\n        long minDiff = maxZeros -
    maxOnes;\n        long diff = maxDiff;\n        long minDiff = maxDiff;\n        long
    maxDiff = maxOnes - maxZeros;\n        long minDiff = maxZeros - maxOnes;\n        long
    diff = maxDiff;\n        long minDiff = maxDiff;\n        long maxDiff = maxOnes
    - maxZeros;\n        long minDiff = maxZeros - maxOnes;\n        long diff = maxDiff;\n
    \       long minDiff = maxDiff;\n        long maxDiff = maxOnes - maxZeros;\n
    \       long minDiff = maxZeros - maxOnes;\n        long diff = maxDiff;\n        long
    minDiff = maxDiff;\n        long maxDiff = maxOnes - maxZeros;\n        long minDiff
    = maxZeros - maxOnes;\n        long diff = maxDiff;\n        long minDiff = maxDiff;\n
    \       long maxDiff = maxOnes - maxZeros;\n        long minDiff = maxZeros -
    maxOnes;\n        long diff = maxDiff;\n        long minDiff = maxDiff;\n        long
    maxDiff = maxOnes - maxZeros;\n        long minDiff = maxZeros - maxOnes;\n        long
    diff = maxDiff;\n\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmprn7i2a62.cs(30,14): error CS0128: A local variable or function named ''minDiff''
    is already defined in this scope

    /tmp/tmprn7i2a62.cs(31,14): error CS0128: A local variable or function named ''maxDiff''
    is already defined in this scope

    /tmp/tmprn7i2a62.cs(32,14): error CS0128: A local variable or function named ''minDiff''
    is already defined in this scope

    /tmp/tmprn7i2a62.cs(33,14): error CS0128: A local variable or function named ''diff''
    is already defined in this scope

    /tmp/tmprn7i2a62.cs(34,14): error CS0128: A local variable or function named ''minDiff''
    is already defined in this scope

    /tmp/tmprn7i2a62.cs(35,14): error CS0128: A local variable or function named ''maxDiff''
    is already defined in this scope

    /tmp/tmprn7i2a62.cs(36,14): error CS0128: A local variable or function named ''minDiff''
    is already defined in this scope

    /tmp/tmprn7i2a62.cs(37,14): error CS0128: A local variable or function named ''diff''
    is already defined in this scope

    /tmp/tmprn7i2a62.cs(38,14): error CS0128: A local variable or function named ''minDiff''
    is already defined in this scope

    /tmp/tmprn7i2a62.cs(39,14): error CS0128: A local variable or function named ''maxDiff''
    is already defined in this scope

    /tmp/tmprn7i2a62.cs(40,14): error CS0128: A local variable or function named ''minDiff''
    is already defined in this scope

    /tmp/tmprn7i2a62.cs(41,14): error CS0128: A local variable or function named ''diff''
    is already defined in this scope

    /tmp/tmprn7i2a62.cs(42,14): error CS0128: A local variable or function named ''minDiff''
    is already defined in this scope

    /tmp/tmprn7i2a62.cs(43,14): error CS0128: A local variable or function named ''maxDiff''
    is already defined in this scope

    /tmp/tmprn7i2a62.cs(44,14): error CS0128: A local variable or function named ''minDiff''
    is already defined in this scope

    /tmp/tmprn7i2a62.cs(45,14): error CS0128: A local variable or function named ''diff''
    is already defined in this scope

    /tmp/tmprn7i2'
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long zeros = 0;\n        long max = 0;\n        foreach (long i in arr)
    {\n            ones += i;\n            zeros -= i;\n            if (ones > max)
    {\n                max = ones;\n            }\n            if (zeros > max) {\n
    \               max = zeros;\n            }\n        }\n        long onesCount
    = 0;\n        long zerosCount = 0;\n        long maxCount = 0;\n        foreach
    (long i in arr) {\n            onesCount += i;\n            zerosCount -= i;\n
    \           if (onesCount > maxCount) {\n                maxCount = onesCount;\n
    \           }\n            if (zerosCount > maxCount) {\n                maxCount
    = zerosCount;\n            }\n        }\n        long onesCount2 = 0;\n        long
    zerosCount2 = 0;\n        long maxCount2 = 0;\n        foreach (long i in arr)
    {\n            onesCount2 += i;\n            zerosCount2 -= i;\n            if
    (onesCount2 > maxCount2) {\n                maxCount2 = onesCount2;\n            }\n
    \           if (zerosCount2 > maxCount2) {\n                maxCount2 = zerosCount2;\n
    \           }\n        }\n        long onesCount3 = 0;\n        long zerosCount3
    = 0;\n        long maxCount3 = 0;\n        foreach (long i in arr) {\n            onesCount3
    += i;\n            zerosCount3 -= i;\n            if (onesCount3 > maxCount3)
    {\n                maxCount3 = onesCount3;\n            }\n            if (zerosCount3
    > maxCount3) {\n                maxCount3 = zerosCount3;\n            }\n        }\n
    \       long onesCount4 = 0;\n        long zerosCount4 = 0;\n        long maxCount4
    = 0;\n        foreach (long i in arr) {\n            onesCount4 += i;\n            zerosCount4
    -= i;\n            if (onesCount4 > maxCount4) {\n                maxCount4 =
    onesCount4;\n            }\n            if (zerosCount4 > maxCount4) {\n                maxCount4
    = zerosCount4;\n            }\n        }\n        long onesCount5 = 0;\n        long
    zerosCount5 = 0;\n        long maxCount5 = 0;\n        foreach (long i in arr)
    {\n            onesCount5 += i;\n            zerosCount5 -= i;\n            if
    (onesCount5 > maxCount5) {\n                maxCount5 = onesCount5;\n            }\n
    \           if (zerosCount5 > maxCount5) {\n                maxCount5 = zerosCount5;\n
    \           }\n        }\n        long onesCount6 = 0;\n        long zerosCount6
    = 0;\n        long maxCount6 = 0;\n        foreach (long i in arr) {\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpo3x35u4l.cs(104,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpo3x35u4l.cs(115,2): error CS1513: } expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           } else if (i == 0L) {\n                zeros++;\n            } else
    {\n                max = Math.Max(max, i);\n            }\n        }\n        long
    onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long onesMax2
    = onesMax * onesMax;\n        long zerosMax2 = zerosMax * zerosMax;\n        long
    onesMax3 = onesMax2 * onesMax;\n        long zerosMax3 = zerosMax2 * zerosMax;\n
    \       long onesMax4 = onesMax3 * onesMax;\n        long zerosMax4 = zerosMax3
    * zerosMax;\n        long onesMax5 = onesMax4 * onesMax;\n        long zerosMax5
    = zerosMax4 * zerosMax;\n        long onesMax6 = onesMax5 * onesMax;\n        long
    zerosMax6 = zerosMax5 * zerosMax;\n        long onesMax7 = onesMax6 * onesMax;\n
    \       long zerosMax7 = zerosMax6 * zerosMax;\n        long onesMax8 = onesMax7
    * onesMax;\n        long zerosMax8 = zerosMax7 * zerosMax;\n        long onesMax9
    = onesMax8 * onesMax;\n        long zerosMax9 = zerosMax8 * zerosMax;\n        long
    onesMax10 = onesMax9 * onesMax;\n        long zerosMax10 = zerosMax9 * zerosMax;\n
    \       long onesMax11 = onesMax10 * onesMax;\n        long zerosMax11 = zerosMax10
    * zerosMax;\n        long onesMax12 = onesMax11 * onesMax;\n        long zerosMax12
    = zerosMax11 * zerosMax;\n        long onesMax13 = onesMax12 * onesMax;\n        long
    zerosMax13 = zerosMax12 * zerosMax;\n        long onesMax14 = onesMax13 * onesMax;\n
    \       long zerosMax14 = zerosMax13 * zerosMax;\n        long onesMax15 = onesMax14
    * onesMax;\n        long zerosMax15 = zerosMax14 * zerosMax;\n        long onesMax16
    = onesMax15 * onesMax;\n        long zerosMax16 = zerosMax15 * zerosMax;\n        long
    onesMax\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkru_dgu5.cs(64,21): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        if (ones == 0) return
    arr;\n        long zeros = arr.Sum(x => x & 0L);\n        if (zeros == 0) return
    arr;\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros = arr.Max(x
    => x & 0L);\n        if (maxOnes < maxZeros) return arr;\n        long maxOnesZeros
    = arr.Max(x => x & 1L | x & 0L);\n        long maxOnesOnes = arr.Max(x => x &
    1L & ~x & 0L);\n        long maxOnesZeroOnes = arr.Max(x => x & 1L & ~x & 1L);\n
    \       long maxOnesOnesZeros = arr.Max(x => x & 1L & ~x & 0L & ~x & 1L);\n        long
    maxOnesZeroOnesOnes = arr.Max(x => x & 1L & ~x & 0L & ~x & 1L & ~x & 0L);\n        long
    maxOnesZeroOnesOnesZeros = arr.Max(x => x & 1L & ~x & 0L & ~x & 1L & ~x & 0L &
    ~x & 1L);\n        long maxOnesZeroOnesOnesOnesZeros = arr.Max(x => x & 1L & ~x
    & 0L & ~x & 1L & ~x & 0L & ~x & 1L & ~x & 0L);\n        long maxOnesZeroOnesOnesOnesOnesZeros
    = arr.Max(x => x & 1L & ~x & 0L & ~x & 1L & ~x & 0L & ~x & 1L & ~x & 0L & ~x &
    1L);\n        long maxOnesZeroOnesOnesOnesOnesOnesZeros = arr.Max(x => x & 1L
    & ~x & 0L & ~x & 1L & ~x & 0L & ~x & 1L & ~x & 0L & ~x & 1L & ~x & 0L & ~x & 1L
    & ~x & 0L);\n        long maxOnesZeroOnesOnesOnesOnesOnesOnesZeros = arr.Max(x
    => x & 1L & ~x & 0L & ~x & 1L & ~x & 0L & ~x & 1L & ~x & 0L & ~x & 1L & ~x & \n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp83wwtv_9.cs(36,143): error CS1525: Invalid expression term ''}''

    /tmp/tmp83wwtv_9.cs(36,143): error CS1026: ) expected

    /tmp/tmp83wwtv_9.cs(36,143): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x >> 1);\n        if (ones == zeros) {\n            return arr.OrderBy(x =>
    x).ToList();\n        }\n        long maxOnes = arr.Sum(x => x & 1L);\n        long
    maxZeros = arr.Sum(x => x >> 1);\n        if (maxOnes == maxZeros) {\n            return
    arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(maxOnes)))
    * x)).ToList();\n        }\n        long maxOnesPow2 = Convert.ToInt64(Math.Pow(2,
    Convert.ToInt32(Math.Log10(maxOnes))));\n        long maxZerosPow2 = Convert.ToInt64(Math.Pow(2,
    Convert.ToInt32(Math.Log10(maxZeros))));\n        long maxOnesPow10 = Math.Pow(10,
    Convert.ToInt32(Math.Log10(maxOnes)));\n        long maxZerosPow10 = Math.Pow(10,
    Convert.ToInt32(Math.Log10(maxZeros)));\n        long maxOnesPow10Pow2 = Math.Pow(maxOnesPow10,
    2);\n        long maxZerosPow10Pow2 = Math.Pow(maxZerosPow10, 2);\n        long
    maxOnesPow10Pow10 = Math.Pow(maxOnesPow10, 10);\n        long maxZerosPow10Pow10
    = Math.Pow(maxZerosPow10, 10);\n        long maxOnesPow10Pow10Pow2 = Math.Pow(maxOnesPow10Pow10,
    2);\n        long maxZerosPow10Pow10Pow2 = Math.Pow(maxZerosPow10Pow10, 2);\n
    \       long maxOnesPow10Pow10Pow10 = Math.Pow(maxOnesPow10Pow10, 10);\n        long
    maxZerosPow10Pow10Pow10 = Math.Pow(maxZerosPow10Pow10, 10);\n        long maxOnesPow10Pow10Pow10Pow2
    = Math.Pow(maxOnesPow10Pow10Pow10, 2);\n        long maxZerosPow10Pow10Pow10Pow2
    = Math.Pow(maxZerosPow10Pow10Pow10, 2);\n        long maxOnesPow10Pow10Pow10Pow10
    = Math.Pow(maxOnesPow10Pow10Pow10, 10);\n        long maxZerosPow10Pow10Pow10Pow10
    = Math.Pow(maxZerosPow\n    }\n    public static void Main(string[] args) {\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp6g79ww2_.cs(45,65): error CS1026: ) expected

    /tmp/tmp6g79ww2_.cs(45,65): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long num in arr) {\n            if (num
    == 1) {\n                ones++;\n            }\n            if (num == 0) {\n
    \               zeros++;\n            }\n            if (num > max) {\n                max
    = num;\n            }\n            if (num < min) {\n                min = num;\n
    \           }\n        }\n        long onesMax = ones * max;\n        long onesMin
    = ones * min;\n        long zerosMax = zeros * max;\n        long zerosMin = zeros
    * min;\n        long maxOnesMax = onesMax * max;\n        long maxOnesMin = onesMax
    * min;\n        long maxZerosMax = zerosMax * max;\n        long maxZerosMin =
    zerosMax * min;\n        long minOnesMax = onesMin * max;\n        long minOnesMin
    = onesMin * min;\n        long minZerosMax = zerosMin * max;\n        long minZerosMin
    = zerosMin * min;\n        long maxOnesOnesMax = onesMax * onesMax;\n        long
    maxOnesOnesMin = onesMax * onesMin;\n        long maxOnesZerosMax = onesMax *
    zerosMax;\n        long maxOnesZerosMin = onesMax * zerosMin;\n        long maxZerosOnesMax
    = zerosMax * onesMax;\n        long maxZerosOnesMin = zerosMax * onesMin;\n        long
    maxZerosZerosMax = zerosMax * zerosMax;\n        long maxZerosZerosMin = zerosMax
    * zerosMin;\n        long minOnesOnesMax = onesMin * onesMax;\n        long minOnesOnesMin
    = onesMin * onesMin;\n        long minOnesZerosMax = onesMin * zerosMax;\n        long
    minOnesZerosMin = onesMin * zerosMin;\n        long minZerosOnesMax = zerosMin
    * onesMax;\n        long minZerosOnesMin = zerosMin * onesMin;\n        long minZerosZerosMax
    = zerosMin * zerosMax;\n        long minZerosZerosMin\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpm4n8x9nl.cs(65,30): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones;\n        long zerosMax = zeros;\n        long maxMax
    = max;\n        long onesMin = ones;\n        long zerosMin = zeros;\n        long
    maxMin = max;\n        long onesMaxMin = onesMax;\n        long zerosMaxMin =
    zerosMax;\n        long maxMaxMin = maxMax;\n        long onesMinMax = onesMin;\n
    \       long zerosMinMax = zerosMin;\n        long maxMinMax = maxMin;\n        long
    onesMaxMinMax = onesMaxMin;\n        long zerosMaxMinMax = zerosMaxMin;\n        long
    maxMaxMinMax = maxMaxMin;\n        long onesMinMaxMax = onesMinMax;\n        long
    zerosMinMaxMax = zerosMinMax;\n        long maxMinMaxMax = maxMinMax;\n        long
    onesMinMaxMaxMin = onesMinMaxMax;\n        long zerosMinMaxMaxMin = zerosMinMaxMax;\n
    \       long maxMinMaxMaxMin = maxMinMaxMax;\n        long onesMinMaxMaxMinMax
    = onesMinMaxMaxMin;\n        long zerosMinMaxMaxMinMax = zerosMinMaxMaxMin;\n
    \       long maxMinMaxMaxMinMax = maxMinMaxMaxMin;\n        long onesMinMaxMaxMinMaxMax
    = onesMinMaxMaxMinMax;\n        long zerosMinMaxMaxMinMax = zerosMinMaxMaxMinMax;\n
    \       long maxMinMaxMaxMinMax = maxMinMaxMaxMinMax;\n        long onesMinMaxMaxMinMaxMaxMin
    = onesMinMaxMaxMinMax;\n        long zerosMinMaxMaxMinMaxMin = zerosMinMaxMaxMinMax;\n
    \       long maxMinMaxMaxMinMaxMin = maxMinMaxMaxMinMax;\n        long onesMinMaxMaxMinMaxMinMax
    = onesMinMaxMaxMinMax;\n        long zerosMinMaxMaxMinMaxMinMax = zerosMinMaxMaxMinMax;\n
    \       long maxMinMaxMaxMinMaxMinMax = maxMinMaxMaxMinMax\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp9bvvid7i.cs(66,59): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesOnesZeros = maxOnesOnes - maxZeros;\n
    \       long maxOnesOnesOnes = maxOnesOnes - ones;\n        long maxOnesOnesOnesZeros
    = maxOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnes = maxOnesOnesOnes
    - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnes - maxZeros;\n
    \       long maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnes - ones;\n        long
    maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesZeros - maxZeros;\n        long
    maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesOnes - ones;\n        long maxOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesZeros - maxZeros;\n        long maxOnesOnesOnesOnesOnes =
    maxOnesOnesOnesOnesOnes - ones;\n        long maxOnesOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesOnesZeros
    - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesOnesOnes
    - ones;\n        long maxOnesOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesOnesZeros
    - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesOnesOnes
    - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesOnesOnesZeros
    - maxZeros;\n        long maxOne\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmptv8perqa.cs(41,20): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            long
    onesMax = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(ones, 2))) + 1);\n
    \           long zerosMax = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(zeros,
    2))) + 1);\n            long onesMin = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(ones,
    2))) - 1);\n            long zerosMin = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(zeros,
    2))) - 1);\n            long onesMaxMin = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(onesMax,
    2))) - 1);\n            long zerosMaxMin = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(zerosMax,
    2))) - 1);\n            long onesMinMax = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(onesMin,
    2))) - 1);\n            long zerosMinMax = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(zerosMin,
    2))) - 1);\n            long onesMaxMinMax = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(onesMaxMin,
    2))) - 1);\n            long zerosMaxMinMax = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(zerosMaxMin,
    2))) - 1);\n            long onesMinMaxMinMax = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(onesMinMax,
    2))) - 1);\n            long zerosMinMaxMinMax = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(zerosMinMax,
    2))) - 1);\n            long onesMaxMinMaxMinMax = Convert.ToInt64(Math.Pow(2,
    Convert.ToInt32(Math.Log(onesMaxMinMax, 2))) - 1);\n            long zerosMaxMinMaxMinMax
    = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(zerosMaxMinMax, 2))) -
    1);\n            long ones\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpw9i0fifg.cs(54,22): error CS1002: ; expected

    /tmp/tmpw9i0fifg.cs(56,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpw9i0fifg.cs(67,2): error CS1513: } expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones;\n        long zerosMax = zeros;\n        long maxMax
    = max;\n        long onesMin = ones;\n        long zerosMin = zeros;\n        long
    maxMin = max;\n        long onesSum = 0;\n        long zerosSum = 0;\n        long
    maxSum = 0;\n        long onesAvg = 0;\n        long zerosAvg = 0;\n        long
    maxAvg = 0;\n        long onesSum2 = 0;\n        long zerosSum2 = 0;\n        long
    maxSum2 = 0;\n        long onesAvg2 = 0;\n        long zerosAvg2 = 0;\n        long
    maxAvg2 = 0;\n        long onesSum3 = 0;\n        long zerosSum3 = 0;\n        long
    maxSum3 = 0;\n        long onesAvg3 = 0;\n        long zerosAvg3 = 0;\n        long
    maxAvg3 = 0;\n        long onesSum4 = 0;\n        long zerosSum4 = 0;\n        long
    maxSum4 = 0;\n        long onesAvg4 = 0;\n        long zerosAvg4 = 0;\n        long
    maxAvg4 = 0;\n        long onesSum5 = 0;\n        long zerosSum5 = 0;\n        long
    maxSum5 = 0;\n        long onesAvg5 = 0;\n        long zerosAvg5 = 0;\n        long
    maxAvg5 = 0;\n        long onesSum6 = 0;\n        long zerosSum6 = 0;\n        long
    maxSum6 = 0;\n        long onesAvg6 = 0;\n        long zerosAvg6 = 0;\n        long
    maxAvg6 = 0;\n        long onesSum7 = 0;\n        long zerosSum7 = 0;\n        long
    maxSum7 = 0;\n        long onesAvg7 = 0;\n        long zerosAvg7 = 0;\n        long
    maxAvg7 = 0;\n        long onesSum8 = 0;\n        long zerosSum8 = 0;\n        long
    maxSum8 = 0;\n        long onesAvg8 = 0;\n        long zerosAvg8 = 0;\n        long
    maxAvg8 = 0;\n        long onesSum9 = 0;\n        long zerosSum9 = 0;\n        long
    maxSum9 = 0;\n        long onesAvg9 = 0;\n        long zerosAvg9 = 0;\n        long
    maxAvg9 = 0;\n        long onesSum10 = 0;\n        long zerosSum10 = 0;\n        long
    maxSum10 = 0;\n        long onesAvg10 = 0;\n        long zerosAvg10 = 0;\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpcous8kwu.cs(40,14): warning CS0219: The variable ''onesSum'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(41,14): warning CS0219: The variable ''zerosSum'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(42,14): warning CS0219: The variable ''maxSum'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(43,14): warning CS0219: The variable ''onesAvg'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(44,14): warning CS0219: The variable ''zerosAvg'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(45,14): warning CS0219: The variable ''maxAvg'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(46,14): warning CS0219: The variable ''onesSum2'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(47,14): warning CS0219: The variable ''zerosSum2'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(48,14): warning CS0219: The variable ''maxSum2'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(49,14): warning CS0219: The variable ''onesAvg2'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(50,14): warning CS0219: The variable ''zerosAvg2'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(51,14): warning CS0219: The variable ''maxAvg2'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(52,14): warning CS0219: The variable ''onesSum3'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(53,14): warning CS0219: The variable ''zerosSum3'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(54,14): warning CS0219: The variable ''maxSum3'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(55,14): warning CS0219: The variable ''onesAvg3'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(56,14): warning CS0219: The variable ''zerosAvg3'' is assigned
    but its value is never used

    /tmp/tmpcous8kwu.cs(57,14): warning CS0219: The variable ''maxAvg3'' is assigned
    but its val'
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMin = ones * min - 1;\n        long zerosMin = zeros * min - 1;\n        long
    onesMaxMin = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n        long
    onesMinMin = onesMin * min;\n        long zerosMinMin = zerosMin * min;\n        long
    onesMaxMinMin = onesMaxMin * min;\n        long zerosMaxMinMin = zerosMaxMin *
    min;\n        long onesMinMinMin = onesMinMin * min;\n        long zerosMinMinMin
    = zerosMinMin * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long
    zerosMaxMinMinMin = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin
    * min;\n        long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin
    = onesMaxMinMin * min;\n        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n
    \       long onesMinMinMinMin = onesMinMinMin * min;\n        long zerosMinMinMinMin
    = zerosMinMinMin * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n
    \       long zerosMaxMinMinMin = zerosMaxMinMin * min;\n        long onesMinMinMinMin
    = onesMinMinMin * min;\n        long zerosMinMinMinMin = zerosMinMinMin * min;\n
    \       long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin
    = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n
    \       long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin
    = onesMaxMinMin * min;\n        long zerosMaxMinMin\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpctsueop7.cs(63,28): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x >> 1);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x >> 1);\n        long maxOnesCount = arr.Count(x => x & 1L);\n
    \       long maxZerosCount = arr.Count(x => x >> 1);\n        long maxOnesDecimal
    = arr.Max(x => Convert.ToDecimal(Convert.ToString(x, 2)));\n        long maxZerosDecimal
    = arr.Max(x => Convert.ToDecimal(Convert.ToString(x, 2)));\n        long maxOnesDecimalCount
    = arr.Count(x => Convert.ToDecimal(Convert.ToString(x, 2)) & 1L);\n        long
    maxZerosDecimalCount = arr.Count(x => Convert.ToDecimal(Convert.ToString(x, 2))
    >> 1);\n        long maxOnesDecimalDecimal = arr.Max(x => Convert.ToDecimal(Convert.ToDecimal(x,
    2)));\n        long maxZerosDecimalDecimal = arr.Max(x => Convert.ToDecimal(Convert.ToDecimal(x,
    2)));\n        long maxOnesDecimalDecimalCount = arr.Count(x => Convert.ToDecimal(Convert.ToDecimal(x,
    2)) & 1L);\n        long maxZerosDecimalDecimalCount = arr.Count(x => Convert.ToDecimal(Convert.ToDecimal(x,
    2)) >> 1);\n        long maxOnesDecimalDecimalDecimal = arr.Max(x => Convert.ToDecimal(Convert.ToDecimal(x,
    2)));\n        long maxZerosDecimalDecimalDecimal = arr.Max(x => Convert.ToDecimal(Convert.ToDecimal(x,
    2)));\n        long maxOnesDecimalDecimalDecimalCount = arr.Count(x => Convert.ToDecimal(Convert.ToDecimal(x,
    2)) & 1L);\n        long maxZerosDecimalDecimalDecimalCount = arr.Count(x => Convert.ToDecimal(Convert.ToDecimal(x,
    2)) >> 1);\n        long maxOnesDecimalDecimalDecimalDecimal = arr.Max(x => Convert.ToDecimal(Convert.ToDecimal(x,
    2)));\n        long maxZerosDecimalDecimalDecimalDecimal = arr.Max(x => Convert.ToDecimal(Convert.ToDecimal(x,
    2)));\n        long maxOnesDecimalDecimalDecimalDecimalCount = arr.Count(x =>
    Convert.ToDecimal(Convert.ToDecimal(x, 2)) & 1L);\n        long maxZerosDecimalDecimalDecimalDecimalCount
    = arr.Count(x => Conver\n    }\n    public static void Main(string[] args) {\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpqu5kg1hk.cs(41,79): error CS1026: ) expected

    /tmp/tmpqu5kg1hk.cs(41,79): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    maxOnes = ones * max;\n        long maxZeros = zeros * max;\n        long maxOnesMax
    = onesMax * max;\n        long maxZerosMax = zerosMax * max;\n        long maxOnesMaxMinusOnes
    = maxOnesMax - 1L;\n        long maxZerosMaxMinusOnes = maxZerosMax - 1L;\n        long
    maxOnesMaxMinusOnesMax = maxOnesMaxMinusOnes * max;\n        long maxZerosMaxMinusOnesMax
    = maxZerosMaxMinusOnes * max;\n        long maxOnesMaxMinusOnesMaxMinusOnes =
    maxOnesMaxMinusOnesMax * max;\n        long maxZerosMaxMinusOnesMaxMinusOnes =
    maxZerosMaxMinusOnesMax * max;\n        long maxOnesMaxMinusOnesMaxMinusOnesMax
    = maxOnesMaxMinusOnesMaxMinusOnes * max;\n        long maxZerosMaxMinusOnesMaxMinusOnesMax
    = maxZerosMaxMinusOnesMaxMinusOnes * max;\n        long maxOnesMaxMinusOnesMaxMinusOnesMaxMinusOnes
    = maxOnesMaxMinusOnesMaxMinusOnesMax * max;\n        long maxZerosMaxMinusOnesMaxMinusOnesMaxMinusOnes
    = maxZerosMaxMinusOnesMaxMinusOnesMax * max;\n        long maxOnesMaxMinusOnesMaxMinusOnesMaxMinusOnesMax
    = maxOnesMaxMinusOnesMaxMinusOnesMaxMinusOnes * max;\n        long maxZerosMaxMinusOnesMaxMinusOnesMaxMinusOnesMax
    = maxZerosMaxMinusOnesMaxMinusOnesMaxMinusOnes * max;\n        long max\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp8l2ybsfq.cs(52,17): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesZeroOnes = maxOnes - zeros;\n
    \       long maxOnesOnesZeros = maxOnes - ones - zeros;\n        long maxOnesOnesOnes
    = maxOnes - ones - ones;\n        long maxOnesOnesOnesZeros = maxOnes - ones -
    ones - zeros;\n        long maxOnesOnesOnesOnes = maxOnes - ones - ones - ones;\n
    \       long maxOnesOnesOnesOnesZeros = maxOnes - ones - ones - ones - zeros;\n
    \       long maxOnesOnesOnesOnesOnes = maxOnes - ones - ones - ones - ones;\n
    \       long maxOnesOnesOnesOnesOnesZeros = maxOnes - ones - ones - ones - ones
    - zeros;\n        long maxOnesOnesOnesOnesOnesOnes = maxOnes - ones - ones - ones
    - ones - ones;\n        long maxOnesOnesOnesOnesOnesZeros = maxOnes - ones - ones
    - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes =
    maxOnes - ones - ones - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros
    = maxOnes - ones - ones - ones - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes
    = maxOnes - ones - ones - ones - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros
    = maxOnes - ones - ones - ones - ones - ones - ones - ones - zeros;\n        long
    maxOnesOnesOnesOnesOnesOnesOnesOnes = maxOnes - ones - ones - ones - ones - ones
    - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnes\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpidy3tkb5.cs(41,37): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            else if (i == 0L) {\n                zeros++;\n            }\n
    \           else {\n                if (ones > zeros) {\n                    max
    = i;\n                }\n                else {\n                    max = zeros;\n
    \               }\n            }\n        }\n        List<long> res = new List<long>();\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                res.Add(i);\n
    \           }\n            else if (i == 0L) {\n                res.Add(max);\n
    \           }\n            else {\n                if (ones > zeros) {\n                    res.Add(i);\n
    \               }\n                else {\n                    res.Add(max);\n
    \               }\n            }\n        }\n        return res;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <9ea1d621897348a49366b95d78a0afb3>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <9ea1d621897348a49366b95d78a0afb3>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659795182
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1);\n        long zeros = arr.Sum(x
    => x & 2);\n        long maxOnes = arr.Max(x => x & 1);\n        long maxZeros
    = arr.Max(x => x & 2);\n        long maxOnesZeros = maxOnes + maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesTwos = maxOnes - ones - zeros;\n
    \       long maxOnesThrees = maxOnes - ones - zeros - ones;\n        long maxOnesFours
    = maxOnes - ones - zeros - ones - zeros;\n        long maxOnesFives = maxOnes
    - ones - zeros - ones - zeros - ones;\n        long maxOnesSixes = maxOnes - ones
    - zeros - ones - zeros - ones - zeros;\n        long maxOnesSevens = maxOnes -
    ones - zeros - ones - zeros - ones - zeros - ones;\n        long maxOnesEights
    = maxOnes - ones - zeros - ones - zeros - ones - zeros - ones - zeros;\n        long
    maxOnesNines = maxOnes - ones - zeros - ones - zeros - ones - zeros - ones - zeros
    - ones;\n        long maxOnesTens = maxOnes - ones - zeros - ones - zeros - ones
    - zeros - ones - zeros - ones - zeros;\n        long maxOnesElevens = maxOnes
    - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones;\n
    \       long maxOnesTwelves = maxOnes - ones - zeros - ones - zeros - ones - zeros
    - ones - zeros - ones - zeros - ones - zeros;\n        long maxOnesThirteens =
    maxOnes - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones - zeros
    - ones - zeros - ones - zeros;\n        long maxOnesFourteens = maxOnes - ones
    - zeros - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones - zeros
    - ones - zeros - ones;\n        long maxOnesFifteens = maxOnes - ones - zeros
    - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones
    - zeros - ones - zeros;\n        long maxOnesSixteens = maxOnes - ones - zeros
    - ones - zero\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpgzny_vek.cs(40,68): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i == max) {\n                max = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            long
    onesMax = ones;\n            long zerosMax = zeros;\n            while (onesMax
    < zerosMax) {\n                result.Add(max);\n                zerosMax--;\n
    \           }\n            while (zerosMax < onesMax) {\n                result.Add(max);\n
    \               onesMax--;\n            }\n        }\n        else {\n            long
    zerosMax = zeros;\n            long onesMax = ones;\n            while (zerosMax
    < onesMax) {\n                result.Add(max);\n                zerosMax--;\n
    \           }\n            while (onesMax < zerosMax) {\n                result.Add(max);\n
    \               onesMax--;\n            }\n        }\n        return result;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <e30ae8bcb5574886b1362176adb44b86>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <e30ae8bcb5574886b1362176adb44b86>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x >> 1);\n        if (ones > zeros) {\n            long max = ones;\n            long
    min = zeros;\n            while (max > min) {\n                long mid = max
    / 2;\n                if (mid > min) {\n                    max = mid;\n                }
    else {\n                    min = mid;\n                }\n            }\n            long
    mid = max / 2;\n            long left = arr.FindIndex(x => x == mid);\n            long
    right = arr.FindIndex(x => x == mid + 1);\n            long midVal = arr[left];\n
    \           arr[left] = arr[right];\n            arr[right] = midVal;\n        }\n
    \       return arr;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp26wsdgbx.cs(26,22): error CS0136: A local or parameter named ''mid'' cannot
    be declared in this scope because that name is used in an enclosing local scope
    to define a local or parameter

    /tmp/tmp26wsdgbx.cs(36,31): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmp26wsdgbx.cs(37,17): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmp26wsdgbx.cs(37,29): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmp26wsdgbx.cs(38,17): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659823606
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           } else if (i == 0L) {\n                zeros++;\n            } else
    {\n                if (ones > zeros) {\n                    max = i;\n                }
    else if (ones < zeros) {\n                    max = -i;\n                }\n            }\n
    \       }\n        List<long> result = new List<long>();\n        if (ones > zeros)
    {\n            foreach (long i in arr) {\n                if (i == max) {\n                    result.Add(i);\n
    \               }\n            }\n        } else if (ones < zeros) {\n            foreach
    (long i in arr) {\n                if (i == -max) {\n                    result.Add(i);\n
    \               }\n            }\n        }\n        return result;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <8fdddaaee197461b91563ba1e515455e>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <8fdddaaee197461b91563ba1e515455e>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x >> 1);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x >> 1);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesZeroOnes = maxOnes - zeros;\n
    \       long maxOnesOnesZeros = maxOnes - ones - zeros;\n        long maxOnesOnesOnes
    = maxOnes - ones - ones;\n        long maxOnesOnesOnesZeros = maxOnes - ones -
    ones - zeros;\n        long maxOnesOnesOnesOnes = maxOnes - ones - ones - ones;\n
    \       long maxOnesOnesOnesOnesZeros = maxOnes - ones - ones - ones - zeros;\n
    \       long maxOnesOnesOnesOnesOnes = maxOnes - ones - ones - ones - ones;\n
    \       long maxOnesOnesOnesOnesOnesZeros = maxOnes - ones - ones - ones - ones
    - zeros;\n        long maxOnesOnesOnesOnesOnesOnes = maxOnes - ones - ones - ones
    - ones - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros = maxOnes - ones
    - ones - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes
    = maxOnes - ones - ones - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesOnesOnesZeros
    = maxOnes - ones - ones - ones - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnesOnesOnes
    = maxOnes - ones - ones - ones - ones - ones - ones - ones - ones;\n        long
    maxOnesOnesOnesOnesOnesOnesOnesOnesZeros = maxOnes - ones - ones - ones - ones
    - ones - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnesOnesOnesOnes
    = maxOnes - ones - ones - ones - ones - ones - ones - ones - ones - ones;\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpnyw5qmer.cs(19,30): error CS0161: ''Problem.SortArray(List<long>)'': not
    all code paths return a value

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long maxOnes
    = 0;\n        long maxZeros = 0;\n        long maxOnesCount = 0;\n        long
    maxZerosCount = 0;\n        long maxOnesCount2 = 0;\n        long maxZerosCount2
    = 0;\n        long maxOnesCount3 = 0;\n        long maxZerosCount3 = 0;\n        long
    maxOnesCount4 = 0;\n        long maxZerosCount4 = 0;\n        long maxOnesCount5
    = 0;\n        long maxZerosCount5 = 0;\n        long maxOnesCount6 = 0;\n        long
    maxZerosCount6 = 0;\n        long maxOnesCount7 = 0;\n        long maxZerosCount7
    = 0;\n        long maxOnesCount8 = 0;\n        long maxZerosCount8 = 0;\n        long
    maxOnesCount9 = 0;\n        long maxZerosCount9 = 0;\n        long maxOnesCount10
    = 0;\n        long maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n        long
    maxZerosCount11 = 0;\n        long maxOnesCount12 = 0;\n        long maxZerosCount12
    = 0;\n        long maxOnesCount13 = 0;\n        long maxZerosCount13 = 0;\n        long
    maxOnesCount14 = 0;\n        long maxZerosCount14 = 0;\n        long maxOnesCount15
    = 0;\n        long maxZerosCount15 = 0;\n        long maxOnesCount16 = 0;\n        long
    maxZerosCount16 = 0;\n        long maxOnesCount17 = 0;\n        long maxZerosCount17
    = 0;\n        long maxOnesCount18 = 0;\n        long maxZerosCount18 = 0;\n        long
    maxOnesCount19 = 0;\n        long maxZerosCount19 = 0;\n        long maxOnesCount20
    = 0;\n        long maxZerosCount20 = 0;\n        long maxOnesCount21 = 0;\n        long
    maxZerosCount21 = 0;\n        long maxOnesCount22 = 0;\n        long maxZerosCount22
    = 0;\n        long maxOnesCount23 = 0;\n        long maxZerosCount23 = 0;\n        long
    maxOnesCount24 = 0;\n        long maxZerosCount24 = 0;\n        long maxOnesCount25
    = 0;\n        long maxZerosCount25 = 0;\n        long maxOnesCount26 = 0;\n        long
    maxZerosCount26 = 0;\n        long maxOnesCount\n    }\n    public static void
    Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpesxj2l0z.cs(76,26): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long num in arr) {\n            if (num
    == 1) {\n                ones++;\n            }\n            if (num == 0) {\n
    \               zeros++;\n            }\n            if (num > max) {\n                max
    = num;\n            }\n            if (num < min) {\n                min = num;\n
    \           }\n        }\n        long onesMax = ones;\n        long zerosMax
    = zeros;\n        long maxMax = max;\n        long minMin = min;\n        long
    onesMin = ones;\n        long zerosMin = zeros;\n        long maxMin = max;\n
    \       long minMax = min;\n        long onesMinMax = ones;\n        long zerosMinMax
    = zeros;\n        long maxMinMax = max;\n        long minMinMax = min;\n        long
    onesMinMaxMin = ones;\n        long zerosMinMaxMin = zeros;\n        long maxMinMaxMin
    = max;\n        long minMinMaxMin = min;\n        long onesMinMaxMinMax = ones;\n
    \       long zerosMinMaxMinMax = zeros;\n        long maxMinMaxMinMax = max;\n
    \       long minMinMaxMinMax = min;\n        long onesMinMaxMinMaxMin = ones;\n
    \       long zerosMinMaxMinMaxMin = zeros;\n        long maxMinMaxMinMaxMin =
    max;\n        long minMinMaxMinMaxMin = min;\n        long onesMinMaxMinMaxMinMax
    = ones;\n        long zerosMinMaxMinMaxMinMax = zeros;\n        long maxMinMaxMinMaxMinMax
    = max;\n        long minMinMaxMinMaxMinMax = min;\n        long onesMinMaxMinMaxMinMaxMin
    = ones;\n        long zerosMinMaxMinMaxMinMaxMin = zeros;\n        long maxMinMaxMinMaxMinMaxMin
    = max;\n        long minMinMaxMinMaxMinMaxMin = min;\n        long onesMinMaxMinMaxMinMaxMin
    = ones;\n        long zerosMinMaxMinMaxMinMaxMin = zeros;\n        long maxMinMaxMinMaxMinMaxMin
    = max;\n        long minMinMaxMinMaxMinMaxMin = min;\n        long onesMinMaxMinMaxMinMaxMinMax
    = ones;\n        long zerosMinMaxMinMaxMinMaxMinMax = zero\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmph5z62ysv.cs(75,50): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones == zeros) {\n            return arr;\n        }\n
    \       long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros = arr.Max(x
    => x & 0L);\n        if (maxOnes == maxZeros) {\n            return arr.OrderBy(x
    => x).ToList();\n        }\n        long maxOnesDecimal = arr.Max(x => x.ToString().Count(c
    => c == '1'));\n        long maxZerosDecimal = arr.Max(x => x.ToString().Count(c
    => c == '0'));\n        if (maxOnesDecimal == maxZerosDecimal) {\n            return
    arr.OrderBy(x => x.ToString()).ToList();\n        }\n        long maxOnesDecimal2
    = arr.Max(x => x.ToString().Count(c => c == '1'));\n        long maxZerosDecimal2
    = arr.Max(x => x.ToString().Count(c => c == '0'));\n        if (maxOnesDecimal2
    == maxZerosDecimal2) {\n            return arr.OrderBy(x => x.ToString()).ToList();\n
    \       }\n        long maxOnesDecimal3 = arr.Max(x => x.ToString().Count(c =>
    c == '1'));\n        long maxZerosDecimal3 = arr.Max(x => x.ToString().Count(c
    => c == '0'));\n        if (maxOnesDecimal3 == maxZerosDecimal3) {\n            return
    arr.OrderBy(x => x.ToString()).ToList();\n        }\n        long maxOnesDecimal4
    = arr.Max(x => x.ToString().Count(c => c == '1'));\n        long maxZerosDecimal4
    = arr.Max(x => x.ToString().Count(c => c == '0'));\n        if (maxOnesDecimal4
    == maxZerosDecimal4) {\n            return arr.OrderBy(x => x.ToString()).ToList();\n
    \       }\n        long maxOnesDecimal5 = arr.Max(x => x.ToString().Count(c =>
    c == '1'));\n        long maxZerosDecimal5 = arr.Max(x => x.ToString().Count(c
    => c == '0'));\n        if (maxOnesDecimal5 == maxZerosDecimal5) {\n            return
    arr.OrderBy(x => x.ToString()).ToList();\n        }\n        long maxOnesDecimal6
    = arr.Max(x => x.ToString().Count(c => c == '1'));\n        long maxZerosDecimal6
    = arr.Max(x => x.ToString\n    }\n    public static void Main(string[] args) {\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpu4gq_es1.cs(56,56): error CS1026: ) expected

    /tmp/tmpu4gq_es1.cs(56,56): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long onesMin = ones * min;\n        long
    zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long onesDiff
    = onesMax - onesMin;\n        long zerosDiff = zerosMax - zerosMin;\n        long
    maxDiff = max - min;\n        long onesDiffMin = onesMin - onesMax;\n        long
    zerosDiffMin = zerosMin - zerosMax;\n        long onesDiffMax = onesMax - onesMin;\n
    \       long zerosDiffMax = zerosMax - zerosMin;\n        long onesDiffMinMax
    = onesDiffMin + onesDiffMax;\n        long zerosDiffMinMax = zerosDiffMin + zerosDiffMax;\n
    \       long onesDiffMinMaxDiff = onesDiffMinMax + maxDiff;\n        long zerosDiffMinMaxDiff
    = zerosDiffMinMax + maxDiff;\n        long onesDiffMinMaxDiffDiff = onesDiffMinMaxDiff
    + maxDiff;\n        long zerosDiffMinMaxDiffDiff = zerosDiffMinMaxDiff + maxDiff;\n
    \       long onesDiffMinMaxDiffDiffDiff = onesDiffMinMaxDiffDiff + maxDiff;\n
    \       long zerosDiffMinMaxDiffDiffDiff = zerosDiffMinMaxDiffDiff + maxDiff;\n
    \       long onesDiffMinMaxDiffDiffDiffDiff = onesDiffMinMaxDiffDiffDiff + maxDiff;\n
    \       long zerosDiffMinMaxDiffDiffDiffDiff = zerosDiffMinMaxDiffDiffDiff + maxDiff;\n
    \       long onesDiffMinMaxDiffDiffDiffDiffDiff = onesDiffMinMaxDiffDiffDiffDiff
    + maxDiff;\n        long zerosDiffMinMaxDiffDiffDiffDiffDiff = zerosDiffMinMaxDiffDiffDiffDiff
    + maxDiff;\n        long onesDiffMinMaxDiffDiffDiffDiffDiffDiff = onesDiffMinMaxDiffDiffDiffDiffDiff
    + maxDiff;\n        long zerosDiffMinMaxDiff\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpwra5teme.cs(62,33): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long zeros = 0;\n        long max = 0;\n        foreach (long i in arr)
    {\n            if (i == 1L) {\n                ones++;\n            }\n            if
    (i == 0L) {\n                zeros++;\n            }\n            if (i > max)
    {\n                max = i;\n            }\n        }\n        long onesMax =
    ones * max;\n        long zerosMax = zeros * max;\n        long onesMin = ones
    * min - 1;\n        long zerosMin = zeros * min - 1;\n        long onesMaxMin
    = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n        long onesMinMax
    = onesMin * max;\n        long zerosMinMax = zerosMin * max;\n        long onesMinMaxMin
    = onesMinMax * min;\n        long zerosMinMaxMin = zerosMinMax * min;\n        long
    onesMaxMinMax = onesMaxMin * max;\n        long zerosMaxMinMax = zerosMaxMin *
    max;\n        long onesMaxMinMaxMin = onesMaxMinMax * min;\n        long zerosMaxMinMaxMin
    = zerosMaxMinMax * min;\n        long onesMaxMinMaxMinMax = onesMaxMinMaxMin *
    max;\n        long zerosMaxMinMaxMinMax = zerosMaxMinMaxMin * max;\n        long
    onesMaxMinMaxMinMaxMin = onesMaxMinMaxMinMax * min;\n        long zerosMaxMinMaxMinMaxMin
    = zerosMaxMinMaxMinMax * min;\n        long onesMaxMinMaxMinMaxMinMax = onesMaxMinMaxMinMaxMinMax
    * max;\n        long zerosMaxMinMaxMinMaxMinMax = zerosMaxMinMaxMinMaxMinMax *
    max;\n        long onesMaxMinMaxMinMaxMinMaxMin = onesMaxMinMaxMinMaxMinMaxMin
    * max;\n        long zerosMaxMinMaxMinMaxMinMax = zerosMaxMinMaxMinMaxMinMax *
    max;\n        long onesMaxMinMaxMinMaxMinMaxMin = onesMaxMinMaxMinMaxMinMaxMin
    * max;\n        long zerosMaxMinMaxMinMaxMinMax = zerosMaxMinMaxMinMaxMinMax *
    max;\n        long onesMaxMinMaxMinMaxMinMaxMinMax = onesMaxMinMaxMinMaxMinMaxMin\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpuk8msck6.cs(59,76): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long onesMin = ones * min;\n        long
    zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long maxOnesMax
    = onesMax * max;\n        long maxOnesMin = onesMax * min;\n        long maxZerosMax
    = zerosMax * max;\n        long maxZerosMin = zerosMax * min;\n        long minOnesMax
    = onesMin * max;\n        long minOnesMin = onesMin * min;\n        long minZerosMax
    = zerosMin * max;\n        long minZerosMin = zerosMin * min;\n        long maxOnesMaxMin
    = onesMax * min;\n        long maxOnesMinMin = onesMin * min;\n        long maxZerosMaxMin
    = zerosMax * min;\n        long maxZerosMinMin = zerosMin * min;\n        long
    minOnesMaxMin = onesMin * min;\n        long minOnesMinMin = onesMin * min;\n
    \       long minZerosMaxMin = zerosMin * min;\n        long minZerosMinMin = zerosMin
    * min;\n        long maxOnesMaxMinMin = onesMax * min;\n        long maxOnesMinMinMin
    = onesMin * min;\n        long maxZerosMaxMinMin = zerosMax * min;\n        long
    maxZerosMinMinMin = zerosMin * min;\n        long minOnesMaxMinMin = onesMin *
    min;\n        long minOnesMinMinMin = onesMin * min;\n        long minZerosMaxMinMin
    = zerosMin * min;\n        long minZerosMinMinMin = zerosMin * min;\n        long
    maxOnesMaxMinMinMin = onesMax * min;\n        long maxOnesMinMinMinMin = onesMin
    * min;\n\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpja2k3k74.cs(19,30): error CS0161: ''Problem.SortArray(List<long>)'': not
    all code paths return a value

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long onesMin = ones * min;\n        long
    zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long onesDiff
    = onesMax - onesMin;\n        long zerosDiff = zerosMax - zerosMin;\n        long
    onesDiffMax = onesDiff > zerosDiff ? onesDiff : zerosDiff;\n        long onesDiffMin
    = onesDiff < zerosDiff ? onesDiff : zerosDiff;\n        long onesDiffMaxMin =
    onesDiffMax * min;\n        long onesDiffMinMax = onesDiffMin * max;\n        long
    onesDiffMaxMinMax = onesDiffMaxMin * max;\n        long onesDiffMinMaxMax = onesDiffMinMax
    * max;\n        long onesDiffMaxMinMaxMax = onesDiffMaxMinMax * max;\n        long
    onesDiffMinMaxMaxMax = onesDiffMinMaxMax * max;\n        long onesDiffMinMaxMaxMaxMax
    = onesDiffMinMaxMax * max;\n        long onesDiffMinMaxMaxMaxMax = onesDiffMinMaxMax
    * max;\n        long onesDiffMinMaxMaxMaxMaxMax = onesDiffMinMaxMax * max;\n        long
    onesDiffMinMaxMaxMaxMaxMax = onesDiffMinMaxMax * max;\n        long onesDiffMinMaxMaxMaxMaxMax
    = onesDiffMinMaxMax * max;\n        long onesDiffMinMaxMaxMaxMaxMaxMax = onesDiffMinMaxMax
    * max;\n        long onesDiffMinMaxMaxMaxMaxMaxMax = onesDiffMinMaxMax * max;\n
    \       long onesDiffMinMaxMaxMaxMaxMaxMax = onesDiffMinMaxMax * max;\n        long
    onesDiffMinMaxMaxMaxMaxMaxMaxMax = onesDiffMinMaxMax * max;\n        long onesDiffMinMaxMaxMaxMaxMaxMax\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp3u3z9eq5.cs(61,43): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            long
    onesMax = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max, 2))) + 1);\n
    \           long onesMin = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) - 1);\n            long onesDiff = onesMax - onesMin;\n            long onesDiff2
    = onesDiff / 2;\n            long onesDiff3 = onesDiff2 / 2;\n            long
    onesDiff4 = onesDiff3 / 2;\n            long onesDiff5 = onesDiff4 / 2;\n            long
    onesDiff6 = onesDiff5 / 2;\n            long onesDiff7 = onesDiff6 / 2;\n            long
    onesDiff8 = onesDiff7 / 2;\n            long onesDiff9 = onesDiff8 / 2;\n            long
    onesDiff10 = onesDiff9 / 2;\n            long onesDiff11 = onesDiff10 / 2;\n            long
    onesDiff12 = onesDiff11 / 2;\n            long onesDiff13 = onesDiff12 / 2;\n
    \           long onesDiff14 = onesDiff13 / 2;\n            long onesDiff15 = onesDiff14
    / 2;\n            long onesDiff16 = onesDiff15 / 2;\n            long onesDiff17
    = onesDiff16 / 2;\n            long onesDiff18 = onesDiff17 / 2;\n            long
    onesDiff19 = onesDiff18 / 2;\n            long onesDiff20 = onesDiff19 / 2;\n
    \           long onesDiff21 = onesDiff20 / 2;\n            long onesDiff22 = onesDiff21
    / 2;\n            long onesDiff23 = onesDiff22 / 2;\n            long onesDiff24
    = onesDiff23 / 2;\n            long onesDiff25 = onesDiff24 / 2;\n            long
    onesDiff26 = onesDiff25 / 2;\n            long onesDiff27 = onesDiff26 / 2;\n
    \           long onesDiff28 = onesDiff27 / 2;\n            long ones\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp3rucstsf.cs(66,22): error CS1002: ; expected

    /tmp/tmp3rucstsf.cs(68,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp3rucstsf.cs(79,2): error CS1513: } expected

    '
  timestamp: 1659823606
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long num in arr) {\n            ones += num;\n            zeros
    -= num;\n            if (ones > max) {\n                max = ones;\n            }\n
    \           if (zeros > max) {\n                max = zeros;\n            }\n
    \       }\n        List<long> result = new List<long>();\n        foreach (long
    num in arr) {\n            if (num == 1) {\n                result.Add(num);\n
    \           } else {\n                result.Add(num / max);\n            }\n
    \       }\n        return result;\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <ec42d31ea3034c218e3664ffbd66e60f>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <ec42d31ea3034c218e3664ffbd66e60f>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        if (arr.Count < 2)\n            return arr;\n        long ones
    = arr.Where(x => x == 1).Count();\n        long zeros = arr.Where(x => x == 0).Count();\n
    \       if (ones < zeros) {\n            long temp = ones;\n            ones =
    zeros;\n            zeros = temp;\n        }\n        long maxOnes = ones;\n        long
    maxZeros = zeros;\n        long maxOnesCount = 0;\n        long maxZerosCount
    = 0;\n        long maxOnesCount2 = 0;\n        long maxZerosCount2 = 0;\n        long
    maxOnesCount3 = 0;\n        long maxZerosCount3 = 0;\n        long maxOnesCount4
    = 0;\n        long maxZerosCount4 = 0;\n        long maxOnesCount5 = 0;\n        long
    maxZerosCount5 = 0;\n        long maxOnesCount6 = 0;\n        long maxZerosCount6
    = 0;\n        long maxOnesCount7 = 0;\n        long maxZerosCount7 = 0;\n        long
    maxOnesCount8 = 0;\n        long maxZerosCount8 = 0;\n        long maxOnesCount9
    = 0;\n        long maxZerosCount9 = 0;\n        long maxOnesCount10 = 0;\n        long
    maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n        long maxZerosCount11
    = 0;\n        long maxOnesCount12 = 0;\n        long maxZerosCount12 = 0;\n        long
    maxOnesCount13 = 0;\n        long maxZerosCount13 = 0;\n        long maxOnesCount14
    = 0;\n        long maxZerosCount14 = 0;\n        long maxOnesCount15 = 0;\n        long
    maxZerosCount15 = 0;\n        long maxOnesCount16 = 0;\n        long maxZerosCount16
    = 0;\n        long maxOnesCount17 = 0;\n        long maxZerosCount17 = 0;\n        long
    maxOnesCount18 = 0;\n        long maxZerosCount18 = 0;\n        long maxOnesCount19
    = 0;\n        long maxZerosCount19 = 0;\n        long maxOnesCount20 = 0;\n        long
    maxZerosCount20 = 0;\n        long maxOnesCount21 = 0;\n        long maxZerosCount21
    = 0;\n        long maxOnesCount22 = 0;\n        long maxZerosCount22 = 0;\n        long
    maxOnesCount23 = 0;\n        long maxZerosCount23 = 0;\n        long maxOnes\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp0p8wtj20.cs(77,21): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones == zeros) {\n            return arr;\n        }\n
    \       List<long> result = new List<long>();\n        long maxOnes = ones;\n
    \       long maxZeros = zeros;\n        long maxOnesCount = 0;\n        long maxZerosCount
    = 0;\n        foreach (long x in arr) {\n            long onesCount = x & 1L;\n
    \           long zerosCount = x & 0L;\n            if (onesCount > maxOnesCount)
    {\n                maxOnesCount = onesCount;\n            }\n            if (zerosCount
    > maxZerosCount) {\n                maxZerosCount = zerosCount;\n            }\n
    \       }\n        long maxOnesCountInt = Convert.ToInt64(maxOnesCount);\n        long
    maxZerosCountInt = Convert.ToInt64(maxZerosCount);\n        long maxOnesCountDecimal
    = maxOnesCountInt * 10 + maxOnesCountInt % 10;\n        long maxZerosCountDecimal
    = maxZerosCountInt * 10 + maxZerosCountInt % 10;\n        long maxOnesCountDecimalInt
    = Convert.ToInt64(maxOnesCountDecimal);\n        long maxZerosCountDecimalInt
    = Convert.ToInt64(maxZerosCountDecimal);\n        long maxOnesCountDecimalDecimal
    = maxOnesCountDecimalInt * 10 + maxOnesCountDecimalInt % 10;\n        long maxZerosCountDecimalDecimal
    = maxZerosCountDecimalInt * 10 + maxZerosCountDecimalInt % 10;\n        long maxOnesCountDecimalDecimalInt
    = Convert.ToInt64(maxOnesCountDecimalDecimal);\n        long maxZerosCountDecimalDecimalInt
    = Convert.ToInt64(maxZerosCountDecimalDecimal);\n        long maxOnesCountDecimalDecimalDecimal
    = maxOnesCountDecimalDecimalInt * 10 + maxOnesCountDecimalDecimalInt % 10;\n        long
    maxZerosCountDecimalDecimalDecimal = maxZerosCountDecimalDecimalInt * 10 + maxZerosCountDecimalDecimalInt
    % 10;\n        long maxOnesCountDecimalDecimalDecimalInt = Convert.ToInt64(maxOnesCountDecimalDecimalDecimal);\n
    \       long maxZerosCountDecimalDecimalDecimalInt = Convert.ToInt64(maxZerosCountDecimal\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpvkh5fx02.cs(53,90): error CS1026: ) expected

    /tmp/tmpvkh5fx02.cs(53,90): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            } else {\n                zeros++;\n
    \           }\n            if (max < i) {\n                max = i;\n            }\n
    \           if (min > i) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long onesMin = ones * min;\n        long
    zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long maxOnes
    = ones * max;\n        long maxZeros = zeros * max;\n        long minOnes = ones
    * min;\n        long minZeros = zeros * min;\n        long maxOnesMax = onesMax
    * max;\n        long maxOnesMin = onesMin * max;\n        long maxZerosMax = zerosMax
    * max;\n        long maxZerosMin = zerosMin * max;\n        long minOnesMax =
    onesMax * min;\n        long minOnesMin = onesMin * min;\n        long minZerosMax
    = zerosMax * min;\n        long minZerosMin = zerosMin * min;\n        List<long>
    result = new List<long>();\n        if (onesMax > zerosMax) {\n            result.Add(maxOnes);\n
    \           result.Add(maxZeros);\n            result.Add(minOnes);\n            result.Add(minZeros);\n
    \       } else if (onesMin > zerosMin) {\n            result.Add(maxOnes);\n            result.Add(maxZeros);\n
    \           result.Add(minOnes);\n            result.Add(minZeros);\n        }
    else if (zerosMax > onesMax) {\n            result.Add(maxOnes);\n            result.Add(maxZeros);\n
    \           result.Add(minOnes);\n            result.Add(minZeros);\n        }
    else if (zerosMin > onesMin) {\n            result.Add(maxOnes);\n            result.Add(maxZeros);\n
    \           result.Add(minOnes);\n            result.Add(minZeros);\n        }
    else if (onesMax > zerosMax) {\n            result.Add(maxOnes);\n            result.Add(maxZeros);\n
    \           result.Add(minOnes);\n            result.Add(minZeros);\n        }
    else if (onesMin > zerosMin) {\n            result.Add(maxOnes);\n            result.Add(maxZeros);\n
    \           result.Add(minOnes);\n            result.Add(minZeros);\n        }
    else if (zerosMax > onesMax) {\n            result.Add(maxOnes);\n            result.\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpdarv3bbd.cs(86,20): error CS1001: Identifier expected

    /tmp/tmpdarv3bbd.cs(86,20): error CS1002: ; expected

    /tmp/tmpdarv3bbd.cs(88,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpdarv3bbd.cs(99,2): error CS1513: } expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesOnesZeros = maxOnesOnes - maxZeros;\n
    \       long maxOnesOnesOnes = maxOnesOnes - ones;\n        long maxOnesOnesOnesZeros
    = maxOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnes = maxOnesOnesOnes
    - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnes - maxZeros;\n
    \       long maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnes - ones;\n        long
    maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesZeros - maxZeros;\n        long
    maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnesOnes =
    maxOnesOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnes
    = maxOnesOnesOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes
    = maxOnesOnesOnesOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnes\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp0pfqudoy.cs(40,72): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones;\n        long zerosMax = zeros;\n        long maxMax
    = max;\n        long onesMin = ones;\n        long zerosMin = zeros;\n        long
    maxMin = max;\n        long onesCurr = ones;\n        long zerosCurr = zeros;\n
    \       long maxCurr = max;\n        long onesPrev = 0;\n        long zerosPrev
    = 0;\n        long maxPrev = 0;\n        long onesNext = 0;\n        long zerosNext
    = 0;\n        long maxNext = 0;\n        long onesCurrPrev = 0;\n        long
    zerosCurrPrev = 0;\n        long maxCurrPrev = 0;\n        long onesCurrNext =
    0;\n        long zerosCurrNext = 0;\n        long maxCurrNext = 0;\n        long
    onesPrevPrev = 0;\n        long zerosPrevPrev = 0;\n        long maxPrevPrev =
    0;\n        long onesPrevNext = 0;\n        long zerosPrevNext = 0;\n        long
    maxPrevNext = 0;\n        long onesNextNext = 0;\n        long zerosNextNext =
    0;\n        long maxNextNext = 0;\n        long onesCurrPrevPrev = 0;\n        long
    zerosCurrPrevPrev = 0;\n        long maxCurrPrevPrev = 0;\n        long onesCurrPrevNext
    = 0;\n        long zerosCurrPrevNext = 0;\n        long maxCurrPrevNext = 0;\n
    \       long onesCurrNextPrev = 0;\n        long zerosCurrNextPrev = 0;\n        long
    maxCurrNextPrev = 0;\n        long onesCurrNextNext = 0;\n        long zerosCurrNextNext
    = 0;\n        long maxCurrNextNext = 0;\n        long onesPrevPrevPrev = 0;\n
    \       long zerosPrevPrevPrev = 0;\n        long maxPrevPrevPrev = 0;\n        long
    onesPrevPrevNext = 0;\n        long zerosPrevPrevNext = 0;\n        long maxPrevPrevNext
    = 0;\n        long onesPrevNextPrev = 0;\n        long zerosPrevNextPrev = 0;\n
    \       long maxPrevNextPrev = 0;\n        long onesPrevNextNext = 0;\n        long
    zerosPrevNextNext = 0;\n        long maxPrevNextNext = 0;\n        long onesNextNextPrev
    = 0;\n        long \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpindirvmi.cs(89,13): error CS1001: Identifier expected

    /tmp/tmpindirvmi.cs(89,13): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones > zeros) {\n            return arr.OrderBy(x =>
    BitConverter.ToInt64(BitConverter.GetBytes(x), 0)).ToList();\n        }\n        if
    (zeros > ones) {\n            return arr.OrderByDescending(x => BitConverter.ToInt64(BitConverter.GetBytes(x),
    0)).ToList();\n        }\n        return arr.OrderBy(x => BitConverter.ToInt64(BitConverter.GetBytes(x),
    0)).ToList();\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <a2106159986346e89fd48be10bbb4bab>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <a2106159986346e89fd48be10bbb4bab>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesZeroOnes = maxOnes - zeros;\n
    \       long maxOnesOneOnes = maxOnes - ones - ones;\n        long maxOnesZeroZeroOnes
    = maxOnes - zeros - zeros;\n        long maxOnesZeroZeroOnes = maxOnes - zeros
    - zeros - ones;\n        long maxOnesOneZeroOnes = maxOnes - ones - zeros - ones;\n
    \       long maxOnesZeroZeroZeroOnes = maxOnes - zeros - zeros - zeros - ones;\n
    \       long maxOnesOneZeroZeroOnes = maxOnes - ones - zeros - zeros - ones;\n
    \       long maxOnesZeroZeroZeroOnes = maxOnes - zeros - zeros - zeros - zeros
    - ones;\n        long maxOnesOneZeroZeroZeroOnes = maxOnes - ones - zeros - zeros
    - zeros - ones;\n        long maxOnesZeroZeroZeroOnes = maxOnes - zeros - zeros
    - zeros - zeros - zeros - ones;\n        long maxOnesOneZeroZeroZeroOnes = maxOnes
    - ones - zeros - zeros - zeros - zeros - zeros - ones;\n        long maxOnesZeroZeroZeroZeroOnes
    = maxOnes - zeros - zeros - zeros - zeros - zeros - zeros - ones;\n        long
    maxOnesOneZeroZeroZeroZeroOnes = maxOnes - ones - zeros - zeros - zeros - zeros
    - zeros - zeros - ones;\n        long maxOnesZeroZeroZeroZeroOnes = maxOnes -
    zeros - zeros - zeros - zeros - zeros - zeros - zeros - ones;\n        long maxOnesOneZeroZeroZeroZeroOnes
    = maxOnes - ones - zeros - zeros - zeros - zeros - zeros - zeros - zeros - ones;\n
    \       long maxOnesZeroZeroZeroZeroZeroOnes = maxOnes - zeros - zeros - zeros
    - zeros - zeros - zeros - zeros - zeros - ones;\n        long maxOnesOneZeroZeroZeroZeroZeroOnes
    = maxOnes - ones - zeros - zeros - zeros - zeros - zeros - \n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpdrfahgk0.cs(42,107): error CS1525: Invalid expression term ''}''

    /tmp/tmpdrfahgk0.cs(42,107): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            long
    onesMax = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max, 2))) + 1);\n
    \           long onesMin = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) - 1);\n            long onesMaxDecimal = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2)) - 1));\n            long onesMinDecimal = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2)) + 1));\n            long onesMaxDecimal2 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2)) + 1));\n            long onesMinDecimal2 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2)) - 1));\n            long onesMaxDecimal3 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2)) + 1));\n            long onesMinDecimal3 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2)) - 1));\n            long onesMaxDecimal4 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2)) - 1));\n            long onesMinDecimal4 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2)) + 1));\n            long onesMaxDecimal5 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2)) + 1));\n            long onesMinDecimal5 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2)) - 1));\n            long onesMaxDecimal6 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2)) - 1));\n            long onesMinDecimal6 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2)) + 1));\n            long onesMaxDecimal7 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2)) + 1));\n            long onesMinDecimal7 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2)) - 1));\n            long onesMaxDecimal\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpjwkkfg6w.cs(52,32): error CS1002: ; expected

    /tmp/tmpjwkkfg6w.cs(54,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpjwkkfg6w.cs(65,2): error CS1513: } expected

    '
  timestamp: 1659823606
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            else if (i == 0L) {\n                zeros++;\n            }\n
    \           else {\n                if (ones > zeros) {\n                    max
    = i;\n                }\n                else {\n                    max = i;\n
    \               }\n            }\n        }\n        List<long> result = new List<long>();\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                result.Add(i);\n
    \           }\n            else if (i == 0L) {\n                result.Add(i);\n
    \           }\n            else {\n                if (ones > zeros) {\n                    result.Add(i);\n
    \               }\n                else {\n                    result.Add(max);\n
    \               }\n            }\n        }\n        return result;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <2ca6552433fb431d9ee8c580acf45ebd>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <2ca6552433fb431d9ee8c580acf45ebd>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesOnesZeros = maxOnesOnes - maxZeros;\n
    \       long maxOnesOnesOnes = maxOnesOnes - ones;\n        long maxOnesOnesOnesZeros
    = maxOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnes = maxOnesOnesOnes
    - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnes - maxZeros;\n
    \       long maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnes - ones;\n        long
    maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesZeros - maxZeros;\n        long
    maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnesOnes =
    maxOnesOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnes
    = maxOnesOnesOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes
    = maxOnesOnesOnesOnesOnesOnesOnesZeros - ones;\n        long maxOnesOnesOnesOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnes\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp0pfqudoy.cs(40,72): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long num in arr) {\n            if (num
    == 1) ones++;\n            else if (num == 0) zeros++;\n            else if (num
    > max) max = num;\n            else if (num < min) min = num;\n        }\n        long
    onesMax = ones * max;\n        long onesMin = ones * min;\n        long zerosMax
    = zeros * max;\n        long zerosMin = zeros * min;\n        long maxOnesMax
    = onesMax * max;\n        long maxOnesMin = onesMax * min;\n        long minOnesMax
    = onesMin * max;\n        long minOnesMin = onesMin * min;\n        long maxZerosMax
    = zerosMax * max;\n        long maxZerosMin = zerosMax * min;\n        long minZerosMax
    = zerosMin * max;\n        long minZerosMin = zerosMin * min;\n        long maxOnesMaxZerosMax
    = onesMax * zerosMax * max;\n        long maxOnesMaxZerosMin = onesMax * zerosMax
    * min;\n        long minOnesMaxZerosMax = onesMin * zerosMax * max;\n        long
    minOnesMaxZerosMin = onesMin * zerosMax * min;\n        long maxOnesMinZerosMax
    = onesMax * onesMin * max;\n        long maxOnesMinZerosMin = onesMax * onesMin
    * min;\n        long minOnesMaxZerosMaxZerosMax = onesMin * zerosMax * zerosMax
    * max;\n        long minOnesMaxZerosMinZerosMax = onesMin * zerosMax * zerosMax
    * min;\n        long maxOnesMinZerosMaxZerosMin = onesMax * onesMin * zerosMax
    * max;\n        long maxOnesMinZerosMinZerosMax = onesMax * onesMin * zerosMax
    * min;\n        long minOnesMaxZerosMaxZerosMinZerosMax = onesMin * onesMax *
    zerosMax * zerosMax * max;\n        long minOnesMaxZerosMinZerosMin\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp1bljpwwd.cs(53,40): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones > zeros) {\n            arr.Sort((x, y) => Compare(ones,
    zeros, x, y));\n        } else {\n            arr.Sort((x, y) => Compare(zeros,
    ones, x, y));\n        }\n        return arr;\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpslptcm5p.cs(23,32): error CS0103: The name ''Compare'' does not exist
    in the current context

    /tmp/tmpslptcm5p.cs(25,32): error CS0103: The name ''Compare'' does not exist
    in the current context

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones > zeros ? ones : zeros;\n        long zerosMax = zeros
    > ones ? zeros : ones;\n        long onesMin = ones < zeros ? ones : zeros;\n
    \       long zerosMin = zeros < ones ? zeros : ones;\n        long onesAvg = (ones
    + zeros) / 2;\n        long zerosAvg = (zeros + ones) / 2;\n        long onesDev
    = Math.Sqrt(Math.Pow(onesAvg, 2) - Math.Pow(ones, 2));\n        long zerosDev
    = Math.Sqrt(Math.Pow(zerosAvg, 2) - Math.Pow(zeros, 2));\n        long onesDeviation
    = (onesDev > zerosDev) ? onesDev : zerosDev;\n        long zerosDeviation = (zerosDev
    > onesDev) ? zerosDev : onesDev;\n        long onesDeviationMin = onesDev < zerosDev
    ? onesDev : zerosDev;\n        long zerosDeviationMin = zerosDev < onesDev ? zerosDev
    : onesDev;\n        long onesDeviationMax = onesDev > zerosDev ? onesDev : zerosDev;\n
    \       long zerosDeviationMax = zerosDev > onesDev ? zerosDev : onesDev;\n        long
    onesDeviationAvg = (onesDev + zerosDev) / 2;\n        long zerosDeviationAvg =
    (zerosDev + onesDev) / 2;\n        long onesDeviationDev = Math.Sqrt(Math.Pow(onesDeviationAvg,
    2) - Math.Pow(onesAvg, 2));\n        long zerosDeviationDev = Math.Sqrt(Math.Pow(zerosDeviationAvg,
    2) - Math.Pow(zerosAvg, 2));\n        long onesDeviationDeviation = (onesDeviationDev
    > zerosDeviationDev) ? onesDeviationDev : zerosDeviationDev;\n        long zerosDeviationDeviation
    = (zerosDeviationDev > onesDeviationDev) ? zerosDeviationDev : onesDeviationDev;\n
    \       long onesDevi\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpass67svo.cs(54,22): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones;\n        long zerosMax = zeros;\n        long maxMax
    = max;\n        long onesMin = ones;\n        long zerosMin = zeros;\n        long
    maxMin = max;\n        long onesCurr = ones;\n        long zerosCurr = zeros;\n
    \       long maxCurr = max;\n        long onesNext = ones;\n        long zerosNext
    = zeros;\n        long maxNext = max;\n        long onesPrev = ones;\n        long
    zerosPrev = zeros;\n        long maxPrev = max;\n        long onesCurrPrev = ones;\n
    \       long zerosCurrPrev = zeros;\n        long maxCurrPrev = max;\n        long
    onesNextPrev = ones;\n        long zerosNextPrev = zeros;\n        long maxNextPrev
    = max;\n        long onesPrevPrev = ones;\n        long zerosPrevPrev = zeros;\n
    \       long maxPrevPrev = max;\n        long onesNextPrev = ones;\n        long
    zerosNextPrev = zeros;\n        long maxNextPrev = max;\n        long onesPrevPrev
    = ones;\n        long zerosPrevPrev = zeros;\n        long maxPrevPrev = max;\n
    \       long onesNextPrev = ones;\n        long zerosNextPrev = zeros;\n        long
    maxNextPrev = max;\n        long onesPrevPrev = ones;\n        long zerosPrevPrev
    = zeros;\n        long maxPrevPrev = max;\n        long onesNextPrev = ones;\n
    \       long zerosNextPrev = zeros;\n        long maxNextPrev = max;\n        long
    onesPrevPrev = ones;\n        long zerosPrevPrev = zeros;\n        long maxPrevPrev
    = max;\n        long onesNextPrev = ones;\n        long zerosNextPrev = zeros;\n
    \       long maxNextPrev = max;\n        long onesPrevPrev = ones;\n        long
    zerosPrevPrev = zeros;\n        long maxPrevPrev = max;\n        long onesNextPrev
    = ones;\n        long zerosNextPrev = \n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpznczub30.cs(83,29): error CS1525: Invalid expression term ''}''

    /tmp/tmpznczub30.cs(83,29): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           } else if (i == 0L) {\n                zeros++;\n            } else
    {\n                max = Math.Max(max, i);\n            }\n        }\n        long
    onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long maxDiff
    = onesMax - zerosMax;\n        long maxDiffIndex = Array.IndexOf(arr.ToArray(),
    maxDiff);\n        long onesDiff = arr[maxDiffIndex] - arr[maxDiffIndex - 1];\n
    \       long zerosDiff = arr[maxDiffIndex - 1] - arr[maxDiffIndex];\n        long
    onesDiffIndex = Array.IndexOf(arr.ToArray(), onesDiff);\n        long zerosDiffIndex
    = Array.IndexOf(arr.ToArray(), zerosDiff);\n        long onesDiffIndex2 = Array.IndexOf(arr.ToArray(),
    onesDiff);\n        long zerosDiffIndex2 = Array.IndexOf(arr.ToArray(), zerosDiff);\n
    \       long onesDiffIndex3 = Array.IndexOf(arr.ToArray(), onesDiff);\n        long
    zerosDiffIndex3 = Array.IndexOf(arr.ToArray(), zerosDiff);\n        long onesDiffIndex4
    = Array.IndexOf(arr.ToArray(), onesDiff);\n        long zerosDiffIndex4 = Array.IndexOf(arr.ToArray(),
    zerosDiff);\n        long onesDiffIndex5 = Array.IndexOf(arr.ToArray(), onesDiff);\n
    \       long zerosDiffIndex5 = Array.IndexOf(arr.ToArray(), zerosDiff);\n        long
    onesDiffIndex6 = Array.IndexOf(arr.ToArray(), onesDiff);\n        long zerosDiffIndex6
    = Array.IndexOf(arr.ToArray(), zerosDiff);\n        long onesDiffIndex7 = Array.IndexOf(arr.ToArray(),
    onesDiff);\n        long zerosDiffIndex7 = Array.IndexOf(arr.ToArray(), zerosDiff);\n
    \       long onesDiffIndex8 = Array.IndexOf(arr.ToArray(), onesDiff);\n        long
    zerosDiffIndex8 = Array.IndexOf(arr.ToArray(), zerosDiff);\n        long onesDiffIndex9
    = Array.IndexOf(arr.ToArray(), onesDiff);\n        long zerosDiffIndex9 = Array.IndexOf(arr.ToArray(),
    zerosDiff);\n        long onesDiffIndex10 = Array.IndexOf(arr.ToArray(), onesDiff);\n
    \       long zerosDiffIndex10 = Array.IndexOf(arr.ToArray(), zerosDiff);\n        long
    onesDiffIndex11 = Array.IndexOf(arr.To\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp1ku723tr.cs(58,52): error CS1026: ) expected

    /tmp/tmp1ku723tr.cs(58,52): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long maxOnes
    = 0;\n        long maxZeros = 0;\n        long maxOnesCount = 0;\n        long
    maxZerosCount = 0;\n        long maxOnesCount2 = 0;\n        long maxZerosCount2
    = 0;\n        foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \               if (maxOnesCount < ones) {\n                    maxOnesCount =
    ones;\n                }\n                if (maxOnesCount2 < ones) {\n                    maxOnesCount2
    = ones;\n                }\n                if (maxOnes < ones) {\n                    maxOnes
    = ones;\n                }\n            } else {\n                zeros++;\n                if
    (maxZerosCount < zeros) {\n                    maxZerosCount = zeros;\n                }\n
    \               if (maxZerosCount2 < zeros) {\n                    maxZerosCount2
    = zeros;\n                }\n                if (maxZeros < zeros) {\n                    maxZeros
    = zeros;\n                }\n            }\n        }\n        List<long> result
    = new List<long>();\n        long onesCount = 0;\n        long zerosCount = 0;\n
    \       long maxOnesCount3 = 0;\n        long maxZerosCount3 = 0;\n        long
    maxOnesCount4 = 0;\n        long maxZerosCount4 = 0;\n        foreach (long i
    in arr) {\n            if (i == 1L) {\n                onesCount++;\n                if
    (maxOnesCount3 < onesCount) {\n                    maxOnesCount3 = onesCount;\n
    \               }\n                if (maxOnesCount4 < onesCount) {\n                    maxOnesCount4
    = onesCount;\n                }\n                if (maxOnes < onesCount) {\n
    \                   maxOnes = onesCount;\n                }\n            } else
    {\n                zerosCount++;\n                if (maxZerosCount3 < zerosCount)
    {\n                    maxZerosCount3 = zerosCount;\n                }\n                if
    (maxZerosCount4 < zerosCount) {\n                    maxZerosCount4 = zerosCount;\n
    \               }\n                if (maxZeros < zerosCount) {\n                    maxZeros
    = zerosCount;\n                }\n            }\n        }\n        long onesCount2
    = 0;\n        long zerosCount2 = 0;\n        long maxOnesCount5 = 0;\n        long
    maxZerosCount5 = 0;\n        long maxOnesCount6 = 0;\n        long maxZerosCount6
    = 0;\n        foreach (long i in arr) {\n            if (i == 1L) {\n                onesCount2++;\n
    \               if (maxOnesCount5 < onesCount2) {\n                    maxOnesCount5
    = onesCount2;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp9oufhejj.cs(97,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp9oufhejj.cs(108,2): error CS1513: } expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x >> 1);\n        if (ones > zeros) {\n            return arr.OrderBy(x =>
    Convert.ToInt32(Math.Floor(Math.Log10(x / ones))));\n        } else {\n            return
    arr.OrderBy(x => Convert.ToInt32(Math.Floor(Math.Log10(x / zeros))));\n        }\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpw9nrwoeu.cs(23,20): error CS0266: Cannot implicitly convert type ''System.Linq.IOrderedEnumerable<long>''
    to ''System.Collections.Generic.List<long>''. An explicit conversion exists (are
    you missing a cast?)

    /tmp/tmpw9nrwoeu.cs(25,20): error CS0266: Cannot implicitly convert type ''System.Linq.IOrderedEnumerable<long>''
    to ''System.Collections.Generic.List<long>''. An explicit conversion exists (are
    you missing a cast?)

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesOnesZeros = maxOnesOnes - maxZeros;\n
    \       long maxOnesOnesOnes = maxOnesOnes - ones;\n        long maxOnesOnesOnesZeros
    = maxOnesOnesOnes - maxZeros;\n        long maxOnesOnesOnesOnes = maxOnesOnesOnes
    - ones;\n        long maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnes - maxZeros;\n
    \       long maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnes - ones;\n        long
    maxOnesOnesOnesOnesZeros = maxOnesOnesOnesOnesZeros - maxZeros;\n        long
    maxOnesOnesOnesOnesOnes = maxOnesOnesOnesOnesOnes - ones;\n        long maxOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesZeros - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnes
    = maxOnesOnesOnesOnesOnesOnes - ones;\n        long maxOnesOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnesZeros - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnes
    = maxOnesOnesOnesOnesOnesOnesOnes - ones;\n        long maxOnesOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnesZeros - maxZeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes
    = maxOnesOnesOnesOnesOnesOnesOnesOnes - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros
    = maxOnesOnesOnesOnesOnesOnes\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp0liv2kic.cs(40,76): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        if (ones == 0) return
    arr;\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = ones;\n
    \       long maxZeros = zeros;\n        long maxOnesCount = 0;\n        long maxZerosCount
    = 0;\n        long maxOnesCount2 = 0;\n        long maxZerosCount2 = 0;\n        long
    maxOnesCount3 = 0;\n        long maxZerosCount3 = 0;\n        long maxOnesCount4
    = 0;\n        long maxZerosCount4 = 0;\n        long maxOnesCount5 = 0;\n        long
    maxZerosCount5 = 0;\n        long maxOnesCount6 = 0;\n        long maxZerosCount6
    = 0;\n        long maxOnesCount7 = 0;\n        long maxZerosCount7 = 0;\n        long
    maxOnesCount8 = 0;\n        long maxZerosCount8 = 0;\n        long maxOnesCount9
    = 0;\n        long maxZerosCount9 = 0;\n        long maxOnesCount10 = 0;\n        long
    maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n        long maxZerosCount11
    = 0;\n        long maxOnesCount12 = 0;\n        long maxZerosCount12 = 0;\n        long
    maxOnesCount13 = 0;\n        long maxZerosCount13 = 0;\n        long maxOnesCount14
    = 0;\n        long maxZerosCount14 = 0;\n        long maxOnesCount15 = 0;\n        long
    maxZerosCount15 = 0;\n        long maxOnesCount16 = 0;\n        long maxZerosCount16
    = 0;\n        long maxOnesCount17 = 0;\n        long maxZerosCount17 = 0;\n        long
    maxOnesCount18 = 0;\n        long maxZerosCount18 = 0;\n        long maxOnesCount19
    = 0;\n        long maxZerosCount19 = 0;\n        long maxOnesCount20 = 0;\n        long
    maxZerosCount20 = 0;\n        long maxOnesCount21 = 0;\n        long maxZerosCount21
    = 0;\n        long maxOnesCount22 = 0;\n        long maxZerosCount22 = 0;\n        long
    maxOnesCount23 = 0;\n        long maxZerosCount23 = 0;\n        long maxOnesCount24
    = 0;\n        long maxZerosCount24 = 0;\n        long maxOnesCount25 = 0;\n        long
    max\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpni1rwqjl.cs(74,17): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: -1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            long
    onesMax = ones;\n            long zerosMax = zeros;\n            while (onesMax
    > zerosMax) {\n                result.Add(max);\n                zerosMax--;\n
    \           }\n            while (zerosMax > onesMax) {\n                result.Add(max);\n
    \               onesMax--;\n            }\n        }\n        else {\n            long
    zerosMax = zeros;\n            long onesMax = ones;\n            while (zerosMax
    > onesMax) {\n                result.Add(max);\n                zerosMax--;\n
    \           }\n            while (onesMax > zerosMax) {\n                result.Add(max);\n
    \               onesMax--;\n            }\n        }\n        return result;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Timeout
  stderr: ''
  stdout: None
  timestamp: 1659823612
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMin = ones * min - onesMax;\n        long zerosMin = zeros * min - zerosMax;\n
    \       long onesDiff = onesMax - onesMin;\n        long zerosDiff = zerosMax
    - zerosMin;\n        long onesDiffMin = onesMin + onesDiff;\n        long zerosDiffMin
    = zerosMin + zerosDiff;\n        long onesDiffMax = onesMax - onesDiff;\n        long
    zerosDiffMax = zerosMax - zerosDiff;\n        long onesDiffMinMax = onesDiffMin
    + onesDiffMax;\n        long zerosDiffMinMax = zerosDiffMin + zerosDiffMax;\n
    \       long onesDiffMinMaxMin = onesDiffMinMax + onesDiffMin;\n        long zerosDiffMinMaxMin
    = zerosDiffMinMax + zerosDiffMin;\n        long onesDiffMinMaxMinMinMin = onesDiffMinMaxMin
    + onesDiffMinMin;\n        long zerosDiffMinMaxMinMinMin = zerosDiffMinMaxMin
    + zerosDiffMinMin;\n        long onesDiffMinMaxMinMinMinMin = onesDiffMinMaxMinMin
    + onesDiffMinMinMin;\n        long zerosDiffMinMaxMinMinMin = zerosDiffMinMaxMinMin
    + zerosDiffMinMinMin;\n        long onesDiffMinMaxMinMinMinMin = onesDiffMinMaxMinMin
    + onesDiffMinMinMin;\n        long zerosDiffMinMaxMinMinMin = zerosDiffMinMaxMinMin
    + zerosDiffMinMinMin;\n        long onesDiffMinMaxMinMinMinMin = onesDiffMinMaxMinMin
    + onesDiffMinMinMin;\n        long zerosDiffMinMaxMinMinMin = zerosDiffMinMaxMinMin
    + zerosDiffMinMinMin;\n        long onesDiffMinMaxMinMinMinMin = onesDiffMinMaxMinMin
    + onesDiffMinMinMin;\n        long zerosDiffMinMaxMinMinMin = zerosDiffMin\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpuepog4xc.cs(57,53): error CS1002: ; expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long tens = 0;\n        long hundreds = 0;\n        long thousands = 0;\n
    \       long tenthousands = 0;\n        long hundredthousands = 0;\n        long
    millions = 0;\n        long billions = 0;\n        long trillions = 0;\n        long
    quadrillions = 0;\n        long quintillions = 0;\n        long sextillions =
    0;\n        long septillions = 0;\n        long octillions = 0;\n        long
    nonillions = 0;\n        long decillions = 0;\n        long undecillions = 0;\n
    \       long duodecillions = 0;\n        long tredecillions = 0;\n        long
    quattuordecillions = 0;\n        long quindecillions = 0;\n        long sexdecillions
    = 0;\n        long septendecillions = 0;\n        long octodecillions = 0;\n        long
    novemdecillions = 0;\n        long vigintillions = 0;\n        long unvigintillions
    = 0;\n        long duovigintillions = 0;\n        long trevigintillions = 0;\n
    \       long quattuorvigintillions = 0;\n        long quinvigintillions = 0;\n
    \       long sexvigintillions = 0;\n        long septenvigintillions = 0;\n        long
    octovigintillions = 0;\n        long novemvigintillions = 0;\n        long vigintillions
    = 0;\n        long unvigintillions = 0;\n        long duovigintillions = 0;\n
    \       long trevigintillions = 0;\n        long quattuorvigintillions = 0;\n
    \       long quinvigintillions = 0;\n        long sexvigintillions = 0;\n        long
    septenvigintillions = 0;\n        long octovigintillions = 0;\n        long novemvigintillions
    = 0;\n        long vigintillions = 0;\n        long unvigintillions = 0;\n        long
    duovigintillions = 0;\n        long trevigintillions = 0;\n        long quattuorvigintillions
    = 0;\n        long quinvigintillions = 0;\n        long sexvigintillions = 0;\n
    \       long septenvigintillions = 0;\n        long octovigintillions = 0;\n\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp03_qiaxj.cs(56,14): error CS0128: A local variable or function named ''vigintillions''
    is already defined in this scope

    /tmp/tmp03_qiaxj.cs(57,14): error CS0128: A local variable or function named ''unvigintillions''
    is already defined in this scope

    /tmp/tmp03_qiaxj.cs(58,14): error CS0128: A local variable or function named ''duovigintillions''
    is already defined in this scope

    /tmp/tmp03_qiaxj.cs(59,14): error CS0128: A local variable or function named ''trevigintillions''
    is already defined in this scope

    /tmp/tmp03_qiaxj.cs(60,14): error CS0128: A local variable or function named ''quattuorvigintillions''
    is already defined in this scope

    /tmp/tmp03_qiaxj.cs(61,14): error CS0128: A local variable or function named ''quinvigintillions''
    is already defined in this scope

    /tmp/tmp03_qiaxj.cs(62,14): error CS0128: A local variable or function named ''sexvigintillions''
    is already defined in this scope

    /tmp/tmp03_qiaxj.cs(63,14): error CS0128: A local variable or function named ''septenvigintillions''
    is already defined in this scope

    /tmp/tmp03_qiaxj.cs(64,14): error CS0128: A local variable or function named ''octovigintillions''
    is already defined in this scope

    /tmp/tmp03_qiaxj.cs(65,14): error CS0128: A local variable or function named ''novemvigintillions''
    is already defined in this scope

    /tmp/tmp03_qiaxj.cs(66,14): error CS0128: A local variable or function named ''vigintillions''
    is already defined in this scope

    /tmp/tmp03_qiaxj.cs(67,14): error CS0128: A local variable or function named ''unvigintillions''
    is already defined in this scope

    /tmp/tmp03_qiaxj.cs(68,14): error CS0128: A local variable or function named ''duovigintillions''
    is already defined in this scope

    /tmp/tmp03_qiaxj.cs(69,14): error CS0128: A local variable or function named ''trevigintillions''
    is already defined in this scope

    /tmp/tmp03_qiaxj.cs(70,14): error CS0128: A local variable or function named ''quattuorvigintillions''
    is already'
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long max = Math.Max(ones, zeros);\n        long min = Math.Min(ones,
    zeros);\n        long diff = max - min;\n        if (diff == 0) {\n            return
    arr;\n        }\n        List<long> result = new List<long>();\n        long onesCount
    = 0;\n        long zerosCount = 0;\n        long maxCount = 0;\n        long minCount
    = 0;\n        long diffCount = 0;\n        foreach (long x in arr) {\n            long
    count = x & 1L;\n            if (count == 1L) {\n                onesCount++;\n
    \               if (onesCount > maxCount) {\n                    maxCount = onesCount;\n
    \               }\n                if (onesCount < minCount) {\n                    minCount
    = onesCount;\n                }\n                if (onesCount > diffCount) {\n
    \                   diffCount = onesCount;\n                }\n            }\n
    \           count = x & 0L;\n            if (count == 0L) {\n                zerosCount++;\n
    \               if (zerosCount > maxCount) {\n                    maxCount = zerosCount;\n
    \               }\n                if (zerosCount < minCount) {\n                    minCount
    = zerosCount;\n                }\n                if (zerosCount > diffCount)
    {\n                    diffCount = zerosCount;\n                }\n            }\n
    \       }\n        long onesDiff = onesCount - maxCount;\n        long zerosDiff
    = zerosCount - maxCount;\n        long maxDiff = maxCount - minCount;\n        long
    minDiff = minCount - minCount;\n        long diffDiff = diffCount - minCount;\n
    \       if (onesDiff == 0) {\n            if (zerosDiff == 0) {\n                if
    (maxDiff == 0) {\n                    if (minDiff == 0) {\n                        if
    (diffDiff == 0) {\n                            result.AddRange(arr.OrderBy(x =>
    x).ToList());\n                        }\n                        else {\n                            result.AddRange(arr.OrderByDescending(x
    => x).ToList());\n                        }\n                    }\n                    else
    {\n                        result.AddRange(arr.OrderByDescending(x => x / diff).ToList());\n
    \                   }\n                }\n                else {\n                    result.AddRange(arr.OrderByDescending(x
    => x / maxDiff).ToList());\n                }\n            }\n            else
    {\n                result.AddRange(arr.OrderByDescending(x => x / minDiff).ToList());\n
    \           }\n        }\n        else {\n            if (zerosDiff == 0) {\n
    \               if (maxDiff == 0) {\n                    if (minDiff == 0) {\n
    \                       if (\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp5ezlcc0a.cs(94,29): error CS1525: Invalid expression term ''}''

    /tmp/tmp5ezlcc0a.cs(94,29): error CS1026: ) expected

    /tmp/tmp5ezlcc0a.cs(94,29): error CS1002: ; expected

    /tmp/tmp5ezlcc0a.cs(96,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp5ezlcc0a.cs(107,2): error CS1513: } expected

    '
  timestamp: 1659823606
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        if (ones == 0) return
    arr;\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = ones;\n
    \       long maxZeros = zeros;\n        long maxDiff = maxOnes - maxZeros;\n        long
    minDiff = maxZeros - maxOnes;\n        long diff;\n        long temp;\n        bool
    swap;\n        do {\n            swap = false;\n            diff = maxDiff - minDiff;\n
    \           temp = maxOnes;\n            maxOnes = maxZeros;\n            maxZeros
    = temp;\n            minDiff = maxDiff - minDiff;\n            diff--;\n            while
    (diff > 0) {\n                temp = arr[minDiff];\n                arr[minDiff]
    = arr[diff];\n                arr[diff] = temp;\n                swap = true;\n
    \               minDiff--;\n                diff--;\n            }\n        }
    while (swap);\n        return arr;\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp17vth2g_.cs(39,28): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmp17vth2g_.cs(40,21): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmp17vth2g_.cs(40,36): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    /tmp/tmp17vth2g_.cs(41,21): error CS1503: Argument 1: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long onesMin = ones * min;\n        long
    zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long maxOnes
    = ones * max;\n        long maxZeros = zeros * max;\n        long minOnes = ones
    * min;\n        long minZeros = zeros * min;\n        long maxOnesMax = onesMax
    * max;\n        long maxOnesMin = onesMin * max;\n        long maxZerosMax = zerosMax
    * max;\n        long maxZerosMin = zerosMin * max;\n        long minOnesMax =
    onesMax * min;\n        long minOnesMin = onesMin * min;\n        long minZerosMax
    = zerosMax * min;\n        long minZerosMin = zerosMin * min;\n        long onesMaxMin
    = onesMax * min;\n        long onesMinMax = onesMin * max;\n        long zerosMaxMin
    = zerosMax * min;\n        long zerosMinMax = zerosMin * max;\n        long onesMaxMinMax
    = onesMax * minMax;\n        long onesMinMaxMax = onesMin * maxMax;\n        long
    zerosMaxMinMax = zerosMax * minMax;\n        long zerosMinMaxMax = zerosMin *
    maxMax;\n        long onesMaxMinMaxMax = onesMax * minMaxMax;\n        long onesMinMaxMaxMax
    = onesMin * maxMaxMax;\n        long zerosMaxMinMaxMax = zerosMax * minMaxMax;\n
    \       long zerosMinMaxMaxMax = zerosMin * maxMaxMax;\n        long onesMaxMinMaxMaxMax
    = onesMax * minMaxMaxMax;\n        long onesMinMaxMaxMaxMax = onesMin * maxMaxMaxMax;\n
    \       long zerosMaxMinMaxMaxMax = zerosMax * minMaxMaxMax;\n        long zerosMin\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp6oegsh59.cs(69,22): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long tens = 0;\n        long hundreds = 0;\n        long thousands = 0;\n
    \       long tenThousands = 0;\n        long oneThousands = 0;\n        long oneHundreds
    = 0;\n        long oneThousandHundreds = 0;\n        long oneThousandThousands
    = 0;\n        long oneHundredThousands = 0;\n        long oneHundredThousandHundreds
    = 0;\n        long oneHundredThousandThousands = 0;\n        long oneThousandHundredThousands
    = 0;\n        long oneThousandThousandHundredThousands = 0;\n        long oneHundredThousandThousandHundredThousands
    = 0;\n        long oneHundredThousandHundredThousandHundredThousands = 0;\n        long
    oneThousandHundredThousandHundredThousandHundredThousands = 0;\n        long oneHundredThousandThousandHundredThousandHundredThousandHundredThousands
    = 0;\n        long oneHundredThousandHundredThousandHundredThousandHundredThousandHundredThousands
    = 0;\n        long oneThousandThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousands
    = 0;\n        long oneHundredThousandThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousands
    = 0;\n        long oneHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousands
    = 0;\n        long oneThousandThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousands
    = 0;\n        long oneHundredTh\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpvuala6dt.cs(44,26): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long maxOnes
    = 0;\n        long maxZeros = 0;\n        long maxOnesCount = 0;\n        long
    maxZerosCount = 0;\n        foreach (long i in arr) {\n            if (i == 1L)
    {\n                ones++;\n                if (maxOnesCount < ones) {\n                    maxOnesCount
    = ones;\n                }\n            }\n            if (i == 0L) {\n                zeros++;\n
    \               if (maxZerosCount < zeros) {\n                    maxZerosCount
    = zeros;\n                }\n            }\n        }\n        List<long> result
    = new List<long>();\n        foreach (long i in arr) {\n            if (i == 1L)
    {\n                result.Add(i);\n                if (maxOnesCount > ones) {\n
    \                   result.Add(maxOnesCount);\n                }\n                maxOnesCount
    = 0;\n                maxOnes = 0;\n            }\n            if (i == 0L) {\n
    \               result.Add(i);\n                if (maxZerosCount > zeros) {\n
    \                   result.Add(maxZerosCount);\n                }\n                maxZerosCount
    = 0;\n                maxZeros = 0;\n            }\n        }\n        return
    result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <08e2ff981de94a86aa3953bee7e8d5f9>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <08e2ff981de94a86aa3953bee7e8d5f9>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        if (ones == 0) {\n
    \           return arr;\n        }\n        long maxOnes = arr.Max(x => x & 1L);\n
    \       long maxOnesIndex = arr.FindIndex(x => x & 1L == maxOnes);\n        long
    maxOnesValue = (maxOnesIndex == arr.Count - 1) ? arr.Max() : arr[maxOnesIndex
    + 1];\n        long maxOnesValueIndex = arr.FindIndex(x => x & 1L == maxOnesValue);\n
    \       long maxOnesValueValue = (maxOnesValueIndex == arr.Count - 1) ? arr.Max()
    : arr[maxOnesValueIndex + 1];\n        long maxOnesValueValueIndex = arr.FindIndex(x
    => x & 1L == maxOnesValueValue);\n        long maxOnesValueValueValue = (maxOnesValueValueIndex
    == arr.Count - 1) ? arr.Max() : arr[maxOnesValueValueIndex + 1];\n        long
    maxOnesValueValueValueIndex = arr.FindIndex(x => x & 1L == maxOnesValueValueValue);\n
    \       long maxOnesValueValueValueValue = (maxOnesValueValueValueIndex == arr.Count
    - 1) ? arr.Max() : arr[maxOnesValueValueValueIndex + 1];\n        long maxOnesValueValueValueValueIndex
    = arr.FindIndex(x => x & 1L == maxOnesValueValueValueValue);\n        long maxOnesValueValueValueValue
    = (maxOnesValueValueValueIndex == arr.Count - 1) ? arr.Max() : arr[maxOnesValueValueValueIndex
    + 1];\n        long maxOnesValueValueValueValueIndex = arr.FindIndex(x => x &
    1L == maxOnesValueValueValueValue);\n        long maxOnesValueValueValueValue
    = (maxOnesValueValueValueIndex == arr.Count - 1) ? arr.Max() : arr[maxOnesValueValueValueIndex
    + 1];\n        long maxOnesValueValueValueValueIndex = arr.FindIndex(x => x &
    1L == maxOnesValueValueValueValue);\n        long maxOnesValueValueValueValue
    = (maxOnesValueValueValueIndex == arr.Count - 1) ? arr.Max() : arr[maxOnesValueValueValueIndex
    + 1];\n        long maxOnesValueValueValueValueIndex = arr.FindIndex(x => x &
    1L == maxOnesValueValueValueValue);\n        long maxOnesValueValueValueValue
    = (maxOnesValueValueValueIndex == arr.Count - 1) ? arr.Max\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpsw32yfty.cs(40,100): error CS1003: Syntax error, '':'' expected

    /tmp/tmpsw32yfty.cs(40,100): error CS1525: Invalid expression term ''}''

    /tmp/tmpsw32yfty.cs(40,100): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           } else if (i == 0L) {\n                zeros++;\n            } else
    {\n                if (ones > zeros) {\n                    max = i;\n                }
    else if (ones < zeros) {\n                    max = -i;\n                }\n            }\n
    \       }\n        List<long> result = new List<long>();\n        if (ones > zeros)
    {\n            foreach (long i in arr) {\n                if (i == 1L) {\n                    result.Add(i);\n
    \               } else if (i == 0L) {\n                    result.Add(-i);\n                }
    else if (i == max) {\n                    result.Add(max);\n                }
    else {\n                    result.Add(i);\n                }\n            }\n
    \       } else if (ones < zeros) {\n            foreach (long i in arr) {\n                if
    (i == 1L) {\n                    result.Add(-i);\n                } else if (i
    == 0L) {\n                    result.Add(i);\n                } else if (i ==
    max) {\n                    result.Add(-max);\n                } else {\n                    result.Add(-i);\n
    \               }\n            }\n        }\n        return result;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <096f341d18c3461ea8c6927d6323f852>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <096f341d18c3461ea8c6927d6323f852>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        if (ones == 0)\n            return
    arr;\n        long zeros = arr.Sum(x => x & 0L);\n        long maxOnes = ones;\n
    \       long maxZeros = zeros;\n        long maxDiff = maxOnes - maxZeros;\n        long
    minOnes = maxOnes - 1L;\n        long minZeros = maxZeros - 1L;\n        long
    minDiff = minOnes - minZeros;\n        long diff = maxDiff - minDiff;\n        long
    maxDiffIndex = arr.FindIndex(x => x > maxDiff);\n        long minDiffIndex = arr.FindIndex(x
    => x < minDiff);\n        long maxOnesIndex = arr.FindIndex(x => x > maxOnes);\n
    \       long minOnesIndex = arr.FindIndex(x => x < minOnes);\n        long maxZerosIndex
    = arr.FindIndex(x => x > maxZeros);\n        long minZerosIndex = arr.FindIndex(x
    => x < minZeros);\n        long maxDiffIndex2 = arr.FindIndex(x => x > maxDiff);\n
    \       long minDiffIndex2 = arr.FindIndex(x => x < minDiff);\n        long maxOnesIndex2
    = arr.FindIndex(x => x > maxOnes);\n        long minOnesIndex2 = arr.FindIndex(x
    => x < minOnes);\n        long maxZerosIndex2 = arr.FindIndex(x => x > maxZeros);\n
    \       long minZerosIndex2 = arr.FindIndex(x => x < minZeros);\n        long
    maxDiffIndex3 = arr.FindIndex(x => x > maxDiff);\n        long minDiffIndex3 =
    arr.FindIndex(x => x < minDiff);\n        long maxOnesIndex3 = arr.FindIndex(x
    => x > maxOnes);\n        long minOnesIndex3 = arr.FindIndex(x => x < minOnes);\n
    \       long maxZerosIndex3 = arr.FindIndex(x => x > maxZeros);\n        long
    minZerosIndex3 = arr.FindIndex(x => x < minZeros);\n        long maxDiffIndex4
    = arr.FindIndex(x => x > maxDiff);\n        long minDiffIndex4 = arr.FindIndex(x
    => x < minDiff);\n        long maxOnesIndex4 = arr.FindIndex(x => x > maxOnes);\n
    \       long minOnesIndex4 = arr.FindIndex(x => x < minOnes);\n        long maxZerosIndex4
    = arr.FindIndex(x => x > maxZ\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmptp27u3zs.cs(53,58): error CS1026: ) expected

    /tmp/tmptp27u3zs.cs(53,58): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        if (arr.Count < 2)\n            return arr;\n        long ones
    = arr.Where(x => x == 1).Count();\n        long zeros = arr.Where(x => x == 0).Count();\n
    \       long maxOnes = arr.Where(x => x == 1).Max();\n        long maxZeros =
    arr.Where(x => x == 0).Max();\n        long maxOnesZeros = maxOnes - maxZeros;\n
    \       long maxOnesZeros_2 = maxOnesZeros >> 1;\n        long maxOnesZeros_3
    = maxOnesZeros >> 2;\n        long maxOnesZeros_4 = maxOnesZeros >> 3;\n        long
    maxOnesZeros_5 = maxOnesZeros >> 4;\n        long maxOnesZeros_6 = maxOnesZeros
    >> 5;\n        long maxOnesZeros_7 = maxOnesZeros >> 6;\n        long maxOnesZeros_8
    = maxOnesZeros >> 7;\n        long maxOnesZeros_9 = maxOnesZeros >> 8;\n        long
    maxOnesZeros_10 = maxOnesZeros >> 9;\n        long maxOnesZeros_11 = maxOnesZeros
    >> 10;\n        long maxOnesZeros_12 = maxOnesZeros >> 11;\n        long maxOnesZeros_13
    = maxOnesZeros >> 12;\n        long maxOnesZeros_14 = maxOnesZeros >> 13;\n        long
    maxOnesZeros_15 = maxOnesZeros >> 14;\n        long maxOnesZeros_16 = maxOnesZeros
    >> 15;\n        long maxOnesZeros_17 = maxOnesZeros >> 16;\n        long maxOnesZeros_18
    = maxOnesZeros >> 17;\n        long maxOnesZeros_19 = maxOnesZeros >> 18;\n        long
    maxOnesZeros_20 = maxOnesZeros >> 19;\n        long maxOnesZeros_21 = maxOnesZeros
    >> 20;\n        long maxOnesZeros_22 = maxOnesZeros >> 21;\n        long maxOnesZeros_23
    = maxOnesZeros >> 22;\n        long maxOnesZeros_24 = maxOnesZeros >> 23;\n        long
    maxOnesZeros_25 = maxOnesZeros >> 24;\n        long maxOnesZeros_26 = maxOnesZeros
    >> 25;\n        long maxOnesZero\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpubw3devk.cs(52,25): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMin = ones * min - 1;\n        long zerosMin = zeros * min - 1;\n        long
    onesMaxMin = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n        long
    onesMinMin = onesMin * min;\n        long zerosMinMin = zerosMin * min;\n        long
    onesMaxMinMin = onesMaxMin * min;\n        long zerosMaxMinMin = zerosMaxMin *
    min;\n        long onesMinMinMin = onesMinMin * min;\n        long zerosMinMinMin
    = zerosMinMin * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long
    zerosMaxMinMinMin = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin
    * min;\n        long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin
    = onesMaxMinMin * min;\n        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n
    \       long onesMinMinMinMin = onesMinMinMin * min;\n        long zerosMinMinMinMin
    = zerosMinMinMin * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n
    \       long zerosMaxMinMinMin = zerosMaxMinMin * min;\n        long onesMinMinMinMin
    = onesMinMinMin * min;\n        long zerosMinMinMinMin = zerosMinMinMin * min;\n
    \       long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin
    = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n
    \       long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin
    = onesMaxMinMin * min;\n        long zerosMaxMinMin\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpctsueop7.cs(63,28): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            else if (i == 0L) {\n                zeros++;\n            }\n
    \           else {\n                if (ones > zeros) {\n                    max
    = i;\n                }\n                else {\n                    max = zeros;\n
    \               }\n            }\n        }\n        List<long> result = new List<long>();\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                result.Add(i);\n
    \           }\n            else if (i == 0L) {\n                result.Add(max);\n
    \           }\n            else {\n                if (ones > zeros) {\n                    result.Add(i);\n
    \               }\n                else {\n                    result.Add(max);\n
    \               }\n            }\n        }\n        return result;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <6f83d4ce7c504acdb39aa8054970e114>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <6f83d4ce7c504acdb39aa8054970e114>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823605
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long maxOnes
    = 0;\n        long maxZeros = 0;\n        foreach (long i in arr) {\n            ones
    += i;\n            zeros += (long)Math.Abs(i);\n            if (i > maxOnes) maxOnes
    = i;\n            if (i < maxZeros) maxZeros = i;\n        }\n        List<long>
    result = new List<long>();\n        if (maxOnes == maxZeros) result.Add(maxOnes);\n
    \       else {\n            long onesDiff = maxOnes - maxZeros;\n            long
    zerosDiff = maxZeros - maxOnes;\n            if (onesDiff == zerosDiff) result.Add(maxOnes);\n
    \           else {\n                long onesDiffAbs = Math.Abs(onesDiff);\n                long
    zerosDiffAbs = Math.Abs(zerosDiff);\n                if (onesDiff > zerosDiff)
    result.Add(maxOnes);\n                else if (onesDiff < zerosDiff) result.Add(maxZeros);\n
    \               else {\n                    long onesDiffAbsMul = onesDiffAbs
    * onesDiffAbs;\n                    long zerosDiffAbsMul = zerosDiffAbs * zerosDiffAbs;\n
    \                   if (onesDiffAbsMul > zerosDiffAbsMul) result.Add(maxOnes);\n
    \                   else if (onesDiffAbsMul < zerosDiffAbsMul) result.Add(maxZeros);\n
    \                   else result.Add(maxOnes);\n                }\n            }\n
    \       }\n        return result;\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <0540ed8cd7924b30b99a083eb03b14b9>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <0540ed8cd7924b30b99a083eb03b14b9>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones;\n        long zerosMax = zeros;\n        long maxMax
    = max;\n        long onesMin = ones;\n        long zerosMin = zeros;\n        long
    maxMin = max;\n        long onesSum = 0;\n        long zerosSum = 0;\n        long
    maxSum = 0;\n        long onesAvg = 0;\n        long zerosAvg = 0;\n        long
    maxAvg = 0;\n        long onesSumAvg = 0;\n        long zerosSumAvg = 0;\n        long
    maxSumAvg = 0;\n        long onesAvgAvg = 0;\n        long zerosAvgAvg = 0;\n
    \       long maxAvgAvg = 0;\n        long onesSumAvgAvg = 0;\n        long zerosSumAvgAvg
    = 0;\n        long maxSumAvgAvg = 0;\n        long onesAvgAvgAvg = 0;\n        long
    zerosAvgAvgAvg = 0;\n        long maxAvgAvgAvg = 0;\n        long onesSumAvgAvgAvg
    = 0;\n        long zerosSumAvgAvgAvg = 0;\n        long maxSumAvgAvgAvg = 0;\n
    \       long onesAvgAvgAvg = 0;\n        long zerosAvgAvgAvg = 0;\n        long
    maxAvgAvgAvg = 0;\n        long onesSumAvgAvgAvg = 0;\n        long zerosSumAvgAvgAvg
    = 0;\n        long maxSumAvgAvgAvg = 0;\n        long onesAvgAvgAvg = 0;\n        long
    zerosAvgAvgAvg = 0;\n        long maxAvgAvgAvg = 0;\n        long onesSumAvgAvgAvg
    = 0;\n        long zerosSumAvgAvgAvg = 0;\n        long maxSumAvgAvgAvg = 0;\n
    \       long onesAvgAvgAvg = 0;\n        long zerosAvgAvgAvg = 0;\n        long
    maxAvgAvgAvg = 0;\n        long onesSumAvgAvgAvg = 0;\n        long zerosSumAvgAvgAvg
    = 0;\n        long maxSumAvgAvgAvg = 0;\n        long onesAvgAvgAvg = 0;\n        long
    zerosAvgAvgAvg = 0;\n        long maxAvgAvgAvg = 0;\n        long onesSumAvgAvgAvg
    = 0;\n        long zerosSumAvgAvgAvg = 0;\n        long maxSumAvgAvgAvg = 0;\n
    \       long onesAvgAvgAvg = 0;\n        long zerosAvgAvgAvg = 0;\n        long
    maxAvgAvgAvg = 0;\n        long onesSum\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp6ewaoakl.cs(88,21): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x >> 1);\n        if (ones == zeros) {\n            return arr.OrderBy(x =>
    x).ToList();\n        }\n        long maxOnes = arr.Max(x => x & 1L);\n        long
    maxZeros = arr.Max(x => x >> 1);\n        if (maxOnes == maxZeros) {\n            return
    arr.OrderBy(x => x).ToList();\n        }\n        long maxOnesCount = arr.Count(x
    => x & 1L);\n        long maxZerosCount = arr.Count(x => x >> 1);\n        if
    (maxOnesCount == maxZerosCount) {\n            return arr.OrderBy(x => x).ToList();\n
    \       }\n        long maxOnesCount2 = arr.Count(x => x & 1L);\n        long
    maxZerosCount2 = arr.Count(x => x >> 1);\n        if (maxOnesCount2 == maxZerosCount2)
    {\n            return arr.OrderBy(x => x).ToList();\n        }\n        long maxOnesCount3
    = arr.Count(x => x & 1L);\n        long maxZerosCount3 = arr.Count(x => x >> 1);\n
    \       if (maxOnesCount3 == maxZerosCount3) {\n            return arr.OrderBy(x
    => x).ToList();\n        }\n        long maxOnesCount4 = arr.Count(x => x & 1L);\n
    \       long maxZerosCount4 = arr.Count(x => x >> 1);\n        if (maxOnesCount4
    == maxZerosCount4) {\n            return arr.OrderBy(x => x).ToList();\n        }\n
    \       long maxOnesCount5 = arr.Count(x => x & 1L);\n        long maxZerosCount5
    = arr.Count(x => x >> 1);\n        if (maxOnesCount5 == maxZerosCount5) {\n            return
    arr.OrderBy(x => x).ToList();\n        }\n        long maxOnesCount6 = arr.Count(x
    => x & 1L);\n        long maxZerosCount6 = arr.Count(x => x >> 1);\n        if
    (maxOnesCount6 == maxZerosCount6) {\n            return arr.OrderBy(x => x).ToList();\n
    \       }\n        long maxOnesCount7 = arr.Count(x => x & 1L);\n        long
    maxZerosCount7 = arr.Count(x => x >> 1);\n        if (maxOnesCount7 == maxZerosCount7)
    {\n            return arr.OrderBy(x => x).To\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp4bvs_t3k.cs(63,42): error CS1002: ; expected

    /tmp/tmp4bvs_t3k.cs(65,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp4bvs_t3k.cs(76,2): error CS1513: } expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long n in arr) {\n            if (n == 1L) {\n                ones++;\n
    \           }\n            if (n == 0L) {\n                zeros++;\n            }\n
    \           if (n > max) {\n                max = n;\n            }\n        }\n
    \       long onesMax = ones == max ? max : ones;\n        long zerosMax = zeros
    == max ? max : zeros;\n        long onesMin = ones == max ? max : ones - 1;\n
    \       long zerosMin = zeros == max ? max : zeros - 1;\n        long onesMaxMin
    = onesMax == max ? max : onesMax;\n        long zerosMaxMin = zerosMax == max
    ? max : zerosMax;\n        long onesMinMin = onesMin == max ? max : onesMin;\n
    \       long zerosMinMin = zerosMin == max ? max : zerosMin;\n        long onesMaxMinMin
    = onesMaxMin == max ? max : onesMaxMin;\n        long zerosMaxMinMin = zerosMaxMin
    == max ? max : zerosMaxMin;\n        long onesMinMinMin = onesMinMin == max ?
    max : onesMinMin;\n        long zerosMinMinMin = zerosMinMin == max ? max : zerosMinMin;\n
    \       long onesMaxMinMinMin = onesMaxMinMin == max ? max : onesMaxMinMin;\n
    \       long zerosMaxMinMinMin = zerosMaxMinMin == max ? max : zerosMaxMinMin;\n
    \       long onesMinMinMinMin = onesMinMinMin == max ? max : onesMinMinMin;\n
    \       long zerosMinMinMinMin = zerosMinMinMin == max ? max : zerosMinMinMin;\n
    \       long onesMaxMinMinMinMin = onesMaxMinMinMin == max ? max : onesMaxMinMinMin;\n
    \       long zerosMaxMinMinMinMin = zerosMaxMinMinMin == max ? max : zerosMaxMinMinMin;\n
    \       long onesMinMinMinMinMin = onesMinMinMinMin == max ? max : onesMinMinMinMin;\n
    \       long zerosMinMinMinMin = zerosMinMinMinMin == max ? max : zerosMinMinMinMin;\n
    \       long onesMaxMinMinMinMin = onesMaxMinMinMinMin == max ? max : onesMax\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpa5v4icy6.cs(54,78): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesZeroOnes = maxOnesZeros - ones;\n
    \       long maxOnesOnesZeros = maxOnesOnes - ones;\n        long maxOnesZeroOnesOnes
    = maxOnesZeroOnes - ones;\n        long maxOnesZeroOnesZeros = maxOnesOnesZeros
    - zeros;\n        long maxOnesZeroOnesOnesZeros = maxOnesZeroOnesOnes - zeros;\n
    \       long maxOnesZeroOnesOnesOnesZeros = maxOnesZeroOnesZeros - ones;\n        long
    maxOnesZeroOnesZeroOnesOnesZeros = maxOnesZeroOnesOnesZeros - zeros;\n        long
    maxOnesZeroOnesZeroOnesZeroOnesOnes = maxOnesZeroOnesZeroOnesOnesZeros - ones;\n
    \       long maxOnesZeroOnesZeroOnesZeroOnesZeros = maxOnesZeroOnesZeroOnesOnesOnesZeros
    - zeros;\n        long maxOnesZeroOnesZeroOnesZeroOnesOnesZeros = maxOnesZeroOnesZeroOnesZeroOnesZeroOnesOnesZeros
    - ones;\n        long maxOnesZeroOnesZeroOnesZeroOnesZeroOnesOnes = maxOnesZeroOnesZeroOnesZeroOnesZeroOnesOnesZeros
    - zeros;\n        long maxOnesZeroOnesZeroOnesZeroOnesZeroOnesOnesZeros = maxOnesZeroOnesZeroOnesZeroOnesZeroOnesZeroOnesOnesZeros
    - ones;\n        long maxOnesZeroOnesZeroOnesZeroOnesZeroOnesZeroOnesOnes = maxOnesZeroOnesZeroOnesZeroOnesZeroOnesZeroOnesZeroOnesOnesZeros
    - zeros;\n        long maxOnesZeroOnesZeroOnesZeroOnesZeroOnesZeroOnesOnesZeros
    = maxOnesZeroOnes\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpeh4_zqv7.cs(39,88): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long maxOnes
    = 0;\n        long maxZeros = 0;\n        long max = 0;\n        foreach (long
    i in arr) {\n            if (i == 1L) {\n                ones++;\n                if
    (ones > maxOnes) maxOnes = ones;\n            } else {\n                zeros++;\n
    \               if (zeros > maxZeros) maxZeros = zeros;\n            }\n        }\n
    \       if (maxOnes > maxZeros) max = maxOnes;\n        else max = maxZeros;\n
    \       long onesCount = 0;\n        long zerosCount = 0;\n        long maxOnesCount
    = 0;\n        long maxZerosCount = 0;\n        long maxCount = 0;\n        foreach
    (long i in arr) {\n            if (i == 1L) {\n                onesCount++;\n
    \               if (onesCount > maxOnesCount) maxOnesCount = onesCount;\n            }
    else {\n                zerosCount++;\n                if (zerosCount > maxZerosCount)
    maxZerosCount = zerosCount;\n            }\n        }\n        if (maxOnesCount
    > maxZerosCount) maxCount = maxOnesCount;\n        else maxCount = maxZerosCount;\n
    \       long onesSum = 0;\n        long zerosSum = 0;\n        long maxOnesSum
    = 0;\n        long maxZerosSum = 0;\n        long maxSum = 0;\n        foreach
    (long i in arr) {\n            if (i == 1L) {\n                onesSum += i;\n
    \               if (onesSum > maxOnesSum) maxOnesSum = onesSum;\n            }
    else {\n                zerosSum += i;\n                if (zerosSum > maxZerosSum)
    maxZerosSum = zerosSum;\n            }\n        }\n        if (maxOnesSum > maxZerosSum)
    maxSum = maxOnesSum;\n        else maxSum = maxZerosSum;\n        long onesAvg
    = 0;\n        long zerosAvg = 0;\n        long maxOnesAvg = 0;\n        long maxZerosAvg
    = 0;\n        long maxAvg = 0;\n        foreach (long i in arr) {\n            if
    (i == 1L) {\n                onesAvg += i;\n                if (onesAvg > maxOnesAvg)
    maxOnesAvg = onesAvg;\n            } else {\n                zerosAvg += i;\n
    \               if (zerosAvg > maxZerosAvg) maxZerosAvg = zerosAvg;\n            }\n
    \       }\n        if (maxOnesAvg > maxZerosAvg) maxAvg = maxOnesAvg;\n        else
    maxAvg = \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp7yp27pg5.cs(83,22): error CS1525: Invalid expression term ''}''

    /tmp/tmp7yp27pg5.cs(83,22): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        if (ones == 0) return
    arr;\n        long zeros = arr.Sum(x => x & 0L);\n        if (zeros == 0) return
    arr;\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros = arr.Max(x
    => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long maxOnesOnes
    = maxOnes - ones;\n        long maxOnesZeroOnes = maxOnes - zeros;\n        long
    maxOnesOnesZeros = maxOnes - ones - zeros;\n        long maxOnesZeroOnesOnes =
    maxOnes - zeros - ones;\n        long maxOnesOnesZeroOnes = maxOnes - ones - zeros
    - ones;\n        long maxOnesZeroOnesOnesZeros = maxOnes - zeros - ones - zeros;\n
    \       long maxOnesOnesZeroOnesZeros = maxOnes - ones - zeros - ones - zeros;\n
    \       long maxOnesZeroOnesOnesZerosZeros = maxOnes - zeros - ones - zeros -
    ones - zeros;\n        long maxOnesOnesZeroOnesZerosZeros = maxOnes - ones - zeros
    - ones - zeros - ones - zeros;\n        long maxOnesZeroOnesOnesZerosZeros = maxOnes
    - zeros - ones - zeros - ones - zeros - ones - zeros;\n        long maxOnesOnesZeroOnesZerosZerosZeros
    = maxOnes - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones -
    zeros;\n        long maxOnesZeroOnesOnesZerosZerosZeros = maxOnes - zeros - ones
    - zeros - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones - zeros;\n
    \       long maxOnesOnesZeroOnesZerosZerosZerosZeros = maxOnes - ones - zeros
    - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones - zeros - ones
    - zeros - ones - zeros;\n        long maxOnesZeroOnesOnesZerosZerosZerosZerosZeros
    = maxOnes - zeros - ones - zeros - ones - zeros - ones - zeros - ones - zeros
    - ones - zeros - one\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpy5p4jqsv.cs(40,157): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1) {\n                ones++;\n            }\n            if (i == 0) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long onesMin = ones * min;\n        long
    zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long maxOnes
    = ones * max;\n        long maxZeros = zeros * max;\n        long minOnes = ones
    * min;\n        long minZeros = zeros * min;\n        long maxOnesMax = onesMax
    * max;\n        long maxOnesMin = onesMin * max;\n        long maxZerosMax = zerosMax
    * max;\n        long maxZerosMin = zerosMin * max;\n        long minOnesMax =
    onesMax * min;\n        long minOnesMin = onesMin * min;\n        long minZerosMax
    = zerosMax * min;\n        long minZerosMin = zerosMin * min;\n        long maxOnesMaxMin
    = onesMax * min * max;\n        long maxOnesMinMax = onesMin * min * max;\n        long
    maxZerosMaxMin = zerosMax * min * max;\n        long maxZerosMinMax = zerosMin
    * min * max;\n        long minOnesMaxMin = onesMax * min * min;\n        long
    minOnesMinMax = onesMin * min * min;\n        long minZerosMaxMin = zerosMax *
    min * min;\n        long minZerosMinMax = zerosMin * min * min;\n        long
    maxOnesMaxMinMin = onesMax * min * min * max;\n        long maxOnesMinMaxMin =
    onesMin * min * min * max;\n        long maxZerosMaxMin = zerosMax * min * min
    * max;\n        long maxZerosMinMax = zerosMin * min * min * max;\n        long
    minOnesMaxMinMin = onesMax * min * min * min;\n        long minOnesMinMaxMin =
    onesMin \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp9din1e3d.cs(67,40): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesTwos = maxOnes - twos;\n        long
    maxOnesThrees = maxOnes - threes;\n        long maxOnesFours = maxOnes - fours;\n
    \       long maxOnesFives = maxOnes - fives;\n        long maxOnesSixes = maxOnes
    - sixes;\n        long maxOnesSevens = maxOnes - sevens;\n        long maxOnesEights
    = maxOnes - eights;\n        long maxOnesNines = maxOnes - nines;\n        long
    maxOnesTens = maxOnes - tens;\n        long maxOnesElevens = maxOnes - elevens;\n
    \       long maxOnesTwelves = maxOnes - twelves;\n        long maxOnesThirteens
    = maxOnes - thirteens;\n        long maxOnesFourteens = maxOnes - fourteens;\n
    \       long maxOnesFifteens = maxOnes - fifteens;\n        long maxOnesSixteens
    = maxOnes - sixteens;\n        long maxOnesSeventeens = maxOnes - seventeens;\n
    \       long maxOnesEighteens = maxOnes - eighteens;\n        long maxOnesNineteens
    = maxOnes - nineteens;\n        long maxOnesTwenty = maxOnes - twenty;\n        long
    maxOnesThirty = maxOnes - thirty;\n        long maxOnesFourty = maxOnes - fourty;\n
    \       long maxOnesFifty = maxOnes - fifty;\n        long maxOnesSixty = maxOnes
    - sixty;\n        long maxOnesSeventy = maxOnes - seventy;\n        long maxOnesEighty
    = maxOnes - eighty;\n        long maxOnesNinety = maxOnes - ninety;\n        long
    maxOnesOne = maxOnes - one;\n        long maxOnesTwo = maxOnes - \n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpud40m3kv.cs(53,36): error CS1525: Invalid expression term ''}''

    /tmp/tmpud40m3kv.cs(53,36): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long n in arr) {\n            ones += n;\n            zeros +=
    (n != 0);\n            max = Math.Max(max, n);\n        }\n        List<long>
    result = new List<long>();\n        if (ones == 0) {\n            foreach (long
    n in arr) {\n                if (n != 0) {\n                    result.Add(n);\n
    \               }\n            }\n            return result;\n        }\n        long
    onesCount = 0;\n        long zerosCount = 0;\n        long maxCount = 0;\n        long
    maxOnes = 0;\n        long maxZeros = 0;\n        foreach (long n in arr) {\n
    \           onesCount += n;\n            zerosCount += (n != 0);\n            maxCount
    += n;\n            maxOnes = Math.Max(maxOnes, onesCount);\n            maxZeros
    = Math.Max(maxZeros, zerosCount);\n        }\n        long onesCount2 = onesCount;\n
    \       long zerosCount2 = zerosCount;\n        long maxCount2 = maxCount;\n        long
    maxOnes2 = maxOnes;\n        long maxZeros2 = maxZeros;\n        long maxCount3
    = maxCount2;\n        long maxOnes3 = maxOnes2;\n        long maxZeros3 = maxZeros2;\n
    \       long maxCount4 = maxCount3;\n        long maxOnes4 = maxOnes3;\n        long
    maxZeros4 = maxZeros3;\n        long maxCount5 = maxCount4;\n        long maxOnes5
    = maxOnes4;\n        long maxZeros5 = maxZeros4;\n        long maxCount6 = maxCount5;\n
    \       long maxOnes6 = maxOnes5;\n        long maxZeros6 = maxZeros5;\n        long
    maxCount7 = maxCount6;\n        long maxOnes7 = maxOnes6;\n        long maxZeros7
    = maxZeros6;\n        long maxCount8 = maxCount7;\n        long maxOnes8 = maxOnes7;\n
    \       long maxZeros8 = maxZeros7;\n        long maxCount9 = maxCount8;\n        long
    maxOnes9 = maxOnes8;\n        long maxZeros9 = maxZeros8;\n        long maxCount10
    = maxCount9;\n        long maxOnes10 = maxOnes9;\n        long maxZeros10 = maxZeros9;\n
    \       long maxCount11 = maxCount10;\n        long maxOnes11 = maxOnes10;\n        long
    maxZeros\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmps8z2ro9j.cs(80,22): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            } else if (i == 0L) {\n                zeros++;\n
    \           } else {\n                max = Math.Max(max, i);\n                min
    = Math.Min(min, i);\n            }\n        }\n        List<long> result = new
    List<long>();\n        if (ones > zeros) {\n            result.AddRange(arr.OrderBy(i
    => Convert.ToInt64(Math.Pow(2, Convert.ToInt64(Math.Log10(i))))));\n        }
    else {\n            result.AddRange(arr.OrderBy(i => Convert.ToInt64(Math.Pow(2,
    Convert.ToInt64(Math.Log10(i))))));\n        }\n        return result;\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <0423c9da2f024871966aca379fc13ada>:0
    \n\nUnhandled Exception:\nSystem.OverflowException: Arithmetic operation resulted
    in an overflow.\n  at (wrapper managed-to-native) System.Object.__icall_wrapper___emul_fconv_to_ovf_i8(double)\n
    \ at System.Convert.ToInt64 (System.Double value) [0x00006] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem+<>c.<SortArray>b__0_1 (System.Int64 i) [0x00010] in <0423c9da2f024871966aca379fc13ada>:0
    \n  at System.Linq.EnumerableSorter`2[TElement,TKey].ComputeKeys (TElement[] elements,
    System.Int32 count) [0x00010] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.EnumerableSorter`1[TElement].ComputeMap
    (TElement[] elements, System.Int32 count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0
    \n  at System.Linq.EnumerableSorter`1[TElement].Sort (TElement[] elements, System.Int32
    count) [0x00000] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Linq.OrderedEnumerable`1[TElement].SortedMap
    (System.Linq.Buffer`1[TElement] buffer) [0x00006] in <e540098dd111461e919c5863f6975c29>:0
    \n  at System.Linq.OrderedEnumerable`1+<GetEnumerator>d__3[TElement].MoveNext
    () [0x0003d] in <e540098dd111461e919c5863f6975c29>:0 \n  at System.Collections.Generic.List`1[T].AddEnumerable
    (System.Collections."
  stdout: ''
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x >> 1);\n        if (ones < zeros) {\n            long temp = ones;\n            ones
    = zeros;\n            zeros = temp;\n        }\n        long maxOnes = ones;\n
    \       long maxZeros = zeros;\n        long maxDiff = maxZeros - maxOnes;\n        long
    maxDiffIndex = arr.Count - 1;\n        long maxDiffIndex2 = arr.Count - 2;\n        long
    maxDiffIndex3 = arr.Count - 3;\n        long maxDiffIndex4 = arr.Count - 4;\n
    \       long maxDiffIndex5 = arr.Count - 5;\n        long maxDiffIndex6 = arr.Count
    - 6;\n        long maxDiffIndex7 = arr.Count - 7;\n        long maxDiffIndex8
    = arr.Count - 8;\n        long maxDiffIndex9 = arr.Count - 9;\n        long maxDiffIndex10
    = arr.Count - 10;\n        long maxDiffIndex11 = arr.Count - 11;\n        long
    maxDiffIndex12 = arr.Count - 12;\n        long maxDiffIndex13 = arr.Count - 13;\n
    \       long maxDiffIndex14 = arr.Count - 14;\n        long maxDiffIndex15 = arr.Count
    - 15;\n        long maxDiffIndex16 = arr.Count - 16;\n        long maxDiffIndex17
    = arr.Count - 17;\n        long maxDiffIndex18 = arr.Count - 18;\n        long
    maxDiffIndex19 = arr.Count - 19;\n        long maxDiffIndex20 = arr.Count - 20;\n
    \       long maxDiffIndex21 = arr.Count - 21;\n        long maxDiffIndex22 = arr.Count
    - 22;\n        long maxDiffIndex23 = arr.Count - 23;\n        long maxDiffIndex24
    = arr.Count - 24;\n        long maxDiffIndex25 = arr.Count - 25;\n        long
    maxDiffIndex26 = arr.Count - 26;\n        long maxDiffIndex27 = arr.Count - 27;\n
    \       long maxDiffIndex28 = arr.Count - 28;\n        long maxDiffIndex29 = arr.Count
    - 29;\n        long maxDiffIndex30 = arr.Count - 30;\n        long maxDiffIndex31
    = arr.Count - 31;\n        long maxDiffIndex32 = arr.Count - 32;\n        long
    maxDiffIndex33 = arr.Count - 33;\n        long maxDiffIndex34 = arr.Count - 34;\n
    \       long maxDiffIndex35 = arr.Count - 35;\n        long maxDiffIndex36\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpnnyrgi0s.cs(65,28): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long n in arr) {\n            if (n == 1L) {\n                ones++;\n
    \           }\n            if (n == 0L) {\n                zeros++;\n            }\n
    \           if (n > max) {\n                max = n;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            result.Add(max);\n
    \           result.AddRange(arr.Where(n => n == max).OrderBy(n => n).ToList());\n
    \       }\n        if (zeros > ones) {\n            result.AddRange(arr.Where(n
    => n == max).OrderByDescending(n => n).ToList());\n        }\n        return result;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <611ef63a32fa4d0cb20e35a6b169881e>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <611ef63a32fa4d0cb20e35a6b169881e>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long tens = 0;\n        long hundreds = 0;\n        long thousands = 0;\n
    \       long tenths = 0;\n        long hundredths = 0;\n        long thousandths
    = 0;\n        long tenthths = 0;\n        long hundredthths = 0;\n        long
    thousandthths = 0;\n        long tenthths = 0;\n        long hundredthths = 0;\n
    \       long thousandthths = 0;\n        long tenthths = 0;\n        long hundredthths
    = 0;\n        long thousandthths = 0;\n        long tenthths = 0;\n        long
    hundredthths = 0;\n        long thousandthths = 0;\n        long tenthths = 0;\n
    \       long hundredthths = 0;\n        long thousandthths = 0;\n        long
    tenthths = 0;\n        long hundredthths = 0;\n        long thousandths = 0;\n
    \       long tenthths = 0;\n        long hundredthths = 0;\n        long thousandths
    = 0;\n        long tenthths = 0;\n        long hundredthths = 0;\n        long
    thousandths = 0;\n        long tenthths = 0;\n        long hundredthths = 0;\n
    \       long thousandths = 0;\n        long tenthths = 0;\n        long hundredthths
    = 0;\n        long thousandths = 0;\n        long tenthths = 0;\n        long
    hundredthths = 0;\n        long thousandths = 0;\n        long tenthths = 0;\n
    \       long hundredthths = 0;\n        long thousandths = 0;\n        long tenthths
    = 0;\n        long hundredthths = 0;\n        long thousandths = 0;\n        long
    tenthths = 0;\n        long hundredthths = 0;\n        long thousandths = 0;\n
    \       long tenthths = 0;\n        long hundredthths = 0;\n        long thousandths
    = 0;\n        long tenthths = 0;\n        long hundredthths = 0;\n        long
    thousandths = 0;\n        long tenthths = 0;\n        long hundredthths = 0;\n
    \       long thousandths = 0;\n        long tenthths = 0;\n        long hundredthths
    = 0;\n        long thousandths = 0;\n        long tenthths = 0;\n        long
    hundredthths = 0;\n        long thousandths = 0;\n        long tenthths = 0;\n
    \       long hundredthths = 0;\n        long thousandths = 0;\n        long tenthths
    = 0;\n        long hundredthths = 0;\n\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpr7hwubgm.cs(31,14): error CS0128: A local variable or function named ''tenthths''
    is already defined in this scope

    /tmp/tmpr7hwubgm.cs(32,14): error CS0128: A local variable or function named ''hundredthths''
    is already defined in this scope

    /tmp/tmpr7hwubgm.cs(33,14): error CS0128: A local variable or function named ''thousandthths''
    is already defined in this scope

    /tmp/tmpr7hwubgm.cs(34,14): error CS0128: A local variable or function named ''tenthths''
    is already defined in this scope

    /tmp/tmpr7hwubgm.cs(35,14): error CS0128: A local variable or function named ''hundredthths''
    is already defined in this scope

    /tmp/tmpr7hwubgm.cs(36,14): error CS0128: A local variable or function named ''thousandthths''
    is already defined in this scope

    /tmp/tmpr7hwubgm.cs(37,14): error CS0128: A local variable or function named ''tenthths''
    is already defined in this scope

    /tmp/tmpr7hwubgm.cs(38,14): error CS0128: A local variable or function named ''hundredthths''
    is already defined in this scope

    /tmp/tmpr7hwubgm.cs(39,14): error CS0128: A local variable or function named ''thousandthths''
    is already defined in this scope

    /tmp/tmpr7hwubgm.cs(40,14): error CS0128: A local variable or function named ''tenthths''
    is already defined in this scope

    /tmp/tmpr7hwubgm.cs(41,14): error CS0128: A local variable or function named ''hundredthths''
    is already defined in this scope

    /tmp/tmpr7hwubgm.cs(42,14): error CS0128: A local variable or function named ''thousandthths''
    is already defined in this scope

    /tmp/tmpr7hwubgm.cs(43,14): error CS0128: A local variable or function named ''tenthths''
    is already defined in this scope

    /tmp/tmpr7hwubgm.cs(44,14): error CS0128: A local variable or function named ''hundredthths''
    is already defined in this scope

    /tmp/tmpr7hwubgm.cs(45,14): error CS0128: A local variable or function named ''thousandths''
    is already defined in this scope

    /tmp/tmpr7hwubgm.cs(46,14): error CS0128: A local variable or f'
  timestamp: 1659823607
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones > zeros) {\n            return arr.OrderBy(x =>
    x).ToList();\n        }\n        if (zeros > ones) {\n            return arr.OrderByDescending(x
    => x).ToList();\n        }\n        return arr.OrderBy(x => x.ToString(\"N\")).ToList();\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <d8211fda7b284495aa2552ff91140d55>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <d8211fda7b284495aa2552ff91140d55>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMin = ones * min;\n        long zerosMin = zeros * min;\n        long onesMaxMin
    = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n        long onesMinMax
    = onesMin * max;\n        long zerosMinMax = zerosMin * max;\n        long onesMaxMinMax
    = onesMaxMin * max;\n        long zerosMaxMinMax = zerosMaxMin * max;\n        long
    onesMinMaxMinMax = onesMinMax * min;\n        long zerosMinMaxMinMax = zerosMinMax
    * min;\n        long onesMaxMinMaxMinMax = onesMaxMinMax * min;\n        long
    zerosMinMaxMinMax = zerosMinMaxMin * min;\n        long onesMaxMinMaxMinMax =
    onesMaxMinMax * min;\n        long zerosMinMaxMinMax = zerosMinMaxMin * min;\n
    \       long onesMaxMinMaxMinMax = onesMaxMinMax * min;\n        long zerosMinMaxMinMax
    = zerosMinMaxMin * min;\n        long onesMaxMinMaxMinMax = onesMaxMinMax * min;\n
    \       long zerosMinMaxMinMax = zerosMinMaxMin * min;\n        long onesMaxMinMaxMinMax
    = onesMaxMinMax * min;\n        long zerosMinMaxMinMax = zerosMinMaxMin * min;\n
    \       long onesMaxMinMaxMinMax = onesMaxMinMax * min;\n        long zerosMinMaxMinMax
    = zerosMinMaxMin * min;\n        long onesMaxMinMaxMinMax = onesMaxMinMax * min;\n
    \       long zerosMinMaxMinMax = zerosMinMaxMin * min;\n        long onesMaxMinMaxMinMax
    = onesMaxMinMax * min;\n        long zerosMinMaxMinMax = zerosMinMaxMin * min;\n\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpodz217k3.cs(51,14): error CS0128: A local variable or function named ''zerosMinMaxMinMax''
    is already defined in this scope

    /tmp/tmpodz217k3.cs(51,34): error CS0103: The name ''zerosMinMaxMin'' does not
    exist in the current context

    /tmp/tmpodz217k3.cs(52,14): error CS0128: A local variable or function named ''onesMaxMinMaxMinMax''
    is already defined in this scope

    /tmp/tmpodz217k3.cs(53,14): error CS0128: A local variable or function named ''zerosMinMaxMinMax''
    is already defined in this scope

    /tmp/tmpodz217k3.cs(53,34): error CS0103: The name ''zerosMinMaxMin'' does not
    exist in the current context

    /tmp/tmpodz217k3.cs(54,14): error CS0128: A local variable or function named ''onesMaxMinMaxMinMax''
    is already defined in this scope

    /tmp/tmpodz217k3.cs(55,14): error CS0128: A local variable or function named ''zerosMinMaxMinMax''
    is already defined in this scope

    /tmp/tmpodz217k3.cs(55,34): error CS0103: The name ''zerosMinMaxMin'' does not
    exist in the current context

    /tmp/tmpodz217k3.cs(56,14): error CS0128: A local variable or function named ''onesMaxMinMaxMinMax''
    is already defined in this scope

    /tmp/tmpodz217k3.cs(57,14): error CS0128: A local variable or function named ''zerosMinMaxMinMax''
    is already defined in this scope

    /tmp/tmpodz217k3.cs(57,34): error CS0103: The name ''zerosMinMaxMin'' does not
    exist in the current context

    /tmp/tmpodz217k3.cs(58,14): error CS0128: A local variable or function named ''onesMaxMinMaxMinMax''
    is already defined in this scope

    /tmp/tmpodz217k3.cs(59,14): error CS0128: A local variable or function named ''zerosMinMaxMinMax''
    is already defined in this scope

    /tmp/tmpodz217k3.cs(59,34): error CS0103: The name ''zerosMinMaxMin'' does not
    exist in the current context

    /tmp/tmpodz217k3.cs(60,14): error CS0128: A local variable or function named ''onesMaxMinMaxMinMax''
    is already defined in this scope

    /tmp/tmpodz217k3.cs(61,14): error CS0128: A local variable or function named ''zer'
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        if (ones > zeros) {\n            result.Add(min);\n
    \           result.AddRange(arr.Where(i => i == min).OrderBy(i => i).Take(ones
    - 1).ToList());\n            result.Add(max);\n            result.AddRange(arr.Where(i
    => i == max).OrderBy(i => i).Take(zeros - 1).ToList());\n        } else {\n            result.Add(max);\n
    \           result.AddRange(arr.Where(i => i == max).OrderBy(i => i).Take(ones
    - 1).ToList());\n            result.Add(min);\n            result.AddRange(arr.Where(i
    => i == min).OrderBy(i => i).Take(zeros - 1).ToList());\n        }\n        return
    result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpp4mg4eex.cs(41,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpp4mg4eex.cs(43,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpp4mg4eex.cs(46,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpp4mg4eex.cs(48,75): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long zeros = 0;\n        long max = 0;\n        foreach (long i in arr)
    {\n            ones += i;\n            zeros -= i;\n            if (ones > max)
    {\n                max = ones;\n            }\n            if (zeros > max) {\n
    \               max = zeros;\n            }\n        }\n        long onesMax =
    max;\n        long zerosMax = max;\n        long maxOnes = 0;\n        long maxZeros
    = 0;\n        long maxOnesMax = 0;\n        long maxZerosMax = 0;\n        long
    maxOnesMaxOnesMax = 0;\n        long maxZerosMaxZerosMax = 0;\n        long maxOnesMaxZerosMax
    = 0;\n        long maxZerosMaxOnesMax = 0;\n        long maxOnesMaxOnesMaxZerosMax
    = 0;\n        long maxZerosMaxZerosMaxOnesMax = 0;\n        long maxOnesMaxZerosMaxOnesMaxZerosMax
    = 0;\n        long maxOnesMaxOnesMaxZerosMaxOnesMax = 0;\n        long maxZerosMaxZerosMaxOnesMaxOnesMax
    = 0;\n        long maxOnesMaxOnesMaxZerosMaxOnesMaxZerosMax = 0;\n        long
    maxOnesMaxOnesMaxOnesMaxZerosMaxOnesMax = 0;\n        long maxZerosMaxZerosMaxOnesMaxOnesMaxOnesMax
    = 0;\n        long maxOnesMaxOnesMaxZerosMaxOnesMaxOnesMaxZerosMax = 0;\n        long
    maxOnesMaxOnesMaxOnesMaxZerosMaxOnesMaxOnesMax = 0;\n        long maxZerosMaxZerosMaxOnesMaxOnesMaxOnesMaxOnesMax
    = 0;\n        long maxOnesMaxOnesMaxZerosMaxOnesMaxOnesMaxOnesMaxZerosMax = 0;\n
    \       long maxOnesMaxOnesMaxOnesMaxZerosMaxOnesMaxOnesMaxOnesMaxZerosMax = 0;\n
    \       long maxOnesMaxOnesMaxOnesMaxZerosMaxOnesMaxOnesMaxOnesMaxZerosMaxOnesMax
    = 0;\n        long maxOnesMaxOnesMaxOnesMaxZerosMaxOnesMaxOnesMaxOnesMaxZeros\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpttpcsw0x.cs(58,72): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMin = ones * min;\n        long zerosMin = zeros * min;\n        long onesMaxMin
    = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n        long onesMinMax
    = onesMin * max;\n        long zerosMinMax = zerosMin * max;\n        long onesMaxMinMax
    = onesMaxMin * max;\n        long zerosMaxMinMax = zerosMaxMin * max;\n        long
    onesMinMaxMinMax = onesMinMax * max;\n        long zerosMinMaxMinMax = zerosMinMax
    * max;\n        long onesMinMaxMinMaxMin = onesMinMaxMin * min;\n        long
    zerosMinMaxMinMax = zerosMinMax * min;\n        long onesMinMaxMinMaxMinMax =
    onesMinMaxMinMax * max;\n        long zerosMinMaxMinMaxMinMax = zerosMinMaxMinMax
    * max;\n        long onesMinMaxMinMaxMinMaxMin = onesMinMaxMinMaxMinMax * min;\n
    \       long zerosMinMaxMinMaxMinMax = zerosMinMaxMinMax * min;\n        long
    onesMinMaxMinMaxMinMaxMinMax = onesMinMaxMinMaxMinMax * min;\n        long zerosMinMaxMinMaxMinMaxMinMax
    = zerosMinMaxMinMax * min;\n        long onesMinMaxMinMaxMinMaxMinMaxMin = onesMinMaxMinMaxMinMax
    * min;\n        long zerosMinMaxMinMaxMinMaxMinMax = zerosMinMaxMinMax * min;\n
    \       long onesMinMaxMinMaxMinMaxMinMaxMin = onesMinMaxMinMaxMinMax * min;\n
    \       long zerosMinMaxMinMaxMinMaxMinMax = zerosMinMaxMinMax * min;\n        long
    onesMinMaxMinMaxMinMaxMinMaxMin = onesMinMaxMinMaxMinMax * min;\n        long
    zerosMinMaxMinMaxMinMaxMinMaxMin = \n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpnlvm19al.cs(59,48): error CS1525: Invalid expression term ''}''

    /tmp/tmpnlvm19al.cs(59,48): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones > zeros ? ones : zeros;\n        long zerosMax = zeros
    > ones ? zeros : ones;\n        long maxMax = max > onesMax ? max : onesMax;\n
    \       long maxMin = max < zerosMax ? max : zerosMax;\n        List<long> res
    = new List<long>();\n        foreach (long i in arr) {\n            if (i == 1L)
    {\n                res.Add(i);\n            }\n            if (i == 0L) {\n                res.Add(-i);\n
    \           }\n            if (i > maxMin) {\n                res.Add(max);\n
    \           }\n            if (i < maxMax) {\n                res.Add(-max);\n
    \           }\n        }\n        return res;\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <8852838685a3445fb984f13302c63476>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <8852838685a3445fb984f13302c63476>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMin = ones * max;\n        long zerosMin = zeros * max;\n        long onesMaxMin
    = onesMax * max;\n        long zerosMaxMin = zerosMax * max;\n        long onesMinMin
    = onesMin * max;\n        long zerosMinMin = zerosMin * max;\n        long onesMaxMinMin
    = onesMaxMin * max;\n        long zerosMaxMinMin = zerosMaxMin * max;\n        long
    onesMinMinMin = onesMinMin * max;\n        long zerosMinMinMin = zerosMinMin *
    max;\n        long onesMaxMinMinMin = onesMaxMinMin * max;\n        long zerosMaxMinMinMin
    = zerosMaxMinMin * max;\n        long onesMinMinMinMin = onesMinMinMin * max;\n
    \       long zerosMinMinMinMin = zerosMinMinMin * max;\n        long onesMaxMinMinMin
    = onesMaxMinMin * max;\n        long zerosMaxMinMinMin = zerosMaxMinMin * max;\n
    \       long onesMinMinMinMin = onesMinMinMin * max;\n        long zerosMinMinMinMin
    = zerosMinMinMin * max;\n        long onesMaxMinMinMin = onesMaxMinMin * max;\n
    \       long zerosMaxMinMinMin = zerosMaxMinMin * max;\n        long onesMinMinMinMin
    = onesMinMinMin * max;\n        long zerosMinMinMinMin = zerosMinMinMin * max;\n
    \       long onesMaxMinMinMin = onesMaxMinMin * max;\n        long zerosMaxMinMinMin
    = zerosMaxMinMin * max;\n        long onesMinMinMinMin = onesMinMinMin * max;\n
    \       long zerosMinMinMinMin = zerosMinMinMin * max;\n        long onesMaxMinMinMin
    = onesMaxMinMin * max;\n        long zerosMaxMinMinMin = \n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkw9jx13g.cs(63,33): error CS1525: Invalid expression term ''}''

    /tmp/tmpkw9jx13g.cs(63,33): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones;\n        long zerosMax = zeros;\n        long maxMax
    = max;\n        long onesMin = ones;\n        long zerosMin = zeros;\n        long
    maxMin = max;\n        long onesCur = 0;\n        long zerosCur = 0;\n        long
    maxCur = 0;\n        long onesPrev = 0;\n        long zerosPrev = 0;\n        long
    maxPrev = 0;\n        long onesNext = 0;\n        long zerosNext = 0;\n        long
    maxNext = 0;\n        long onesCurMax = 0;\n        long zerosCurMax = 0;\n        long
    maxCurMax = 0;\n        long onesCurMin = 0;\n        long zerosCurMin = 0;\n
    \       long maxCurMin = 0;\n        long onesPrevMax = 0;\n        long zerosPrevMax
    = 0;\n        long maxPrevMax = 0;\n        long onesPrevMin = 0;\n        long
    zerosPrevMin = 0;\n        long maxPrevMin = 0;\n        long onesNextMax = 0;\n
    \       long zerosNextMax = 0;\n        long maxNextMax = 0;\n        long onesNextMin
    = 0;\n        long zerosNextMin = 0;\n        long maxNextMin = 0;\n        long
    onesCurCur = 0;\n        long zerosCurCur = 0;\n        long maxCurCur = 0;\n
    \       long onesPrevCur = 0;\n        long zerosPrevCur = 0;\n        long maxPrevCur
    = 0;\n        long onesNextCur = 0;\n        long zerosNextCur = 0;\n        long
    maxNextCur = 0;\n        long onesCurPrev = 0;\n        long zerosCurPrev = 0;\n
    \       long maxCurPrev = 0;\n        long onesPrevPrev = 0;\n        long zerosPrevPrev
    = 0;\n        long maxPrevPrev = 0;\n        long onesNextPrev = 0;\n        long
    zerosNextPrev = 0;\n        long maxNextPrev = 0;\n        long onesCurCurMax
    = 0;\n        long zerosCurCurMax = 0;\n        long maxCurCurMax = 0;\n        long
    onesPrevCurMax = 0;\n        long zerosPrevCurMax = 0;\n        long maxPrevCurMax
    = 0;\n        long onesNextCurMax = 0;\n        long zerosNextCurMax = 0;\n        long
    maxNextCurMax = 0;\n        long onesCurCur\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkst26mnj.cs(94,24): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           } else if (i == 0L) {\n                zeros++;\n            } else
    {\n                max = Math.Max(max, i);\n            }\n        }\n        List<long>
    result = new List<long>();\n        if (ones > zeros) {\n            long onesMax
    = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max, 2))) + 1);\n            long
    zerosMax = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max, 2))) - 1);\n
    \           long onesMin = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) - 1);\n            long zerosMin = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) + 1);\n            long onesMaxIndex = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) + 1);\n            long zerosMaxIndex = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) - 1);\n            long onesMinIndex = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) - 1);\n            long zerosMinIndex = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) + 1);\n            long onesMaxIndex2 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) + 1);\n            long zerosMaxIndex2 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) - 1);\n            long onesMinIndex2 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) - 1);\n            long zerosMinIndex2 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) + 1);\n            long onesMaxIndex3 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) + 1);\n            long zerosMaxIndex3 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) - 1);\n            long onesMinIndex3 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) - 1);\n            long zerosMinIndex3 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    2))) + 1);\n            long onesMaxIndex4 = Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log(max,
    \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmphbhm5bod.cs(50,91): error CS1525: Invalid expression term ''}''

    /tmp/tmphbhm5bod.cs(50,91): error CS1026: ) expected

    /tmp/tmphbhm5bod.cs(50,91): error CS1002: ; expected

    /tmp/tmphbhm5bod.cs(52,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmphbhm5bod.cs(63,2): error CS1513: } expected

    '
  timestamp: 1659823607
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            ones += i;\n            zeros -=
    i;\n            if (ones > max) {\n                max = ones;\n            }\n
    \           if (zeros > max) {\n                max = zeros;\n            }\n
    \       }\n        List<long> result = new List<long>();\n        foreach (long
    i in arr) {\n            if (i == 1) {\n                result.Add(i);\n            }
    else {\n                result.Add(max - i);\n            }\n        }\n        return
    result;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <c97423a9b829459487e4afb350801884>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <c97423a9b829459487e4afb350801884>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long onesMin = ones * min;\n        long
    zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long maxOnes
    = ones * max;\n        long maxZeros = zeros * max;\n        long minOnes = ones
    * min;\n        long minZeros = zeros * min;\n        long maxOnesMax = onesMax
    * max;\n        long maxOnesMin = onesMin * max;\n        long maxZerosMax = zerosMax
    * max;\n        long maxZerosMin = zerosMin * max;\n        long minOnesMax =
    onesMax * min;\n        long minOnesMin = onesMin * min;\n        long minZerosMax
    = zerosMax * min;\n        long minZerosMin = zerosMin * min;\n        long maxOnesMaxMin
    = onesMax * min;\n        long maxOnesMinMax = onesMin * max;\n        long maxZerosMaxMin
    = zerosMax * min;\n        long maxZerosMinMax = zerosMin * max;\n        long
    minOnesMaxMin = onesMax * min;\n        long minOnesMinMax = onesMin * min;\n
    \       long minZerosMaxMin = zerosMax * min;\n        long minZerosMinMax = zerosMin
    * min;\n        long maxOnesMaxMinMax = onesMax * min;\n        long maxOnesMinMaxMax
    = onesMin * max;\n        long maxZerosMaxMinMax = zerosMax * min;\n        long
    maxZerosMinMaxMax = zerosMin * max;\n        long minOnesMaxMinMax = onesMax *
    min;\n        long minOnesMinMaxMax = onesMin * max;\n        long minZerosMaxMinMax
    = zerosMax * min;\n        long minZerosMinMaxMax = \n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpvedbfhxx.cs(69,33): error CS1525: Invalid expression term ''}''

    /tmp/tmpvedbfhxx.cs(69,33): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMax2 = onesMax * onesMax;\n        long zerosMax2 = zerosMax * zerosMax;\n
    \       long onesMax3 = onesMax2 * onesMax;\n        long zerosMax3 = zerosMax2
    * zerosMax;\n        long onesMax4 = onesMax3 * onesMax;\n        long zerosMax4
    = zerosMax3 * zerosMax;\n        long onesMax5 = onesMax4 * onesMax;\n        long
    zerosMax5 = zerosMax4 * zerosMax;\n        long onesMax6 = onesMax5 * onesMax;\n
    \       long zerosMax6 = zerosMax5 * zerosMax;\n        long onesMax7 = onesMax6
    * onesMax;\n        long zerosMax7 = zerosMax6 * zerosMax;\n        long onesMax8
    = onesMax7 * onesMax;\n        long zerosMax8 = zerosMax7 * zerosMax;\n        long
    onesMax9 = onesMax8 * onesMax;\n        long zerosMax9 = zerosMax8 * zerosMax;\n
    \       long onesMax10 = onesMax9 * onesMax;\n        long zerosMax10 = zerosMax9
    * zerosMax;\n        long onesMax11 = onesMax10 * onesMax;\n        long zerosMax11
    = zerosMax10 * zerosMax;\n        long onesMax12 = onesMax11 * onesMax;\n        long
    zerosMax12 = zerosMax11 * zerosMax;\n        long onesMax13 = onesMax12 * onesMax;\n
    \       long zerosMax13 = zerosMax12 * zerosMax;\n        long onesMax14 = onesMax13
    * onesMax;\n        long zerosMax14 = zerosMax13 * zerosMax;\n        long onesMax15
    = onesMax14 * onesMax;\n        long zerosMax15 = zerosMax14 * zerosMax;\n        long
    onesMax16 = onesMax15 * onesMax;\n        long zerosMax16 = zerosMax15 * zerosMax;\n
    \       long \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpe4coxiz3.cs(66,13): error CS1001: Identifier expected

    /tmp/tmpe4coxiz3.cs(66,13): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: -1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           } else if (i == 0L) {\n                zeros++;\n            } else
    {\n                max = Math.Max(max, i);\n            }\n        }\n        List<long>
    result = new List<long>();\n        if (ones > zeros) {\n            long onesMax
    = ones;\n            long zerosMax = zeros;\n            while (onesMax > zerosMax)
    {\n                result.Add(max);\n                zerosMax--;\n            }\n
    \           while (zerosMax < onesMax) {\n                result.Add(max);\n                onesMax--;\n
    \           }\n        } else {\n            long zerosMax = zeros;\n            long
    onesMax = ones;\n            while (zerosMax < onesMax) {\n                result.Add(max);\n
    \               zerosMax--;\n            }\n            while (onesMax < zerosMax)
    {\n                result.Add(max);\n                onesMax--;\n            }\n
    \       }\n        return result;\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Timeout
  stderr: ''
  stdout: None
  timestamp: 1659823613
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long zeros = 0;\n        long max = 0;\n        foreach (long i in arr)
    {\n            ones += i;\n            if (i == 1L) {\n                result.Add(i);\n
    \               zeros++;\n            }\n            else if (i == 0L) {\n                result.Add(i);\n
    \               zeros++;\n            }\n            else {\n                max
    = Math.Max(max, i);\n            }\n        }\n        long onesCount = ones -
    zeros;\n        long maxCount = max - ones;\n        long maxCount2 = maxCount
    * maxCount;\n        long onesCount2 = onesCount * onesCount;\n        long onesCount3
    = onesCount2 * onesCount;\n        long onesCount4 = onesCount3 * onesCount;\n
    \       long onesCount5 = onesCount4 * onesCount;\n        long onesCount6 = onesCount5
    * onesCount;\n        long onesCount7 = onesCount6 * onesCount;\n        long
    onesCount8 = onesCount7 * onesCount;\n        long onesCount9 = onesCount8 * onesCount;\n
    \       long onesCount10 = onesCount9 * onesCount;\n        long onesCount11 =
    onesCount10 * onesCount;\n        long onesCount12 = onesCount11 * onesCount;\n
    \       long onesCount13 = onesCount12 * onesCount;\n        long onesCount14
    = onesCount13 * onesCount;\n        long onesCount15 = onesCount14 * onesCount;\n
    \       long onesCount16 = onesCount15 * onesCount;\n        long onesCount17
    = onesCount16 * onesCount;\n        long onesCount18 = onesCount17 * onesCount;\n
    \       long onesCount19 = onesCount18 * onesCount;\n        long onesCount20
    = onesCount19 * onesCount;\n        long onesCount21 = onesCount20 * onesCount;\n
    \       long onesCount22 = onesCount21 * onesCount;\n        long onesCount23
    = onesCount22 * onesCount;\n        long onesCount24 = onesCount23 * onesCount;\n
    \       long onesCount25 = onesCount24 * onesCount;\n        long onesCount26\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpwvv1y0qi.cs(65,25): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones == zeros) {\n            return arr.OrderBy(x =>
    x).ToList();\n        }\n        long onesDecimal = ones / 10;\n        long zerosDecimal
    = zeros / 10;\n        long onesDecimalDecimal = onesDecimal / 10;\n        long
    zerosDecimalDecimal = zerosDecimal / 10;\n        long onesDecimalDecimalDecimal
    = onesDecimalDecimal / 10;\n        long zerosDecimalDecimalDecimal = zerosDecimalDecimal
    / 10;\n        long onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal
    / 10;\n        long zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal
    / 10;\n        long onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal
    / 10;\n        long zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal
    / 10;\n        long onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal
    / 10;\n        long zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal
    / 10;\n        long onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal
    / 10;\n        long zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal
    / 10;\n        long onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / 10;\n        long
    zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    / 10;\n        long onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    / 10;\n        long zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    / 10;\n        long onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    / 10;\n        long zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    / 10;\n        long onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal
    = onesDecimal\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpk2t9v2xc.cs(45,102): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMax2 = onesMax * onesMax;\n        long zerosMax2 = zerosMax * zerosMax;\n
    \       long onesMax3 = onesMax2 * onesMax;\n        long zerosMax3 = zerosMax2
    * zerosMax;\n        long onesMax4 = onesMax3 * onesMax;\n        long zerosMax4
    = zerosMax3 * zerosMax;\n        long onesMax5 = onesMax4 * onesMax;\n        long
    zerosMax5 = zerosMax4 * zerosMax;\n        long onesMax6 = onesMax5 * onesMax;\n
    \       long zerosMax6 = zerosMax5 * zerosMax;\n        long onesMax7 = onesMax6
    * onesMax;\n        long zerosMax7 = zerosMax6 * zerosMax;\n        long onesMax8
    = onesMax7 * onesMax;\n        long zerosMax8 = zerosMax7 * zerosMax;\n        long
    onesMax9 = onesMax8 * onesMax;\n        long zerosMax9 = zerosMax8 * zerosMax;\n
    \       long onesMax10 = onesMax9 * onesMax;\n        long zerosMax10 = zerosMax9
    * zerosMax;\n        long onesMax11 = onesMax10 * onesMax;\n        long zerosMax11
    = zerosMax10 * zerosMax;\n        long onesMax12 = onesMax11 * onesMax;\n        long
    zerosMax12 = zerosMax11 * zerosMax;\n        long onesMax13 = onesMax12 * onesMax;\n
    \       long zerosMax13 = zerosMax12 * zerosMax;\n        long onesMax14 = onesMax13
    * onesMax;\n        long zerosMax14 = zerosMax13 * zerosMax;\n        long onesMax15
    = onesMax14 * onesMax;\n        long zerosMax15 = zerosMax14 * zerosMax;\n        long
    onesMax16 = onesMax15 * onesMax;\n        long zerosMax16 = zerosMax15 * zerosMax;\n
    \       long \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpe4coxiz3.cs(66,13): error CS1001: Identifier expected

    /tmp/tmpe4coxiz3.cs(66,13): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long onesMin = ones * min;\n        long
    zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long maxOnes
    = ones * max;\n        long maxZeros = zeros * max;\n        long minOnes = ones
    * min;\n        long minZeros = zeros * min;\n        long maxOnesMax = onesMax
    * max;\n        long maxOnesMin = onesMin * max;\n        long maxZerosMax = zerosMax
    * max;\n        long maxZerosMin = zerosMin * max;\n        long minOnesMax =
    onesMax * min;\n        long minOnesMin = onesMin * min;\n        long minZerosMax
    = zerosMax * min;\n        long minZerosMin = zerosMin * min;\n        long maxOnesMaxMin
    = onesMax * min;\n        long maxOnesMinMax = onesMin * max;\n        long maxZerosMaxMin
    = zerosMax * min;\n        long maxZerosMinMax = zerosMin * max;\n        long
    minOnesMaxMin = onesMax * min;\n        long minOnesMinMax = onesMin * min;\n
    \       long minZerosMaxMin = zerosMax * min;\n        long minZerosMinMax = zerosMin
    * min;\n        long maxOnesMaxMinMax = onesMax * min;\n        long maxOnesMinMaxMax
    = onesMin * max;\n        long maxZerosMaxMinMax = zerosMax * min;\n        long
    maxZerosMinMaxMax = zerosMin * max;\n        long minOnesMaxMinMax = onesMax *
    min;\n        long minOnesMinMaxMax = onesMin * max;\n        long minZerosMaxMinMax
    = zerosMax * min;\n        long minZerosMinMaxMax = \n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpvedbfhxx.cs(69,33): error CS1525: Invalid expression term ''}''

    /tmp/tmpvedbfhxx.cs(69,33): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long maxOnes
    = 0;\n        long maxZeros = 0;\n        foreach (long i in arr) {\n            ones
    += i;\n            zeros += (long)Math.Abs(i);\n            if (i > maxOnes) maxOnes
    = i;\n            if (i < maxZeros) maxZeros = i;\n        }\n        List<long>
    result = new List<long>();\n        foreach (long i in arr) {\n            long
    onesCount = 0;\n            long zerosCount = 0;\n            long maxOnesCount
    = 0;\n            long maxZerosCount = 0;\n            long maxOnesCount2 = 0;\n
    \           long maxZerosCount2 = 0;\n            long maxOnesCount3 = 0;\n            long
    maxZerosCount3 = 0;\n            long maxOnesCount4 = 0;\n            long maxZerosCount4
    = 0;\n            long maxOnesCount5 = 0;\n            long maxZerosCount5 = 0;\n
    \           long maxOnesCount6 = 0;\n            long maxZerosCount6 = 0;\n            long
    maxOnesCount7 = 0;\n            long maxZerosCount7 = 0;\n            long maxOnesCount8
    = 0;\n            long maxZerosCount8 = 0;\n            long maxOnesCount9 = 0;\n
    \           long maxZerosCount9 = 0;\n            long maxOnesCount10 = 0;\n            long
    maxZerosCount10 = 0;\n            long maxOnesCount11 = 0;\n            long maxZerosCount11
    = 0;\n            long maxOnesCount12 = 0;\n            long maxZerosCount12 =
    0;\n            long maxOnesCount13 = 0;\n            long maxZerosCount13 = 0;\n
    \           long maxOnesCount14 = 0;\n            long maxZerosCount14 = 0;\n
    \           long maxOnesCount15 = 0;\n            long maxZerosCount15 = 0;\n
    \           long maxOnesCount16 = 0;\n            long maxZerosCount16 = 0;\n
    \           long maxOnesCount17 = 0;\n            long maxZerosCount17 = 0;\n
    \           long maxOnesCount18 = 0;\n            long maxZerosCount18 = 0;\n
    \           long maxOnesCount19 = 0;\n            long maxZerosCount19 = 0;\n
    \           long maxOnesCount20 = 0;\n            long maxZerosCount20 = 0;\n
    \           long maxOnesCount21 = 0;\n            long maxZerosCount21 = 0;\n
    \           long maxOnesCount22 = 0;\n            long maxZerosCount22 = 0;\n
    \           long maxOnesCount\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpaie8b2wx.cs(78,30): error CS1002: ; expected

    /tmp/tmpaie8b2wx.cs(80,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpaie8b2wx.cs(91,2): error CS1513: } expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long zeros = 0;\n        foreach (long i in arr) {\n            ones +=
    i;\n        }\n        foreach (long i in arr) {\n            zeros += i;\n        }\n
    \       ones = ones / 2;\n        zeros = zeros / 2;\n        long onesCount =
    0;\n        long zerosCount = 0;\n        long onesSum = 0;\n        long zerosSum
    = 0;\n        long onesMax = 0;\n        long zerosMax = 0;\n        long onesMin
    = Long.MaxValue;\n        long zerosMin = Long.MinValue;\n        foreach (long
    i in arr) {\n            if (i == 1) {\n                onesCount++;\n                onesSum
    += i;\n                if (onesCount > onesMax) {\n                    onesMax
    = onesCount;\n                }\n                if (onesCount < onesMin) {\n
    \                   onesMin = onesCount;\n                }\n            }\n            if
    (i == 0) {\n                zerosCount++;\n                zerosSum += i;\n                if
    (zerosCount > zerosMax) {\n                    zerosMax = zerosCount;\n                }\n
    \               if (zerosCount < zerosMin) {\n                    zerosMin = zerosCount;\n
    \               }\n            }\n        }\n        onesSum = onesSum / 2;\n
    \       zerosSum = zerosSum / 2;\n        onesSum = onesSum - onesMax;\n        zerosSum
    = zerosSum - zerosMax;\n        onesSum = onesSum - onesMin;\n        zerosSum
    = zerosSum - zerosMin;\n        onesSum = onesSum * onesCount;\n        zerosSum
    = zerosSum * zerosCount;\n        onesSum = onesSum + zerosSum;\n        zerosSum
    = zerosSum + onesSum;\n        onesSum = onesSum / 2;\n        zerosSum = zerosSum
    / 2;\n        onesSum = onesSum - onesMax;\n        zerosSum = zerosSum - zerosMax;\n
    \       onesSum = onesSum - onesMin;\n        zerosSum = zerosSum - zerosMin;\n
    \       onesSum = onesSum * onesCount;\n        zerosSum = zerosSum * zerosCount;\n
    \       onesSum = onesSum + zerosSum;\n        zerosSum = zerosSum + onesSum;\n
    \       onesSum = onesSum / 2;\n        zerosSum = zerosSum / 2;\n        ones\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmptgbzkpky.cs(83,13): error CS1002: ; expected

    '
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        long maxOnes = arr.Max(x => x & 1L);\n        long maxZeros
    = arr.Max(x => x & 0L);\n        long maxOnesZeros = maxOnes - maxZeros;\n        long
    maxOnesOnes = maxOnes - ones;\n        long maxOnesZeroOnes = maxOnes - zeros;\n
    \       long maxOnesOnesZeros = maxOnes - ones - zeros;\n        long maxOnesOnesOnes
    = maxOnes - ones - ones;\n        long maxOnesOnesOnesZeros = maxOnes - ones -
    ones - zeros;\n        long maxOnesOnesOnesOnes = maxOnes - ones - ones - ones;\n
    \       long maxOnesOnesOnesOnesZeros = maxOnes - ones - ones - ones - zeros;\n
    \       long maxOnesOnesOnesOnesOnes = maxOnes - ones - ones - ones - ones;\n
    \       long maxOnesOnesOnesOnesOnesZeros = maxOnes - ones - ones - ones - ones
    - zeros;\n        long maxOnesOnesOnesOnesOnesOnes = maxOnes - ones - ones - ones
    - ones - ones;\n        long maxOnesOnesOnesOnesOnesZeros = maxOnes - ones - ones
    - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes =
    maxOnes - ones - ones - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros
    = maxOnes - ones - ones - ones - ones - ones - ones - zeros;\n        long maxOnesOnesOnesOnesOnesOnesOnes
    = maxOnes - ones - ones - ones - ones - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnesOnesZeros
    = maxOnes - ones - ones - ones - ones - ones - ones - ones - zeros;\n        long
    maxOnesOnesOnesOnesOnesOnesOnesOnes = maxOnes - ones - ones - ones - ones - ones
    - ones - ones - ones;\n        long maxOnesOnesOnesOnesOnes\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpidy3tkb5.cs(41,37): error CS1002: ; expected

    '
  timestamp: 1659823604
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones;\n        long zerosMax = zeros;\n        long maxMax
    = max;\n        long onesMin = ones;\n        long zerosMin = zeros;\n        long
    maxMin = max;\n        long onesMaxMin = ones;\n        long zerosMaxMin = zeros;\n
    \       long maxMaxMin = max;\n        long onesMinMax = ones;\n        long zerosMinMax
    = zeros;\n        long maxMinMax = max;\n        long onesMaxMinMax = ones;\n
    \       long zerosMaxMinMax = zeros;\n        long maxMaxMinMax = max;\n        long
    onesMinMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n        long maxMinMaxMax
    = max;\n        long onesMinMaxMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n
    \       long maxMinMaxMax = max;\n        long onesMinMaxMaxMax = ones;\n        long
    zerosMinMaxMax = zeros;\n        long maxMinMaxMax = max;\n        long onesMinMaxMaxMax
    = ones;\n        long zerosMinMaxMax = zeros;\n        long maxMinMaxMax = max;\n
    \       long onesMinMaxMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n
    \       long maxMinMaxMax = max;\n        long onesMinMaxMaxMax = ones;\n        long
    zerosMinMaxMax = zeros;\n        long maxMinMaxMax = max;\n        long onesMinMaxMaxMax
    = ones;\n        long zerosMinMaxMax = zeros;\n        long maxMinMaxMax = max;\n
    \       long onesMinMaxMaxMax = ones;\n        long zerosMinMaxMax = zeros;\n
    \       long maxMinMaxMax = max;\n        long onesMinMaxMaxMax = ones;\n        long
    zerosMinMaxMax = zeros;\n        long maxMinMaxMax = max;\n        long onesMinMaxMaxMax
    = ones;\n        long zerosMinMaxMax = zeros;\n        long maxMinMaxMax\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpsi_e1ndh.cs(78,26): error CS1002: ; expected

    '
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long n in arr) {\n            ones += n;\n            zeros +=
    (long)Math.Abs(n);\n            if (n > max) {\n                max = n;\n            }\n
    \       }\n        long onesMax = ones;\n        long zerosMax = zeros;\n        long
    maxAbs = max;\n        long onesMaxAbs = onesMax;\n        long zerosMaxAbs =
    zerosMax;\n        long maxAbsAbs = maxAbs;\n        long onesMaxAbsAbs = onesMaxAbs;\n
    \       long zerosMaxAbsAbs = zerosMaxAbs;\n        long maxAbsAbsAbs = maxAbsAbs;\n
    \       long onesMaxAbsAbsAbs = onesMaxAbsAbs;\n        long zerosMaxAbsAbsAbs
    = zerosMaxAbsAbs;\n        long maxAbsAbsAbsAbs = maxAbsAbsAbs;\n        long
    onesMaxAbsAbsAbsAbs = onesMaxAbsAbsAbs;\n        long zerosMaxAbsAbsAbsAbs = zerosMaxAbsAbsAbs;\n
    \       long maxAbsAbsAbsAbsAbs = maxAbsAbsAbsAbsAbs;\n        long onesMaxAbsAbsAbsAbsAbs
    = onesMaxAbsAbsAbsAbsAbs;\n        long zerosMaxAbsAbsAbsAbsAbs = zerosMaxAbsAbsAbsAbsAbs;\n
    \       long maxAbsAbsAbsAbsAbsAbs = maxAbsAbsAbsAbsAbsAbs;\n        long onesMaxAbsAbsAbsAbsAbsAbs
    = onesMaxAbsAbsAbsAbsAbsAbs;\n        long zerosMaxAbsAbsAbsAbsAbsAbs = zerosMaxAbsAbsAbsAbsAbsAbs;\n
    \       long maxAbsAbsAbsAbsAbsAbsAbs = maxAbsAbsAbsAbsAbsAbsAbsAbs;\n        long
    onesMaxAbsAbsAbsAbsAbsAbsAbs = onesMaxAbsAbsAbsAbsAbsAbsAbs;\n        long zerosMaxAbsAbsAbsAbsAbsAbs\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpj59_afbi.cs(52,40): error CS1002: ; expected

    '
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones < zeros) {\n            long temp = ones;\n            ones
    = zeros;\n            zeros = temp;\n        }\n        long max = arr.Max();\n
    \       long min = arr.Min();\n        long mid = max / 2;\n        long midOnes
    = arr.Where(x => x & 1L).Sum(x => x & 1L);\n        long midZeros = arr.Where(x
    => x & 0L).Sum(x => x & 0L);\n        if (midOnes < midZeros) {\n            long
    temp = midOnes;\n            midOnes = midZeros;\n            midZeros = temp;\n
    \       }\n        long midMax = arr.Where(x => x & 1L).Max();\n        long midMin
    = arr.Where(x => x & 1L).Min();\n        long midMid = (midMax + midMin) / 2;\n
    \       long midMidOnes = arr.Where(x => x & 1L).Where(x => x & 1L).Sum(x => x
    & 1L);\n        long midMidZeros = arr.Where(x => x & 0L).Where(x => x & 0L).Sum(x
    => x & 0L);\n        if (midMidOnes < midMidZeros) {\n            long temp =
    midMidOnes;\n            midMidOnes = midMidZeros;\n            midMidZeros =
    temp;\n        }\n        long midMidMax = arr.Where(x => x & 1L).Where(x => x
    & 1L).Max();\n        long midMidMin = arr.Where(x => x & 1L).Where(x => x & 1L).Min();\n
    \       long midMidMid = (midMidMax + midMidMin) / 2;\n        long midMidMidOnes
    = arr.Where(x => x & 1L).Where(x => x & 1L).Where(x => x & 1L).Sum(x => x & 1L);\n
    \       long midMidMidZeros = arr.Where(x => x & 0L).Where(x => x & 0L).Where(x
    => x & 0L).Sum(x => x & 0L);\n        if (midMidMidOnes < midMidMidZeros) {\n
    \           long temp = midMidMidOnes;\n            midMidMidOnes = midMid\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpj3ttvvgu.cs(54,35): error CS1002: ; expected

    /tmp/tmpj3ttvvgu.cs(56,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpj3ttvvgu.cs(67,2): error CS1513: } expected

    '
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long num in arr) {\n            if (num
    == 1) ones++;\n            else if (num == 0) zeros++;\n            else if (num
    > max) max = num;\n            else if (num < min) min = num;\n        }\n        List<long>
    result = new List<long>();\n        if (ones > zeros) {\n            long onesMax
    = Convert.ToInt64(Math.Pow(2, Math.Log10(ones)));\n            long onesMin =
    Convert.ToInt64(Math.Pow(2, Math.Log10(ones) - 1));\n            long zeroMax
    = Convert.ToInt64(Math.Pow(2, Math.Log10(zeros)));\n            long zeroMin =
    Convert.ToInt64(Math.Pow(2, Math.Log10(zeros) - 1));\n            long onesDiff
    = onesMax - onesMin;\n            long zerosDiff = zeroMax - zeroMin;\n            long
    onesDiff2 = onesDiff / 2;\n            long zerosDiff2 = zerosDiff / 2;\n            long
    onesDiff3 = onesDiff / 3;\n            long zerosDiff3 = zerosDiff / 3;\n            long
    onesDiff4 = onesDiff / 4;\n            long zerosDiff4 = zerosDiff / 4;\n            long
    onesDiff5 = onesDiff / 5;\n            long zerosDiff5 = zerosDiff / 5;\n            long
    onesDiff6 = onesDiff / 6;\n            long zerosDiff6 = zerosDiff / 6;\n            long
    onesDiff7 = onesDiff / 7;\n            long zerosDiff7 = zerosDiff / 7;\n            long
    onesDiff8 = onesDiff / 8;\n            long zerosDiff8 = zerosDiff / 8;\n            long
    onesDiff9 = onesDiff / 9;\n            long zerosDiff9 = zerosDiff / 9;\n            long
    onesDiff10 = onesDiff / 10;\n            long zerosDiff10 = zerosDiff / 10;\n
    \           long onesDiff11 = onesDiff / 11;\n            long zerosDiff11 = zerosDiff
    / 11;\n            long onesDiff12 = onesDiff / 12;\n            long zerosDiff12
    = zerosDiff / 12;\n            long onesDiff13 = onesDiff / 13;\n            long
    zerosDiff13 = zerosDiff / 13;\n            long onesDiff14 = onesDiff / 14;\n
    \           long zerosDiff14 = zerosDiff / 14;\n            long onesDiff15 =
    onesDiff / 15;\n            \n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpy4w43v6u.cs(67,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmpy4w43v6u.cs(78,2): error CS1513: } expected

    '
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = arr.Sum(x => x & 1L);\n        long zeros = arr.Sum(x
    => x & 0L);\n        if (ones > zeros) {\n            arr = arr.OrderBy(x => Convert.ToInt64(Math.Pow(2,
    Convert.ToInt32(Math.Log10(Math.Abs(x))))).ToString()).ToList();\n        } else
    {\n            arr = arr.OrderBy(x => Convert.ToInt64(Math.Pow(2, Convert.ToInt32(Math.Log10(Math.Abs(x))))).ToString()).ToList();\n
    \       }\n        return arr;\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <21e4157412a347fba85a8aae58830ccd>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <21e4157412a347fba85a8aae58830ccd>:0
    \n\nUnhandled Exception:\nSystem.OverflowException: Value was either too large
    or too small for an Int32.\n  at System.Convert.ToInt32 (System.Double value)
    [0x0007a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0 \n  at Problem+<>c.<SortArray>b__0_2
    (System.Int64 x) [0x00015] in <21e4157412a347fba85a8aae58830ccd>:0 \n  at System.Linq.EnumerableSorter`2[TE"
  stdout: ''
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       if (ones > zeros) {\n            long temp = ones;\n            ones =
    zeros;\n            zeros = temp;\n        }\n        List<long> result = new
    List<long>();\n        long onesCount = 0;\n        long zerosCount = 0;\n        long
    maxCount = 0;\n        foreach (long i in arr) {\n            if (i == 1L) {\n
    \               onesCount++;\n            }\n            if (i == 0L) {\n                zerosCount++;\n
    \           }\n            if (i > max) {\n                maxCount++;\n            }\n
    \       }\n        long onesCount2 = onesCount * ones;\n        long zerosCount2
    = zerosCount * zeros;\n        long maxCount2 = maxCount * max;\n        long
    onesCount3 = onesCount2 * ones;\n        long zerosCount3 = zerosCount2 * zeros;\n
    \       long maxCount3 = maxCount2 * max;\n        long onesCount4 = onesCount3
    * ones;\n        long zerosCount4 = zerosCount3 * zeros;\n        long maxCount4
    = maxCount3 * max;\n        long onesCount5 = onesCount4 * ones;\n        long
    zerosCount5 = zerosCount4 * zeros;\n        long maxCount5 = maxCount4 * max;\n
    \       long onesCount6 = onesCount5 * ones;\n        long zerosCount6 = zerosCount5
    * zeros;\n        long maxCount6 = maxCount5 * max;\n        long onesCount7 =
    onesCount6 * ones;\n        long zerosCount7 = zerosCount6 * zeros;\n        long
    maxCount7 = maxCount6 * max;\n        long onesCount8 = onesCount7 * ones;\n        long
    zerosCount8 = zerosCount7 * zeros;\n        long maxCount8 = maxCount7 * max;\n
    \       long onesCount9 = onesCount8 * ones;\n        long zerosCount9 = zerosCount8
    * zeros;\n        long maxCount9 = maxCount8 * max;\n        long onesCount10
    = onesCount9 * ones;\n        long zerosCount10 = zerosCount9 * zeros;\n        long
    maxCount10 = maxCount9 * max;\n        long onesCount11 = onesCount10 * ones;\n
    \       long zerosCount11 = zerosCount10 * zeros;\n        long \n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmptk8ry0x0.cs(83,13): error CS1001: Identifier expected

    /tmp/tmptk8ry0x0.cs(83,13): error CS1002: ; expected

    '
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       List<long> res = new List<long>();\n        if (ones > zeros) {\n            long
    temp = ones;\n            ones = zeros;\n            zeros = temp;\n        }\n
    \       if (ones > 0) {\n            long temp = ones;\n            ones = 0;\n
    \           while (ones > 0) {\n                res.Add(min);\n                ones--;\n
    \           }\n        }\n        if (zeros > 0) {\n            long temp = zeros;\n
    \           zeros = 0;\n            while (zeros > 0) {\n                res.Add(max);\n
    \               zeros--;\n            }\n        }\n        if (ones > zeros)
    {\n            long temp = ones;\n            ones = zeros;\n            zeros
    = temp;\n        }\n        if (ones > 0) {\n            long temp = ones;\n            ones
    = 0;\n            while (ones > 0) {\n                res.Add(min);\n                ones--;\n
    \           }\n        }\n        if (zeros > 0) {\n            long temp = zeros;\n
    \           zeros = 0;\n            while (zeros > 0) {\n                res.Add(max);\n
    \               zeros--;\n            }\n        }\n        if (ones > zeros)
    {\n            long temp = ones;\n            ones = zeros;\n            zeros
    = temp;\n        }\n        if (ones > 0) {\n            long temp = ones;\n            ones
    = 0;\n            while (ones > 0) {\n                res.Add(min);\n                ones--;\n
    \           }\n        }\n        if (zeros > 0) {\n            long temp = zeros;\n
    \           zeros = 0;\n            while (zeros > 0) {\n                res.Add(max);\n
    \               zeros--;\n            }\n        }\n        if (ones > zeros)
    {\n            long temp = ones;\n            ones = zeros;\n            zeros
    = temp;\n        }\n        if (ones > 0) {\n            long temp = ones;\n            ones
    = 0;\n            while (ones > 0) {\n                res.Add(min);\n                ones--;\n
    \           }\n        }\n        if (zeros > 0) {\n            long temp = zeros;\n
    \           zeros = 0;\n            while (zeros > 0) {\n                res.Add(max);\n
    \               zeros--;\n            }\n        }\n        if (ones > zeros)
    {\n            long temp = ones;\n            ones = zeros;\n            zeros
    = temp;\n        }\n        if (ones > 0) {\n            long temp = ones;\n            \n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp8jircfn6.cs(132,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp8jircfn6.cs(143,2): error CS1513: } expected

    '
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long maxOnes
    = 0;\n        long maxZeros = 0;\n        long maxOnesCount = 0;\n        long
    maxZerosCount = 0;\n        long maxOnesCount2 = 0;\n        long maxZerosCount2
    = 0;\n        long maxOnesCount3 = 0;\n        long maxZerosCount3 = 0;\n        long
    maxOnesCount4 = 0;\n        long maxZerosCount4 = 0;\n        long maxOnesCount5
    = 0;\n        long maxZerosCount5 = 0;\n        long maxOnesCount6 = 0;\n        long
    maxZerosCount6 = 0;\n        long maxOnesCount7 = 0;\n        long maxZerosCount7
    = 0;\n        long maxOnesCount8 = 0;\n        long maxZerosCount8 = 0;\n        long
    maxOnesCount9 = 0;\n        long maxZerosCount9 = 0;\n        long maxOnesCount10
    = 0;\n        long maxZerosCount10 = 0;\n        long maxOnesCount11 = 0;\n        long
    maxZerosCount11 = 0;\n        long maxOnesCount12 = 0;\n        long maxZerosCount12
    = 0;\n        long maxOnesCount13 = 0;\n        long maxZerosCount13 = 0;\n        long
    maxOnesCount14 = 0;\n        long maxZerosCount14 = 0;\n        long maxOnesCount15
    = 0;\n        long maxZerosCount15 = 0;\n        long maxOnesCount16 = 0;\n        long
    maxZerosCount16 = 0;\n        long maxOnesCount17 = 0;\n        long maxZerosCount17
    = 0;\n        long maxOnesCount18 = 0;\n        long maxZerosCount18 = 0;\n        long
    maxOnesCount19 = 0;\n        long maxZerosCount19 = 0;\n        long maxOnesCount20
    = 0;\n        long maxZerosCount20 = 0;\n        long maxOnesCount21 = 0;\n        long
    maxZerosCount21 = 0;\n        long maxOnesCount22 = 0;\n        long maxZerosCount22
    = 0;\n        long maxOnesCount23 = 0;\n        long maxZerosCount23 = 0;\n        long
    maxOnesCount24 = 0;\n        long maxZerosCount24 = 0;\n        long maxOnesCount25
    = 0;\n        long maxZerosCount25 = 0;\n        long maxOnesCount26 = 0;\n        long
    maxZerosCount26 = 0;\n        long maxOnesCount\n    }\n    public static void
    Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpesxj2l0z.cs(76,26): error CS1002: ; expected

    '
  timestamp: 1659795181
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            else if (i == 0L) {\n
    \               zeros++;\n            }\n            else {\n                max
    = Math.Max(max, i);\n                min = Math.Min(min, i);\n            }\n
    \       }\n        long onesMax = ones * max;\n        long onesMin = ones * min;\n
    \       long zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long
    maxOnes = ones * max;\n        long maxZeros = zeros * max;\n        long minOnes
    = ones * min;\n        long minZeros = zeros * min;\n        long maxOnesMax =
    onesMax * max;\n        long maxOnesMin = onesMin * max;\n        long maxZerosMax
    = zerosMax * max;\n        long maxZerosMin = zerosMin * max;\n        long minOnesMax
    = onesMax * min;\n        long minOnesMin = onesMin * min;\n        long minZerosMax
    = zerosMax * min;\n        long minZerosMin = zerosMin * min;\n        long maxOnesMaxMin
    = onesMax * min;\n        long maxOnesMinMax = onesMin * max;\n        long maxZerosMaxMin
    = zerosMax * min;\n        long maxZerosMinMax = zerosMin * max;\n        long
    minOnesMaxMin = onesMax * min;\n        long minOnesMinMax = onesMin * min;\n
    \       long minZerosMaxMin = zerosMax * min;\n        long minZerosMinMax = zerosMin
    * min;\n        long maxOnesMaxMinMinMax = onesMax * min;\n        long maxOnesMinMaxMinMax
    = onesMin * max;\n        long maxZerosMaxMinMax = zerosMax * min;\n        long
    maxZerosMinMaxMinMax = zerosMin * max;\n        long minOnesMaxMinMax = onesMax
    * min;\n        long minOnesMinMaxMinMax = onesMin * min;\n        long minZerosMaxMinMax
    = zerosMax * min;\n        long minZerosMin\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L,
    (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L,
    (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new
    long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp_6pgbtw7.cs(67,25): error CS1002: ; expected

    '
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            }\n            if (i == 0L) {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMin = ones * min;\n        long zerosMin = zeros * min;\n        long onesAvg
    = ones * ones / arr.Count;\n        long zerosAvg = zeros * ones / arr.Count;\n
    \       long onesDiff = onesMax - onesAvg;\n        long zerosDiff = zerosMax
    - zerosAvg;\n        long onesDiffMin = onesMax - onesMin;\n        long zerosDiffMin
    = zerosMax - zerosMin;\n        long onesDiffAvg = onesMax - onesAvg;\n        long
    zerosDiffAvg = zerosMax - zerosAvg;\n        long onesDiffDiff = onesDiffMax -
    onesDiff;\n        long zerosDiffDiff = zerosDiffMax - zerosDiff;\n        long
    onesDiffDiffMin = onesDiffMax - onesDiffMin;\n        long zerosDiffDiffMin =
    zerosDiffMax - zerosDiffMin;\n        long onesDiffDiffAvg = onesDiffMax - onesDiffAvg;\n
    \       long zerosDiffDiffAvg = zerosDiffMax - zerosDiffAvg;\n        long onesDiffDiffDiff
    = onesDiffDiffMax - onesDiffDiff;\n        long zerosDiffDiffDiff = zerosDiffDiffMax
    - zerosDiffDiff;\n        long onesDiffDiffDiffMin = onesDiffDiffMax - onesDiffDiffMin;\n
    \       long zerosDiffDiffDiffMin = zerosDiffDiffMax - zerosDiffDiffMin;\n        long
    onesDiffDiffDiffAvg = onesDiffDiffMax - onesDiffDiffAvg;\n        long zerosDiffDiffDiffAvg
    = zerosDiffDiffMax - zerosDiffDiffAvg;\n        long onesDiffDiffDiffDiff = onesDiffDiffDiffMax
    - onesDiffDiffDiff;\n        long zerosDiffDiffDiffDiff = zerosDiffDiffDiffMax
    - zerosDiffDiffDiff;\n        long onesDiffDiffDiffDiffMin = onesDiffDiffDiffMax
    - ones\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp0h_u16fl.cs(64,66): error CS1002: ; expected

    '
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        List<long> result = new List<long>();\n        long ones = 0;\n
    \       long tens = 0;\n        long hundreds = 0;\n        long thousands = 0;\n
    \       long tenths = 0;\n        long oneths = 0;\n        long tenth = 0;\n
    \       long oneth = 0;\n        long tens = 0;\n        long hundreds = 0;\n
    \       long thousands = 0;\n        long tenths = 0;\n        long oneths = 0;\n
    \       long tenth = 0;\n        long oneth = 0;\n        long tens = 0;\n        long
    hundreds = 0;\n        long thousands = 0;\n        long tenths = 0;\n        long
    oneths = 0;\n        long tenth = 0;\n        long oneth = 0;\n        long tens
    = 0;\n        long hundreds = 0;\n        long thousands = 0;\n        long tenths
    = 0;\n        long oneths = 0;\n        long tenth = 0;\n        long oneth =
    0;\n        long tens = 0;\n        long hundreds = 0;\n        long thousands
    = 0;\n        long tenths = 0;\n        long oneths = 0;\n        long tenth =
    0;\n        long oneth = 0;\n        long tens = 0;\n        long hundreds = 0;\n
    \       long thousands = 0;\n        long tenths = 0;\n        long oneths = 0;\n
    \       long tenth = 0;\n        long oneth = 0;\n        long tens = 0;\n        long
    hundreds = 0;\n        long thousands = 0;\n        long tenths = 0;\n        long
    oneths = 0;\n        long tenth = 0;\n        long oneth = 0;\n        long tens
    = 0;\n        long hundreds = 0;\n        long thousands = 0;\n        long tenths
    = 0;\n        long oneths = 0;\n        long tenth = 0;\n        long oneth =
    0;\n        long tens = 0;\n        long hundreds = 0;\n        long thousands
    = 0;\n        long tenths = 0;\n        long oneths = 0;\n        long tenth =
    0;\n        long oneth = 0;\n        long tens = 0;\n        long hundreds = 0;\n
    \       long thousands = 0;\n        long tenths = 0;\n        long oneths = 0;\n
    \       long tenth = 0;\n        long oneth = 0;\n        long tens = 0;\n        long
    hundreds = 0;\n        long thousands = 0;\n        long tenths = 0;\n        long
    oneths = 0;\n        long tenth = 0;\n        long oneth = 0;\n        long tens
    = 0;\n        long hundreds = 0;\n        long thousands = 0;\n        long tenths
    = 0;\n        long oneths = 0;\n        long tenth = 0;\n        long oneth =
    0;\n        long tens = 0;\n\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpu_1djpxj.cs(29,14): error CS0128: A local variable or function named ''tens''
    is already defined in this scope

    /tmp/tmpu_1djpxj.cs(30,14): error CS0128: A local variable or function named ''hundreds''
    is already defined in this scope

    /tmp/tmpu_1djpxj.cs(31,14): error CS0128: A local variable or function named ''thousands''
    is already defined in this scope

    /tmp/tmpu_1djpxj.cs(32,14): error CS0128: A local variable or function named ''tenths''
    is already defined in this scope

    /tmp/tmpu_1djpxj.cs(33,14): error CS0128: A local variable or function named ''oneths''
    is already defined in this scope

    /tmp/tmpu_1djpxj.cs(34,14): error CS0128: A local variable or function named ''tenth''
    is already defined in this scope

    /tmp/tmpu_1djpxj.cs(35,14): error CS0128: A local variable or function named ''oneth''
    is already defined in this scope

    /tmp/tmpu_1djpxj.cs(36,14): error CS0128: A local variable or function named ''tens''
    is already defined in this scope

    /tmp/tmpu_1djpxj.cs(37,14): error CS0128: A local variable or function named ''hundreds''
    is already defined in this scope

    /tmp/tmpu_1djpxj.cs(38,14): error CS0128: A local variable or function named ''thousands''
    is already defined in this scope

    /tmp/tmpu_1djpxj.cs(39,14): error CS0128: A local variable or function named ''tenths''
    is already defined in this scope

    /tmp/tmpu_1djpxj.cs(40,14): error CS0128: A local variable or function named ''oneths''
    is already defined in this scope

    /tmp/tmpu_1djpxj.cs(41,14): error CS0128: A local variable or function named ''tenth''
    is already defined in this scope

    /tmp/tmpu_1djpxj.cs(42,14): error CS0128: A local variable or function named ''oneth''
    is already defined in this scope

    /tmp/tmpu_1djpxj.cs(43,14): error CS0128: A local variable or function named ''tens''
    is already defined in this scope

    /tmp/tmpu_1djpxj.cs(44,14): error CS0128: A local variable or function named ''hundreds''
    is already defined in this scope

    /tmp/tmpu_1djpx'
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            } else {\n                zeros++;\n
    \           }\n            if (i > max) {\n                max = i;\n            }\n
    \           if (i < min) {\n                min = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long onesMin = ones * min;\n        long
    zerosMax = zeros * max;\n        long zerosMin = zeros * min;\n        long maxOnes
    = ones * max;\n        long maxZeros = zeros * max;\n        long minOnes = ones
    * min;\n        long minZeros = zeros * min;\n        long maxOnesMax = onesMax
    * max;\n        long maxOnesMin = onesMin * max;\n        long maxZerosMax = zerosMax
    * max;\n        long maxZerosMin = zerosMin * max;\n        long minOnesMax =
    onesMax * min;\n        long minOnesMin = onesMin * min;\n        long minZerosMax
    = zerosMax * min;\n        long minZerosMin = zerosMin * min;\n        long maxOnesMaxMin
    = onesMax * min;\n        long maxOnesMinMax = onesMin * max;\n        long maxZerosMaxMin
    = zerosMax * min;\n        long maxZerosMinMax = zerosMin * max;\n        long
    minOnesMaxMin = onesMax * min;\n        long minOnesMinMax = onesMin * min;\n
    \       long minZerosMaxMin = zerosMax * min;\n        long minZerosMinMax = zerosMin
    * min;\n        long maxOnesMaxMinMax = onesMax * min;\n        long maxOnesMinMaxMax
    = onesMin * max;\n        long maxZerosMaxMinMax = zerosMax * min;\n        long
    maxZerosMinMaxMax = zerosMin * max;\n        long minOnesMaxMinMax = onesMax *
    min;\n        long minOnesMinMaxMax = onesMin * min;\n        long minZerosMaxMinMax
    = zerosMax * min;\n        long minZerosMinMaxMax = zerosMin * max;\n\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp7k614q85.cs(19,30): error CS0161: ''Problem.SortArray(List<long>)'': not
    all code paths return a value

    '
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       long min = 0;\n        foreach (long i in arr) {\n            if (i ==
    1L) {\n                ones++;\n            } else if (i == 0L) {\n                zeros++;\n
    \           } else {\n                if (ones > zeros) {\n                    max
    = i;\n                } else if (ones < zeros) {\n                    min = i;\n
    \               }\n            }\n        }\n        List<long> result = new List<long>();\n
    \       if (ones > zeros) {\n            result.Add(min);\n            result.AddRange(arr.Where(i
    => i != min).OrderBy(i => Math.Abs(i - min)).Take(ones - 1).ToList());\n            result.Add(max);\n
    \           result.AddRange(arr.Where(i => i != max).OrderBy(i => Math.Abs(i -
    max)).Take(zeros - 1).ToList());\n        } else {\n            result.Add(max);\n
    \           result.AddRange(arr.Where(i => i != max).OrderBy(i => Math.Abs(i -
    max)).Take(ones - 1).ToList());\n            result.Add(min);\n            result.AddRange(arr.Where(i
    => i != min).OrderBy(i => Math.Abs(i - min)).Take(zeros - 1).ToList());\n        }\n
    \       return result;\n    }\n    public static void Main(string[] args) {\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)5L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)4L,
    (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L,
    (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L,
    (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n
    \   Debug.Assert(SortArray((new List<long>())).Equals((new List<long>())));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)5L, (long)77L,
    (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)2L, (long)4L, (long)4L, (long)3L, (long)3L,
    (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)3L, (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new
    List<long>(new long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new
    long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpps8luk54.cs(40,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpps8luk54.cs(42,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpps8luk54.cs(45,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    /tmp/tmpps8luk54.cs(47,91): error CS1503: Argument 2: cannot convert from ''long''
    to ''int''

    '
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       List<long> result = new List<long>();\n        long onesMax = 0;\n        long
    zerosMax = 0;\n        long maxMax = 0;\n        long onesMin = 0;\n        long
    zerosMin = 0;\n        long maxMin = 0;\n        long onesMaxMin = 0;\n        long
    zerosMaxMin = 0;\n        long maxMaxMin = 0;\n        long onesMinMax = 0;\n
    \       long zerosMinMax = 0;\n        long maxMinMax = 0;\n        long onesMaxMinMax
    = 0;\n        long zerosMaxMinMax = 0;\n        long maxMaxMinMax = 0;\n        long
    onesMinMaxMax = 0;\n        long zerosMinMaxMinMax = 0;\n        long maxMinMaxMinMax
    = 0;\n        long onesMaxMinMaxMax = 0;\n        long zerosMaxMinMaxMinMax =
    0;\n        long maxMaxMinMaxMinMax = 0;\n        long onesMinMaxMaxMax = 0;\n
    \       long zerosMinMaxMinMaxMinMax = 0;\n        long maxMinMaxMinMaxMinMax
    = 0;\n        long onesMaxMinMaxMax = 0;\n        long zerosMinMaxMinMaxMinMax
    = 0;\n        long maxMaxMinMaxMinMax = 0;\n        long onesMinMaxMaxMax = 0;\n
    \       long zerosMinMaxMinMaxMinMax = 0;\n        long maxMinMaxMinMaxMinMax
    = 0;\n        long onesMaxMinMaxMax = 0;\n        long zerosMinMaxMinMaxMinMax
    = 0;\n        long maxMaxMinMaxMinMax = 0;\n        long onesMinMaxMaxMax = 0;\n
    \       long zerosMinMaxMinMaxMinMax = 0;\n        long maxMinMaxMinMaxMinMax
    = 0;\n        long onesMaxMinMaxMax = 0;\n        long zerosMinMaxMinMaxMinMax
    = 0;\n        long maxMaxMinMaxMinMax = 0;\n        long onesMinMaxMaxMax = 0;\n
    \       long zerosMinMaxMinMaxMinMax = 0;\n        long maxMinMaxMinMaxMinMax
    = 0;\n        long onesMaxMinMaxMax = 0;\n        long zerosMinMaxMinMaxMinMax
    = 0;\n        long maxMaxMinMaxMinMax = 0;\n        long onesMinMaxMaxMax = 0;\n
    \       long zerosMinMaxMinMaxMinMax = 0;\n        long maxMinMax\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpovopu4lp.cs(82,23): error CS1002: ; expected

    '
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones * max;\n        long zerosMax = zeros * max;\n        long
    onesMin = ones * min - 1;\n        long zerosMin = zeros * min - 1;\n        long
    onesMaxMin = onesMax * min;\n        long zerosMaxMin = zerosMax * min;\n        long
    onesMinMin = onesMin * min;\n        long zerosMinMin = zerosMin * min;\n        long
    onesMaxMinMin = onesMaxMin * min;\n        long zerosMaxMinMin = zerosMaxMin *
    min;\n        long onesMinMinMin = onesMinMin * min;\n        long zerosMinMinMin
    = zerosMinMin * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n        long
    zerosMaxMinMinMin = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin
    * min;\n        long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin
    = onesMaxMinMin * min;\n        long zerosMaxMinMinMin = zerosMaxMinMin * min;\n
    \       long onesMinMinMinMin = onesMinMinMin * min;\n        long zerosMinMinMinMin
    = zerosMinMinMin * min;\n        long onesMaxMinMinMin = onesMaxMinMin * min;\n
    \       long zerosMaxMinMinMin = zerosMaxMinMin * min;\n        long onesMinMinMinMin
    = onesMinMinMin * min;\n        long zerosMinMinMinMin = zerosMinMinMin * min;\n
    \       long onesMaxMinMinMin = onesMaxMinMin * min;\n        long zerosMaxMinMinMin
    = zerosMaxMinMin * min;\n        long onesMinMinMinMin = onesMinMinMin * min;\n
    \       long zerosMinMinMinMin = zerosMinMinMin * min;\n        long onesMaxMinMinMin
    = onesMaxMinMin * min;\n        long zerosMaxMinMin\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)1L,
    (long)2L, (long)4L, (long)3L, (long)5L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L}))).Equals((new
    List<long>(new long[]{(long)-4L, (long)-2L, (long)-6L, (long)-5L, (long)-3L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)0L, (long)1L, (long)2L,
    (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new List<long>())).Equals((new
    List<long>())));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)2L,
    (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L, (long)7L, (long)2L,
    (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)2L, (long)4L,
    (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L, (long)7L, (long)77L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)3L, (long)6L, (long)44L,
    (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new long[]{(long)32L,
    (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpctsueop7.cs(63,28): error CS1002: ; expected

    '
  timestamp: 1659823605
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones;\n        long zerosMax = zeros;\n        long maxMax
    = max;\n        long onesMin = ones;\n        long zerosMin = zeros;\n        long
    maxMin = max;\n        long onesMaxMin = ones;\n        long zerosMaxMin = zeros;\n
    \       long maxMaxMin = max;\n        long onesMinMin = ones;\n        long zerosMinMin
    = zeros;\n        long maxMinMin = max;\n        long onesMaxMinMin = ones;\n
    \       long zerosMaxMinMin = zeros;\n        long maxMaxMinMin = max;\n        long
    onesMinMinMin = ones;\n        long zerosMinMinMin = zeros;\n        long maxMinMinMin
    = max;\n        long onesMaxMinMinMin = ones;\n        long zerosMaxMinMinMin
    = zeros;\n        long maxMaxMinMinMin = max;\n        long onesMinMinMinMin =
    ones;\n        long zerosMinMinMinMin = zeros;\n        long maxMinMinMinMin =
    max;\n        long onesMaxMinMinMin = ones;\n        long zerosMaxMinMinMin =
    zeros;\n        long maxMaxMinMinMin = max;\n        long onesMinMinMinMin = ones;\n
    \       long zerosMinMinMinMin = zeros;\n        long maxMinMinMinMin = max;\n
    \       long onesMaxMinMinMin = ones;\n        long zerosMaxMinMinMin = zeros;\n
    \       long maxMaxMinMinMin = max;\n        long onesMinMinMinMin = ones;\n        long
    zerosMinMinMinMin = zeros;\n        long maxMinMinMinMin = max;\n        long
    onesMaxMinMinMin = ones;\n        long zerosMaxMinMinMin = zeros;\n        long
    maxMaxMinMinMin = max;\n        long onesMinMinMinMin = ones;\n        long zerosMinMinMinMin
    = zeros;\n        long maxMinMinMinMin = max;\n        long onesMaxMinMinMin =
    ones;\n\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp2353w6wk.cs(58,14): error CS0128: A local variable or function named ''onesMaxMinMinMin''
    is already defined in this scope

    /tmp/tmp2353w6wk.cs(59,14): error CS0128: A local variable or function named ''zerosMaxMinMinMin''
    is already defined in this scope

    /tmp/tmp2353w6wk.cs(60,14): error CS0128: A local variable or function named ''maxMaxMinMinMin''
    is already defined in this scope

    /tmp/tmp2353w6wk.cs(61,14): error CS0128: A local variable or function named ''onesMinMinMinMin''
    is already defined in this scope

    /tmp/tmp2353w6wk.cs(62,14): error CS0128: A local variable or function named ''zerosMinMinMinMin''
    is already defined in this scope

    /tmp/tmp2353w6wk.cs(63,14): error CS0128: A local variable or function named ''maxMinMinMinMin''
    is already defined in this scope

    /tmp/tmp2353w6wk.cs(64,14): error CS0128: A local variable or function named ''onesMaxMinMinMin''
    is already defined in this scope

    /tmp/tmp2353w6wk.cs(65,14): error CS0128: A local variable or function named ''zerosMaxMinMinMin''
    is already defined in this scope

    /tmp/tmp2353w6wk.cs(66,14): error CS0128: A local variable or function named ''maxMaxMinMinMin''
    is already defined in this scope

    /tmp/tmp2353w6wk.cs(67,14): error CS0128: A local variable or function named ''onesMinMinMinMin''
    is already defined in this scope

    /tmp/tmp2353w6wk.cs(68,14): error CS0128: A local variable or function named ''zerosMinMinMinMin''
    is already defined in this scope

    /tmp/tmp2353w6wk.cs(69,14): error CS0128: A local variable or function named ''maxMinMinMinMin''
    is already defined in this scope

    /tmp/tmp2353w6wk.cs(70,14): error CS0128: A local variable or function named ''onesMaxMinMinMin''
    is already defined in this scope

    /tmp/tmp2353w6wk.cs(71,14): error CS0128: A local variable or function named ''zerosMaxMinMinMin''
    is already defined in this scope

    /tmp/tmp2353w6wk.cs(72,14): error CS0128: A local variable or function named ''maxMaxMinMinMin''
    is already defined '
  timestamp: 1659823608
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long maxOnes
    = 0;\n        long maxZeros = 0;\n        long max = 0;\n        foreach (long
    i in arr) {\n            if (i == 1L) {\n                ones++;\n                if
    (ones > maxOnes) maxOnes = ones;\n            } else {\n                zeros++;\n
    \               if (zeros > maxZeros) maxZeros = zeros;\n            }\n        }\n
    \       if (maxOnes > maxZeros) max = maxOnes;\n        else max = maxZeros;\n
    \       long onesCount = 0;\n        long zerosCount = 0;\n        long maxOnesCount
    = 0;\n        long maxZerosCount = 0;\n        long maxCount = 0;\n        foreach
    (long i in arr) {\n            if (i == 1L) {\n                onesCount++;\n
    \               if (onesCount > maxOnesCount) maxOnesCount = onesCount;\n            }
    else {\n                zerosCount++;\n                if (zerosCount > maxZerosCount)
    maxZerosCount = zerosCount;\n            }\n        }\n        if (maxOnesCount
    > maxZerosCount) maxCount = maxOnesCount;\n        else maxCount = maxZerosCount;\n
    \       long onesSum = 0;\n        long zerosSum = 0;\n        long maxOnesSum
    = 0;\n        long maxZerosSum = 0;\n        long maxSum = 0;\n        foreach
    (long i in arr) {\n            if (i == 1L) {\n                onesSum += i;\n
    \               if (onesSum > maxOnesSum) maxOnesSum = onesSum;\n            }
    else {\n                zerosSum += i;\n                if (zerosSum > maxZerosSum)
    maxZerosSum = zerosSum;\n            }\n        }\n        if (maxOnesSum > maxZerosSum)
    maxSum = maxOnesSum;\n        else maxSum = maxZerosSum;\n        long onesAvg
    = 0;\n        long zerosAvg = 0;\n        long maxOnesAvg = 0;\n        long maxZerosAvg
    = 0;\n        long maxAvg = 0;\n        foreach (long i in arr) {\n            if
    (i == 1L) {\n                onesAvg += i;\n                if (onesAvg > maxOnesAvg)
    maxOnesAvg = onesAvg;\n            } else {\n                zerosAvg += i;\n
    \               if (zerosAvg > maxZerosAvg) maxZerosAvg = zerosAvg;\n            }\n
    \       }\n        if (maxOnesAvg > maxZerosAvg) maxAvg = maxOnesAvg;\n        else
    maxAvg = \n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp7yp27pg5.cs(83,22): error CS1525: Invalid expression term ''}''

    /tmp/tmp7yp27pg5.cs(83,22): error CS1002: ; expected

    '
  timestamp: 1659823607
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // In this Kata, you have to sort an array of non-negative integers
    according to\n    // number of ones in their binary representation in ascending
    order.\n    // For similar number of ones, sort based on decimal value.\n    //
    It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,
    (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,
    (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new
    long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new
    List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n
    \   // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L,
    (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L,
    (long)2L, (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long>
    arr) {\n        long ones = 0;\n        long zeros = 0;\n        long max = 0;\n
    \       foreach (long i in arr) {\n            if (i == 1L) {\n                ones++;\n
    \           }\n            if (i == 0L) {\n                zeros++;\n            }\n
    \           if (i > max) {\n                max = i;\n            }\n        }\n
    \       long onesMax = ones > zeros ? ones : zeros;\n        long zerosMax = zeros
    > ones ? zeros : ones;\n        long maxMax = max > onesMax ? max : onesMax;\n
    \       List<long> result = new List<long>();\n        long onesCount = 0;\n        long
    zerosCount = 0;\n        long maxCount = 0;\n        foreach (long i in arr) {\n
    \           if (i == 1L) {\n                onesCount++;\n            }\n            if
    (i == 0L) {\n                zerosCount++;\n            }\n            if (i >
    maxCount) {\n                maxCount = i;\n            }\n            if (i ==
    maxCount) {\n                result.Add(i);\n            }\n        }\n        long
    onesCountMax = onesCount > zerosCount ? onesCount : zerosCount;\n        long
    zerosCountMax = zerosCount > onesCount ? zerosCount : onesCount;\n        long
    maxCountMax = maxCount > onesCountMax ? maxCount : onesCountMax;\n        long
    onesMaxCount = 0;\n        long zerosMaxCount = 0;\n        long maxMaxCount =
    0;\n        foreach (long i in arr) {\n            if (i == 1L) {\n                onesMaxCount++;\n
    \           }\n            if (i == 0L) {\n                zerosMaxCount++;\n
    \           }\n            if (i > maxMaxCount) {\n                maxMaxCount
    = i;\n            }\n            if (i == maxMaxCount) {\n                result.Add(i);\n
    \           }\n        }\n        long onesMaxCountMax = onesMaxCount > zerosMaxCount
    ? onesMaxCount : zerosMaxCount;\n        long zerosMaxCountMax = zerosMaxCount
    > onesMaxCount ? zerosMaxCount : onesMaxCount;\n        long maxMaxCountMax =
    maxMaxCount > onesMaxCountMax ? maxMaxCount : onesMaxCountMax;\n        long onesMaxMaxCount
    = 0;\n        long zerosMaxMaxCount = 0;\n        long maxMaxMaxCount = 0;\n        foreach
    (long i in arr) {\n            if (i == 1L) {\n                onesMaxMaxCount++;\n
    \           }\n            if (i == 0L) {\n                zerosMaxMaxCount++;\n
    \           }\n            if (i > maxMaxMaxCount) {\n                maxMaxMaxCount
    = i;\n\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new
    List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,
    (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,
    (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new
    long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new
    List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new
    long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,
    (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,
    (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,
    (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,
    (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new
    long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n    Debug.Assert(SortArray((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new
    List<long>(new long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n
    \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,
    (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,
    (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp1x3sropd.cs(92,5): error CS0106: The modifier ''public'' is not valid
    for this item

    /tmp/tmp1x3sropd.cs(103,2): error CS1513: } expected

    '
  timestamp: 1659823608
