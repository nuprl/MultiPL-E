name: HumanEval_59_largest_prime_factor
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
  \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n\
  // 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long n)\
  \ {\n"
tests: "}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
  \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
  \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
  }\n"
completions: ["    long m = n;\n    while (m % 2 == 0) m /= 2;\n    while (m % 3 ==\
    \ 0) m /= 3;\n    while (m % 5 == 0) m /= 5;\n    while (m % 7 == 0) m /= 7;\n\
    \    return m;", "    long a = 2, b = 2, c = n, d = 1, e;\n    while (c > 1) {\n\
    \        while (c % 2 == 0) {\n            c = c / 2;\n        }\n        if (c\
    \ * b > n) {\n            b = b;\n            d = c;\n        }\n        while\
    \ (b * d < n) {\n            while (d % 2 == 0) {\n                d = d / 2;\n\
    \            }\n            if (b * d > n) {\n                d = c;\n       \
    \         c = b;\n            }\n            b = b * 2;\n        }\n        a\
    \ = a + 1;\n        c = n - 1;\n        b = b - 1;\n    }\n    return d;", " \
    \ int max_factor = 3;\n  int i = 3;\n  while (i <= sqrt(n)) {\n    if (n % i ==\
    \ 0) {\n      max_factor = i;\n    } else {\n      i++;\n    }\n  }\n  return\
    \ max_factor;", "    long f=0;\n    long p=2;\n    while(p*p<=n)\n    {\n    \
    \    f=p*p;\n        if(n%f)\n            break;\n        p++;\n    }\n    return\
    \ f;", "\tif (n == 1) return 1;\n\tlong p = 2;\n\twhile (p < n)\n\t{\n\t\twhile\
    \ (n % p == 0 && p < n / p)\n\t\t\tp++;\n\t\tif (p > n) break;\n\t}\n\treturn\
    \ p;", "    long max_prime = n;\n    int i = 2;\n    while (max_prime % i == 0)\
    \ {\n        max_prime /= i;\n        i++;\n    }\n    return max_prime;", " \
    \  long i;\n   int count = 3; // Sieve of Eratosthenes\n   long num = 2;\n   for(i=3;i<=n;i+=2)\
    \ {\n      // Only odd factors matter\n      if(num%i==0) {\n         long m =\
    \ num;\n         while(m % i == 0) {\n            m = m/i;\n         }\n     \
    \    if(m>count) {\n            count = m;\n         }\n      }\n   }\n   return\
    \ num;", "    assert(n > 1);\n    long factor = 1;\n    for (int i = 3; i <= n;\
    \ i += 2) {\n        while (n % i == 0) {\n            factor = i;\n         \
    \   n /= i;\n        }\n    }\n    return factor;", "  assert(n > 1 && n != -1);\n\
    \  long factor = 1;\n  long max_factor = 1;\n  long max_factor_index = 0;\n\n\
    \  for(int i = 2; i < n; ++i) {\n    if (n % i == 0) {\n      // The i^th prime\
    \ factor of n is n%i\n      factor *= i;\n      // Check if its largest factor\
    \ has already been computed.\n      if (factor > max_factor) {\n        max_factor\
    \ = factor;\n        max_factor_index = i;\n      }\n    }\n  }\n\n  // If n has\
    \ a prime factor, then the largest prime factor is n.\n  if (max_factor != 1)\
    \ {\n    factor *= n;\n  }\n\n  return factor;", "    long p = 0;\n    long q\
    \ = n;\n    long r = 1;\n    long s = 1;\n    long limit = (long)sqrt(n) + 1;\n\
    \    while (true) {\n        if (n % p == 0) {\n            p = p;\n         \
    \   q += p;\n        } else if (q == 1) {\n            p += 1;\n            q\
    \ = 2;\n        } else {\n            if (n % q == 0) {\n                q +=\
    \ p;\n            } else if (p == 1 && q == 2) {\n                p += 1;\n  \
    \              q = 1;\n            } else {\n                q += s;\n       \
    \     }\n            p = 2;\n        }\n        limit = limit / p;\n        if\
    \ ((limit * p) > n) {\n            r = 1;\n            limit = limit * s;\n  \
    \          limit += 1;\n        } else {\n            if (limit > 1) {\n     \
    \           s = p;\n            }\n        }\n        if (r > limit) {\n     \
    \       break;\n        }\n    }\n    return p;", "    int largest = n;\n    long\
    \ p = 2;\n    bool isPrime = true;\n    // Check for primes up to sqrt(n).\n \
    \   while (p <= n / p) {\n        if (n % p == 0) {\n            isPrime = false;\n\
    \            break;\n        }\n        p += 1;\n    }\n    if (isPrime) {\n \
    \       // check for composite numbers up to sqrt(n)\n        while (p <= n /\
    \ p) {\n            if (n % p == 0) {\n                largest = p;\n        \
    \        break;\n            }\n            p += 1;\n        }\n    } else {\n\
    \        // check for composite numbers up to sqrt(n)\n        while (p <= n /\
    \ p) {\n            p += 1;\n        }\n    }\n    return largest;", "    long\
    \ result = 2;\n    long p = n;\n    while (p % 2 == 0) {\n        p /= 2;\n  \
    \      ++result;\n    }\n    for (long i = 3; i <= p / 2; i += 2) {\n        while\
    \ (n % i == 0) {\n            n /= i;\n            ++result;\n        }\n    }\n\
    \    return result;", "    assert(n > 2);\n    // Sieve of Eratosthenes. \n  \
    \  // https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes \n    // https://stackoverflow.com/questions/5382539/prime-factors-in-c\n\
    \    std::vector<long> primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127,\
    \ 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,\
    \ 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307,\
    \ 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401,\
    \ 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,\
    \ 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,\
    \ 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709,\
    \ 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823,\
    \ 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937,\
    \ 941, 947, 953, 967, 971, 977, 983, 991, 997};\n    // The first 2 primes are\
    \ 2, 3.\n    // If the input is 2 then it is not prime, so the largest prime factor\
    \ is 2.\n    // If n is not prime, then 2 is the first prime that divides n, so\
    \ it is its largest prime factor.\n    std::vector<long> result{2, 3};\n    long\
    \ factor = 2;\n    while (n > 2) {\n        if (n % primes[factor]) {\n      \
    \      factor++;\n        }\n        else {\n            result.push_back(factor);\n\
    \            n /= primes[factor];\n        }\n    }\n    return result.size()\
    \ > 1 ? result.at(1) : 2;", "    int l = 1;\n    while (n != 2) {\n        l =\
    \ ((n / l) * l) + 1;\n        n = n / l;\n    }\n    return l;", "    long res\
    \ = n;\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n    while (n % 3 ==\
    \ 0) {\n        n /= 3;\n    }\n    while (n % 5 == 0) {\n        n /= 5;\n  \
    \  }\n    while (n % 7 == 0) {\n        n /= 7;\n    }\n    while (n % 11 == 0)\
    \ {\n        n /= 11;\n    }\n    while (n % 13 == 0) {\n        n /= 13;\n  \
    \  }\n    while (n % 17 == 0) {\n        n /= 17;\n    }\n    while (n % 19 ==\
    \ 0) {\n        n /= 19;\n    }\n    while (n % 23 == 0) {\n        n /= 23;\n\
    \    }\n    while (n % 29 == 0) {\n        n /= 29;\n    }\n    while (n % 31\
    \ == 0) {\n        n /= 31;\n    }\n    while (n % 37 == 0) {\n        n /= 37;\n\
    \    }\n    while (n % 41 == 0) {\n        n /= 41;\n    }\n    while (n % 43\
    \ == 0) {\n        n /= 43;\n    }\n    while (n % 47 == 0) {\n        n /= 47;\n\
    \    }\n    while (n % 53 == 0) {\n        n /= 53;\n    }\n    while (n % 59\
    \ == 0) {\n        n /= 59;\n    }\n    while (n % 61 == 0) {\n        n /= 61;\n\
    \    }\n    while (n % 67 == 0) {\n        n /= 67;\n    }\n    while (n % 73\
    \ == 0) {\n        n /= 73;\n    }\n    while (n % 79 == 0) {\n        n /= 79;\n\
    \    }\n    while (n % 83 == 0) {\n        n /= 83;\n    }\n    while (n % 89\
    \ == 0) {\n        n /= 89;\n    }\n    while (n % 97 == 0) {\n        n /= 97;\n\
    \    }\n    while (n % 103 == 0) {\n        n /= 103;\n    }\n    while (n % 109\
    \ == 0) {\n        n /= 109;\n    }\n    while (n % 127 == 0) {\n        n /=\
    \ 127;\n    }\n    while (n % 135 == 0) {\n        n /= 135;\n    }\n    while\
    \ (n % 141 == 0) {\n        n /= 141;\n    }\n    while (n % 147 == 0) {\n   \
    \     n /= 147;\n    }\n    while (n % 153 == 0) {\n        n /= 153;\n    }\n\
    \    while (n % 159 == 0) {\n        n /= 159;\n    }\n    while (n % 163 == 0)\
    \ {\n        n /= 163;\n    }\n    while (n % 167 == 0) {\n        n /= 167;\n\
    \    }\n    while (n % 173 == 0) {\n        n /= 173;\n    }\n    while (n % 179\
    \ == 0) {\n        n /= 179;\n    }\n    while (n % 183 == 0) {\n        n /=\
    \ 183;\n    }\n    while (n % 189 == 0) {\n        n /= 189;\n    }\n    while\
    \ (n % 193 == 0) {\n        n /= 193;\n    }\n    while (", "    long i = 2;\n\
    \    long largest = i;\n    long largestPrime = 2;\n    while (n%i == 0) {\n \
    \       n = n/i;\n        largest = i;\n        largestPrime = 2;\n        i++;\n\
    \    }\n    return largestPrime;", "    assert(n > 1 && \"The argument must be\
    \ greater than 1\");\n    long i = 3, nfactor = 1;\n    while (i > 1) {\n    \
    \    while ((n % i) == 0) {\n            n = n / i;\n            nfactor++;\n\
    \        }\n        i--;\n    }\n    return nfactor;", "    int n = 1;\n    int\
    \ res = 1;\n    while (n%2 == 0) {\n        n = n/2;\n        res = res+1;\n \
    \   }\n    while (n % 3 == 0) {\n        n = n/3;\n        res = res+1;\n    }\n\
    \    while (n % 5 == 0) {\n        n = n/5;\n        res = res+1;\n    }\n   \
    \ while (n % 7 == 0) {\n        n = n/7;\n        res = res+1;\n    }\n    return\
    \ res;", "    long long count = 0;\n    for (long long i = 2; i * i <= n; i++)\n\
    \        if (n % i == 0) {\n            count++;\n            if (count > n) {\n\
    \                return n;\n            }\n            n /= i;\n        }\n  \
    \  return n;", "  assert(n > 1);\n  if (n == 1) return 1;\n  if (n == 2) return\
    \ 2;\n  if (n % 2 == 0) return n;\n  long result = 3;\n  while (n % result ==\
    \ 0) {\n    if (result > n) return n;\n    result *= 2;\n  }\n  return n;", " \
    \   long res = 1;\n    long d = 2;\n    long r = n - 1;\n    long t = n;\n   \
    \ while (t % d == 0) {\n        res = d;\n        t /= d;\n    }\n    return res;",
  "    long factor = 2;\n    while ((n % factor) == 0) {\n        ++factor;\n    }\n\
    \    return factor;", "    long pf;\n    // Start with 2 as a base and increment\
    \ by 2 for each factor found. \n    // The base is always odd. \n    for (long\
    \ i = 2; i <= n / 2; ++i) {\n        // If i divides n, n is prime. \n       \
    \ if (n % i == 0) pf = i;\n        // If i is a factor of n then divide n by i\
    \ \n        else n /= i;\n    }\n    return pf;", "  assert(n > 1);\n  long p\
    \ = 0;\n  long m = n;\n  while (m % 2 == 0)\n    m /= 2;\n  while (m % 3 == 0)\n\
    \    m /= 3;\n  while (m % 5 == 0)\n    m /= 5;\n  while (m % 7 == 0)\n    m /=\
    \ 7;\n  long max_factor = m * 2;\n  while (p * p <= max_factor) {\n    p = p +\
    \ 1;\n    if (p > m) {\n      max_factor = p * 2;\n    } else {\n      max_factor\
    \ = p;\n      break;\n    }\n  }\n  return p;", "    long x = 2;\n    while ((n\
    \ % x) == 0) {\n        x += x;\n    }\n    return x;", "    long i, largest_factor\
    \ = 1;\n    for(i = 2; i < n; i++){\n        if(n%i == 0){\n            largest_factor\
    \ = i;\n            break;\n        }\n    }\n    return largest_factor;", " \
    \   // Check factors of n from 2 to n\n    for (int i = 2; i <= n / i; i++) {\n\
    \        if (n % i == 0) {\n            n /= i;\n            break;\n        }\n\
    \    }\n    return n;", "    long p = 2;\n    while ( p < n / p ) {\n        ++p;\n\
    \    }\n    return p;", "    long max_factor = 2;\n    for (long i = 2; i <= n\
    \ / 2; i++) {\n        if (n % i == 0) {\n            max_factor = i;\n      \
    \  }\n    }\n    return max_factor;", "    if (n < 2) return 1;\n    long i =\
    \ 2;\n    while (i * i < n) {\n        if (n % i == 0) return i;\n        i =\
    \ i + 2;\n    }\n    return n;", "    if (n == 1) return 2;\n    long m = n;\n\
    \    long lsq = 1;\n    long t = 2;\n    while (m > 1) {\n        lsq = lsq *\
    \ t + (m & 1);\n        m = m/2;\n        t = t + 1;\n    }\n    return lsq;",
  "    // write your code here\n    long p = 2;\n    while (p < n)\n    {\n      \
    \  long q = n%p;\n        if (q == 0)\n        {\n            break;\n       \
    \ }\n        p = q;\n    }\n    return p;", "  if (n == 1)\n    return n;\n  long\
    \ l = 2;\n  while (l < n) \n    { \n      if ((n % l) == 0)\n        return l;\
    \ \n      l++; \n    }\n  return n;", "    long largest_factor = 1;\n    long\
    \ factor = 2;\n    long limit = (long)sqrt(n);\n    while (factor <= limit) {\n\
    \        if (n % factor == 0) {\n            largest_factor = factor;\n      \
    \      break;\n        }\n        factor++;\n    }\n    return largest_factor;",
  "    // your code goes here\n    long ans=2;\n    long k=n;\n    while(k>1 && k%2==0)\n\
    \        k=k/2;\n    while(k%2==0)\n        k=k/2;\n    for(int i=3;i*i<=k;i*=2)\
    \ {\n        if(k%i==0)\n            ans=i;\n    }\n    return ans;", "    long\
    \ largest = 2;\n    for (long i = 3; i <= n; i += 2)\n        if (n % i == 0)\n\
    \            largest = i;\n    return largest;", "    long i = 2;\n    while (i\
    \ <= sqrt(n)) {\n        if (n % i == 0)\n            return i;\n        i++;\n\
    \    }\n    return n;", "    long i = 2;\n    while (i <= n) {\n        if (n\
    \ % i == 0)\n            return i;\n        i++;\n    }\n    return n;", "   \
    \ if(n==1 || n==2) return 1;\n    long m=n*n/2;\n    while(m<=(n+1))\n    {\n\
    \        if(n%m==0) return m;\n        m=m*m/2;\n    }\n    return m;", "    //\
    \ write your code here\n    long ans = 0;\n    int i;\n    for (i = 2; i <= n\
    \ / 2; i++) {\n        int count = 0;\n        while (n % i == 0) {\n        \
    \    n = n / i;\n            count++;\n        }\n        if (count > ans) {\n\
    \            ans = count;\n        }\n    }\n    return ans;", "\tassert(n > 1);\n\
    \tlong max_factor = 1;\n\tfor (long i = 2; i < n; i++) {\n\t\tif (n % i == 0)\
    \ {\n\t\t\tif (max_factor < (i / 2)) {\n\t\t\t\tmax_factor = i / 2;\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn max_factor;", "    long result = 1;\n    // Iterate from\
    \ 2 to sqrt(n) by increments of 2.\n    // While (divisor < sqrt(n)) do { result\
    \ += 2 divisor; divisor += 2 }\n    for (long i = 2; i <= n / 2; i++) {\n    \
    \    long divisor = 1;\n        // Keep dividing n by divisor while it is smaller\
    \ than n.\n        while (n % divisor == 0) {\n            divisor++;\n      \
    \  }\n        // Keep dividing n by divisor while it is larger than n.\n     \
    \   while (n % (divisor << 1) == 0) {\n            divisor++;\n        }\n   \
    \     result = max(divisor, result);\n    }\n    return result;", "    int i,\
    \ maxi = 1;\n    long maxfactor = 1;\n    for(i = 2; i <= n / i; i++) {\n    \
    \    if(n % i == 0) {\n            maxfactor = i;\n            maxi = i;\n   \
    \     }\n    }\n    return maxfactor;", "    std::stack<long> s;\n    for (long\
    \ i = 1; i < n; ++i) s.push(i);\n    long res = 1;\n    while (!s.empty()) {\n\
    \        long p = s.top();\n        if (p*p > n) break;\n        if (n%p == 0)\
    \ return p;\n        while (n % p == 0) {\n            std::swap(p,s.top());\n\
    \            s.pop();\n            if (p*p > n) break;\n        }\n        s.push(p);\n\
    \        res *= p;\n    }\n    return res;", "    int i, maxi = 1, maxpf = n;\n\
    \    for (i = 2; i <= sqrt(n); i++) {\n        while (n % i == 0) {\n        \
    \    maxpf = i;\n            n = n / i;\n        }\n    }\n    return maxpf;",
  "  assert(n >= 2);\n  long result = 0;\n  for (int i = 1; i <= n / 2; i++) {\n \
    \   while (n % i == 0) {\n      n /= i;\n      result = i;\n    }\n  }\n  return\
    \ result;", "    long ans = 1;\n    long p = 2;\n    while( n%p ) {\n        ans\
    \ = p;\n        p += 1;\n    }\n    if( n>1 ) {\n        ans *= n;\n    }\n  \
    \  return ans;", "    assert(n >= 2);\n    if (n < 2) return n;\n    if (n ==\
    \ 2) return 2;\n    long x = sqrt(n);\n    long y = 2;\n    long max_factor =\
    \ n - 1;\n    for (int i = max_factor; i > 1; i--)\n        if (n % i == 0) {\n\
    \            x = x;\n            y = i;\n        }\n    while (x*y <= max_factor)\
    \ {\n        if (n%(x*y) == 0) return y*x;\n        x++;\n        y++;\n    }\n\
    \    return n;", "\tint i = (int) sqrt(n);\n\twhile (i * i <= n) {\n\t\tif (n\
    \ % i == 0) return i;\n\t\ti += 1;\n\t}\n\treturn n;", "    long factor = 2;\n\
    \    while (n > 1) {\n        if (n % factor) {\n            n /= factor;\n  \
    \          ++factor;\n        } else {\n            factor++;\n        }\n   \
    \ }\n    return factor;", "    long i = 2;\n    long max_divisor = n;\n    while\
    \ (i < max_divisor) {\n        if (n % i == 0)\n            i += 1;\n        else\n\
    \            n = n / i;\n    }\n    return i;", "\tlong factor = 1;\n\tfor(long\
    \ i = 2; i <= n; i++) {\n\t\tif(n % i == 0) {\n\t\t\tfactor = i;\n\t\t\tbreak;\n\
    \t\t}\n\t}\n\treturn factor;", "    if (n == 1) return 1;\n    if (n % 2 == 0)\
    \ return 2;\n    long maxDivisor = 1;\n    long divisor = 2;\n    while (n % divisor\
    \ != 0) {\n        divisor++;\n        maxDivisor++;\n    }\n    if (divisor >\
    \ n) return divisor;\n    while (n % (maxDivisor + 1) != 0) {\n        maxDivisor++;\n\
    \    }\n    return maxDivisor;", "    long a = 2;\n    long b = 2;\n    long c\
    \ = 2;\n    while (b * b <= n) {\n        while (b * b > n) {\n            while\
    \ (n % b == 0) {\n                n = n / b;\n                a++;\n         \
    \   }\n            b++;\n        }\n        c++;\n    }\n    return a;", "   \
    \ long max_prime_factor = 1;\n    // Check if n is a prime number\n    if (n <=\
    \ 1) return 2;\n    // The largest prime factor p of n must not exceed n\n   \
    \ while (n % 2 == 0) max_prime_factor *= 2;\n    while (n % 3 == 0) max_prime_factor\
    \ *= 3;\n    while (n % 5 == 0) max_prime_factor *= 5;\n    while (n % 7 == 0)\
    \ max_prime_factor *= 7;\n    // If n is not a prime, then n is not a prime factor\n\
    \    if (n < 1) return n;\n    // If n is a prime, then n is a prime factor\n\
    \    for (long i = 5; i <= sqrt(n); i += 6) {\n        if (n % i == 0) return\
    \ max_prime_factor * i;\n    }\n    return max_prime_factor;", "    if(n<2) return\
    \ 0;\n    long largest = 1;\n    for(long i=2;i<=sqrt(n);i++) {\n        if(n%i==0)\
    \ {\n            largest = i;\n            break;\n        }\n    }\n    return\
    \ largest;", "\t// Write your code here.\n\t// We will use sieve approach to find\
    \ the largest prime factor.\n\t// We will use a list of prime factors as an intermediate\
    \ solution\n\tbool arr[prime_factors_size] = { true, };\n\tlong max_prime_factor\
    \ = 0;\n\tlong prime_factor = 0;\n\t// Loop till we find a prime factor for n\n\
    \twhile (prime_factor < prime_factors_size && arr[prime_factor]) {\n\t\tif (n\
    \ % prime_factor == 0) {\n\t\t\tmax_prime_factor = prime_factor;\n\t\t\tbreak;\n\
    \t\t}\n\t\tif (n % (prime_factor + 1)) {\n\t\t\tmax_prime_factor = prime_factor;\n\
    \t\t}\n\t\tprime_factor++;\n\t}\n\treturn max_prime_factor;", "    long i = 2;\n\
    \    int m = n;\n    while ((m % i) == 0) {\n        m /= i;\n        i++;\n \
    \   }\n    return m;", "    long i, x = 1;\n    for(i = 2; i <= n; ++i) {\n  \
    \      if (n % i == 0) {\n            x /= i;\n        }\n    }\n    if (x !=\
    \ 1) {\n        return x;\n    }\n    return 2;", "\tint i = 2;\n\tlong p = 2;\n\
    \tlong flag = 0;\n\twhile ( i <= n ) {\n\t\tif (n % i == 0) {\n\t\t\tp = i;\n\t\
    \t\tflag = 1;\n\t\t}\n\t\ti++;\n\t}\n\tlong temp = p;\n\twhile ( flag == 0 ) {\n\
    \t\tflag = 0;\n\t\tfor ( i = p; i <= n; i += p ) {\n\t\t\tif (n % i == 0) {\n\t\
    \t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = temp;\n\t\ttemp++;\n\t\
    }\n\t\n\treturn p;", "    int i = 2;\n    long prime = 2;\n    while (i <= sqrt(n))\
    \ {\n        if (n % i == 0) {\n            prime = i;\n            break;\n \
    \       }\n        ++i;\n    }\n    return prime;", "\t// Initialize two variables,\
    \ one for prime and one for composite.\n\tbool prime = true;\n\tlong largest_prime_factor\
    \ = 1;\n\n\t// The prime factor of 1 is a special case and has no effect. \n\t\
    // It can help us exit the loop in some cases.\n\tif (n == 1) {\n\t\treturn 1;\n\
    \t}\n\n\t// The only even prime number is a natural multiple of 2, \n\t// but\
    \ this value should not be used.\n\tassert(n % 2 == 0);\n\n\t// Find the largest\
    \ prime factor of n.\n\twhile (n != 1) {\n\t\t// If n is evenly divisible by all\
    \ smaller \n\t\t// primes, it is already a composite.\n\t\tif (n % 2 == 0 && n\
    \ == 2) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (prime) {\n\t\t\t// If n is prime then\
    \ we know that it \n\t\t\t// is not a composite because all smaller \n\t\t\t//\
    \ primes were tested already and were not \n\t\t\t// provablly primes themselves.\n\
    \t\t\tif (n % 2 == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprime = false;\n\t\t\
    }\n\n\t\tlargest_prime_factor *= n;\n\n\t\t// Reduce the number to all even numbers\
    \ that are \n\t\t// not primes.\n\t\twhile (n % 2 == 0 && n % largest_prime_factor\
    \ == 0) {\n\t\t\tn /= 2;\n\t\t}\n\n\t\t// If we were asked to find the largest\
    \ prime \n\t\t// factor of the number 1 then we found the \n\t\t// largest prime\
    \ factor of n. Otherwise \n\t\t// the largest prime factor of n is 1 and we \n\
    \t\t// need to test all smaller primes.\n\t\tif (n == 1) {\n\t\t\tbreak;\n\t\t\
    }\n\t}\n\n\treturn largest_prime_factor;", "    long m1 = pow(10, floor(log10(n))-1);\n\
    \    long m2 = pow(10, floor(log10(m1)));\n    if (m1 * m2 >= n) return n;\n \
    \   long p = 2, q = 1;\n    while ((p < m1) || (q < m2)) {\n        if (p > m2)\
    \ {\n            q++;\n        }\n        if (q * p >= n) break;\n        if (n\
    \ % p == 0) p += q;\n        else {\n            q *= 10;\n            n /= p;\n\
    \        }\n    }\n    return n;", "    long res = 2;\n    while (n/2 >= 1) res\
    \ = (n%2 == 0) ? res+1 : res;\n    return res;", "  assert(n > 1);\n  long p =\
    \ 2;\n  while (p < n / p) {\n    while (n % p == 0)\n      n /= p;\n    p++;\n\
    \  }\n  return n;", "    long m = 2;\n    while (m <= n/2) {\n        if (n %\
    \ m == 0) {\n            return m;\n        }\n        m++;\n    }\n    return\
    \ n;", "    long f = n;\n    long p = 2;\n    while (f*f <= n) {\n        if (f%p\
    \ == 0) {\n            f /= p;\n        } else {\n            p = p*2;\n     \
    \   }\n    }\n    return p; ", "    long largest = 0;\n    long divisor = 2;\n\
    \    while (divisor <= n) {\n        if (n % divisor == 0) {\n            if (largest\
    \ == 0) {\n                largest = divisor;\n            } else if (largest\
    \ == divisor) {\n                largest = largest;\n            }\n        }\n\
    \        divisor += 2;\n    }\n    return largest;", "    long res = 1;\n    for\
    \ (long i = 2; i <= n / 2; ++i) {\n        if (n % i == 0) {\n            res\
    \ = i;\n            break;\n        }\n    }\n    return res;", "\t// Create a\
    \ boolean array for primality test\n\tbool prime[n + 1];\n\t// Initialize all\
    \ values as not prime\n\tfor (int i = 0; i <= n; i++)\n\t\tprime[i] = false;\n\
    \tprime[0] = true;\n\tprime[1] = true;\n\tfor (int i = 2; i <= n; i++) {\n\t\t\
    // Check to see if the number is prime\n\t\tif (prime[i]) {\n\t\t\t// If number\
    \ is already prime, skip it\n\t\t\tif (i > n)\n\t\t\t\tbreak;\n\t\t\t// Check\
    \ for factor\n\t\t\tfor (int j = 2; j < i; j++)\n\t\t\t\tif (i % j == 0)\n\t\t\
    \t\t\tbreak;\n\t\t\t// If no factor found, increment counter\n\t\t\tif (j == i)\n\
    \t\t\t\tprime[i++] = true;\n\t\t}\n\t}\n\t// Return the first non-prime number\n\
    \treturn i; // Return n", "    int max_factor = 0;\n    int max_prime = 0;\n \
    \   for (int i = 2; i < n; i++) {\n        while (n % i == 0) {\n            if\
    \ (max_factor < i) {\n                max_factor = i;\n                max_prime\
    \ = 1;\n            }\n        }\n        n /= i;\n    }\n    return max_factor\
    \ * max_prime;", "  assert(n > 0L);\n  long prime = 2L;\n  while (prime * prime\
    \ <= n) {\n    if (n % prime == 0) {\n      long cur = n/prime;\n      long div\
    \ = 2L;\n      while (cur != 0) {\n        if (cur % prime == 0) {\n         \
    \ return prime;\n        }\n        div++;\n        cur /= prime;\n      }\n \
    \   }\n    prime++;\n  }\n  return n;", "  // n%2==0 means n is not a prime number.\n\
    \  // n%3==0 means n is not a prime number.\n  // n%5==0 means n is not a prime\
    \ number.\n  // n%7==0 means n is not a prime number.\n  // n%11==0 means n is\
    \ not a prime number.\n  // n%13==0 means n is not a prime number.\n  // n%17==0\
    \ means n is not a prime number.\n  // n%19==0 means n is not a prime number.\n\
    \  // n%23==0 means n is not a prime number.\n  // n%29==0 means n is not a prime\
    \ number.\n  // n%31==0 means n is not a prime number.\n  // n%41==0 means n is\
    \ not a prime number.\n  // n%43==0 means n is not a prime number.\n  // n%47==0\
    \ means n is not a prime number.\n  // n%53==0 means n is not a prime number.\n\
    \  // n%59==0 means n is not a prime number.\n  // n%61==0 means n is not a prime\
    \ number.\n  // n%67==0 means n is not a prime number.\n  // n%71==0 means n is\
    \ not a prime number.\n  // n%73==0 means n is not a prime number.\n  // n%79==0\
    \ means n is not a prime number.\n  // n%83==0 means n is not a prime number.\n\
    \  // n%89==0 means n is not a prime number.\n  // n%97==0 means n is not a prime\
    \ number.\n  // n%101==0 means n is not a prime number.\n  // n%103==0 means n\
    \ is not a prime number.\n  // n%107==0 means n is not a prime number.\n  // n%109==0\
    \ means n is not a prime number.\n  // n%113==0 means n is not a prime number.\n\
    \  // n%115==0 means n is not a prime number.\n  // n%117==0 means n is not a\
    \ prime number.\n  // n%119==0 means n is not a prime number.\n  // n%123==0 means\
    \ n is not a prime number.\n  // n%127==0 means n is not a prime number.\n  //\
    \ n%129==0 means n is not a prime number.\n  // n%131==0 means n is not a prime\
    \ number.\n  // n%137==0 means n is not a prime number.\n  // n%139==0 means n\
    \ is not a prime number.\n  // n%141==0 means n is not a prime number.\n  // n%",
  "    int n = n;\n    int limit = 2;\n    long k = 2;\n    while (limit < n)\n  \
    \      if (n % limit == 0)\n            k = limit * k;\n        else\n       \
    \     limit = limit + 1;\n    return k;", "    long i = 2, max_num = n;\n    while(i\
    \ < max_num / i) {\n        i += 2;\n    }\n    return i;", "\tlong result = 2;\n\
    \tlong tmp;\n\t// We are only looking for primes larger than n.\n\t// If we find\
    \ one, it will be in the range [1, n].\n\tfor (long i = 3; i <= sqrt(n); i +=\
    \ 2) {\n\t\tif (n % i == 0) {\n\t\t\t// We found a factor. Let's check its\n\t\
    \t\t// primality, and see if it's in the range.\n\t\t\ttmp = n / i;\n\t\t\tif\
    \ (tmp > 1 && tmp <= n)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == n) {\n\t\t// We\
    \ did not find a factor. If n > 2\n\t\t// (this should really only happen if n\
    \ is a\n\t\t// power of 2), then we only need to check odd numbers.\n\t\t// We'll\
    \ see if it's in the range [1, n/2+1].\n\t\tif (n > 2)\n\t\t\ttmp = n / 2;\n\t\
    \telse\n\t\t\ttmp = 1;\n\t\tfor (long i = 3; i <= tmp; i += 2) {\n\t\t\tif (n\
    \ % i == 0) {\n\t\t\t\t// We found a factor. Let's check its\n\t\t\t\t// primality,\
    \ and see if it's in the range.\n\t\t\t\ttmp = n / i;\n\t\t\t\tif (tmp > 1 &&\
    \ tmp <= n)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;", "    if\
    \ (n <= 1) {\n        return 0;\n    }\n    long max_val = 2, max_factor = 2;\n\
    \    for (long i = 2; i < n; ++i) {\n        long j = 2;\n        while (j < i)\
    \ {\n            if (i % j == 0) {\n                break;\n            }\n  \
    \          j += 1;\n        }\n        if (j > i) {\n            i += j;\n   \
    \     }\n        if (i > max_val) {\n            max_val = i;\n            max_factor\
    \ = j;\n        }\n    }\n    return max_factor;", "    if (n<2) return n;\n \
    \   int max_divisor = n/2;\n    while (max_divisor*max_divisor < n) ++max_divisor;\n\
    \    long divisor = 2;\n    while (divisor <= max_divisor) {\n        if (n%divisor\
    \ == 0) return divisor;\n        divisor+=2;\n    }\n    // If n is a prime number,\
    \ it can be factored into any odd number except 3.\n    return n;", "    long\
    \ p = 2;\n    while (p < n)\n        if (n % p == 0)\n            p += p;\n  \
    \      else\n            p = 2;\n    return p;", "    int i=2;\n    long max_factor=1;\n\
    \    long max_num=1;\n    long next_num=n;\n    while(next_num>=2*i) {\n     \
    \   if(next_num%(i+1)==0) {\n            if(next_num/(i+1)>max_factor) {\n   \
    \             max_num=i;\n                max_factor=next_num/(i+1);\n       \
    \     }\n        }\n        ++i;\n    }\n    return max_num;", "    if (n<=1)\n\
    \        return 1;\n    if (n%2==0)\n        return 2;\n    long max_root = 2;\n\
    \    long root = max_root;\n    for(long i=3; i*i<= n; ++i)\n    {\n        if\
    \ (n % i == 0)\n        {\n            if ( root*root > i)\n                root\
    \ = i;\n        }\n    }\n    return root;", "    assert(n > 1);\n    int i =\
    \ 2;\n    long x = 3;\n    while (i <= n / x) {\n        if (n % x == 0) {\n \
    \           x = x + i;\n        }\n        ++i;\n    }\n    return x;", "    assert(n\
    \ > 1);\n    long m = n;\n    long a = n;\n    while (m != 1) {\n        while\
    \ (m % a == 0) {\n            m /= a;\n        }\n        a += 1;\n    }\n   \
    \ return n;", "    assert(n > 1 && n != 1 && n != 2);\n    long i = 2;\n    long\
    \ res = n;\n    while (i < res) {\n        if (n % i == 0) {\n            res\
    \ = i;\n        }\n        ++i;\n    }\n    return res;", "    if(n <= 1) return\
    \ n;\n    long long l = 0;\n    while(n % 2 == 0) {\n        n /= 2;\n       \
    \ l += 2;\n    }\n    while(n % 3 == 0) {\n        n /= 3;\n        l += 3;\n\
    \    }\n    while(n % 5 == 0) {\n        n /= 5;\n        l += 5;\n    }\n   \
    \ while(n % 7 == 0) {\n        n /= 7;\n        l += 7;\n    }\n    return l;",
  "    long i = 3, p, f, m;\n    long d = sqrt(n);\n    int isPrime = 1;\n    while\
    \ (i >= 2) {\n        m = d % i;\n        if (m == 0) {\n            isPrime =\
    \ 1;\n        } else {\n            if (m != 0) {\n                isPrime = 0;\n\
    \            } else {\n                isPrime = 1;\n            }\n        }\n\
    \        i /= 2;\n    }\n    if (isPrime) {\n        // Prime number\n       \
    \ p = i;\n    } else {\n        // Not a prime number\n        while ((n % p)\
    \ != 0) {\n            ++p;\n        }\n        f = p;\n        while ((n % f)\
    \ != 0) {\n            f *= p;\n            ++p;\n        }\n        if (f ==\
    \ n) {\n            f = p;\n        }\n    }\n    return f;", "    long res =\
    \ 1;\n    // Make sure n is odd.\n    n = n & -n;\n    // We only need to check\
    \ odd numbers, because:\n    // n & (n - 1) always yields 0.\n    for (long d\
    \ = 2; d * d <= n; d += 2) {\n        if (n % (d * d) == 0)\n            continue;\n\
    \        if (n % d == 0)\n            res = d;\n    }\n    return res;", "\tlong\
    \ i = 2;\n\twhile(i <= n/2){\n\t\tif(n%i == 0)\n\t\t\treturn i;\n\t\ti++;\n\t\
    }\n\treturn n;", "    std::stack<long> primes;\n    primes.push(n);\n    long\
    \ p = 2;\n    long pmax = 2;\n    while (primes.size() > 0) {\n        long tmp\
    \ = primes.top();\n        if (tmp == 1)\n            break;\n        long i =\
    \ 2;\n        while (i < tmp) {\n            if (tmp % i == 0) {\n           \
    \     long pnew = i;\n                if (pnew > pmax) {\n                   \
    \ pmax = pnew;\n                }\n            }\n            i += p++;\n    \
    \    }\n        primes.pop();\n    }\n    return pmax;", "  if (n == 1)\n    return\
    \ 2;\n  if (n % 2 == 0) {\n    long f = 3; // 3 because 2 = 6\n    while (f <\
    \ n / 2)\n      f += 2; // 6 + 2 = 10\n    return f;\n  }\n  long f = 1; // 1\
    \ because primes are odd numbers\n  while (f < n / 2)\n    f += 2; // 4 + 2 =\
    \ 6\n  while (n % f == 0)\n    f = f + 2;\n  return f;", "  assert(n > 1);\n \
    \ long f = 3;\n  while (f <= n/2) f*=f;\n  for (int i = 4; i*i <= n; i += 2) {\n\
    \    if (n%i==0) return i;\n  }\n  return n;", "    // Write your code here\n\
    \    long ans=2;\n    for(int i=3; i*i<=n; i++) {\n        if(n%i==0) {\n    \
    \        if(n>ans) {\n                ans=n;\n            }\n            n=ans;\n\
    \        }\n        ans*=i;\n    }\n    return ans;", "  int k;\n  long largest_factor\
    \ = 3;\n  for (k = 2; k <= n / 2; k++) {\n    if (n % k == 0) {\n      largest_factor++;\n\
    \      n = n / k;\n    }\n  }\n  return largest_factor;", "    long i = 1L;\n\
    \    long temp = 2L;\n    long maxi = 1L;\n    while (i <= sqrt(n)) {\n      \
    \  if (n % i == 0) {\n            temp = i;\n            while (temp < maxi) {\n\
    \                if (n % temp == 0) {\n                    maxi = temp;\n    \
    \                break;\n                }\n                temp++;\n        \
    \    }\n        }\n        i++;\n    }\n    return maxi;", "\t// write your code\
    \ here\n\tlong largest = 1;\n\tfor (long i=2;i<=sqrt(n);i++){\n\t\tif(n%i==0){\n\
    \t\t\tlargest = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tassert(largest!=1);\n\treturn\
    \ largest;", "    long res = n;\n    for(long i=2; i<res; i++) {\n        if(n\
    \ % i == 0) return i;\n    }\n    return n;", "\tint i = 11;\n\tlong p = n;\n\t\
    long q = n;\n\twhile (1) {\n\t\tlong t;\n\t\tif (q == 0) break;\n\t\tt = p * q;\n\
    \t\tp = (p % q + q) % q;\n\t\tq = t;\n\t}\n\treturn q;", "    int l = 2;\n   \
    \ while (l < n) l = (l*l+1)/2;\n    return l*2;", "\tint i, j;\n\tlong max = 2,\
    \ max2 = 2;\n\tbool flag = false;\n\tlong ans = 0;\n\tfor (int i = 1; i < n; i++)\
    \ {\n\t\tfor (j = 2; j <= (i / max); j++) {\n\t\t\tif (max2 * j % i == 0) {\n\t\
    \t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag) max2 = max;\n\
    \t\tmax = (max * max) % i;\n\t\tmax2 = max;\n\t\tflag = false;\n\t}\n\tans = max2;\n\
    \treturn ans;", "  if (n == 2) return 2;\n  if (n < 2) return 1;\n  if (n == 1)\
    \ return 2;\n  if (n & 1) return n;\n  long p = largest_prime_factor(n/2);\n \
    \ if (n % p == 0) return p;\n  while (p*p <= n) p = p * 2 + 1;\n  return p;",
  "  assert(n > 1);\n  long max_n = n;\n  // Start with a non-prime\n  long i = 1;\n\
    \  while (i <= max_n) {\n    long m = i * i;\n    // If m is a factor of n, then\
    \ n must have the largest factor.\n    if (n % m == 0) {\n      max_n = m;\n \
    \   }\n    ++i;\n  }\n  return max_n;", "    long ans = 1;\n    for(long i = 2;\
    \ i <= n; i++) {\n        if(n % i == 0) {\n            ans = i;\n        }\n\
    \    }\n    return ans;", "    if (n < 2) return 1;\n    long i, max_i = n;\n\
    \    long max_p = 2;\n    long max_p2 = max_p * max_p;\n    long p2;\n    for\
    \ (i = 3; i <= max_i; i += 2) {\n        p2 = max_p * i;\n        if (p2 > max_p2)\
    \ {\n            max_p = p2;\n            max_p2 = max_p * max_p;\n        }\n\
    \    }\n    return max_p;", "  std::list<long> factors;\n  long factor = 0;\n\
    \  if (n < 2) {\n    return 0;\n  }\n  while (n % 2 == 0) {\n    n = n / 2;\n\
    \    factor++;\n  }\n  while (n > 2) {\n    while (n % 2 == 0) {\n      n = n\
    \ / 2;\n      factor++;\n    }\n    if (n > factor) {\n      factors.push_back(factor);\n\
    \    }\n    if (n > 3) {\n      n = n / 2;\n      while (n % 3 == 0) {\n     \
    \   n = n / 3;\n        factor++;\n      }\n    }\n  }\n  std::reverse(factors.begin(),\
    \ factors.end());\n  return *std::max_element(factors.begin(), factors.end());",
  "  if (n == 1) return n;\n  long sq = n * n;\n  long i = 3;\n  long lim = sqrt(sq);\n\
    \  long p = 2;\n  while (p < lim) {\n    if (n % p == 0) return p;\n    p += 2;\n\
    \  }\n  while (i >= 1 && n % i == 0) i += 2;\n  if (i >= 2) return i;\n  long\
    \ m = sqrt(sq);\n  while (m % 2 == 0) m /= 2;\n  if (m > 2) return m;\n  return\
    \ n;", "    long res = 2;\n    int k = 2;\n    for(; k < n; k++) {\n        if(n\
    \ % k == 0) {\n            res = k;\n            break;\n        }\n    }\n  \
    \  return res;", "    // Write your code here.\n    long maxFactor = 1;\n    long\
    \ currentFactor = 1;\n    for(long i = 2; i <= n; i++)\n        if(n % i == 0)\n\
    \            currentFactor = i;\n    if(currentFactor > maxFactor)\n        maxFactor\
    \ = currentFactor;\n    for(long i = 2; i <= n; i++)\n        if(n % i == 0)\n\
    \            currentFactor = i;\n    for(long i = 2; i <= n; i++)\n        if(n\
    \ % i == 0)\n            currentFactor = i;\n    if(currentFactor > maxFactor)\n\
    \        maxFactor = currentFactor;\n    return maxFactor;", "  assert(n > 1 &&\
    \ n > n);\n  long res = n;\n  while (true) {\n    long res = res * res % n;\n\
    \    if (res == 1) break;\n  }\n  return res; ", "  int primes[] = { 2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,\
    \ 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257,\
    \ 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353,\
    \ 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449,\
    \ 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,\
    \ 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653,\
    \ 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761,\
    \ 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877,\
    \ 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991,\
    \ 997};\n  int max_prime = 0;\n  long maxPrime = 0;\n  for (int i = 0; i < sizeof(primes)\
    \ / sizeof(int); ++i)\n    if (n % primes[i] == 0)\n      if (maxPrime < primes[i])\n\
    \        maxPrime = primes[i];\n      else \n        if (maxPrime == primes[i])\n\
    \          max_prime = primes[i];\n  return max_prime;", "    if (n < 2) return\
    \ -1;\n    // Use sieve of Eratosthenes \n    vector<bool> bits(n+1, true);\n\
    \    bits[1] = false;\n    long result = 2;\n    // First factor out multiples\
    \ of 2\n    for (int i = 2; i <= n; ++i) bits[i] = false;\n    for (int i = 2;\
    \ i < n; ++i) {\n        if (bits[i]) continue;\n        bits[i << 1] = true;\n\
    \        for (int j = i; j < n; j += i) {\n            bits[j] = false;\n    \
    \    }\n    }\n    for (int i = 3; i <= n / i; ++i) {\n        if (bits[i]) continue;\n\
    \        bits[i << 1] = true;\n        for (int j = i; j < n; j += i) {\n    \
    \        bits[j] = false;\n        }\n    }\n    for (int i = n / i; i > 1; --i)\
    \ {\n        if (bits[i]) continue;\n        result = i;\n    }\n    return result;",
  "    long long res = 1;\n    // Find smallest factor greater than or equal to n\n\
    \    for (long long i = 2; i <= n/2; i++){\n        if (n % i == 0)\n        \
    \    continue;\n        if (i > (n/2)){\n            n = n / i;\n            break;\n\
    \        }\n        else{\n            n = n * i;\n            break;\n      \
    \  }\n    }\n    return res;", "    long ret = 0;\n    long m = n;\n    long pm\
    \ = 1;\n    long i = 2;\n    while (pm < m) {\n        if (n % i == 0) {\n   \
    \         pm = m / i;\n            ret = i;\n        }\n        ++i;\n    }\n\
    \    return ret;", "    long i = 2;\n    long p = n; // Assume n>1 and n not a\
    \ prime.\n    while ( p % 2 == 0 ) {\n        p = p*(i+1);\n        ++i;\n   \
    \ }\n    return p;", "\tint i,j,temp;\n\tlong max_num = n;\n\tlong nums[MAX_PRIME];\n\
    \tfor(j=1; j<=max_num/2; j++) {\n\t\ttemp = max_num;\n\t\tfor(i=j; i<=max_num/2;\
    \ i++) {\n\t\t\tif(temp%i == 0) {\n\t\t\t\ttemp = temp/i;\n\t\t\t\tbreak;\n\t\t\
    \t}\n\t\t}\n\t\tif(max_num%temp == 0)\n\t\t\tnums[j] = temp;\n\t}\n\treturn nums[max_num/2];",
  "\t// Based on http://web.archive.org/web/20140816152506/http://www.hackersdelight.org/\n\
    \t// and http://www.primesieve.org/\n\t// and http://mathworld.wolfram.com/PrimeSieve.html\n\
    \t// and http://mathworld.wolfram.com/EratosthenesSieve.html\n\t\n\tlong s = sqrt(n);\n\
    \tlong t = 1;\n\tlong p = 2;\n\twhile (p < s) {\n\t\tt = (t * p) % n;\n\t\tp =\
    \ p * 2 + 1;\n\t}\n\treturn t;", "    std::cerr << \"enter n: \" << n << std::endl;\n\
    \    int res = 1;\n    long div = 1;\n    while (n > div) {\n        div = res;\n\
    \        for (long i = 2; i <= div / 2; ++i) {\n            if (n % i == 0) {\n\
    \                res = i;\n            }\n        }\n    }\n    std::cerr << \"\
    factor: \" << res << std::endl;\n    return res;", "    long max_factor = 1;\n\
    \    for (long i = 2; i*i <= n; ++i) {\n        while (n % i == 0) {\n       \
    \     n /= i;\n            max_factor++;\n        }\n    }\n    return max_factor;",
  "    long long maxf = 0;\n    for(long long i = 2; i <= n; i++) {\n        long\
    \ long f = i;\n        while(n % i == 0) {\n            n /= i;\n            f++;\n\
    \        }\n        maxf = std::max(maxf, f);\n    }\n    return maxf != n ? n\
    \ : 1;", "    long max_divisor = 2;\n    long max_factor = 1;\n    for (int i\
    \ = 3; i <= n; i += 2)\n        if (n % i == 0) {\n            max_factor *= i;\n\
    \            max_divisor = i;\n        }\n    return max_factor;", "    long factor\
    \ = 2;\n    for (long i = 3; i*i <= n; i += 2) {\n        while (n%i==0) {\n \
    \           n = n/i;\n            factor++;\n        }\n    }\n    return factor;",
  "    long x = 2;\n    while (x <= sqrt(n))\n        if (n % x == 0)\n          \
    \  x++;\n        else\n            break;\n    if (x > n)\n        return n;\n\
    \    long y = 3;\n    while (y*y <= x)\n        y++;\n    // x is now the largest\
    \ prime factor of n\n    while (x > 1) {\n        if ((x % 2) == 0)\n        \
    \    x = 3;\n        else\n            x /= 2;\n    }\n    while (y <= n)\n  \
    \      if (y % x == 0)\n            y = n + 1;\n        else\n            break;\n\
    \    return y;", "    assert(n >= 2);\n    long p = 2;\n    while (n%p == 0) {\n\
    \        p = p * 2 + 1;\n    }\n    return n;", "  long i=2, limit=n;\n  assert(n\
    \ >= 2);\n  while(i<limit) {\n    if(n % i == 0) {\n      limit = i;\n    }\n\
    \    i++;\n  }\n  return limit;", "    vector<long> prime_factors(n);\n    vector<long>::iterator\
    \ it;\n    // initialize all prime_factor to 2\n    for (long i = 2; i < n; i++)\n\
    \        prime_factors[i] = 2;\n    for (long i = 2; i < n; i++) {\n        if\
    \ (prime_factors[i] == 2)\n            continue;\n        for (it = prime_factors.begin();\
    \ it != prime_factors.end(); ++it)\n            if (n % it == 0) {\n         \
    \       long temp = n;\n                while (*it * temp % it == 0)\n       \
    \             temp /= it;\n                long temp2 = 1;\n                while\
    \ (temp % temp2 != 0)\n                    temp2 *= temp2;\n                if\
    \ (temp2 == n)\n                    return i;\n                break;\n      \
    \      }\n    }", "    if (n == 1) return n;\n    long sqr = n; // Start with\
    \ n. Square until n > sqr \n    for (long i = 2; i <= sqr; i++) {\n        if\
    \ (n % i == 0) {\n            sqr -= i;\n            break;\n        }\n    }\n\
    \    if (sqr == n) return(sqr);\n    for (long i = 2; i <= sqr; i++) {\n     \
    \   if (n % i == 0) {\n            sqr -= i;\n        }\n    }\n    return(sqr);",
  "    long m = n/2;\n    long r = m;\n    while(r > 1) {\n        r = m/r;\n    \
    \    if(r == 1) {\n            break;\n        }\n        m = m;\n    }\n    return\
    \ m;", "    assert(n >= 2);\n    long s = 2, max_prime = n;\n    long d = n;\n\
    \    while (d % 2 == 0) {\n        d /= 2;\n    }\n    while (d % 3 == 0) {\n\
    \        d /= 3;\n    }\n    while(d % 5 == 0) {\n        d /= 5;\n    }\n   \
    \ while(d % 7 == 0) {\n        d /= 7;\n    }\n    while(d % 11 == 0) {\n    \
    \    d /= 11;\n    }\n    while(d % 13 == 0) {\n        d /= 13;\n    }\n    while(d\
    \ % 17 == 0) {\n        d /= 17;\n    }\n    while(d % 19 == 0) {\n        d /=\
    \ 19;\n    }\n    while(d % 23 == 0) {\n        d /= 23;\n    }\n    while(d %\
    \ 29 == 0) {\n        d /= 29;\n    }\n    while (d % 31 == 0) {\n        d /=\
    \ 31;\n    }\n    while(d % 37 == 0) {\n        d /= 37;\n    }\n    while (d\
    \ % 41 == 0) {\n        d /= 41;\n    }\n    while (d % 43 == 0) {\n        d\
    \ /= 43;\n    }\n    while (d % 47 == 0) {\n        d /= 47;\n    }\n    while\
    \ (d % 53 == 0) {\n        d /= 53;\n    }\n    while (d % 59 == 0) {\n      \
    \  d /= 59;\n    }\n    while (d % 61 == 0) {\n        d /= 61;\n    }\n    while\
    \ (d % 67 == 0) {\n        d /= 67;\n    }\n    while (d % 71 == 0) {\n      \
    \  d /= 71;\n    }\n    while (d % 73 == 0) {\n        d /= 73;\n    }\n    while\
    \ (d % 79 == 0) {\n        d /= 79;\n    }\n    while (d % 83 == 0) {\n      \
    \  d /= 83;\n    }\n    while (d % 89 == 0) {\n        d /= 89;\n    }\n    while\
    \ (d % 97 == 0) {\n        d /= 97;\n    }\n    while (d % 103 == 0) {\n     \
    \   d /= 103;\n    }\n    while (d % 107 == 0) {\n        d /= 107;\n    }\n \
    \   while (d % 111 == 0) {\n        d /= 111;\n    }\n    while (d % 113 == 0)\
    \ {\n        d /= 113;\n    }\n    while (d % 127 == 0) {\n        d /= 127;\n\
    \    }\n    while (d % 131 == 0) {\n        d /= 131;\n    }\n    while (d % 137\
    \ == 0) {\n        d /= 137;\n    }\n    while (d % 139 == 0) {\n        d /=\
    \ 139;\n    }\n    while (d % 149 == 0) {\n        d /= 149;\n    }\n    while\
    \ (d % 151 == 0) {\n        d /= 15", "    assert(n > 1);\n    long res = n;\n\
    \    while (n > 1) {\n        if (n % res == 0) {\n            n /= res;\n   \
    \     } else {\n            res = n;\n            n = 1;\n        }\n    }\n \
    \   return res;", "\tlong factor = 3;\n\tlong d = 2;\n\twhile( n % d != 0 ) {\n\
    \t\tfactor = d;\n\t\td++;\n\t}\n\twhile( n != 1 ) {\n\t\tn = (n % factor);\n\t\
    \tfactor = d;\n\t\td++;\n\t}\n\treturn factor;", "    // Check for perfect powers\n\
    \    int k = 1;\n    while (n%k==0) { k++; }\n    // Check for known primes\n\
    \    if (k == 2 || k == 3) return k;\n    \n    std::vector<bool> factors(n, false);\n\
    \    \n    for (int i = 2; i <= n; i++) {\n        // If i is prime, mark all\
    \ multiples as factors\n        bool prime = true;\n        \n        for (int\
    \ j = i*i; j <= n; j += i) {\n            prime = false;\n            break;\n\
    \        }\n        \n        if (prime) factors[i] = true;\n    }\n    \n   \
    \ // Return first factor > 1\n    for (int i = 2; i <= n; i++) {\n        if (factors[i])\
    \ return i;\n    }\n    \n    // If no factor > 1, return -1\n    return -1;",
  "  long result  = 1;\n  long factor = 2;\n\n  for (long i = 3; i <= n; i += 2) {\n\
    \    long temp  = factor;\n    factor += i;\n\n    if (temp > result) {\n    \
    \  result = temp;\n    }\n  }\n\n  return result;", "\tif(n == 1)\n\t\treturn\
    \ 1;\n\t\n\tlong max_prime = 2;\n\t\n\tif(n%2 == 0) {\n\t\tmax_prime = 2;\n\t\
    }\n\telse {\n\t\tfor( int i = 3; i*i <= n; i += 2) {\n\t\t\tif( n%i == 0) {\n\t\
    \t\t\tlong prod = 1;\n\t\t\t\t\n\t\t\t\twhile(n%i == 0) {\n\t\t\t\t\tn /= i;\n\
    \t\t\t\t\tprod *= i;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max_prime > prod)\n\t\t\t\
    \t\tmax_prime = prod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn max_prime;", "  if (n\
    \ == 2) return 1;\n  long prime = 2;\n  long count = 2;\n  for (long i = 3; i\
    \ <= sqrt(n); i += 2) {\n    if (n % i == 0) {\n      while (n % i == 0) {\n \
    \       n /= i;\n        count++;\n      }\n      if (count == prime) return i;\n\
    \      prime = count;\n      count = 1;\n    }\n  }\n  return prime;", "\tassert(n\
    \ > 1);\n\tlong p = 2;\n\tfor(long i = 3; i <= n / p; ++i) {\n\t\tif(n % i ==\
    \ 0)\n\t\t\tbreak;\n\t\tp++;\n\t}\n\treturn p;", "    assert(n > 1 && n != primes[0]);\n\
    \    long result = n;\n    long prime = 1;\n    while (prime < primes[0]) {\n\
    \        while (n % prime == 0) {\n            n /= prime;\n            if (n\
    \ == 1)\n                break;\n        }\n        prime++;\n    }\n    while\
    \ (n > 1) {\n        while (n % 2 == 0) {\n            n /= 2;\n            if\
    \ (n == 1)\n                break;\n        }\n        while (n % prime == 0)\
    \ {\n            n /= prime;\n            if (n == 1)\n                break;\n\
    \        }\n        prime++;\n    }\n    return result;", "    long i = 2, p =\
    \ 2, flag = 0;\n    while(i <= n / p) {\n        p = p*i;\n        if(p > n) {\n\
    \            flag = 1;\n            break;\n        }\n        i++;\n    }\n \
    \   if(flag == 1) {\n        return -1;\n    }\n    return i;", "  int n = n;\n\
    \  int d = 2;\n  while (n%2 == 0 && n>=2*d){\n    n/=2;\n    d++;\n  }\n  for\
    \ (; d*d <= n; d++){\n    while (n%d == 0){\n      n/=d;\n    }\n  }\n  return\
    \ d;", "    long l = 0, r = n;\n    while (l <= r) {\n        long m = (l + r)\
    \ / 2;\n        if (m == 2 || n % m == 0)\n            return m;\n        if (n\
    \ % m == 0) {\n            r = m - 1;\n        } else {\n            l = m + 1;\n\
    \        }\n    }\n    return n;", "    long long int p = sqrt(n);\n    long long\
    \ int d = 1;\n    while (p * p <= n) {\n        while (p * p < n && n % p == 0)\
    \ {\n            ++p;\n        }\n        if (p * p > n) {\n            break;\n\
    \        }\n        if (n % p == 0) {\n            d = p;\n            while (n\
    \ % p == 0) {\n                n /= p;\n            }\n            break;\n  \
    \      }\n        ++p;\n    }\n    return n;", "    long factors[20]; // 20 is\
    \ max prime factors of n\n    long i, k;\n    bool prime = false;\n    factors[0]\
    \ = 1;\n    for(i = 2; i <= n; ++i) {\n        if (n % i == 0) {\n           \
    \ prime = true;\n        }\n        for (k = 0; k < i; ++k) {\n            if\
    \ (n % i == 0) {\n                factors[k] = i;\n                break;\n  \
    \          }\n        }\n        if (prime) {\n            break;\n        }\n\
    \    }\n    if (prime) {\n        factors[1] = i;\n    }\n    return factors[factors.length\
    \ - 1];", "    if(n<2)\n        return 1;\n    long ans=1,i=2,k=n;\n    while(i*i<=k){\n\
    \        ans=i*ans;\n        if(k%i==0)\n            k/=i;\n        i++;\n   \
    \ }\n    return ans;", "    assert(n > 1 && \"n must be positive\");\n    long\
    \ m = n;\n    long i = 3;\n    while (i <= m) {\n        if (n % i == 0) {\n \
    \           m /= i;\n        } else {\n            ++i;\n        }\n    }\n  \
    \  return m;", "    long factor = 2;\n    long limit = sqrt(n);\n    while (factor\
    \ < limit) {\n        if (n % factor == 0) {\n            limit = sqrt(n);\n \
    \       } else {\n            factor++;\n        }\n    }\n    return factor;",
  "    int primes[] = {0};\n    long result = 0;\n    if (n == 1) {\n        return\
    \ 1;\n    }\n    for (int i = 0; i < n; i++) {\n        int found = 1;\n     \
    \   for (int j = 0; j < i; j++) {\n            if (n % primes[j] == 0) {\n   \
    \             found = 0;\n                break;\n            }\n        }\n \
    \       if (found) {\n            primes[i] = n;\n            if (i > result)\
    \ {\n                result = i;\n            }\n        }\n    }\n    return\
    \ result;", "    assert(n > 1);\n    long i = 2;\n    while (i * i < n) {\n  \
    \      if (n % i == 0)\n            n = n / i;\n        else\n            i++;\n\
    \    }\n    return n;", "    long max = 0;\n    long i;\n    for (i = 2; i <=\
    \ sqrt(n); ++i) {\n        if (n % i == 0) {\n            max = i;\n         \
    \   break;\n        }\n    }\n    return max;", "    long p = n;\n    while ((p\
    \ & 1) == 0) p >>= 1, ++n;\n    long q = n;\n    while ((q & 1) == 0) q >>= 1,\
    \ ++n;\n    while (n > 1) {\n        if (p % q == 0) {\n            p /= q;\n\
    \            ++n;\n        }\n        else if (q % p == 0) {\n            q /=\
    \ p;\n            ++n;\n        }\n    }\n    return n;", "    assert(n >= 2);\n\
    \    long a = 2, b = n, c = 1;\n    while (c != 0) {\n        long m = (b - a)\
    \ / 2;\n        long cur = m * m;\n        if (cur > c) {\n            c = cur;\n\
    \            b = a;\n            a = m;\n        }\n    }\n    return a;", " \
    \   assert(n > 1);\n    long ans = 1;\n    int i = 2;\n    // check for factors\
    \ up to sqrt(n)\n    while (i * i <= n) {\n        if ((n % i == 0) && (n % ans\
    \ == 0)) {\n            ans = i;\n        }\n        ++i;\n    }\n    return ans;",
  "\tassert(n > 1);\n\tint count = 0;\n\tlong p = 2;\n\t// while (count <= n / p)\
    \ {\n\twhile (count <= n / p) {\n\t\tp = p * 2;\n\t\tcount++;\n\t}\n\treturn (p);",
  "    long i, factor = 1;\n    for (i = 2; i <= n; ++i) {\n        while (n % i ==\
    \ 0) {\n            ++factor;\n            n /= i;\n        }\n    }\n    return\
    \ factor;", "  long factor = 2;\n  long max_divisor = 1;\n  while(factor * factor\
    \ <= n && max_divisor * max_divisor <= n) {\n    max_divisor *= factor;\n    factor++;\n\
    \  }\n  return max_divisor;", "\t// The largest prime factor is 2\n\tif (n ==\
    \ 1) return 2;\n\n\t// If n is even, the largest prime factor is n / 2\n\tif (n\
    \ % 2 == 0) return n / 2;\n\n\t// If n is odd, divide the number by 2 to get the\
    \ largest prime factor\n\tlong temp = n / 2;\n\twhile (temp % 2 == 0) temp /=\
    \ 2;\n\n\t// If the number is smaller than the smallest prime factor, that\n\t\
    // is because it is not a prime factor\n\tif (temp < 2) return 2;\n\n\t// Repeat\
    \ the steps until a prime factor is found\n\tlong temp2 = 2;\n\twhile (temp2 *\
    \ temp2 < temp) {\n\t\ttemp2 += 2;\n\t}\n\treturn temp2;", "    if (n == 2)\n\
    \        return 2;\n    long result = 1;\n    while (n % 2 == 0) {\n        result\
    \ *= 2;\n        n /= 2;\n    }\n    while (n % 3 == 0) {\n        result *= 3;\n\
    \        n /= 3;\n    }\n    while (n % 5 == 0) {\n        result *= 5;\n    \
    \    n /= 5;\n    }\n    return result * n;", "    // Write your code here.\n\
    \    long result = 2, counter;\n    for(counter = 2; counter <= n; counter++)\n\
    \    {\n        if(n % counter == 0)\n        {\n            n /= counter;\n \
    \           break;\n        }\n    }\n    while(1)\n    {\n        if(n > 1)\n\
    \        {\n            result *= n;\n            n /= counter;\n        }\n \
    \       else\n        {\n            break;\n        }\n    }\n    return result;",
  "\tint prime = 2; // Start at 2.\n\tlong largestPrimeFactor = 1;\n\twhile (n > 1)\
    \ {\n\t\tif (n % prime == 0) {\n\t\t\tlargestPrimeFactor = prime;\n\t\t\tbreak;\n\
    \t\t}\n\t\tlargestPrimeFactor = prime;\n\t\tprime += 2;\n\t}\n\treturn largestPrimeFactor;",
  "  assert (n > 1);\n  if (n == 2)\n    return n;\n  long d = 1;\n  for (long i =\
    \ 2; i < n; i++)\n    if (n % i == 0)\n      d = i;\n  if (d == 2)\n    return\
    \ 2;\n  for (long i = 3; i < d; i++)\n    if (n % i == 0)\n      return i;\n \
    \ // We should never get here\n  assert(0);\n  return 0;", "    long ans = 2;\n\
    \    if (n <= 1) return ans;\n    for (long i = 2; i < n; i++) {\n        if (n\
    \ % i == 0) {\n            if (i == n) {\n                return ans;\n      \
    \      }\n            ans = i;\n        }\n    }\n    return ans;", "\tint i;\n\
    \tlong factor = 1;\n\tfor (i = 2; i <= n / 2; ++i)\n\t\tif (n % i == 0)\n\t\t\t\
    break;\n\tfor (; i < n; ++i)\n\t\tfactor *= i;\n\treturn factor;", "    long m\
    \ = n;\n    long nfact = 1;\n    long lfact = 1;\n    long i = 3; // loop index\n\
    \    while (i <= m) {\n        while (n % i == 0) {\n            m /= i;\n   \
    \         nfact *= i;\n        }\n        i++;\n        lfact *= i;\n    }\n \
    \   return nfact;", "    long ans = n;\n    long primes[MAXPRIMES];\n    primes[0]\
    \ = 1;\n    primes[1] = 1;\n    for (long i = 2; i <= n; i++)\n        if (primes[i]\
    \ != 0)\n            while (n % primes[i] == 0) {\n                ans = primes[i];\n\
    \                n /= primes[i];\n            }\n    return ans;", "    long k\
    \ = 1;\n    while (!isPrime(k)) {\n        long m = k;\n        while (m % 2 ==\
    \ 0) {\n            m /= 2;\n        }\n        while (m % 3 == 0) {\n       \
    \     m /= 3;\n        }\n        while (m % 5 == 0) {\n            m /= 5;\n\
    \        }\n        k = m;\n    }\n    return k;", "    long i = 3; // Start with\
    \ 2 and move to odd numbers.\n    long res = 2;\n    long isprime = 0;\n    for\
    \ (;;) { // Keep increasing i until it is greater than n.\n        if (i % n ==\
    \ 0) {\n            if (isprime == 0)\n                res = i;\n            isprime\
    \ = 1;\n        }\n        i = i + 2; // Increment by 2\n        if (i > n) {\n\
    \            // If i is greater than n, then n is not a prime and i must\n   \
    \         // be the largest.\n            return res;\n        }\n    }", "  \
    \  long long int i=3, factor=1;\n    while(i < n){\n        if(n%i == 0)\n   \
    \         factor = i;\n        i++;\n    }\n    return factor;", "    if (n ==\
    \ 1) return n;\n    // Primes are greater than 1 and less than n.\n    long p\
    \ = 2;\n    long f = n;\n    while (f * f <= n) {\n        if (n % f == 0) p =\
    \ f * p;\n        f += 2;\n    }\n    if (p != 2 && n != 1) return p;\n    return\
    \ n;", "    if (n == 1) return 2;\n    long i = 2;\n    while (n % i == 0) i++;\n\
    \    long maxi = i;\n    while (i <= sqrt(n)) {\n        if (n % i == 0) {\n \
    \           maxi = i;\n            while (n % (i+i) == 0) i += i;\n        }\n\
    \        i += maxi;\n    }\n    return n;", "  // Write your code here.\n  long\
    \ result = 2;\n  for (int i = 3; i <= n; i += 2)\n    if (n % i == 0)\n      result\
    \ = i;\n  return result;", "    if (n<=1)\n        return n;\n    long maxp =\
    \ 1;\n    long maxq = n-1;\n    long p = 2, q = 2;\n    long while (p<=q) {\n\
    \        if (n%(p+q)==0) {\n            if (p > maxp) {\n                maxp\
    \ = p;\n            }\n            if (q > maxq) {\n                maxq = q;\n\
    \            }\n        }\n        ++p;\n        ++q;\n    }\n    return maxp\
    \ * maxq;", "    // Complete the function\n    long highest_prime_factor = 1,\
    \ result = n;\n    while(n > 1) {\n        if(n % 2 == 0) {\n            n /=\
    \ 2;\n        } else {\n            int i = 3;\n            while(i < n / 2) {\n\
    \                if(n % i == 0) {\n                    n = n / i;\n          \
    \          break;\n                }\n                i += 2;\n            }\n\
    \        }\n        if(highest_prime_factor < n) {\n            highest_prime_factor\
    \ = n;\n        }\n    }\n    return result;", "    long result = 0;\n    for\
    \ (long i = 1; i <=n; i++) {\n        if(n % i == 0) {\n            result =i;\n\
    \            break;\n        }\n    }\n    return result;", "    long ans = 1;\n\
    \    // loop invariant: p * q >= n for all p and q\n    for (long p = 1; p <=\
    \ sqrt(n); p++) {\n        // check if p * q is divisible by n\n        for (long\
    \ q = 0; q * q <= n; q++)\n            if (n % p == 0 && p != q)\n           \
    \     break; // p * q is not divisible by n\n        if (q == n)\n           \
    \ ans = p;\n    }\n    return ans;", "  assert(n >= 2 && n <= 100000);\n  // Start\
    \ from 2. If n is prime then no need to go past sqrt(n).\n  int start = 2;\n \
    \ int end = sqrt(n);\n  while (end >= start) {\n    if (n % end == 0) {\n    \
    \  return end;\n    }\n    end--;\n  }\n  return 2;", '    // Write your code
    here.', "    long p = 2, f = n;\n    long l = 1;\n    while ((f % p) == 0)\n \
    \       p += 1;\n    while (l < p) {\n        f = p * f;\n        p += 1;\n  \
    \      l += 1;\n    }\n    return p;", "    long factor = 1;\n    while (n/factor\
    \ > 1 && factor*factor <= n) factor = factor*factor;\n    return factor;", " \
    \ int i = 2;\n  long maxdiv = n;\n  while(i <= maxdiv) {\n    if(n%i==0)\n   \
    \   return i;\n    i++;\n  }\n  return 2;", "    long res = n;\n    long curr\
    \ = 3;\n    long prev = 3;\n\n    while (n > 1) {\n        while (n % curr ==\
    \ 0) {\n            n /= curr;\n        }\n\n        if (n == 1) {\n         \
    \   break;\n        }\n\n        prev = curr;\n        curr = prev * curr;\n \
    \   }\n\n    while (n > 1) {\n        while (n % prev == 0) {\n            n /=\
    \ prev;\n        }\n\n        if (n == 1) {\n            break;\n        }\n\n\
    \        curr = prev;\n        prev = curr;\n        curr = curr * curr;\n   \
    \ }\n\n    return res;", "    if (n <= 1) {\n        return n;\n    }\n    //\
    \ A prime factor must be larger than the square root of the number that is\n \
    \   // being tested.\n    long square_root = sqrt(n);\n    // If the number is\
    \ evenly divisible by any prime factor less than or\n    // equal to sqrt(n),\
    \ then there are no factors.\n    if (n % 2 == 0) {\n        // Find the first\
    \ prime factor greater than or equal to sqrt(n).\n        long next_prime_factor\
    \ = 2;\n        while (next_prime_factor < square_root && n % next_prime_factor\
    \ == 0) {\n            next_prime_factor++;\n        }\n        if (next_prime_factor\
    \ <= square_root) {\n            return n;\n        }\n    }\n    // Test every\
    \ odd number greater than or equal to sqrt(n) up to sqrt(n)\n    // for factors\
    \ of n.\n    for (long next_prime_factor =\n             next_prime_factor_for_sqrt(square_root);\
    \ next_prime_factor < square_root;\n         next_prime_factor++) {\n        if\
    \ (n % next_prime_factor == 0) {\n            return n;\n        }\n    }\n  \
    \  return next_prime_factor_for_sqrt(square_root);", "    long long d = n - 1;\n\
    \    while (d % 2 == 0)\n        d /= 2;\n    while (d % 3 == 0)\n        d /=\
    \ 3;\n    while (d % 5 == 0)\n        d /= 5;\n    while (d % 7 == 0)\n      \
    \  d /= 7;\n    return d + 1;", "    // Fill this array\n    long long factors[10005];\n\
    \    // Check whether n is prime by finding its square root\n    long long root\
    \ = sqrt(n);\n    if (root % 2 == 0) {\n        factors[0] = root;\n        return\
    \ 1;\n    }\n    // Store factor starting from 3, to exclude 1 and n\n    factors[3]\
    \ = 2;\n    for (int i = 4; i <= root; i += 2) {\n        if (n % i == 0) {\n\
    \            factors[i - 3] = i;\n            while (n % i == 0) {\n         \
    \       n /= i;\n                factors[i - 1]++;\n            }\n        }\n\
    \    }\n    return factors[root];", "    // Corner case\n    if (n <= 1) return\
    \ 1;\n    // Test upper bound\n    // n = 2^p\n    // p^n > n > n^p\n    // n\
    \ > p^n\n    // n > (p^n) * 2^p\n    // n = p^n\n    // p = 2\n    // p^n = n^p\n\
    \    // n^p > p^n\n    // n^p > (p^n) * 2^p\n    // n^p == p^n\n    // n^p + 1\
    \ > p^n\n    // n^p + 1 > n^p\n    // n^p <= p^n\n    // n^p <= n^p + 1\n    //\
    \ p^n < n^p + 1\n    // n^p + 1 < p^n\n    // n^p + 1 < n^p\n    // p^n < n^p\
    \ + 1\n    // n^p + 1 > p^n\n    // n^p + 1 > n^p\n    // n^p <= p^n\n    // n^p\
    \ <= n^p + 1\n    // p^n < n^p + 1\n    // n^p + 1 < p^n\n    // n^p + 1 < n^p\n\
    \    // p^n < n^p + 1\n    // n^p + 1 > p^n\n    // n^p + 1 > n^p\n    // n^p\
    \ <= p^n\n    // n^p <= n^p + 1\n    // p^n < n^p + 1\n    // n^p + 1 < p^n\n\
    \    // n^p + 1 < n^p\n    // p^n < n^p + 1\n    // n^p + 1 > p^n\n    // n^p\
    \ + 1 > n^p\n    // n^p <= p^n\n    // n^p <= n^p + 1\n    // p^n < n^p + 1\n\
    \    // n^p + 1 < p^n\n    // n^p + 1 < n^p\n    // p^n < n^p + 1\n    // n^p\
    \ + 1 > p^n\n    // n^p + 1 > n^p\n    // n^p <= p^n\n    // n^p <= n^p + 1\n\
    \    // p^n < n^p + 1\n    // n^p + 1 < p^n\n    // n^p + 1 < n^p\n    // p^n\
    \ < n^p + 1\n    // n^p + 1 > p^n\n    // n^p + 1 > n^p\n    // n^p <= p^n\n \
    \   // n^", "    // Only need to test up to sqrt(n).\n    // Sieve of Eratosthenes\
    \ will give all the prime factors of n in log(n)\n    // time. Test up to sqrt(n)\
    \ will be enough.\n    long m = prime_factor(n);\n    for (long p = 2; p * p <=\
    \ n; p++) {\n        if (n % p == 0) {\n            return p;\n        }\n   \
    \ }\n    return n;", "   assert(n > 1);\n   long f = 1;\n   while (n != 1 && n\
    \ % f == 0)\n      f = f*f;\n   if (f > n)\n      return n;\n   else\n      return\
    \ f;", "  int i = 2;\n  long k = (n - 1) / i;\n  while (i <= k) {\n    if (n %\
    \ i == 0) {\n      return i;\n    }\n    i++;\n    k = (n - 1) / i;\n  }\n  return\
    \ i;", "\tlong ans = 1;\n\tlong i = 3;\n\twhile ( i <= n / i) {\n\t\tif (n % i\
    \ == 0) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t\ti += 2;\n\t}\n\treturn ans;",
  "    long p = n;\n    long q = p;\n    long d = 2;\n\n    while (q <= p) {\n   \
    \     if (p % q == 0) {\n            q = p + 1;\n        }\n        else {\n \
    \           p = q;\n        }\n        d = d + 1;\n    }\n\n    return n;", " \
    \   long ans = n;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i ==\
    \ 0) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;", "\tlong max_factor = 1;\n\t// Sieve of Eratosthenes\n\tfor (int i = 3;\
    \ i <= n / 2; ++i)\n\t{\n\t\tif ((n % i) == 0) \n\t\t{\n\t\t\tfor (int j = i *\
    \ i; j < n; j += i)\n\t\t\t\t;\n\t\t\tn = j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor\
    \ (int j = i * i; j < n; j += i)\n\t\t\t{\n\t\t\t\tmax_factor = max(max_factor,\
    \ j);\n\t\t\t}\n\t\t}\n\t}\n\treturn max_factor;", "    if (n <= 1) return 0;\n\
    \    long m = n;\n    while (m % 2 == 0) m /= 2;\n    for (long i = 3; i <= m\
    \ && m % i == 0; i++) m /= i;\n    return m;", "    int i, j, temp;\n    long\
    \ ans = 0;\n    temp = 2;\n    while (n > temp) {\n        for(i = 3; i <= (int)\
    \ sqrt(n); i += 2) {\n            if(n % i == 0) {\n                for(j = (int)\
    \ sqrt(i); j > temp; j--) {\n                    if(i % j == 0)\n            \
    \            break;\n                }\n                for(; j < temp; j++) {\n\
    \                    if(i % j == 0)\n                        break;\n        \
    \        }\n                if(j > temp) {\n                    ans = i;\n   \
    \                 temp = j;\n                }\n            }\n        }\n   \
    \ }\n    return ans;", "    long ans = 1;\n    for (long i = 3; i <= n; i += 2)\n\
    \        if (n % i == 0)\n            ans = i;\n    return ans;", "\tif (n <=\
    \ 1)\n\t\treturn 0;\n\tlong p = prime_table[n];\n\tlong r = n % p;\n\tlong s =\
    \ (p * p) % n;\n\tlong q = (s * s) % n;\n\twhile (r > 0) {\n\t\tp = prime_table[n];\n\
    \t\tr = n % p;\n\t\ts = (p * p) % n;\n\t\tq = (r * r * r * q * q) % n;\n\t}\n\t\
    return q;", "    long largest = 0;\n    long limit = n;\n    long m = 2;\n\n \
    \   // loop until there are no factors.\n    while (limit > 1) {\n        // If\
    \ limit is even, divide limit by two.\n        if (limit % 2 == 1) {\n       \
    \     limit = limit / 2;\n        }\n\n        // Test if limit is smaller than\
    \ m and larger than the largest prime factor of n.\n        while (m <= limit)\
    \ {\n            if (n % m == 0) {\n                // Limit divides evenly, so\
    \ n must be prime.\n                return n;\n            }\n            m =\
    \ 2 * m;\n        }\n        limit = limit * 2;\n    }\n    return largest;",
  "    assert(n >= 2 && \"n should be greater than or equal to 2\");\n    long l2\
    \ = n/2;\n    long l3 = l2/2;\n    long l4 = l3/2;\n    long l5 = l4/2;\n    long\
    \ l6 = l5/2;\n    long l7 = l6/2;\n    long l8 = l7/2;\n    long l9 = l8/2;\n\
    \    long l10 = l9/2;\n    long l11 = l10/2;\n    long l12 = l11/2;\n    long\
    \ l13 = l12/2;\n    long l14 = l13/2;\n    long l15 = l14/2;\n    long l16 = l15/2;\n\
    \    long l17 = l16/2;\n    long l18 = l17/2;\n    long l19 = l18/2;\n    long\
    \ l20 = l19/2;\n    long l21 = l20/2;\n    long l22 = l21/2;\n    long l23 = l22/2;\n\
    \    long l24 = l23/2;\n    long l25 = l24/2;\n    long l26 = l25/2;\n    long\
    \ l27 = l26/2;\n    long l28 = l27/2;\n    long l29 = l28/2;\n    long l30 = l29/2;\n\
    \    long l31 = l30/2;\n    long l32 = l31/2;\n    long l33 = l32/2;\n    long\
    \ l34 = l33/2;\n    long l35 = l34/2;\n    long l36 = l35/2;\n    long l37 = l36/2;\n\
    \    long l38 = l37/2;\n    long l39 = l38/2;\n    long l40 = l39/2;\n    long\
    \ l41 = l40/2;\n    long l42 = l41/2;\n    long l43 = l42/2;\n    long l44 = l43/2;\n\
    \    long l45 = l44/2;\n    long l46 = l45/2;\n    long l47 = l46/2;\n    long\
    \ l48 = l47/2;\n    long l49 = l48/2;\n    long l50 = l49/2;\n    long l51 = l50/2;\n\
    \    long l52 = l51/2;\n    long l53 = l52/2;\n    long l54 = l53/2;", "    long\
    \ m = (n-1L) / 2;\n    if (m < 2) return 2;\n    for (long i = 2L; i <= m; i +=\
    \ 2L) {\n        if (n % i == 0) return i;\n    }\n    return n;", "\tint i =\
    \ 1;\n\tint largest;\n\twhile (n) {\n\t\tlargest = i;\n\t\ti++;\n\t\tn = (n /\
    \ i) + 1;\n\t}\n\treturn largest;", "    long count = 0;\n    for (long i = 1;\
    \ i <= n; i++) {\n        if (n % i == 0) {\n            if (i != 1 && i != n)\
    \ count++;\n            else {\n                n = n / i;\n                count++;\n\
    \            }\n        }\n    }\n    return count;", "  long max_divisor = 0;\n\
    \  long max_factor = 1;\n  for (long i = 2; i < n; i++) {\n    // if (n % i ==\
    \ 0) {\n    //   return i;\n    // }\n    long c = n % i;\n    if (c == 0 || c\
    \ > max_factor) {\n      max_factor = c; // keep largest factor\n    }\n    max_divisor\
    \ = i;\n  }\n  return max_factor;", "  if (n == 1)\n    return 1;\n  if (n <=\
    \ 1)\n    return 2;\n  // 2 is the only even prime factor\n  if (n == 2)\n   \
    \ return 2;\n  // Any even number greater than 2 is a prime factor\n  long s =\
    \ 3;\n  while (s % 2 == 0)\n    s *= 2;\n  long limit = (long long) sqrt(n);\n\
    \  // 2 is the only even prime number\n  long limit2 = limit;\n  long limit3 =\
    \ limit2;\n  // 3 is the only odd prime number\n  long limit4 = limit3;\n  long\
    \ limit5 = limit4;\n  long limit6 = limit5;\n  long limit7 = limit6;\n  long limit8\
    \ = limit7;\n  long limit9 = limit8;\n  // 2 is the only even prime factor\n \
    \ while (limit9 % 2 == 0)\n    limit9 *= 2;\n  long limit10 = limit9;\n  long\
    \ limit11 = limit10;\n  long limit12 = limit11;\n  long limit13 = limit12;\n \
    \ long limit14 = limit13;\n  long limit15 = limit14;\n  long limit16 = limit15;\n\
    \  long limit17 = limit16;\n  long limit18 = limit17;\n  long limit19 = limit18;\n\
    \  long limit20 = limit19;\n  long limit21 = limit20;\n  long limit22 = limit21;\n\
    \  // 2 is the only even prime factor\n  while (limit22 % 2 == 0)\n    limit22\
    \ *= 2;\n  long limit23 = limit22;\n  long limit24 = limit23;\n  long limit25\
    \ = limit24;\n  long limit26 = limit25;\n  long limit27 = limit26;\n  long limit28\
    \ = limit27;\n  long limit29 = limit28;\n  long limit30 = limit29;\n  long limit31\
    \ = limit30;\n  long limit32 = limit31;\n  long limit33 = limit32;\n  long limit34\
    \ = limit33;\n  long limit35 = limit34;\n  long limit36 = limit35;\n  long limit37\
    \ = limit36;\n  long limit38 = limit37;\n  long limit39 = limit38;\n  long limit40\
    \ = limit39;\n  long limit41 = limit40;\n  long limit42 = limit41;\n  long limit43\
    \ = limit42;\n  long limit44 = limit43;\n  long limit45 = limit44;\n  long limit46\
    \ = limit45;\n  long limit47 = limit46;\n  long limit48 = ", "    long res = 2;\n\
    \    long i = 2;\n    while (i < n) {\n        while (n % i == 0) {\n        \
    \    n /= i;\n            ++i;\n        }\n        if (n == 1) {\n           \
    \ return i;\n        }\n        ++i;\n    }\n    return res;"]
stop_tokens:
- "\n}"
