name: HumanEval_132_is_nested
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // your code here\n    int i = 0;\n    for ( ; i < string.length(); i++)\
    \ {\n        bool is_opening_bracket = false;\n        bool is_closing_bracket\
    \ = false;\n        if (string[i] == '[') {\n            is_opening_bracket =\
    \ true;\n        }\n        if (string[i] == ']') {\n            is_closing_bracket\
    \ = true;\n        }\n        if (string[i] == '[' || string[i] == ']') {\n  \
    \          if (is_opening_bracket && is_closing_bracket) {\n                return\
    \ true;\n            }\n        }\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpiq69g4yu: /tmp/tmpiq69g4yu.cpp:34: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if (string.empty()) return false;\n    int brackets = 0;\n    for (int\
    \ i = 0; i <= string.size(); ++i) {\n        if (string[i] == '[') ++brackets;\n\
    \        if (string[i] == ']') --brackets;\n    }\n    return brackets == 0;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpe721c83q: /tmp/tmpe721c83q.cpp:25: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int brackets = 0;\n    for (int i = 0; i < string.length(); i++) {\n\
    \        if (string[i] == '[') {\n            brackets++;\n        } else if (string[i]\
    \ == ']') {\n            brackets--;\n        }\n        if (brackets == 0) {\n\
    \            return true;\n        }\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmprtuutc3k: /tmp/tmprtuutc3k.cpp:29: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    \n    for( int i = 0; i < string.length()\
    \ - 1; ++i ) {\n        if( string[i] == '[' ) {\n            if( string[i+1]\
    \ == '[' ) {\n                if( string[i+2] == '[' ) {\n                   \
    \ if( string[i+3] == '[' ) {\n                        if( string[i+4] == '[' )\
    \ {\n                            if( string[i+5] == '[' ) {\n                \
    \                if( string[i+6] == '[' ) {\n                                \
    \    return true;\n                                }\n                       \
    \         else {\n                                    return false;\n        \
    \                        }\n                            }\n                  \
    \          else {\n                                return false;\n           \
    \                 }\n                        }\n                        else {\n\
    \                            return false;\n                        }\n      \
    \              }\n                    else {\n                        return false;\n\
    \                    }\n                }\n                else {\n          \
    \          return false;\n                }\n            }\n            else {\n\
    \                return false;\n            }\n        }\n        else {\n   \
    \         return false;\n        }\n    }\n    \n    return false;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpos6mgw44: /tmp/tmpos6mgw44.cpp:58: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Declare a stack to store the opening brackets \n    bool stack[string.length()\
    \ + 1];\n    // Initialize all the brackets to false \n    stack[string.length()]\
    \ = false;\n    // Push all the opening brackets to the stack \n    for (int i\
    \ = 0; i < string.length(); i++) {\n        if (string[i] == '[') stack[i] = true;\n\
    \    }\n    // Pop all the opening brackets from the stack \n    for (int i =\
    \ 0; i < string.length(); i++) {\n        if (stack[string.length() - i - 1] ==\
    \ true && string[i] == '[') stack[string.length() - i - 1] = false;\n    }\n \
    \   if (stack[string.length()] == true) {\n        return false;\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp9p04bao1: /tmp/tmp9p04bao1.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    size_t n = string.length();\n    stack<char>\
    \ s;\n    for (int i = 0; i < n; i++) {\n        if(string[i] == '[') {\n    \
    \        s.push(string[i]);\n        }\n        else if(string[i] == ']') {\n\
    \            char popped;\n            s.pop(popped);\n            if((popped\
    \ == '[') || (popped == ']')) {\n                found = true;\n            }\n\
    \        }\n    }\n    return found;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_2xl91k_.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp_2xl91k_.cpp:15:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   15 |     stack<char> s;\n  \
    \    |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp_2xl91k_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp_2xl91k_.cpp:15:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   15 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmp_2xl91k_.cpp:18:13: error: \u2018s\u2019 was not declared in this scope\n\
    \   18 |             s.push(string[i]);\n      |             ^\n/tmp/tmp_2xl91k_.cpp:22:13:\
    \ error: \u2018s\u2019 was not declared in this scope\n   22 |             s.pop(popped);\n\
    \      |             ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool result = false;\n    stack<char> stack;\n    for (char c: string)\
    \ {\n        if (c == '[' || c == '(') {\n            stack.push(c);\n       \
    \ }\n        else if (c == '[' && stack.empty()) {\n            result = true;\n\
    \        }\n        else if (c == ']' && stack.empty()) {\n            result\
    \ = false;\n        }\n        else if (c == ']' && stack.size() > 0) {\n    \
    \        if (stack.top() == '[') {\n                stack.pop();\n           \
    \ }\n        }\n        else if (c == ']' && stack.size() > 0 && stack.top() ==\
    \ '[') {\n            stack.pop();\n        }\n        else if (c == ']' && stack.size()\
    \ == 0) {\n            result = false;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp51qh3jgd.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp51qh3jgd.cpp:14:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   14 |     stack<char> stack;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp51qh3jgd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp51qh3jgd.cpp:14:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   14 |     stack<char> stack;\n      |           ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    char stack[100]; // array to store brackets encountered.\n    stack[0]\
    \ = '\\0';\n\n    int index = 0; // To store the last index of 'stack'.\n\n  \
    \  for(int i = 0; string[i] != '\\0'; i++){\n        // If character is not a\
    \ bracket, push it on stack.\n        if(string[i] != '[') {\n            stack[index]\
    \ = string[i];\n            index++;\n        }\n        // If character is a\
    \ bracket, check if previous character was a bracket.\n        else if(string[i]\
    \ == '[') {\n            if(stack[index-1] == '[') {\n                stack[index-1]\
    \ = ']'; // Replace '[' bracket with ']' to maintain balance.\n              \
    \  index--;\n            }\n        }\n        // If character is ']', pop the\
    \ top of stack and store it into index and string.\n        else if(string[i]\
    \ == ']') {\n            string new_string;\n            for(int j = (index-1);\
    \ j >= 0; j--){\n                new_string += stack[j];\n            }\n    \
    \        index--;\n            stack[index] = '\\0';\n            // Return true\
    \ if and only if subsequence of brackets maintained at top.\n            return\
    \ (new_string == string);\n        }\n    }\n    // Return false if string does\
    \ not contain any bracket.\n    return false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpydp5t_zl.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpydp5t_zl.cpp:33:19: error: expected \u2018;\u2019 before \u2018new_string\u2019\
    \n   33 |             string new_string;\n      |                   ^~~~~~~~~~~\n\
    \      |                   ;\n/tmp/tmpydp5t_zl.cpp:35:17: error: \u2018new_string\u2019\
    \ was not declared in this scope; did you mean \u2018string\u2019?\n   35 |  \
    \               new_string += stack[j];\n      |                 ^~~~~~~~~~\n\
    \      |                 string\n/tmp/tmpydp5t_zl.cpp:40:21: error: \u2018new_string\u2019\
    \ was not declared in this scope; did you mean \u2018string\u2019?\n   40 |  \
    \           return (new_string == string);\n      |                     ^~~~~~~~~~\n\
    \      |                     string\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> brackets;\n    bool found = false;\n    for (int i = 0; i\
    \ < string.length(); i++) {\n        if (brackets.empty() && string[i] == '[')\
    \ brackets.push(string[i]);\n        if (brackets.empty() && string[i] == ']')\
    \ brackets.push(string[i]);\n        if (brackets.top() == '[' && string[i] ==\
    \ ']') {\n            brackets.pop();\n            found = true;\n        } else\
    \ {\n            brackets.pop();\n        }\n    }\n    return found;\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyw6xqc42.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpyw6xqc42.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> brackets;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpyw6xqc42.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpyw6xqc42.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> brackets;\n      |        \
    \   ^~~~\n/tmp/tmpyw6xqc42.cpp:16:13: error: \u2018brackets\u2019 was not declared\
    \ in this scope\n   16 |         if (brackets.empty() && string[i] == '[') brackets.push(string[i]);\n\
    \      |             ^~~~~~~~\n/tmp/tmpyw6xqc42.cpp:17:13: error: \u2018brackets\u2019\
    \ was not declared in this scope\n   17 |         if (brackets.empty() && string[i]\
    \ == ']') brackets.push(string[i]);\n      |             ^~~~~~~~\n/tmp/tmpyw6xqc42.cpp:18:13:\
    \ error: \u2018brackets\u2019 was not declared in this scope\n   18 |        \
    \ if (brackets.top() == '[' && string[i] == ']') {\n      |             ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if (string.size() == 0) return false;\n    size_t openCount = 0;\n  \
    \  size_t closeCount = 0;\n    for (size_t i = 0; i < string.size(); i++) {\n\
    \        if (string[i] == '[') openCount++;\n        if (string[i] == ']') closeCount++;\n\
    \    }\n    if (openCount != closeCount) return false;\n    bool result = true;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[' &&\
    \ string[i - 1] != ']') result = false;\n        if (string[i] == ']' && string[i\
    \ + 1] != ']') result = false;\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpg3v91u5g: /tmp/tmpg3v91u5g.cpp:30: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int counter = 0;\n  for (int i = 0; i < string.length(); i++) {\n    if\
    \ (string[i] == '[' && string[i + 1] == '[') {\n      counter++;\n      if (string[i\
    \ + 2] == '[' && string[i + 3] == '[') {\n        counter++;\n      }\n    }\n\
    \    if (string[i] == '[' && string[i + 1] == ']') {\n      counter--;\n    }\n\
    \    if (string[i] == ']' && string[i + 1] == ']') {\n      counter--;\n    }\n\
    \  }\n  if (counter == 0)\n    return false;\n  return true;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpd_3_wg04: /tmp/tmpd_3_wg04.cpp:35: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size(); // length of string\n    // If string has only\
    \ one char, return false\n    if (n == 1)\n        return false;\n    // If string\
    \ does not contain opening or closing brackets, return false\n    if (string[0]\
    \ != '[' || string[n-1] != ']')\n        return false;\n    // Open and close\
    \ brackets index\n    int opening_bracket = 0;\n    int closing_bracket = 0;\n\
    \    // Go through the string, starting at the begining\n    // and ending, checking\
    \ the nesting brackets\n    for (int i = 0; i < n; i++) {\n        // If brackets\
    \ are closed, return false\n        if (string[i] == ']') {\n            // if\
    \ opening brackets are closed, return false\n            if (opening_bracket ==\
    \ closing_bracket)\n                return false;\n            // else decrement\
    \ closing bracket\n            closing_bracket--;\n        }\n        // Else\
    \ open bracket\n        else if (string[i] == '[') {\n            // if opening\
    \ brackets are closed, return false\n            if (opening_bracket == closing_bracket)\n\
    \                return false;\n            // else increment opening bracket\n\
    \            opening_bracket++;\n        }\n        // Else string does not contain\
    \ brackets\n        else {\n            // If brackets still open, return false\n\
    \            if (opening_bracket > closing_bracket)\n                return false;\n\
    \        }\n    }\n    // If brackets are closed, return false\n    if (opening_bracket\
    \ > closing_bracket)\n        return false;\n    // Else brackets are not closed\
    \ or invalid, return true\n    return true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpooux9_dx: /tmp/tmpooux9_dx.cpp:57: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp7xf33b2j: /tmp/tmp7xf33b2j.cpp:17: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int level = 0;\n    for (int i = 0; i < string.size(); ++i) {\n     \
    \   if (string[i] == '[') {\n            ++level;\n        } else if (string[i]\
    \ == ']') {\n            --level;\n        }\n        if (level < 0) {\n     \
    \       return false;\n        }\n    }\n    return true;\n}\nint main() {\n \
    \   auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpdrxn6dc7: /tmp/tmpdrxn6dc7.cpp:30: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    auto bracket_counter = 0;\n    for(auto &c : string) {\n        if(c\
    \ != '[') {\n            continue;\n        }\n        bracket_counter++;\n  \
    \      if(bracket_counter == 1) {\n            continue;\n        }\n        \n\
    \        if(c == ']' && bracket_counter == 2) {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp5kpjcoiu: /tmp/tmp5kpjcoiu.cpp:31: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // TODO: Write a function that takes in a string and returns the length\
    \ of the string.\n    // We will use this length to determine whether brackets\
    \ are nested or not.\n\n    int num_open = 0;\n    int num_close = 0;\n    for\
    \ (int i = 0; i<string.length(); i++) {\n        if (string[i] == '[') num_open++;\n\
    \        else if (string[i] == ']') num_close++;\n    }\n    // TODO: If there\
    \ are only nested brackets.\n    if (num_open == num_close) return true;\n   \
    \ // TODO: If there are any number of unmatched brackets.\n    if (num_open >\
    \ num_close) return false;\n    // TODO: If there are more open brackets than\
    \ closed brackets.\n    if (num_open < num_close) return false;\n    // TODO:\
    \ If there are no open brackets at all.\n    if (num_open == 0) return false;\n\
    \    // TODO: If there are no closed brackets at all.\n    if (num_close == 0)\
    \ return false;\n\n    // TODO: If there are more open brackets than closed brackets.\n\
    \    if (num_open < num_close) return false;\n\n    // TODO: If there are any\
    \ number of unmatched brackets.\n    if (num_open > num_close) return false;\n\
    \n    // TODO: If there are any number of open brackets than closed brackets.\n\
    \    if (num_open < num_close) return false;\n\n    // TODO: If there are any\
    \ number of open brackets than closed brackets.\n    if (num_open > num_close)\
    \ return false;\n\n    // TODO: If there are any number of open brackets than\
    \ closed brackets.\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpaqfsgcqb: /tmp/tmpaqfsgcqb.cpp:52: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size();\n    int count = 0;\n    for (int i = 0; i < n;\
    \ i++) {\n        if (string[i] == '[') count++;\n        if (string[i] == ']')\
    \ count--;\n        if (string[i] == ']' && count < 0) return false;\n    }\n\
    \    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpzjiynw0i: /tmp/tmpzjiynw0i.cpp:26: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your logic here\n    bool foundBracket = false;\n    for(char\
    \ char : string) {\n        if(char == '[') {\n            foundBracket = true;\n\
    \        }\n        if(char == ']' && foundBracket) {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpti9bu00p.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpti9bu00p.cpp:15:19: error: expected unqualified-id before \u2018:\u2019\
    \ token\n   15 |     for(char char : string) {\n      |                   ^\n\
    /tmp/tmpti9bu00p.cpp:16:17: error: expected unqualified-id before \u2018==\u2019\
    \ token\n   16 |         if(char == '[') {\n      |                 ^~\n/tmp/tmpti9bu00p.cpp:19:17:\
    \ error: expected unqualified-id before \u2018==\u2019 token\n   19 |        \
    \ if(char == ']' && foundBracket) {\n      |                 ^~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int counter = 0;\n    for (int i = 0; i < string.length(); i++) {\n \
    \       if (string[i] == '[' && string[i + 1] == ']') {\n            counter++;\n\
    \        } else if (string[i] == '[' && string[i + 1] != ']') {\n            counter\
    \ = 0;\n        }\n    }\n    return counter == 0;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmplyho6efl: /tmp/tmplyho6efl.cpp:25: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> brackets;\n    // Add opening brackets to the stack\n   \
    \ for (char c : string) {\n        if (c == '[') {\n            brackets.push(c);\n\
    \        }\n    }\n    // Check if there are brackets left in the stack\n    while\
    \ (brackets.size() != 0) {\n        // Pop stack until you get to closing brackets\n\
    \        char c = brackets.pop();\n        if (c == '[') {\n            if (brackets.size()\
    \ == 0) {\n                // If all the brackets have been popped then return\
    \ False\n                return false;\n            }\n        } else if (c ==\
    \ '{') {\n            // If all the brackets have been popped then return False\n\
    \            if (brackets.size() == 0) {\n                return false;\n    \
    \        }\n        } else if (c == ']') {\n            // If all the brackets\
    \ have been popped then return False\n            if (brackets.size() == 0) {\n\
    \                return false;\n            }\n        } else if (c == '}') {\n\
    \            // If all the brackets have been popped then return False\n     \
    \       if (brackets.size() == 0) {\n                return false;\n         \
    \   }\n        } else {\n            return false;\n        }\n    }\n    // If\
    \ the stack had no brackets then return True\n    return true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2qyaeojy.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp2qyaeojy.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> brackets;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp2qyaeojy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp2qyaeojy.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> brackets;\n      |        \
    \   ^~~~\n/tmp/tmp2qyaeojy.cpp:17:13: error: \u2018brackets\u2019 was not declared\
    \ in this scope\n   17 |             brackets.push(c);\n      |             ^~~~~~~~\n\
    /tmp/tmp2qyaeojy.cpp:21:12: error: \u2018brackets\u2019 was not declared in this\
    \ scope\n   21 |     while (brackets.size() != 0) {\n      |            ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tstack<char> stack;\n\tbool flag = false;\n\tfor (int i = 0; i < string.size();\
    \ i++) {\n\t\tif (string[i] == '[') stack.push('[');\n\t\telse if (string[i] ==\
    \ ']') if (!stack.empty() && stack.top() == '[') stack.push(']');\n\t\telse if\
    \ (string[i] == ']') if (stack.top() == '[') stack.pop();\n\t\telse if (!stack.empty()\
    \ && stack.top() == '[')\n\t\t\tstack.push(string[i]);\n\t\telse if (!stack.empty()\
    \ && stack.top() == '[' && stack.top() == string[i])\n\t\t\tstack.pop();\n\t\t\
    else if (!stack.empty() && stack.top() == '[' && stack.top() != string[i])\n\t\
    \t\tflag = false;\n\t\telse if (string[i] == '[' && stack.empty()) flag = true;\n\
    \t\telse if (!stack.empty() && stack.top() == '[' && string[i] != stack.top())\n\
    \t\t\tflag = false;\n\t}\n\treturn flag;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp1g8dbk37.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp1g8dbk37.cpp:13:2: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |  stack<char> stack;\n \
    \     |  ^~~~~\n      |  std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp1g8dbk37.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp1g8dbk37.cpp:13:8: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |  stack<char> stack;\n      |        ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // write your code in C++17\n    int l = 0;\n    int r = string.size();\n\
    \    stack<int> st;\n    for(int i = 0; i < r; i++) {\n        if(string[i] ==\
    \ '[') {\n            st.push(i);\n        }\n        if(string[i] == '[') {\n\
    \            while(!st.empty() && st.top() != i) {\n                r--;\n   \
    \             if(string[r] == '[') st.push(r);\n                if(string[r] ==\
    \ ']') st.pop();\n            }\n        }\n    }\n    if(!st.empty()) return\
    \ false;\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp7f04tjaz.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp7f04tjaz.cpp:16:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   16 |     stack<int> st;\n  \
    \    |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp7f04tjaz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp7f04tjaz.cpp:16:11: error: expected primary-expression\
    \ before \u2018int\u2019\n   16 |     stack<int> st;\n      |           ^~~\n\
    /tmp/tmp7f04tjaz.cpp:19:13: error: \u2018st\u2019 was not declared in this scope;\
    \ did you mean \u2018std\u2019?\n   19 |             st.push(i);\n      |    \
    \         ^~\n      |             std\n/tmp/tmp7f04tjaz.cpp:22:20: error: \u2018\
    st\u2019 was not declared in this scope; did you mean \u2018std\u2019?\n   22\
    \ |             while(!st.empty() && st.top() != i) {\n      |               \
    \     ^~\n      |                    std\n/tmp/tmp7f04tjaz.cpp:29:9: error: \u2018\
    st\u2019 was not declared in this scope; did you mean \u2018std\u2019?\n   29\
    \ |     if(!st.empty()) return false;\n      |         ^~\n      |         std\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size();\n    if(n <= 0) return false;\n    for(int i =\
    \ 1; i < n; ++i) {\n        if(string[i - 1] == '[' && string[n - i - 1] == ']')\
    \ {\n            return true;\n        }\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpqsb6fn4m: /tmp/tmpqsb6fn4m.cpp:25: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // base case\n    if (string.length() <= 1)\n        return true;\n\n\
    \    // find first ]\n    auto iter = string.find(\"]\");\n    // if string doesn't\
    \ contain ], return false\n    if (iter == std::string::npos)\n        return\
    \ false;\n\n    // create stack\n    std::vector<bool> stack;\n    stack.push_back(false);\n\
    \    // for every char in string\n    for (auto itr = iter + 1; itr < string.length();\
    \ itr++) {\n        if (stack[string[itr]]) {\n            // return false as\
    \ string is not valid\n            return false;\n        }\n        stack.push_back(false);\n\
    \        // if we encounter any ] pop an item from stack\n        if (string[itr]\
    \ == '[')\n            stack[string[itr]] = true;\n    }\n\n    // if we encounter\
    \ any [ return true as string is in valid\n    return true;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpp8rk0hcn: /tmp/tmpp8rk0hcn.cpp:46: int main(): Assertion `candidate((\"\
    []\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n   //your code here\n    if(string.size()<2) return false; \n    bool lbracket=false;\n\
    \    bool rbracket=false;\n    for(auto i:string) \n        if(i=='[' || i==']')\
    \ lbracket=true;\n        if(i=='{' || i=='}') rbracket=true;\n    if(lbracket\
    \ && rbracket) return true; // If both brackets are present they should be nested\n\
    \    else return false; // If one bracket is present they are not nested\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpew11xjww.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpew11xjww.cpp:19:12: error: \u2018i\u2019 was not declared in this scope\n\
    \   19 |         if(i=='{' || i=='}') rbracket=true;\n      |            ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> brackets;\n    for (char c : string) {\n        if (c ==\
    \ '[') {\n            brackets.push(c);\n        } else if (c == ']') {\n    \
    \        if (brackets.empty())\n                return false;\n            char\
    \ last = brackets.top();\n            brackets.pop();\n            if (last ==\
    \ '[') {\n                brackets.push(c);\n            } else if (last == ']')\n\
    \                return false;\n        }\n    }\n    return brackets.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjxl0c1t5.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpjxl0c1t5.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> brackets;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpjxl0c1t5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpjxl0c1t5.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> brackets;\n      |        \
    \   ^~~~\n/tmp/tmpjxl0c1t5.cpp:16:13: error: \u2018brackets\u2019 was not declared\
    \ in this scope\n   16 |             brackets.push(c);\n      |             ^~~~~~~~\n\
    /tmp/tmpjxl0c1t5.cpp:18:17: error: \u2018brackets\u2019 was not declared in this\
    \ scope\n   18 |             if (brackets.empty())\n      |                 ^~~~~~~~\n\
    /tmp/tmpjxl0c1t5.cpp:20:25: error: \u2018brackets\u2019 was not declared in this\
    \ scope\n   20 |             char last = brackets.top();\n      |            \
    \             ^~~~~~~~\n/tmp/tmpjxl0c1t5.cpp:28:12: error: \u2018brackets\u2019\
    \ was not declared in this scope\n   28 |     return brackets.empty();\n     \
    \ |            ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  // Your code goes here\n  std::stack<char> s;\n  for (size_t i = 0; i <\
    \ string.size(); ++i)\n  {\n    char curr = string[i];\n    if (curr == '[' ||\
    \ curr == '(' || curr == '{' || curr == '<')\n    {\n      if (!s.empty() && s.top()\
    \ == curr)\n      {\n        return true;\n      }\n      s.push(curr);\n    }\n\
    \  }\n  return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpwp6z7kqb: /tmp/tmpwp6z7kqb.cpp:32: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n   \n    // Create an empty stack\n    stack<int> stack{};\n    \n    //\
    \ Push each element from the input string to the stack\n    for (int i = 0; i\
    \ < string.size(); ++i) {\n        // If the element is ']' then we pop one element\
    \ from the stack\n        // and compare it with the ']' \n        if (string[i]\
    \ == ']') {\n            if (!stack.empty() && stack.top() == string[i]) {\n \
    \               stack.pop();\n            } else {\n                // We reach\
    \ here when input string contains no nested brackets\n                return false;\n\
    \            }\n        // If element is not ']' then we push element onto the\
    \ stack\n        } else {\n            stack.push(string[i]);\n        }\n   \
    \ }\n    \n    // We reach here when input string contains no nested brackets\n\
    \    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp9o951_6v.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp9o951_6v.cpp:15:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   15 |     stack<int> stack{};\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp9o951_6v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp9o951_6v.cpp:15:11: error: expected primary-expression\
    \ before \u2018int\u2019\n   15 |     stack<int> stack{};\n      |           ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int counter = 0;\n    for (int i = 0; i < string.length(); i++) {\n \
    \       if (string[i] == '[') {\n            if (string[i + 1] == '[') {\n   \
    \             counter++;\n            }\n            if (string[i + 1] == ']')\
    \ {\n                counter--;\n            }\n        }\n    }\n    return counter\
    \ <= 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpvrjjoytv: /tmp/tmpvrjjoytv.cpp:30: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // TODO: Implement this function\n    return true;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp9fjf64ra: /tmp/tmp9fjf64ra.cpp:19: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::string input = \"[[]\";\n    string output = \"[[]\";\n    for (int\
    \ i = 1; i <= input.size(); i++) {\n        if (input[i-1] == input[i]) {\n  \
    \          output += input[i-1];\n        }\n        else {\n            if (output[output.size()-1]\
    \ == '[' && output[output.size()-2] == ']') {\n                return true;\n\
    \            }\n            else {\n                return false;\n          \
    \  }\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmplvvf1h9_.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmplvvf1h9_.cpp:14:11: error: expected \u2018;\u2019 before \u2018output\u2019\
    \n   14 |     string output = \"[[]\";\n      |           ^~~~~~~\n      |   \
    \        ;\n/tmp/tmplvvf1h9_.cpp:17:13: error: \u2018output\u2019 was not declared\
    \ in this scope\n   17 |             output += input[i-1];\n      |          \
    \   ^~~~~~\n/tmp/tmplvvf1h9_.cpp:20:17: error: \u2018output\u2019 was not declared\
    \ in this scope\n   20 |             if (output[output.size()-1] == '[' && output[output.size()-2]\
    \ == ']') {\n      |                 ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int i, j;\n    bool ok = false;\n    // Check\
    \ every position in the string once\n    // If current position is open bracket,\
    \ check if it is nested.\n    for (i = 1; i < string.size(); i++) {\n        if\
    \ (string[i-1] == '[' && string[i] == ']') {\n            // Add 1 to i because\
    \ we want to check if i+1 is nested\n            for (j = i+1; j < string.size();\
    \ j++) {\n                if (string[j-1] != ']' && string[j-1] != ']' && string[j-1]\
    \ != '[') {\n                    ok = true;\n                }\n            }\n\
    \        } else {\n            ok = true;\n        }\n    }\n    return ok;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpv87iyp0b: /tmp/tmpv87iyp0b.cpp:35: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> s;\n    bool ok = false;\n    \n    for (char c : string)\
    \ {\n        if (c == '[') {\n            s.push( '[' );\n        } else if (c\
    \ == ']') {\n            if (!s.empty()) {\n                if (s.top() == '[')\
    \ s.pop();\n                else ok = false;\n            }\n        } else {\n\
    \            ok = false;\n        }\n    }\n\n    return ok;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnaqvqt0g.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpnaqvqt0g.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> s;\n  \
    \    |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpnaqvqt0g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpnaqvqt0g.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmpnaqvqt0g.cpp:18:13: error: \u2018s\u2019 was not declared in this scope\n\
    \   18 |             s.push( '[' );\n      |             ^\n/tmp/tmpnaqvqt0g.cpp:20:18:\
    \ error: \u2018s\u2019 was not declared in this scope\n   20 |             if\
    \ (!s.empty()) {\n      |                  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size();\n    for (int i = 0; i < n; i++) {\n        if\
    \ (string[i] == '[' && string[i+1] == '[') {\n            i += 2;\n        }\n\
    \        if (string[i] == '[' && string[i+1] != ']') {\n            return false;\n\
    \        }\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpbmr1sa_1: /tmp/tmpbmr1sa_1.cpp:28: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::vector<bool> stack(string.size());\n    for(auto i : string)\n \
    \   {\n        if(stack[i] == true) \n        {\n            continue;\n     \
    \   }\n        stack[i] = false;\n        if(string[i] != '[')\n        {\n  \
    \          continue;\n        }\n        int count = 0;\n        for(int j = i+1;\
    \ j < string.size(); j++)\n        {\n            if(i == j)\n            {\n\
    \                continue;\n            }\n            if(string[j] == '[') \n\
    \            {\n                count++;\n            }\n            else if(string[j]\
    \ == ']')\n            {\n                count--;\n                if(count ==\
    \ 0)\n                {\n                    return true;\n                }\n\
    \            }\n        }\n    }\n    return false;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp61_of14q: /tmp/tmp61_of14q.cpp:50: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int start_pos = 0;\n    int end_pos = 0;\n    int index = 0;\n    bool\
    \ result = false;\n    // Get the subsequence from the string using []\n    while(true)\
    \ {\n        end_pos = string.find('[', index);\n        if(end_pos == string::npos)\
    \ {\n            result = true;\n            break;\n        }\n        start_pos\
    \ = end_pos + 1;\n        ++index;\n    }\n\n    // Get the subsequence from the\
    \ string using ()\n    while(true) {\n        end_pos = string.find('(', index);\n\
    \        if(end_pos == string::npos) {\n            result = true;\n         \
    \   break;\n        }\n        start_pos = end_pos + 1;\n        ++index;\n  \
    \  }\n\n    return result;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpkv6thraj.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpkv6thraj.cpp:20:23: error: \u2018string\u2019 is not a class, namespace,\
    \ or enumeration\n   20 |         if(end_pos == string::npos) {\n      |     \
    \                  ^~~~~~\n/tmp/tmpkv6thraj.cpp:31:23: error: \u2018string\u2019\
    \ is not a class, namespace, or enumeration\n   31 |         if(end_pos == string::npos)\
    \ {\n      |                       ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int left_bracket_count = 0, right_bracket_count = 0;\n    for (int i\
    \ = 0; i != string.length(); ++i) {\n        if (string[i] == '[') ++left_bracket_count;\n\
    \        if (string[i] == ']') ++right_bracket_count;\n        if (string[i] ==\
    \ '(' && left_bracket_count > 0 && right_bracket_count > 0) {\n            --right_bracket_count;\n\
    \            --left_bracket_count;\n        } else if (string[i] == '(' && left_bracket_count\
    \ == 0 && right_bracket_count == 0) {\n            return true;\n        }\n \
    \   }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp134hd925: /tmp/tmp134hd925.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // We will use a stack to keep track of characters in the string. \n\
    \    // If we encounter a '[' character then we will push it on the stack.\n \
    \   // If we encounter a ']' character then we will pop the stack until we encounter\
    \ the \n    // same type of opening bracket. \n    // After we pop the stack,\
    \ we will check if there are still brackets left. If there are no \n    // brackets\
    \ left then we will return False. Otherwise we will return the last value of the\
    \ stack.\n    \n    stack<char> stack;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        // We want to check if the top character on the stack is the\
    \ same as the current \n        // character in the string. If they are equal,\
    \ then we will pop the stack and push \n        // the current character back\
    \ on the stack.\n        // If the top character is different than the current\
    \ character then we will \n        // push the current character on to the stack.\n\
    \        if(stack.empty() || stack.top() != string[i]) {\n            stack.push(string[i]);\n\
    \        } else {\n            stack.pop();\n        }\n    }\n    \n    // We\
    \ should check if the stack is empty after the loop. If it is empty, then there\
    \ \n    // are no nested brackets. \n    if(stack.empty()) {\n        return false;\n\
    \    } else {\n        return stack.empty();\n    }\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpc5j_vmzw.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpc5j_vmzw.cpp:20:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   20 |     stack<char> stack;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpc5j_vmzw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpc5j_vmzw.cpp:20:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   20 |     stack<char> stack;\n      |           ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // We are using two stacks to check if a brackets is nested or not.\n\
    \    stack<char> brackets;\n    stack<char> current;\n    bool flag = false;\n\
    \    // Iterate through the string.\n    for(int i = 0; i < string.size(); i++)\
    \ {\n        // If the current character is a bracket, push the bracket to the\
    \ stack.\n        if(string[i] == '[') {\n            brackets.push(string[i]);\n\
    \        } else if(string[i] == ']') {\n            // If the current bracket\
    \ is closed, pop the current bracket.\n            if(brackets.size() > 0) {\n\
    \                brackets.pop();\n            }\n            // If the current\
    \ bracket is opened, push the current bracket to the stack.\n            if(current.size()\
    \ > 0) {\n                brackets.push(current);\n            }\n           \
    \ // If the current character is another bracket, push the current bracket to\
    \ the stack.\n            if(current.size() == 0 && brackets.size() == 0) {\n\
    \                current.push(string[i]);\n            }\n        }\n        //\
    \ If the current character is neither a bracket or a brace, push the current character\
    \ to the stack.\n        else if(current.size() == 0) {\n            current.push(string[i]);\n\
    \        }\n        // If a string contains more than one closing bracket, break\
    \ the loop.\n        else if(current.size() > 0 && brackets.size() == 0) {\n \
    \           flag = true;\n            break;\n        }\n    }\n    return flag;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7b_21ion.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp7b_21ion.cpp:14:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   14 |     stack<char> brackets;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp7b_21ion.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp7b_21ion.cpp:14:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   14 |     stack<char> brackets;\n      |        \
    \   ^~~~\n/tmp/tmp7b_21ion.cpp:15:11: error: expected primary-expression before\
    \ \u2018char\u2019\n   15 |     stack<char> current;\n      |           ^~~~\n\
    /tmp/tmp7b_21ion.cpp:21:13: error: \u2018brackets\u2019 was not declared in this\
    \ scope\n   21 |             brackets.push(string[i]);\n      |             ^~~~~~~~\n\
    /tmp/tmp7b_21ion.cpp:24:16: error: \u2018brackets\u2019 was not declared in this\
    \ scope\n   24 |             if(brackets.size() > 0) {\n      |              \
    \  ^~~~~~~~\n/tmp/tmp7b_21ion.cpp:28:16: error: \u2018current\u2019 was not declared\
    \ in this scope\n   28 |             if(current.size() > 0) {\n      |       \
    \         ^~~~~~~\n/tmp/tmp7b_21ion.cpp:29:17: error: \u2018brackets\u2019 was\
    \ not declared in this scope\n   29 |                 brackets.push(current);\n\
    \      |                 ^~~~~~~~\n/tmp/tmp7b_21ion.cpp:32:16: error: \u2018current\u2019\
    \ was not declared in this scope\n   32 |             if(current.size() == 0 &&\
    \ brackets.size() == 0) {\n      |                ^~~~~~~\n/tmp/tmp7b_21ion.cpp:32:39:\
    \ error: \u2018brackets\u2019 was not declared in this scope\n   32 |        \
    \     if(current.size() == 0 && brackets.size() == 0) {\n      |             \
    \                          ^~~~~~~~\n/tmp/tmp7b_21ion.cpp:37:17: error: \u2018\
    current\u2019 was not declared in this scope\n   37 |         else if(current.size()\
    \ == 0) {\n      |               "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpzoi2ezxt: /tmp/tmpzoi2ezxt.cpp:17: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i]\
    \ == '[') {\n            int open = i;\n            while(open == string.length()\
    \ || string[open] != '[')\n                open++;\n            bool valid = true;\n\
    \            for(int j = open; j < string.length() && valid == true; j++)\n  \
    \          {\n                if(string[j] == '[') {\n                    valid\
    \ = false;\n                }\n            }\n            int close = i;\n   \
    \         while(close == string.length() || string[close] != ']')\n          \
    \      close++;\n            valid = valid && close - open + 1 == string.length();\n\
    \            if(valid)\n                return true;\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpcdpc0wwp: /tmp/tmpcdpc0wwp.cpp:38: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n   if(string.size()<1)\n      return false;\n   \n   if(string[0]!='[')\n\
    \      return false;\n   int start=1;\n   int end=0;\n   \n   for(int i=1;i<string.length();i++)\n\
    \      {\n         if(string[i]==']')\n          {\n             end=i+1;\n  \
    \           break;\n          }\n         if(string[i]==')')\n          {\n  \
    \           start=i+1;\n          }\n      }\n  \n   if(end<=start)\n      return\
    \ false;\n   \n   for(int i=start;i<=end;i++)\n   {\n     if(string[i]=='[')\n\
    \     {\n       for(int j=i;j<end;j++)\n         if(string[j]=='[')\n        \
    \ {\n           for(int k=j+1;k<end;k++)\n             if(string[k]==']')\n  \
    \           {\n               return true;\n             }\n         }\n     }\n\
    \   }\n   return false;\n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp_7k75f0q: /tmp/tmp_7k75f0q.cpp:62: int main(): Assertion `candidate((\"\
    [][][[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> stack;\n    for (int i = 0; i < string.length(); i++)\
    \ {\n        char c = string[i];\n        if (c == '[') {\n            if (stack.isEmpty())\
    \ {\n                stack.push(c);\n            } else {\n                char\
    \ popped = stack.top();\n                stack.pop();\n                if (c ==\
    \ '[' && popped == ']') {\n                    stack.push(c);\n              \
    \  } else if (c == ']' && popped == '[') {\n                    stack.push(c);\n\
    \                } else if (c == ']' && popped == ']') {\n                   \
    \ stack.push(c);\n                    return true;\n                } else if\
    \ (c == ']' && popped == '[') {\n                    stack.push(c);\n        \
    \            return true;\n                } else if (c == '[' && popped == ']')\
    \ {\n                    stack.push(c);\n                    return true;\n  \
    \              }\n            }\n        } else {\n            if (stack.isEmpty())\
    \ {\n                return false;\n            }\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpv83y2fut.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpv83y2fut.cpp:17:23: error: \u2018class std::stack<char>\u2019 has no\
    \ member named \u2018isEmpty\u2019; did you mean \u2018empty\u2019?\n   17 | \
    \            if (stack.isEmpty()) {\n      |                       ^~~~~~~\n \
    \     |                       empty\n/tmp/tmpv83y2fut.cpp:38:23: error: \u2018\
    class std::stack<char>\u2019 has no member named \u2018isEmpty\u2019; did you\
    \ mean \u2018empty\u2019?\n   38 |             if (stack.isEmpty()) {\n      |\
    \                       ^~~~~~~\n      |                       empty\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if (string.size() < 1)\n        return false;\n\n    int opens = 0;\n\
    \    for (int i = 1; i < string.size(); ++i) {\n        if (string[i] == '[')\
    \ opens++;\n        if (string[i] == ']') opens--;\n    }\n    return opens ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpcu1pkpwg: /tmp/tmpcu1pkpwg.cpp:25: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    int bracketCounter = 0;\n    int lastBracketIndex\
    \ = -1;\n    bool isNested = false;\n    for (int i = 0; i < string.size(); i++)\
    \ {\n        char curr = string[i];\n        if (curr == '[') {\n            bracketCounter++;\n\
    \            lastBracketIndex = i;\n        } else if (curr == ']') {\n      \
    \      bracketCounter--;\n            if (bracketCounter == 0) {\n           \
    \     isNested = true;\n                break;\n            }\n        } else\
    \ if (curr == '[' || curr == ']') {\n            isNested = true;\n        }\n\
    \    }\n    return isNested;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpnwcjnbpe: /tmp/tmpnwcjnbpe.cpp:37: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int n = string.length();\n  // int i = 0 ;\n  // for ( i = 0; i < n ; i++\
    \ ) {\n  //     if (string[i] == '[' ) {\n  //         if (string[i+1] == '[')\
    \ {\n  //             // If i is even, then i+2 is even.\n  //             if\
    \ ( i % 2 == 0 ) {\n  //                 // Check if i+2 is even.\n  //      \
    \           if ( string[i+2] == '[' ) {\n  //                     return true;\n\
    \  //                 }\n  //             }\n  //         }\n  //     }\n  //\
    \ }\n  // return false;\n  int i = 0 ;\n  for ( i = 0; i < n ; i++ ) {\n    if\
    \ ( string[i] == '[' ) {\n      int j = i+1 ;\n      // for (int k = i+1; k <\
    \ n ; k++ ) {\n      for ( j = i+1; j < n ; j++ ) {\n        if (string[j] ==\
    \ '[') {\n          // k = j;\n          // if ( string[k] == '[' ) {\n      \
    \    int k = j+1 ;\n          if ( k < n ) {\n            if ( string[k] == '['\
    \ ) {\n              return true;\n            }\n          }\n        }\n   \
    \   }\n    }\n  }\n  return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpbn6iwuy5: /tmp/tmpbn6iwuy5.cpp:52: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // TODO: write your code here\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp13hwaj55: /tmp/tmp13hwaj55.cpp:17: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    \n    // Your code here\n    \n    if (string.length() == 0)\n      \
    \  return true;\n    \n    int open = string[0];\n    \n    int count = 0;\n \
    \   \n    for (int i = 1; i < string.length(); i++) {\n        \n        // Check\
    \ whether the current character is [\n        if (string[i] == '[') {\n      \
    \      \n            // If current is opening bracket, increment the count.\n\
    \            if (open == '[')\n                count++;\n            \n      \
    \      // If current is closing bracket, decrement the count.\n            if\
    \ (open == ']')\n                count--;\n            \n            // If count\
    \ is zero, return false.\n            if (count == 0)\n                return\
    \ false;\n        }\n        \n        // Increment count for the opening bracket\n\
    \        if (string[i] == open)\n            count++;\n        \n        // Decrement\
    \ count for the closing bracket\n        if (string[i] == open)\n            count--;\n\
    \    }\n    \n    // If count is non-zero, return true.\n    return count > 0;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpx2e3dlnc: /tmp/tmpx2e3dlnc.cpp:56: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here!\n    int i = 1;\n    bool is_nest = true;\n \
    \   while (i < string.length()) {\n        if (string[i] != '[' && string[i] !=\
    \ ']' && string[i] != '{' && string[i] != '}') {\n            is_nest = false;\n\
    \            break;\n        }\n        i += 1;\n    }\n    return is_nest;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpooje2xx2: /tmp/tmpooje2xx2.cpp:28: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int n=0;\n  for(int i=0; i<string.length(); i++) {\n    if(string[i] ==\
    \ '[') {\n      n++;\n    } else if(string[i] == ']') {\n      n--;\n    }\n \
    \   if(n < 0) return false;\n  }\n  return true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpu0xm4bl6: /tmp/tmpu0xm4bl6.cpp:28: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // We keep track of the nesting level\n    int nesting_level = 0;\n \
    \   // We iterate over every character in the input string.\n    // We can safely\
    \ assume that the character at index i is inside the square brackets.\n    //\
    \ The loop will exit as soon as a non-square bracket is encountered.\n    for\
    \ (int i = 0; i < string.length(); ++i) {\n        // When we encounter a non-square\
    \ bracket, we increment the nesting level.\n        // If we encounter a square\
    \ bracket, we decrement the nesting level.\n        // When we reach the top-level,\
    \ we know that the nesting level is zero and the subsequence is valid.\n     \
    \   // If we encounter a closing square bracket without matching opening ones,\
    \ then the subsequence is invalid.\n        if (string[i] == '[') {\n        \
    \    ++nesting_level;\n        } else if (string[i] == ']') {\n            --nesting_level;\n\
    \            // If we reach the top-level, we know that the nesting level is zero\
    \ and the subsequence is valid.\n            if (nesting_level == 0) {\n     \
    \           return true;\n            }\n        } else {\n            // If we\
    \ encounter a non-square bracket, the nesting level has decreased. \n        \
    \    if (nesting_level < 0) {\n                return false;\n            }\n\
    \        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp4ltqv3rv: /tmp/tmp4ltqv3rv.cpp:43: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> stack;\n    bool result = false;\n    for(int i = 0; i <\
    \ string.size(); i++) {\n        if(string[i] == '[') {\n            stack.push(i);\n\
    \        } else if(string[i] == ']') {\n            while(!stack.empty() && stack.top()\
    \ == '[') {\n                stack.pop();\n            }\n            if(stack.empty())\
    \ {\n                result = true;\n            }\n        } else {\n       \
    \     break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpdpweo3he.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpdpweo3he.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> stack;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpdpweo3he.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpdpweo3he.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> stack;\n      |           ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> stack;\n    for (int i = 0; i < string.size(); ++i)\
    \ {\n        if (string[i] != '[' && string[i] != ']') {\n            stack.push(string[i]);\n\
    \            continue;\n        }\n        if (string[i] == '[') {\n         \
    \   if (stack.empty()) {\n                return false;\n            }\n     \
    \       char top = stack.top();\n            stack.pop();\n            if (top\
    \ != ']') {\n                return false;\n            }\n        } else {\n\
    \            if (stack.empty()) {\n                return false;\n           \
    \ }\n            char top = stack.top();\n            stack.pop();\n         \
    \   if (top == '[') {\n                continue;\n            } else {\n     \
    \           return false;\n            }\n        }\n    }\n    return !stack.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpj71tu6wn: /tmp/tmpj71tu6wn.cpp:45: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool result;\n    int level = 0;\n    // find out level by counting brackets.\n\
    \    for (int i = 0; i < string.length(); ++i) {\n        if (string[i] == '['\
    \ && string[i+1] == ']') {\n            ++level;\n        } else if (string[i]\
    \ == '{' && string[i+1] == '}') {\n            ++level;\n        } else if (string[i]\
    \ == '[' && string[i+1] == '}') {\n            --level;\n        } else if (string[i]\
    \ == '[' && string[i+1] == ']') {\n            --level;\n        } else if (string[i]\
    \ == '[') {\n            ++level;\n        } else if (string[i] == ']') {\n  \
    \          --level;\n        } else if (string[i] == '}') {\n            --level;\n\
    \        } else if (string[i] == '{') {\n            ++level;\n        }\n   \
    \ }\n    // if level not 0, then valid subsequence of brackets\n    if (level\
    \ != 0) {\n        result = true;\n    } else {\n        result = false;\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp92_mfgfv: /tmp/tmp92_mfgfv.cpp:45: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    // Solve this problem by solving two problems\
    \ in series. Remember the formula for checking a square bracket nesting is:\n\
    \    // [[ ]] \u279E True\n    // [ ] \u279E False\n    // [ ][ ] \u279E True\n\
    \    // [ ] \u279E False\n    // [] \u279E False\n\n    // The first problem can\
    \ be solved by checking if the string is equal to [[][]] which is false\n    if\
    \ (string.size() != 2 && string.size() != 3) return false;\n    // The second\
    \ problem can be solved by checking if the string is equal to [[]] which is true\n\
    \    else if (string.size() == 2 && (string[0] == '[' || string[1] == '[')) return\
    \ false;\n    // The third problem can be solved by checking if the string is\
    \ equal to [] which is true\n    else if (string.size() == 2 && string[0] == '['\
    \ && string[1] == '[') return true;\n    // The fourth problem can be solved by\
    \ checking if the string is equal to [ ] which is false\n    else if (string.size()\
    \ == 2 && string[0] == '[' && string[1] == ']') return false;\n    // The fifth\
    \ problem can be solved by checking if the string is equal to [ ][ ] which is\
    \ true\n    else if (string.size() == 2 && (string[0] == '[' || string[1] == '[')\n\
    \                && string[0] == '[' && string[1] == ']') return true;\n    //\
    \ The sixth problem can be solved by checking if the string is equal to [][]]\
    \ which is false\n    else if (string.size() == 3 && (string[0] == '[' || string[1]\
    \ == '[')\n                && string[2] == '[') return false;\n    // The seventh\
    \ problem can be solved by checking if the string is equal to [[ ]] which is true\n\
    \    else if (string.size() == 3 && (string[0] == '[' || string[1] == '[')\n \
    \               && string[2] == '[' && string[0] == '[') return true;\n    //\
    \ The eighth problem can be solved by checking if the string is equal to [ ][\
    \ ][ ] which is true\n    else if (string.size() == 3 && (string[0] == '[' ||\
    \ string[1] == '[')\n                && string[2] == '[' && string[0] == '[' &&\
    \ string[1] == '[') return true;\n    // The ninth problem can be solved by checking\
    \ if the string is equal to [][]] which is false\n    else if (string.size() ==\
    \ 3 && (string[0] == '[' || string[1] == '[')\n                && string[2] ==\
    \ '[' && string[0] == '[') return false;\n    // The tenth problem can be solved\
    \ by checking if the string is equal to [[ ][ ] ] which is true\n    else if (string.size()\
    \ == 3 && (string[0] == '[' || string[1] == '[')\n                && string[2]\
    \ == '[' && string[0] == '[' && string[1] == '[') return true;\n    // The eleventh\
    \ problem \n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpy5twy61_: /tmp/tmpy5twy61_.cpp:51: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tbool found = false;\n\tfor (int i = 0; i < string.size(); i++) {\n\t\t\
    if (string[i] == '[' && string[i+1] == '[') {\n\t\t\tfound = true;\n\t\t}\n\t\
    }\n\treturn found;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpwuszi_jp: /tmp/tmpwuszi_jp.cpp:24: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<pair<int, int>> stack;\n    \n    // Iterate through the string\
    \ and add elements to the stack.\n    // If the current character is an opening\
    \ bracket,\n    // increment the depth by 1 and add it to the stack.\n    // If\
    \ the current character is a closing bracket,\n    // decrement the depth by 1\
    \ and remove any elements from the stack.\n    for (char c : string) {\n     \
    \   if (c == '[') {\n            stack.push({1, 0});\n        }\n        else\
    \ if (c == '[') {\n            stack.push({2, 0});\n        }\n        else if\
    \ (c == '[') {\n            stack.push({3, 0});\n        }\n        else if (c\
    \ == '[') {\n            stack.push({4, 0});\n        }\n        else if (c ==\
    \ ']') {\n            pair<int, int> top = stack.top();\n            int depth\
    \ = top.first;\n            int top = stack.top().second;\n            if (--top\
    \ == 0) {\n                stack.pop();\n            }\n            else if (--depth\
    \ == 0) {\n                stack.pop();\n                stack.pop();\n      \
    \      }\n        }\n        else if (c == ']') {\n            pair<int, int>\
    \ top = stack.top();\n            int depth = top.first;\n            int top\
    \ = stack.top().second;\n            if (--top == 0) {\n                stack.pop();\n\
    \            }\n            else if (--depth == 0) {\n                stack.pop();\n\
    \            }\n        }\n        else if (c == ']') {\n            pair<int,\
    \ int> top = stack.top();\n            int depth = top.first;\n            int\
    \ top = stack.top().second;\n            if (--top == 0) {\n                stack.pop();\n\
    \            }\n            else if (--depth == 0) {\n                stack.pop();\n\
    \            }\n        }\n        else if (c == ']') {\n            pair<int,\
    \ int> top = stack.top();\n            int depth = top.first;\n            int\
    \ top = stack.top().second;\n            if (--top == 0) {\n                stack.pop();\n\
    \            }\n            else if (--depth == 0) {\n                stack.pop();\n\
    \            }\n        }\n        else if (c == ']') {\n            pair<int,\
    \ int> top = stack.top();\n            int depth = top.first;\n            int\
    \ top = stack.top().second;\n            if (--top == 0) {\n                stack.pop();\n\
    \            }\n            else if (--depth == 0) {\n                stack.pop();\n\
    \            }\n        }\n        else if (c == ']') {\n            pair<int,\
    \ int> top = stack.top();\n            int depth = top.first;\n            int\
    \ top = stack.top().second;\n            if (--top == 0) {\n                stack.pop();\n\
    \            }\n            else if (--depth == 0) {\n                stack.pop();\n\
    \            }\n        }\n        else if (c == ']') {\n            pair<int,\
    \ int> top = stack.top();\n            \n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp5_eveinb.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp5_eveinb.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<pair<int, int>>\
    \ stack;\n      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp5_eveinb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp5_eveinb.cpp:13:11: error: \u2018pair\u2019 was not\
    \ declared in this scope; did you mean \u2018std::pair\u2019?\n   13 |     stack<pair<int,\
    \ int>> stack;\n      |           ^~~~\n      |           std::pair\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:64,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp5_eveinb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_pair.h:208:12:\
    \ note: \u2018std::pair\u2019 declared here\n  208 |     struct pair\n      |\
    \            ^~~~\n/tmp/tmp5_eveinb.cpp:13:16: error: expected primary-expression\
    \ before \u2018int\u2019\n   13 |     stack<pair<int, int>> stack;\n      |  \
    \              ^~~\n/tmp/tmp5_eveinb.cpp:34:18: error: expected primary-expression\
    \ before \u2018int\u2019\n   34 |             pair<int, int> top = stack.top();"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = 0, found = 0, open = 0;\n    while (n <= string.length()) {\n\
    \        if (string[n] == '[') open++;\n        else if (string[n] == ']') open--;\n\
    \        else if (string[n] == '[' && string[n-1] != ']') found++;\n        n++;\n\
    \    }\n    if (found == 0) return false;\n    for (int i = 0; i < string.length();\
    \ i++)\n        if (string[i] == ']')\n            if (open <= 0 && i != 0)\n\
    \                return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmph3awvij6: /tmp/tmph3awvij6.cpp:29: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Return True if and only if there is a valid subsequence of brackets\
    \ \n    // where at least one bracket in the subsequence is nested.\n    // The\
    \ string passed in must contain at least one bracket ([]).\n    int n = string.length();\n\
    \    for(int i = 0; i < n; i++) {\n        if(string[i] == '[' || string[i] ==\
    \ '{' || string[i] == '(') {\n            if(string[i + 1] == '[' || string[i\
    \ + 1] == '{' || string[i + 1] == '(') {\n                if(string[i + 2] ==\
    \ '[' || string[i + 2] == '{' || string[i + 2] == '(') {\n                   \
    \ if(string[i + 3] == '[' || string[i + 3] == '{' || string[i + 3] == '(') {\n\
    \                        if(string[i + 4] == '[' || string[i + 4] == '{' || string[i\
    \ + 4] == '(') {\n                            if(string[i + 5] == '[' || string[i\
    \ + 5] == '{' || string[i + 5] == '(') {\n                                if(string[i\
    \ + 6] == '[' || string[i + 6] == '{' || string[i + 6] == '(') {\n           \
    \                         if(string[i + 7] == '[' || string[i + 7] == '{' || string[i\
    \ + 7] == '(') {\n                                        if(string[i + 8] ==\
    \ '[' || string[i + 8] == '{' || string[i + 8] == '(') {\n                   \
    \                         if(string[i + 9] == '[' || string[i + 9] == '{' || string[i\
    \ + 9] == '(') {\n                                                if(string[i\
    \ + 10] == '[' || string[i + 10] == '{' || string[i + 10] == '(') {\n        \
    \                                            if(string[i + 11] == '[' || string[i\
    \ + 11] == '{' || string[i + 11] == '(') {\n                                 \
    \                       if(string[i + 12] == '[' || string[i + 12] == '{' || string[i\
    \ + 12] == '(') {\n                                                          \
    \  if(string[i + 13] == '[' || string[i + 13] == '{' || string[i + 13] == '(')\
    \ {\n                                                                if(string[i\
    \ + 14] == '[' || string[i + 14] == '{' || string[i + 14] == '(') {\n        \
    \                                                            if(string[i + 15]\
    \ == '[' || string[i + 15] == '{' || string[i + 15] == '(') {\n              \
    \                                                          if(string[i + 16] ==\
    \ '[' || string[i + 16] == '{' || string[i + 16] == '(') {\n                 \
    \                                                           if(string[i + 17]\
    \ == '[' || string[i + 17] == '{' || string[i + 17] == '(') {\n              \
    \                                                                  if(string[i\
    \ + 18] == '[' || string[i + 18] == '{' || string[i + 18] == '(') {\n        \
    \                                                                            if(string[i\
    \ + 19] == '[' || string[i + 19] == '{' || string[i + 19] == '(') {\n        \
    \                                                                            \
    \    if(string[i + 20] == '[' || string[i + 20] == '{' || string[i + 20] == '(')\
    \ {\n                                                                        \
    \                    return true;\n                                          \
    \                                              }\n                           \
    \                                                         }\n                \
    \                                                                }\n         \
    \                                                                   }\n      \
    \                                                                  }\n       \
    \                                                             }\n            \
    \                                                    }\n                     \
    \           \n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpcnm4vjwx.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpcnm4vjwx.cpp:49:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   49 | int main() {\n      |            ^\n/tmp/tmpcnm4vjwx.cpp:65:1:\
    \ error: expected \u2018}\u2019 at end of input\n   65 | }\n      | ^\n/tmp/tmpcnm4vjwx.cpp:30:133:\
    \ note: to match this \u2018{\u2019\n   30 |                                 \
    \                        if(string[i + 12] == '[' || string[i + 12] == '{' ||\
    \ string[i + 12] == '(') {\n      |                                          \
    \                                                                            \
    \               ^\n/tmp/tmpcnm4vjwx.cpp:65:1: error: expected \u2018}\u2019 at\
    \ end of input\n   65 | }\n      | ^\n/tmp/tmpcnm4vjwx.cpp:29:129: note: to match\
    \ this \u2018{\u2019\n   29 |                                                \
    \     if(string[i + 11] == '[' || string[i + 11] == '{' || string[i + 11] == '(')\
    \ {\n      |                                                                 \
    \                                                                ^\n/tmp/tmpcnm4vjwx.cpp:65:1:\
    \ error: expected \u2018}\u2019 at end of input\n   65 | }\n      | ^\n/tmp/tmpcnm4vjwx.cpp:28:125:\
    \ note: to match this \u2018{\u2019\n   28 |                                 \
    \                if(string[i + 10] == '[' || string[i + 10] == '{' || string[i\
    \ + 10] == '(') {\n      |                                                   \
    \                                                                          ^\n\
    /tmp/tmpcnm4vjwx.cpp:65:1: error: expected \u2018}\u2019 at end of input\n   65\
    \ | }\n      | ^\n/tmp/tmpcnm4vjwx.cpp:27:118: note: to match this \u2018{\u2019\
    \n   27 |                                             if(string[i + 9] == '['\
    \ || string[i + 9] == '{' || string[i + 9] == '(') {\n      |                \
    \                                                                            \
    \                          ^\n/tmp/tmpcnm4vjwx.cpp:65:1: error: expected \u2018\
    }\u2019 at end of input\n   65 | }\n      | ^\n/tmp/tmpcnm4vjwx.cpp:26:114: note:\
    \ to match this \u2018{\u2019\n   26 |                                       \
    \  if(string[i + 8] == '[' || string[i +"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int i=0;\n  // bool flag=true;\n  while(i < string.length()) {\n    if(string[i]\
    \ == '[' && string[i+1] == ']' && string[i+2] == ']') {\n      return true;\n\
    \    }\n    i++;\n  }\n  // return flag;\n  return false;\n}\nint main() {\n \
    \   auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp2l78lhhh: /tmp/tmp2l78lhhh.cpp:27: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int cnt = 0;\n  int i;\n  int len = string.length();\n  // Iterate over\
    \ the string and count the number of opening and closing brackets.\n  for (i =\
    \ 0; i < len; i++) {\n    if (string[i] == '[') {\n      cnt++;\n    }\n    if\
    \ (string[i] == ']') {\n      cnt--;\n    }\n    if (cnt == 0) {\n      return\
    \ true;\n    }\n  }\n  return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpxvaa891i: /tmp/tmpxvaa891i.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if (string.size() < 2) {\n        return false;\n    }\n    // Iterate\
    \ through the string from the beginning\n    // If the current character is [,\
    \ return true\n    // If the current character is ], return false\n    // If the\
    \ current character is }, return false\n    for (char c : string.substr(0, string.size()\
    \ - 1)) {\n        if (c == '[' || c == '{' || c == '}' || c == '(' || c == ')'\
    \ || c == ']') {\n            return true;\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpjglihl38: /tmp/tmpjglihl38.cpp:30: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> stk;\n    for(auto &el : string)\n        if(el == '[')\n\
    \            stk.push('[');\n        else if(el == ']')\n            if(stk.empty())\n\
    \                return false;\n            else\n                stk.push(']');\n\
    \        else\n            stk.push(el);\n    return stk.empty();\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmprsl3w8bz: /tmp/tmprsl3w8bz.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Initialize our variable to false\n    bool isOkay = false;\n    //\
    \ Our variable that holds our position within the string\n    int pos;\n    //\
    \ Our variable that holds our found brackets\n    bool foundOpenBracket = false;\n\
    \    // Our variable that holds our found brackets\n    bool foundCloseBracket\
    \ = false;\n    // Our variable that holds our found brackets\n    bool foundNest\
    \ = false;\n    // Iterate through each character of the string\n    for (size_t\
    \ i = 0; i < string.length(); i++) {\n        // Get the character at the current\
    \ index i\n        char current = string[i];\n        // If the current character\
    \ is a bracket\n        if (current == '[') {\n            // If the brackets\
    \ are open\n            if (foundOpenBracket) {\n                // The brackets\
    \ are closed \n                if (foundCloseBracket) {\n                    //\
    \ Nest is already found\n                    if (foundNest) {\n              \
    \          // Nest is found\n                        isOkay = true;\n        \
    \                break;\n                    }\n                    foundNest\
    \ = true;\n                } else {\n                    // Nest is found\n  \
    \                  foundNest = true;\n                    foundCloseBracket =\
    \ true;\n                    break;\n                }\n            } else {\n\
    \                // Nest is not found\n                foundOpenBracket = true;\n\
    \                foundNest = true;\n                break;\n            }\n  \
    \      } else if (current == ']') {\n            // If the brackets are open\n\
    \            if (foundOpenBracket) {\n                // The brackets are closed\n\
    \                if (foundNest) {\n                    // Nest is found\n    \
    \                isOkay = true;\n                    break;\n                }\n\
    \                foundNest = true;\n            } else {\n                // Nest\
    \ is not found\n                foundOpenBracket = true;\n                foundCloseBracket\
    \ = true;\n                break;\n            }\n        } else {\n         \
    \   // Current character is not a bracket\n            // Nest is not found\n\
    \            foundOpenBracket = false;\n            foundCloseBracket = false;\n\
    \            foundNest = false;\n            break;\n        }\n    }\n\n    return\
    \ isOkay;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmptdtxqdph: /tmp/tmptdtxqdph.cpp:82: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // TODO: write your code\n    bool result = true;\n    for(int i = 0;\
    \ i < string.length(); i++) {\n        if(string[i] == '[') {\n            if(!is_nested(string.substr(0,i)))\
    \ {\n                result = false;\n                break;\n            }\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpkyifiuf_: /tmp/tmpkyifiuf_.cpp:28: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int n = string.length();\n    int open = 0;\n\
    \    int close = 0;\n    for (int i = 0; i < n; ++i) {\n        if (string[i]\
    \ == '[') {\n            ++open;\n        }\n        if (string[i] == ']') {\n\
    \            ++close;\n        }\n    }\n    return close == open && close ==\
    \ 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpd6dv0wup: /tmp/tmpd6dv0wup.cpp:29: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int i = 1;\n    bool flag = true;\n    for(unsigned int i=0; i<string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = false;\n        \
    \    i++;\n        } else if(string[i] == ']') {\n            flag = true;\n \
    \           i++;\n        } else if(i == string.length() - 1) {\n            flag\
    \ = false;\n            i++;\n        }\n    }\n    return flag;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmprcq72bnk: /tmp/tmprcq72bnk.cpp:36: int main(): Assertion `candidate((\"\
    []]]]]]]]]]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    for(int i = 0; i < string.length(); i++){\n        if(string[i] != '['\
    \ || string[i+1] != '[')\n            continue;\n        // if we have a '[' then\
    \ check if the next char is ']'\n        if(string[i+1] == '}')\n            continue;\n\
    \        if(string[i+1] == ']'){\n            // check if we have an ']' on the\
    \ next char\n            if(i+2 >= string.length() || string[i+2] != '[')\n  \
    \              continue;\n            // we have an ']' then check if we have\
    \ another '['\n            if(string[i+2] == '[')\n                continue;\n\
    \            else\n                // if we do not have another ']' then we have\
    \ the nested brackets\n                return true;\n        }\n    }\n    //\
    \ if we reach this line then there is either no nested brackets \n    // or no\
    \ valid subsequence of brackets\n    return false;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpl7h6t2bo: /tmp/tmpl7h6t2bo.cpp:37: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    std::stack<char> s;\n    for(char c : string)\n\
    \    {\n        if(c == '[') s.push(c);\n        else if(c == ']'){\n        \
    \    if((s.top() == '[') || (s.top() == '{'))\n                return true;\n\
    \            s.pop();\n        }\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpd0cuj2ux: /tmp/tmpd0cuj2ux.cpp:29: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int count = 0; // Counter for the number of open brackets\n  char ch; //\
    \ Temporary variable to store current character\n  bool flag = false; // Flag\
    \ to return true or false\n  for (int i = 0; i < string.size(); i++) {\n    ch\
    \ = string[i];\n    if (ch == '[') {\n      count++;\n    } else if (ch == ']')\
    \ {\n      count--;\n      if (count == 0 && flag == false) { // A closing bracket\
    \ must have a matching opening bracket\n        flag = true;\n      }\n    }\n\
    \  }\n  return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpwbdhso0g: /tmp/tmpwbdhso0g.cpp:32: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int brackets = 0;\n    bool found = false;\n\n    for (int i = 0; i <\
    \ string.length(); i++) {\n        char c = string[i];\n        if (brackets <\
    \ 0) {\n            if (c == '[') {\n                brackets++;\n           \
    \ } else if (c == ']') {\n                brackets--;\n            }\n       \
    \ } else {\n            if (c == '[') {\n                brackets--;\n       \
    \     } else if (c == ']') {\n                brackets++;\n            }\n   \
    \     }\n        if (c == '[') {\n            if (brackets == 0) {\n         \
    \       found = true;\n            }\n        } else if (c == ']') {\n       \
    \     if (brackets != 0) {\n                found = true;\n            }\n   \
    \     }\n    }\n    return found;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpkgwjjc_4: /tmp/tmpkgwjjc_4.cpp:46: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if (string.empty()) return false;\n    int cur = string.size() - 1;\n\
    \    for (int i = 0; i < string.length(); ++i) {\n        if (string[i] == '['\
    \ && string[i + 1] == '[') ++cur;\n        else if (string[i] == '[' && string[i\
    \ + 1] != ']') return false;\n        else if (string[i] == ']' && string[i +\
    \ 1] != ']') return false;\n        else if (string[i] == ']' && string[i + 1]\
    \ == '[') --cur;\n    }\n    return cur == -1;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp9sgghn7g: /tmp/tmp9sgghn7g.cpp:25: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmps25bin72: /tmp/tmps25bin72.cpp:17: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Complete this function\n    // 1. Write a while loop that loops until\
    \ there is an empty string inside string argument\n    // 2. Complete the string\
    \ argument with square brackets.\n    // 3. Return true if and only if string\
    \ argument has an opening square bracket that also contains closing square bracket.\n\
    \    std::string stringCopy(string);\n    bool check = false;\n    while(check\
    \ != true) {\n        std::cout << \"stringCopy: \" << stringCopy << std::endl;\n\
    \        std::string::size_type openingBracket = stringCopy.find(\"[\", openBracketPos);\n\
    \        std::string::size_type closingBracket = stringCopy.find(\"]\", openBracketPos);\n\
    \        if(openingBracket != std::string::npos && closingBracket != std::string::npos)\
    \ {\n            check = true;\n        }\n    }\n    if(openBracketPos == stringCopy.size())\
    \ { \n        check = true;\n    }\n    return check;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpkpjlaaoa.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpkpjlaaoa.cpp:21:70: error: \u2018openBracketPos\u2019 was not declared\
    \ in this scope\n   21 |         std::string::size_type openingBracket = stringCopy.find(\"\
    [\", openBracketPos);\n      |                                               \
    \                       ^~~~~~~~~~~~~~\n/tmp/tmpkpjlaaoa.cpp:27:8: error: \u2018\
    openBracketPos\u2019 was not declared in this scope\n   27 |     if(openBracketPos\
    \ == stringCopy.size()) {\n      |        ^~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // your code here\n    \n    std::string opening = string; // save the\
    \ string without brackets\n    \n    std::string closing = string; // save the\
    \ string without brackets\n    \n    std::stack<std::string> opening_stack;\n\
    \    std::stack<std::string> closing_stack;\n    \n    for (char c : opening)\n\
    \    {\n        // push opening bracket\n        if (c == '[' && opening_stack.empty())\n\
    \        {\n            opening_stack.push(c);\n        }\n        // pop opening\
    \ bracket\n        else if (c == ']')\n        {\n            closing_stack.push(c);\n\
    \            if (opening_stack.empty())\n            {\n                return\
    \ false; // invalid nested brackets\n            }\n            opening_stack.pop();\n\
    \        }\n    }\n    \n    closing_stack.pop();\n    \n    for (char c : closing)\n\
    \    {\n        // push closing bracket\n        if (c == '[' && closing_stack.empty())\n\
    \        {\n            closing_stack.push(c);\n        }\n        // pop closing\
    \ bracket\n        else if (c == ']')\n        {\n            closing_stack.pop();\n\
    \            if (closing_stack.empty())\n            {\n                return\
    \ false; // invalid nested brackets\n            }\n        }\n    }\n    \n \
    \   return true; // valid nested brackets\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpy0lfsnqu.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpy0lfsnqu.cpp:27:33: error: no matching function for call to \u2018\
    std::stack<std::__cxx11::basic_string<char> >::push(char&)\u2019\n   27 |    \
    \         opening_stack.push(c);\n      |                                 ^\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpy0lfsnqu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:233:7:\
    \ note: candidate: \u2018void std::stack<_Tp, _Sequence>::push(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Sequence = std::deque<std::__cxx11::basic_string<char>,\
    \ std::allocator<std::__cxx11::basic_string<char> > >; std::stack<_Tp, _Sequence>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n  233 |       push(const value_type&\
    \ __x)\n      |       ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:233:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \  233 |       push(const value_type& __x)\n      |            ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:238:7: note:\
    \ candidate: \u2018void std::stack<_Tp, _Sequence>::push(std::stack<_Tp, _Sequence>::value_type&&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Sequence = std::deque<std::__cxx11::basic_string<char>,\
    \ std::allocator<std::__cxx11::basic_string<char> > >; std::stack<_Tp, _Sequence>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n  238 |       push(value_type&& __x)\n\
    \      |       ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:238:25:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::stack<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \  238 |       push(value_type&& __x)\n      |            ~~~~~~~~~~~~~^~~\n/tmp/tmpy0lfsnqu.cpp:3"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    int stack_count = 0;\n    for (int i = 0;\
    \ i < string.size(); i++) {\n        if (string[i] == '[') stack_count++;\n  \
    \      if (string[i] == ']') stack_count--;\n        if (stack_count < 0) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpz7b22p_o: /tmp/tmpz7b22p_o.cpp:26: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = static_cast<int>(string.length());\n    \n    for (int i = 0;\
    \ i < n; i++){\n        if (string[i] == '[' && string[i+1] == ']'){\n       \
    \     return true; // This means there is an open bracket in a string\n      \
    \  }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpaxc9umpd: /tmp/tmpaxc9umpd.cpp:25: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int cnt = 0;\n    int index = 0;\n    for (unsigned int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            cnt++;\n        }\n   \
    \     else if (string[i] == ']') {\n            cnt--;\n        }\n        if\
    \ (cnt < 0) {\n            return false;\n        }\n    }\n    return cnt > 0;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp94q56kvx: /tmp/tmp94q56kvx.cpp:30: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if (string == \"[]\" || string == \"[[]\") {\n        return true;\n\
    \    }\n\n    if (string.size()%2 == 1)\n        return false;\n\n    std::string\
    \ temp;\n    for (std::size_t i = 0; i< string.size()/2; i++) {\n        temp\
    \ = string + string.substr(i*2, 2);\n        if (temp == \"[]\" || temp == \"\
    [[]\") {\n            return true;\n        }\n    }\n    return false;\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpm00nu0ts: /tmp/tmpm00nu0ts.cpp:31: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Initialize flag to indicate valid input.\n    // Flag is set to true\
    \ by default.\n    bool flag = true;\n\n    // Iterate through the string one\
    \ character at a time.\n    for (char character : string) {\n        // If the\
    \ current character is an opening bracket '{',\n        // then flag is set to\
    \ true.\n        if (character == '[') {\n            flag = true;\n        }\n\
    \n        // If the current character is an closing bracket '}',\n        // then\
    \ flag is set to false if flag is already true.\n        else if (character ==\
    \ ']') {\n            if (!flag) {\n                return false;\n          \
    \  }\n        }\n\n        // If the current character is not a closing bracket\
    \ '{',\n        // then flag is set to false if flag is already true.\n      \
    \  else if (character != '[') {\n            if (!flag) {\n                return\
    \ false;\n            }\n        }\n    }\n\n    // If we reach the end of the\
    \ string, then there is a valid subsequence of brackets.\n    return true;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpsmw3hj72: /tmp/tmpsmw3hj72.cpp:48: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if(string[0] == '[') {\n        string temp;\n        for(int i = 0;\
    \ i < string.length(); i++){\n            if(string[i] == '['){\n            \
    \    temp += string[i];\n            } else if(string[i] == ']'){\n          \
    \      temp += string[i];\n                if(temp != \"[]\" && temp != \"[[]\"\
    ) {\n                    return false;\n                }\n            }\n   \
    \     }\n        return true;\n    } else {\n        return false;\n    }\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp09afwf08.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp09afwf08.cpp:14:15: error: expected \u2018;\u2019 before \u2018temp\u2019\
    \n   14 |         string temp;\n      |               ^~~~~\n      |         \
    \      ;\n/tmp/tmp09afwf08.cpp:17:17: error: \u2018temp\u2019 was not declared\
    \ in this scope\n   17 |                 temp += string[i];\n      |         \
    \        ^~~~\n/tmp/tmp09afwf08.cpp:19:17: error: \u2018temp\u2019 was not declared\
    \ in this scope\n   19 |                 temp += string[i];\n      |         \
    \        ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int brackets = 0;\n    for (int i = 0; i < string.size(); i++) {\n  \
    \      if (string[i] == '[') {\n            brackets++;\n        } else if (string[i]\
    \ == ']') {\n            if (brackets == 0) {\n                return false;\n\
    \            }\n            brackets--;\n        }\n    }\n    return brackets\
    \ == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp2pnxmc4n: /tmp/tmp2pnxmc4n.cpp:30: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int left = 0;\n    int right = 0;\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n       \
    \     left = i;\n        }\n        if(string[i] == ']') {\n            right\
    \ = i;\n            break;\n        }\n    }\n    for(int i = left; i <= right;\
    \ i++) {\n        if(string[i] == '[') {\n            if((i - left) == 0) {\n\
    \                for(int j = i; j < string.length(); j++) {\n                \
    \    if(string[j] == '[') {\n                        break;\n                \
    \    }\n                    if(string[j] == ']') {\n                        break;\n\
    \                    }\n                }\n                return true;\n    \
    \        }\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmph8qzupuh: /tmp/tmph8qzupuh.cpp:45: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if(string.find(\"[\") != string::npos) {\n        int i=0;\n        for(auto\
    \ x: string) {\n            if(x == '[') i++;\n            else if(x == ']') i--;\n\
    \            if(i == 0) return true;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9qs1n48a.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp9qs1n48a.cpp:13:28: error: \u2018string\u2019 is not a class, namespace,\
    \ or enumeration\n   13 |     if(string.find(\"[\") != string::npos) {\n     \
    \ |                            ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Initialize a variable to hold the length of the subsequence.\n   \
    \ // Initialize a variable to hold the current bracket's opening position\n  \
    \  int left_bracket = -1;\n    // Initialize a variable to hold the current bracket's\
    \ closing position\n    int right_bracket = -1;\n    // Initialize a variable\
    \ to hold the length of string\n    int len = 0;\n    // Initialize a variable\
    \ to hold the index within string\n    int index = 0;\n    // Initialize a variable\
    \ to hold whether a string contains a valid subsequence\n    bool valid = false;\n\
    \    \n    // Loop through string, if opening bracket is found increment right_bracket\n\
    \    // if the closing bracket is found decrement left_bracket else increment\
    \ index\n    while (index < string.length()) {\n        // Increment right_bracket\n\
    \        if (string[index] == '[') {\n            right_bracket++;\n        }\
    \ else if (string[index] == ']') {\n            right_bracket--;\n        }\n\
    \        // Increment left_bracket\n        if (left_bracket == -1 && right_bracket\
    \ == -1 && string[index] != ']' && string[index] != '[') {\n            left_bracket++;\n\
    \            right_bracket++;\n        } else if (left_bracket != -1 && right_bracket\
    \ != -1 && string[index] != ']' && string[index] != '[') {\n            left_bracket++;\n\
    \            index++;\n        } else if (left_bracket != -1 && right_bracket\
    \ == -1 && string[index] == ']') {\n            left_bracket++;\n            index++;\n\
    \        }\n        // Increment index\n        index++;\n    }\n    // Check\
    \ the final index\n    if (left_bracket == -1 && right_bracket == -1 && string[index]\
    \ != ']' && string[index] != '[') {\n        valid = true;\n    } else if (left_bracket\
    \ != -1 && right_bracket != -1 && string[index] != ']' && string[index] != '[')\
    \ {\n        valid = false;\n    }\n\n    return valid;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpp5ifaef_: /tmp/tmpp5ifaef_.cpp:61: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int i = 0;\n  int count = 0; // count is zero only at the begining of loop\n\
    \  while (i < string.length() && count < 2) // while there are still brackets\
    \ left\n  {\n    if (string[i] == '[')\n      ++count; // we found an opening\
    \ bracket\n    else if (string[i] == ']') // found closing bracket\n      --count;\
    \ // we found a closing bracket\n    ++i; // move to the next bracket\n  }\n \
    \ return count > 1;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpxa4i3x26: /tmp/tmpxa4i3x26.cpp:34: int main(): Assertion `candidate((\"\
    [[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> st;\n    for (char ch: string.at(0) ) st.push(ch);\n    for\
    \ (char ch: string.at(1-1) ) st.push(ch);\n    if (st.top() == '[') st.push(']');\n\
    \    for (auto it = st.rbegin(); it != st.rend(); ++it ) {\n        if (st.top()\
    \ == '[') st.push(']');\n    }\n    return st.empty() == true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe0ybrdu3.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpe0ybrdu3.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> st;\n \
    \     |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpe0ybrdu3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpe0ybrdu3.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> st;\n      |           ^~~~\n\
    /tmp/tmpe0ybrdu3.cpp:14:30: error: \u2018begin\u2019 was not declared in this\
    \ scope; did you mean \u2018std::begin\u2019?\n   14 |     for (char ch: string.at(0)\
    \ ) st.push(ch);\n      |                              ^\n      |            \
    \                  std::begin\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpe0ybrdu3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:1224:5:\
    \ note: \u2018std::begin\u2019 declared here\n 1224 |     begin(const valarray<_Tp>&\
    \ __va)\n      |     ^~~~~\n/tmp/tmpe0ybrdu3.cpp:14:30: error: \u2018end\u2019\
    \ was not declared in this scope; did you mean \u2018std::end\u2019?\n   14 |\
    \     for (char ch: string.at(0) ) st.push(ch);\n      |                     \
    \         ^\n      |                              std::end\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpe0ybrdu3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:1244:5:\
    \ note: \u2018std::end\u2019 declared here\n 1244 |     end(const valarray<_Tp>&\
    \ __va)\n      |     ^~~\n/tmp/tmpe0ybrdu3.cpp:14:34: error: \u2018st\u2019 was\
    \ not declared in this scope; did you mean \u2018std\u2019?\n   14 |     for (char\
    \ ch: string.at(0) ) st.push(ch);\n      |             "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int i = 0;\n  for (; i < string.length() - 1; i++) {\n    if (string[i]\
    \ == '[' && string[i + 1] == '[') {\n      return true;\n    }\n  }\n  return\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpw2lrkywb: /tmp/tmpw2lrkywb.cpp:24: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    int cnt = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        if (string[i] == '[') {\n            cnt++;\n        }\n   \
    \     if (string[i] == ']') {\n            cnt--;\n        }\n        if (cnt\
    \ < 0)\n            break;\n    }\n    if (cnt == 0)\n        flag = true;\n \
    \   return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp4qm4io_c: /tmp/tmp4qm4io_c.cpp:33: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\t\n\tint leftBracket = 0;\n\tint rightBracket = 0;\n\tint leftNest = 0;\n\
    \tint rightNest = 0;\n\t\n\tbool ret = false;\n\t\n\tfor (int i = 0; i < string.size();\
    \ i++) {\n\t\tif (string[i] == '[') {\n\t\t\tleftBracket++;\n\t\t} else if (string[i]\
    \ == ']') {\n\t\t\trightBracket++;\n\t\t} else if (string[i] == '(') {\n\t\t\t\
    leftNest++;\n\t\t} else if (string[i] == ')') {\n\t\t\trightNest++;\n\t\t}\n\t\
    }\n\n\tif (leftNest > 0 && rightNest > 0) {\n\t\tret = true;\n\t}\n\n\treturn\
    \ ret;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmph7upthkh: /tmp/tmph7upthkh.cpp:41: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size();\n    if(string.find('[') == string::npos || string.find(']')\
    \ == string::npos) {\n        return false;\n    }\n    \n    int first = string.find('[',\
    \ string::npos);\n    int last = string.find(']', string::npos);\n    \n    if(last\
    \ == string::npos) {\n        return false;\n    }\n    \n    string leftBracket\
    \ = string.substr(first);\n    string rightBracket = string.substr(last);\n  \
    \  \n    int leftBracketSize = leftBracket.size();\n    int rightBracketSize =\
    \ rightBracket.size();\n    \n    int count = 0;\n    \n    for(int i = 0; i <\
    \ n; i++) {\n        char c = string[i];\n        if(c == '[') {\n           \
    \ count++;\n        }\n        else if(c == ']') {\n            count--;\n   \
    \     }\n        if(count == leftBracketSize) {\n            return true;\n  \
    \      }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpfpi070pm.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpfpi070pm.cpp:14:28: error: \u2018string\u2019 is not a class, namespace,\
    \ or enumeration\n   14 |     if(string.find('[') == string::npos || string.find(']')\
    \ == string::npos) {\n      |                            ^~~~~~\n/tmp/tmpfpi070pm.cpp:14:64:\
    \ error: \u2018string\u2019 is not a class, namespace, or enumeration\n   14 |\
    \     if(string.find('[') == string::npos || string.find(']') == string::npos)\
    \ {\n      |                                                                ^~~~~~\n\
    /tmp/tmpfpi070pm.cpp:18:34: error: \u2018string\u2019 is not a class, namespace,\
    \ or enumeration\n   18 |     int first = string.find('[', string::npos);\n  \
    \    |                                  ^~~~~~\n/tmp/tmpfpi070pm.cpp:19:33: error:\
    \ \u2018string\u2019 is not a class, namespace, or enumeration\n   19 |     int\
    \ last = string.find(']', string::npos);\n      |                            \
    \     ^~~~~~\n/tmp/tmpfpi070pm.cpp:21:16: error: \u2018string\u2019 is not a class,\
    \ namespace, or enumeration\n   21 |     if(last == string::npos) {\n      | \
    \               ^~~~~~\n/tmp/tmpfpi070pm.cpp:25:11: error: expected \u2018;\u2019\
    \ before \u2018leftBracket\u2019\n   25 |     string leftBracket = string.substr(first);\n\
    \      |           ^~~~~~~~~~~~\n      |           ;\n/tmp/tmpfpi070pm.cpp:26:11:\
    \ error: expected \u2018;\u2019 before \u2018rightBracket\u2019\n   26 |     string\
    \ rightBracket = string.substr(last);\n      |           ^~~~~~~~~~~~~\n     \
    \ |           ;\n/tmp/tmpfpi070pm.cpp:28:27: error: \u2018leftBracket\u2019 was\
    \ not declared in this scope; did you mean \u2018leftBracketSize\u2019?\n   28\
    \ |     int leftBracketSize = leftBracket.size();\n      |                   \
    \        ^~~~~~~~~~~\n      |                           leftBracketSize\n/tmp/tmpfpi070pm.cpp:29:28:\
    \ error: \u2018rightBracket\u2019 was not declared in this scope; did you mean\
    \ \u2018rightBracketSize\u2019?\n   29 |     int rightBracketSize = rightBracket.size();\n\
    \      |                            ^~~~~~~~~~~~\n      |                    \
    \        rightBracketSize\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Create an empty stack.\n    bool stack[string.size()];\n    // Initialize\
    \ stack.\n    for(int i=0; i<string.size(); i++) {\n        stack[i] = false;\n\
    \    }\n    // Pop each character from the string.\n    for(int i=0; i<string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            stack[i--] = true;\n   \
    \     } else {\n            stack[i] = false;\n        }\n    }\n    // If stack\
    \ is empty return false.\n    if(!stack[0]) return 0;\n    for(int i=0; i<string.size();\
    \ i++) {\n        if(string[i] == ']') {\n            while(stack[--i] && string[i+1]\
    \ != ']') {\n                stack[i] = false;\n            }\n        } else\
    \ if(!stack[i] && string[i] != '[') {\n            return 0;\n        }\n    }\n\
    \    return 1;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if(string[0] != '[' || string[string.size()-1] != ']')\n        return\
    \ false;\n    \n    bool ans = false;\n    int left_count = 0;\n    int right_count\
    \ = 0;\n    for(int i = 0; i < (int)string.size()-1; i++)\n        if(string[i]\
    \ == '[' && string[i+1] == '[')\n            left_count++;\n        else if(string[i]\
    \ == '[' && string[i+1] == ']')\n            right_count++;\n        else if(string[i]\
    \ == ']' && string[i+1] == ']')\n            ans = left_count+right_count == 2;\n\
    \        \n    return ans;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpqplf6q4k: /tmp/tmpqplf6q4k.cpp:35: int main(): Assertion `candidate((\"\
    [[[[]]]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  // We are going to use stack here\n  int stack[string.size()+1];\n  int\
    \ i=0;\n  bool ret = false;\n  // We are going to use stack here\n  stack[i]=0;\n\
    \  while(i < string.size()) {\n    if(string[i] == '[' && string[i+1] == '[')\
    \ {\n      stack[i]++;\n    }else if(string[i] == '[' && string[i+1] == ']') {\n\
    \      stack[i]--;\n    }else if(string[i] == ']' && string[i+1] == ']') {\n \
    \     stack[i]++;\n    }else if(string[i] == ']' && string[i+1] == '[') {\n  \
    \    stack[i]--;\n    }\n    i++;\n  }\n  // We have reached the end of the string\
    \ and are left with an empty string\n  // So if stack[i] is zero then we are done\
    \ and ret should return True\n  if(stack[i] == 0)\n    ret = true;\n  return ret;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp2hfie0j7: /tmp/tmp2hfie0j7.cpp:39: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    char opens = 0;\n    char closes = 0;\n\
    \    for(int i = 0;i < n; i++) {\n        if(string[i] == '[') opens++;\n    \
    \    if(string[i] == ']') closes++;\n    }\n    if(opens > closes || opens < 1)\
    \ return false;\n    for(int i = 1; i < n; i++) {\n        if(string[i] == ']')\
    \ closes--;\n        if(string[i] == '[') opens--;\n        if(opens > 0 && closes\
    \ <= 0) return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmps4q4z_t1: /tmp/tmps4q4z_t1.cpp:30: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int left = 0;\n    int right = string.size() - 1;\n    while (left <\
    \ right) {\n        if (string[left] == '[' && string[right] == ']') {\n     \
    \       left++;\n            right--;\n        } else if (string[left] == '['\
    \ && string[right] != ']') {\n            left++;\n        } else if (string[left]\
    \ != string[right]) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp5hp0ha0q: /tmp/tmp5hp0ha0q.cpp:32: int main(): Assertion `candidate((\"\
    []\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    size_t opens = 0;\n    for (size_t i=0; i<string.length(); i++) {\n \
    \       if (string[i] == '[') {\n            opens++;\n        } else if (string[i]\
    \ == ']') {\n            opens--;\n        } else if (string[i] == ']' && opens\
    \ == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpezil4taf: /tmp/tmpezil4taf.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    for (std::size_t i = 1; i < string.size(); i++) {\n        if (string[i\
    \ - 1] == '[' && string[i] == '[') {\n            bool result = true;\n      \
    \      for (std::size_t j = i - 1; j > 0; j--) {\n                if (string[j]\
    \ == '[' && string[j + 1] != ']') {\n                    result = false;\n   \
    \             }\n                if (string[j + 1] == ']') {\n               \
    \     break;\n                }\n            }\n            if (result) {\n  \
    \              return true;\n            }\n        }\n        if (string[i] ==\
    \ '[' && string[i - 1] != ']') {\n            return false;\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp1ev1ctn9: /tmp/tmp1ev1ctn9.cpp:38: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n   std::stack<char> s;\n   s.push('[');\n   for(char c : string){\n     \
    \ if(c=='[' || c=='('){\n         s.push(c);\n      } else if(c==']' || c==')'){\n\
    \         if(s.empty()) return false;\n         char top = s.top();\n        \
    \ s.pop();\n         if(top==c){\n            s.push(c);\n         } else {\n\
    \            return false;\n         }\n      }\n   }\n   return true;\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpf1pluq_j: /tmp/tmpf1pluq_j.cpp:33: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int start = 0;\n  int end = string.size()-1;\n  while (start < end && string[start]\
    \ == '[' && string[end] == ']') {\n    start++;\n    end--;\n  }\n  return end\
    \ > start && string[start] == '[' && string[end] == ']';\n}\nint main() {\n  \
    \  auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpojmgexig: /tmp/tmpojmgexig.cpp:23: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    \n    bool result = false;\n    int i = 0;\n    int count = 0;\n    bool\
    \ open = true;\n    \n    while (i < string.size()) \n    {\n        if (string[i]\
    \ == '[' && string[i + 1] == '[')\n        {\n            count += 2;\n      \
    \      i += 2;\n        }\n        if (string[i] == '[')\n        {\n        \
    \    if (open)\n            {\n                count += 1;\n                i\
    \ += 1;\n            }\n            else\n            {\n                open\
    \ = true;\n                i += 1;\n            }\n        }\n        if (string[i]\
    \ == ']')\n        {\n            if (open)\n            {\n                count\
    \ -= 2;\n                if (count > 0)\n                {\n                 \
    \   open = false;\n                    i += 1;\n                }\n          \
    \      else\n                {\n                    result = true;\n         \
    \           i += 1;\n                }\n            }\n            else\n    \
    \        {\n                result = false;\n                i += 1;\n       \
    \     }\n        }\n        i += 1;\n    }\n    \n    return result;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmptzb0s0y5: /tmp/tmptzb0s0y5.cpp:69: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    int counter = 0;\n    int start = 0;\n  \
    \  int end = 0;\n    int cur = 0;\n    for (end = string.size(); end >= start;\
    \ end--) {\n        cur = string[end];\n        if (cur == '[' && string[end -\
    \ 1] == '[' && string[end - 2] == '[') {\n            counter++;\n        }\n\
    \        if (cur == ']' && string[end - 1] == ']' && string[end - 2] == ']') {\n\
    \            counter--;\n        }\n    }\n    return counter == 0;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp20df6oyi: /tmp/tmp20df6oyi.cpp:33: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::vector<std::pair<int, int> > v;\n    int n = string.length();\n\
    \    std::string current = \"[]\";\n    bool flag = false;\n    for (int i = 0;\
    \ i < n; i++) {\n        if (string[i] == '[') {\n            v.push_back(std::make_pair(i,\
    \ 0));\n        }\n        if (string[i] == '[') {\n            if (current.length()\
    \ == 1) {\n                v.push_back(std::make_pair(i, current));\n        \
    \    }\n        }\n        if (string[i] == ']') {\n            current = current.substr(0,\
    \ current.length() - 1);\n            if (current.length() == 1) {\n         \
    \       if (flag) {\n                    flag = false;\n                } else\
    \ {\n                    v.push_back(std::make_pair(i, current));\n          \
    \      }\n            }\n        }\n    }\n    if (current.length() == 1) {\n\
    \        for (int i = 0; i < v.size(); i++) {\n            if (v[i].second ==\
    \ current.length()) {\n                flag = true;\n                break;\n\
    \            }\n        }\n    }\n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpq19uu3dg.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpq19uu3dg.cpp:23:55: error: no matching function for call to \u2018\
    std::vector<std::pair<int, int> >::push_back(std::pair<int, std::__cxx11::basic_string<char>\
    \ >)\u2019\n   23 |                 v.push_back(std::make_pair(i, current));\n\
    \      |                                                       ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpq19uu3dg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::pair<int, int>; _Alloc = std::allocator<std::pair<int, int>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::pair<int, int>]\u2019\n 1184\
    \ |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018std::pair<int, std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018const value_type&\u2019 {aka \u2018const std::pair<int, int>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::pair<int, int>; _Alloc = std::allocator<std::pair<int,\
    \ int> >; std::vector<_Tp, _Alloc>::value_type = std::pair<int, int>]\u2019\n\
    \ 1200 |       push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018std::pair<int, std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::vector<std::pair<int, int> >::value_type&&\u2019 {aka\
    \ \u2018std::pair<int, int>&&\u2019}\n 1200 |       pus"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool ret = false;\n    stack<char> s;\n\
    \    for(int i = 0; i < string.size(); ++i) {\n        if(s.empty() && (string[i]\
    \ == '[' || string[i] == '{')) s.push(string[i]);\n        if(s.empty() && (string[i]\
    \ == '}' || string[i] == ']')) s.push(string[i]);\n        if(!s.empty() && s.top()\
    \ == '[' && string[i] == ']') ret = true;\n        if(!s.empty() && s.top() ==\
    \ '{' && string[i] == '}') ret = true;\n    }\n    return ret;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp22gi0ufc.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp22gi0ufc.cpp:15:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   15 |     stack<char> s;\n  \
    \    |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp22gi0ufc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp22gi0ufc.cpp:15:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   15 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmp22gi0ufc.cpp:17:12: error: \u2018s\u2019 was not declared in this scope\n\
    \   17 |         if(s.empty() && (string[i] == '[' || string[i] == '{')) s.push(string[i]);\n\
    \      |            ^\n/tmp/tmp22gi0ufc.cpp:18:12: error: \u2018s\u2019 was not\
    \ declared in this scope\n   18 |         if(s.empty() && (string[i] == '}' ||\
    \ string[i] == ']')) s.push(string[i]);\n      |            ^\n/tmp/tmp22gi0ufc.cpp:19:13:\
    \ error: \u2018s\u2019 was not declared in this scope\n   19 |         if(!s.empty()\
    \ && s.top() == '[' && string[i] == ']') ret = true;\n      |             ^\n\
    /tmp/tmp22gi0ufc.cpp:20:13: error: \u2018s\u2019 was not declared in this scope\n\
    \   20 |         if(!s.empty() && s.top() == '{' && string[i] == '}') ret = true;\n\
    \      |             ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint i = 0, j = 0, k = 0, open = 0, close = 0;\n\twhile(i < string.length()\
    \ && j < string.length()) {\n\t\tif(string[i] == '[') {\n\t\t\topen++;\n\t\t}\n\
    \t\telse if(string[i] == ']') {\n\t\t\tclose++;\n\t\t}\n\t\telse if(open != close)\
    \ {\n\t\t\treturn false;\n\t\t}\n\t\ti++;\n\t\tj++;\n\t}\n\tassert(i == string.length());\n\
    \tassert(j == string.length());\n\tassert(open != close);\n\treturn open > close;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpxc160dbi: /tmp/tmpxc160dbi.cpp:29: bool is_nested(std::string): Assertion\
    \ `open != close' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int size = string.length();\n    for (int i = 0; i < size - 1; i++) {\n\
    \        if (string[i] == '[' && string[i + 1] == '[') {\n            if (string[i\
    \ + 2] == '[' && string[i + 3] == '[') {\n                if (string[i + 4] ==\
    \ '[') {\n                    i += 4;\n                } else if (string[i + 5]\
    \ == '[' && string[i + 6] == '[') {\n                    i += 6;\n           \
    \     } else {\n                    return false;\n                }\n       \
    \     } else if (string[i + 3] == '[') {\n                i += 3;\n          \
    \  } else {\n                return false;\n            }\n        } else if (string[i]\
    \ == '[' && string[i + 1] == ']') {\n            if (string[i + 2] == '[') {\n\
    \                i += 2;\n            } else if (string[i + 3] == '[') {\n   \
    \             i += 3;\n            } else {\n                return false;\n \
    \           }\n        } else {\n            return false;\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmplw_duhun: /tmp/tmplw_duhun.cpp:45: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    bool first = true;\n    \n    for(int i = 0;\
    \ i < string.length(); i++) {\n        char c = string[i];\n        if (c == '[')\
    \ {\n            first = false;\n        } else if (c == '}') {\n            if\
    \ (!found) {\n                found = true;\n            } else {\n          \
    \      found = false;\n                first = true;\n            }\n        }\n\
    \    }\n    return found;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpcs25czy5: /tmp/tmpcs25czy5.cpp:33: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = 0, b = 0;\n    for (char c: string) {\n        if (c == '[')\
    \ n++;\n        if (c == ']') n--;\n        if (n == 0) return true;\n       \
    \ if (c == '[') b++;\n        if (c == ']') b--;\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp2kd_a_iy: /tmp/tmp2kd_a_iy.cpp:26: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    char bracket = '[';\n    for (char letter : string)\
    \ {\n        if (letter == '[') {\n            count++;\n        } else if (letter\
    \ == ']') {\n            count--;\n        }\n        if (count < 0) {\n     \
    \       return false;\n        }\n    }\n    return count == 0;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpm_3app2b: /tmp/tmpm_3app2b.cpp:31: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int start = 0;\n    int end = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         start = i;\n        } else if (string[i] == ']') {\n            end\
    \ = i;\n            if (end - start >= 2) {\n                // check if there\
    \ is at least 2 brackets\n                if (string.substr(start - 1, 2) == \"\
    [[\" && string.substr(end - 1, 2) == \"]]\") {\n                    return true;\n\
    \                }\n            }\n        }\n    }\n    return false;\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 18446744073709551615) > this->size()\
    \ (which is 14)\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  stack<char> stack;\n  stack<char> opStack;\n  stack<char> opopStack;\n\
    \  int index = 0;\n  bool found = false;\n\n  for (int i = 0; i < string.length();\
    \ ++i) {\n    if (isalnum(string[i])) {\n      stack.push(string[i]);\n      opStack.push('_');\n\
    \      opopStack.push('_');\n    }\n    else if (string[i] == '[') {\n      stack.push(string[i]);\n\
    \      opStack.push('[');\n      opopStack.push('_');\n    }\n    else if (string[i]\
    \ == ']') {\n      if (stack.length() == 0) {\n        return false;\n      }\n\
    \      else {\n        if (stack.pop() != '[') {\n          return false;\n  \
    \      }\n        else {\n          stack.push(']');\n          opStack.push(']');\n\
    \          opopStack.push('_');\n        }\n      }\n    }\n    else if (string[i]\
    \ == ']') {\n      if (stack.length() == 0) {\n        return false;\n      }\n\
    \      else {\n        if (stack.pop() != '[') {\n          return false;\n  \
    \      }\n        else {\n          stack.push(']');\n          opStack.push(']');\n\
    \          opopStack.push('_');\n        }\n      }\n    }\n    else if (string[i]\
    \ == '_') {\n      if (stack.length() == 0) {\n        return false;\n      }\n\
    \      else {\n        if (stack.pop() != '[') {\n          return false;\n  \
    \      }\n        else {\n          stack.push(string[i]);\n          opStack.push(string[i]);\n\
    \          opopStack.push('_');\n        }\n      }\n    }\n    else {\n     \
    \ return false;\n    }\n  }\n\n  if (opStack.length() != opopStack.top()) {\n\
    \    return false;\n  }\n  else {\n    if (opStack.length() != stack.top()) {\n\
    \      return false;\n    }\n    else {\n      stack.pop();\n      opStack.pop();\n\
    \      opopStack.pop();\n      found = true;\n    }\n  }\n\n  return found;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2bwbhepy.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp2bwbhepy.cpp:13:3: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |   stack<char> stack;\n\
    \      |   ^~~~~\n      |   std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp2bwbhepy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp2bwbhepy.cpp:13:9: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |   stack<char> stack;\n      |         ^~~~\n\
    /tmp/tmp2bwbhepy.cpp:14:9: error: expected primary-expression before \u2018char\u2019\
    \n   14 |   stack<char> opStack;\n      |         ^~~~\n/tmp/tmp2bwbhepy.cpp:15:9:\
    \ error: expected primary-expression before \u2018char\u2019\n   15 |   stack<char>\
    \ opopStack;\n      |         ^~~~\n/tmp/tmp2bwbhepy.cpp:22:7: error: \u2018opStack\u2019\
    \ was not declared in this scope; did you mean \u2018obstack\u2019?\n   22 | \
    \      opStack.push('_');\n      |       ^~~~~~~\n      |       obstack\n/tmp/tmp2bwbhepy.cpp:23:7:\
    \ error: \u2018opopStack\u2019 was not declared in this scope\n   23 |       opopStack.push('_');\n\
    \      |       ^~~~~~~~~\n/tmp/tmp2bwbhepy.cpp:27:7: error: \u2018opStack\u2019\
    \ was not declared in this scope; did you mean \u2018obstack\u2019?\n   27 | \
    \      opStack.push('[');\n      |       ^~~~~~~\n      |       obstack\n/tmp/tmp2bwbhepy.cpp:28:7:\
    \ error: \u2018opopStack\u2019 was not declared in this scope\n   28 |       opopStack.push('_');\n\
    \      |       ^~~~~~~~~\n/tmp/tmp2bwbhepy.cpp:40:11: error: \u2018opStack\u2019\
    \ was not declared in this scope; did you mean \u2018obstack\u2019?\n   40 | \
    \          opStack.push(']');\n      |           ^~~~~~~\n      |           obstack\n\
    /tmp/tmp2bwbhepy.cpp:41:11: error: \u2018opopStack\u2019 was not declared in this\
    \ scope\n   41 |           opopStack.push('_');\n      |           ^~~~~~~~~\n\
    /tmp/tmp2bwbhepy.cpp:55:11: error: \u2018opStack\u2019 was not declared in this\
    \ sc"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Only a single open square bracket is allowed in the string.\n    //\
    \ If there are any brackets present in the string that do not match this criteria,\
    \ \n    // then the string is not nested.\n    for (int i = 0; i < string.length();\
    \ i++)\n        if (string[i] != '[' && string[i] != ']')\n            return\
    \ false;\n\n    // There is an open square bracket and only a single close square\
    \ bracket is allowed in the \n    // string. If there are any brackets present\
    \ in the string that do not match this criteria, \n    // then the string is not\
    \ nested.\n    for (int i = 0; i < string.length(); i++)\n        if (string[i]\
    \ != ']')\n            return false;\n\n    return true;\n}\nint main() {\n  \
    \  auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp5w4co18x: /tmp/tmp5w4co18x.cpp:31: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Complete the code.\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpgrezzj8s: /tmp/tmpgrezzj8s.cpp:17: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tassert (string.length() == 2);\n\treturn !string.compare(\"[\");\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpb9mil5ls: /tmp/tmpb9mil5ls.cpp:13: bool is_nested(std::string): Assertion\
    \ `string.length() == 2' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int i, j;\n    int size = string.size();\n    int count = 0;\n    for\
    \ (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n       \
    \     if (string[i] == '[' && string[j] == ']') {\n                count++;\n\
    \            }\n        }\n    }\n    return count == 0;\n}\nint main() {\n  \
    \  auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpfa7bkdil: /tmp/tmpfa7bkdil.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Complete the implementation of this function.\n    bool result = false;\n\
    \    for(int i = 0;i<string.length()-1;i++) {\n        if(string[i] == '[' &&\
    \ string[i+1] == '[') {\n            bool found = false;\n            for(int\
    \ j = i+2;j<string.length();j++) {\n                if(string[j] == '[' && string[j+1]\
    \ == ']') {\n                    found = true;\n                    break;\n \
    \               }\n            }\n            if(!found) result = false;\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpadz2q0po: /tmp/tmpadz2q0po.cpp:31: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int counter = 0;\n    int i = 0;\n    while\
    \ (i < string.length()) {\n        if (string[i] == '[') {\n            counter++;\n\
    \            i++;\n        }\n        else if (string[i] == ']') {\n         \
    \   counter--;\n            i++;\n        }\n        i++;\n    }\n    return (counter\
    \ == 1);\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmph884bbnc: /tmp/tmph884bbnc.cpp:31: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    for (int i = 0; i < string.size(); ++i) {\n        for (int j = 0; j\
    \ < string[i].size(); ++j) {\n            if (string[i][j] == '[' && string[i\
    \ + 1][j] == ']') {\n                return true;\n            }\n        }\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp3kmlmfb3.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp3kmlmfb3.cpp:14:39: error: request for member \u2018size\u2019 in \u2018\
    string.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   14 |         for (int j =\
    \ 0; j < string[i].size(); ++j) {\n      |                                   \
    \    ^~~~\n/tmp/tmp3kmlmfb3.cpp:15:28: error: invalid types \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}[int]\u2019 for array subscript\n   15 |       \
    \      if (string[i][j] == '[' && string[i + 1][j] == ']') {\n      |        \
    \                    ^\n/tmp/tmp3kmlmfb3.cpp:15:55: error: invalid types \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}[int]\u2019\
    \ for array subscript\n   15 |             if (string[i][j] == '[' && string[i\
    \ + 1][j] == ']') {\n      |                                                 \
    \      ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    char left='[', right=']', count=0;\n    for(int i=0;i<string.size();i++){\n\
    \        if(string[i]==left){\n            count++;\n        }else if(string[i]==right){\n\
    \            count--;\n        }\n        if(count==0)\n            return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpayiewuhp: /tmp/tmpayiewuhp.cpp:28: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int i = 0;\n    int j = string.size() - 1;\n    int c = 0;\n    while\
    \ ((i < j) && (c < string.size()) && (string[i] == '[') && (string[j] == ']'))\
    \ {\n        i++;\n        j--;\n        c++;\n    }\n    if (i == j) {\n    \
    \    return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpmcao4a9u: /tmp/tmpmcao4a9u.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    for(auto i = 0; i < string.size(); i++) {\n  \
    \      if(string[i] != '[') {\n            return false;\n        }\n    }\n \
    \   return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmppjvfldi5: /tmp/tmppjvfldi5.cpp:23: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int n= string.length();\n    int count =\
    \ 0;\n    if (string[0] == '[' && string[n-1] == ']')\n    {\n        for(int\
    \ i = 1; i < n - 1; i++)\n        {\n            if (string[i] == '[' && string[i-1]\
    \ == ']')\n            {\n                count++;\n            }\n        }\n\
    \        if (count == 0)\n        {\n            return false;\n        }\n  \
    \      else\n        {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpe57fjja3: /tmp/tmpe57fjja3.cpp:38: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = true;\n    int counter = 0;\n    char bracket = '[';\n  \
    \  \n    for (int i = 0; i <= string.size(); i++) {\n        counter++;\n    \
    \    \n        if ((bracket = string[i]) == '[') {\n            counter--;\n \
    \       }\n        else if (bracket == ']') {\n            counter++;\n      \
    \  }\n        \n        if (counter > 0) {\n            flag = false;\n      \
    \  }\n    }\n    \n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpupq8d1yb: /tmp/tmpupq8d1yb.cpp:36: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size();\n    // Initialize a boolean array to False to\
    \ mark positions where opening brackets are found.\n    bool openingbracket[100];\n\
    \    // Initialize a boolean array to False to mark positions where closing brackets\
    \ are found.\n    bool closingbracket[100];\n    // Initialize a boolean array\
    \ to True to mark positions where brackets are nested.\n    bool nested[100];\n\
    \    \n    // Initialize a boolean array to False to mark positions where opening\
    \ brackets are found.\n    for(int i=0 ; i < n ; i++)\n    {\n        if(openingbracket[string[i]]==false)\n\
    \        {\n            openingbracket[string[i]]=true;\n        }\n    }\n\n\
    \    // Initialize a boolean array to False to mark positions where closing brackets\
    \ are found.\n    for(int j=0 ; j < n ; j++)\n    {\n        if(closingbracket[string[j]]==false)\n\
    \        {\n            closingbracket[string[j]]=true;\n        }\n    }\n  \
    \  // Initialize a boolean array to True to mark positions where brackets are\
    \ nested.\n    for(int k=0 ; k < n ; k++)\n    {\n        if(openingbracket[string[k]]==true\
    \ && closingbracket[string[k]]==true)\n        {\n            nested[string[k]]=true;\n\
    \        }\n    }\n\n    // Check for valid brackets\n    for(int l=0 ; l < n\
    \ ; l++)\n    {\n        if(openingbracket[string[l]]==true && closingbracket[string[l]]==true)\n\
    \        {\n            if(nested[string[l]]==false)\n            {\n        \
    \        return false;\n            }\n        }\n    }\n    \n    return true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpsdsy8om1: /tmp/tmpsdsy8om1.cpp:64: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    size_t length = string.length();\n    bool ret = false;\n    stack<char>\
    \ brackets;\n    \n    for(int i = 0; i <= length; i++){\n        if( string[i]\
    \ == '[' && string[i-1] == ']' ) {\n            if( brackets.size() > 0 ) {\n\
    \                ret = ret || brackets.top() == '[';\n            }\n        \
    \    brackets.push( string[i] );\n        } else {\n            if( brackets.size()\
    \ > 0 ) {\n                ret = ret || brackets.top() == string[i];\n       \
    \     }\n            brackets.pop();\n        }\n    }\n    return ret;\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4z9iigcu.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp4z9iigcu.cpp:15:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   15 |     stack<char> brackets;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp4z9iigcu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp4z9iigcu.cpp:15:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   15 |     stack<char> brackets;\n      |        \
    \   ^~~~\n/tmp/tmp4z9iigcu.cpp:19:17: error: \u2018brackets\u2019 was not declared\
    \ in this scope\n   19 |             if( brackets.size() > 0 ) {\n      |    \
    \             ^~~~~~~~\n/tmp/tmp4z9iigcu.cpp:22:13: error: \u2018brackets\u2019\
    \ was not declared in this scope\n   22 |             brackets.push( string[i]\
    \ );\n      |             ^~~~~~~~\n/tmp/tmp4z9iigcu.cpp:24:17: error: \u2018\
    brackets\u2019 was not declared in this scope\n   24 |             if( brackets.size()\
    \ > 0 ) {\n      |                 ^~~~~~~~\n/tmp/tmp4z9iigcu.cpp:27:13: error:\
    \ \u2018brackets\u2019 was not declared in this scope\n   27 |             brackets.pop();\n\
    \      |             ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // initialize count to 0 on first call\n    size_t count = 0;\n    \n\
    \    // initialize boolean to false\n    bool valid = false;\n    \n    size_t\
    \ begin = 0;\n    size_t end = 0;\n    \n    // loop through all chars in the\
    \ string\n    for (const char& c : string) {\n        // increment the count of\
    \ consecutive brackets\n        if (c != '[') {\n            // if the previous\
    \ count was zero increment the count\n            if (count == 0) {\n        \
    \        count++;\n            }\n            else {\n                // if the\
    \ previous count was 1 decrement the count\n                if (count == 1) {\n\
    \                    count--;\n                }\n                else {\n   \
    \                 // if the previous count was 2 and the current count is 1 we\
    \ found a nested bracket pair\n                    if (count == 2 && count ==\
    \ 1) {\n                        // we found the end of the valid subsequence \n\
    \                        valid = true;\n                        break;\n     \
    \               }\n                    else {\n                        // reset\
    \ count back to zero for the next iteration\n                        count = 0;\n\
    \                    }\n                }\n            }\n        }\n        else\
    \ {\n            // if the previous count was 1 and the current count is 0 we\
    \ found a nested bracket pair\n            if (count == 1 && count == 0) {\n \
    \               // we found the end of the valid subsequence \n              \
    \  valid = true;\n                break;\n            }\n            else {\n\
    \                // reset count back to zero for the next iteration\n        \
    \        count = 0;\n            }\n        }\n    }\n    return valid;\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp11jo1q9u: /tmp/tmp11jo1q9u.cpp:66: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint i = 0, j = 0;\n\tint n = string.size();\n\twhile(i < n && string[i]\
    \ == '[') {\n\t\ti++;\n\t}\n\tint n1 = string.size();\n\twhile(j < n1 && string[j]\
    \ == ']') {\n\t\tj++;\n\t}\n\tif(i >= j - 1) {\n\t\treturn true;\n\t} else {\n\
    \t\treturn false;\n\t}\n}\nint main() {\n    auto candidate = is_nested;\n   \
    \ assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpu68fw691: /tmp/tmpu68fw691.cpp:31: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if (string.empty()) return false;\n    for (char c : string) {\n    \
    \    if (c != '[') return false;\n    }\n    return true;\n}\nint main() {\n \
    \   auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmppd5ekx0g: /tmp/tmppd5ekx0g.cpp:21: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint count = 0;\n\tint len = string.length();\n\tfor (int i = 0; i < len\
    \ - 1; ++i) {\n\t\tif (string[i] != '[') {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int\
    \ j = i + 1; j < len; ++j) {\n\t\t\tif (string[j] == ']') {\n\t\t\t\t++count;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (count == 0) {\n\t\t\treturn false;\n\t\
    \t}\n\t\tcount = 0;\n\t}\n\treturn true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpr3atvnxi: /tmp/tmpr3atvnxi.cpp:35: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    auto found = string[string.size()-2];\n    if (found == '[' && string[string.size()-3]\
    \ == '[') {\n        return true;\n    }\n    if (found != ']') {\n        return\
    \ false;\n    }\n    if (string[string.size()-2] == '[') {\n        return is_nested(string);\n\
    \    }\n    auto found1 = string[string.size()-4];\n    if (found1 == '[' && string[string.size()-5]\
    \ == '[') {\n        return true;\n    }\n    if (found1 != ']') {\n        return\
    \ false;\n    }\n    if (string[string.size()-4] == '[') {\n        return is_nested(string);\n\
    \    }\n    auto found2 = string[string.size()-6];\n    if (found2 == '[' && string[string.size()-7]\
    \ == '[') {\n        return true;\n    }\n    if (found2 != ']') {\n        return\
    \ false;\n    }\n    if (string[string.size()-6] == '[') {\n        return is_nested(string);\n\
    \    }\n    auto found3 = string[string.size()-8];\n    if (found3 == '[' && string[string.size()-9]\
    \ == '[') {\n        return true;\n    }\n    if (found3 != ']') {\n        return\
    \ false;\n    }\n    if (string[string.size()-8] == '[') {\n        return is_nested(string);\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpdbnl62tc: /tmp/tmpdbnl62tc.cpp:57: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  if(string.length() == 0) return false;\n  if(string[0] == '[' && string[string.length()-1]\
    \ == ']') return true;\n  if(string[0] == '[' && string[string.length()-1] !=\
    \ ']') return false;\n  return is_nested(string.substr(1, string.length()-2));\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpbgp8g2a_: /tmp/tmpbgp8g2a_.cpp:21: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    return 0;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp828sw0iz: /tmp/tmp828sw0iz.cpp:19: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Iterate through all characters in the input string.\n    for(int i\
    \ = 0; i < string.length(); i++)\n        // If the character at index i is a\
    \ square bracket, \n        // increment a counter if it is not already set.\n\
    \        if(string[i] == '[') {\n            if(i + 1 >= string.length())\n  \
    \              return false;\n            else if(string[i + 1] != ']')\n    \
    \            return false;\n            i++;\n        }\n    // If the counter\
    \ has not reached the end, return True.\n    return (i == string.length() - 1);\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptxda97j_.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmptxda97j_.cpp:25:13: error: \u2018i\u2019 was not declared in this scope\n\
    \   25 |     return (i == string.length() - 1);\n      |             ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> s;\n    \n    // We will use the stack to keep track of opening\
    \ and closing brackets\n    \n    // Traverse the string and push opening and\
    \ closing brackets onto the stack\n    \n    for (int i=0; i<string.size(); i++)\
    \ {\n        // Push the character onto the stack\n        if (string[i] == '[')\
    \ {\n            s.push(string[i]);\n        } else if (string[i] == ']') {\n\
    \            if (s.size() == 0) {\n                // If the stack is empty, then\
    \ the bracket is not nested\n                return false;\n            }\n  \
    \          \n            char ch1 = s.pop();\n            \n            if (ch1\
    \ == '[') {\n                s.push(string[i]);\n            } else if (ch1 ==\
    \ ']') {\n                char ch2 = s.pop();\n                if (ch2 == '[')\
    \ {\n                    s.push(string[i]);\n                }\n            }\n\
    \        }\n    }\n    \n    // After the loop, if the stack is empty, then the\
    \ bracket is nested\n    return s.size() == 0;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpgkl6jqxn.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpgkl6jqxn.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> s;\n  \
    \    |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpgkl6jqxn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpgkl6jqxn.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmpgkl6jqxn.cpp:22:13: error: \u2018s\u2019 was not declared in this scope\n\
    \   22 |             s.push(string[i]);\n      |             ^\n/tmp/tmpgkl6jqxn.cpp:24:17:\
    \ error: \u2018s\u2019 was not declared in this scope\n   24 |             if\
    \ (s.size() == 0) {\n      |                 ^\n/tmp/tmpgkl6jqxn.cpp:29:24: error:\
    \ \u2018s\u2019 was not declared in this scope\n   29 |             char ch1 =\
    \ s.pop();\n      |                        ^\n/tmp/tmpgkl6jqxn.cpp:43:12: error:\
    \ \u2018s\u2019 was not declared in this scope\n   43 |     return s.size() ==\
    \ 0;\n      |            ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int i = 0;\n    for (; i < string.length(); ++i) {\n        if (string[i]\
    \ != '[' && string[i] != ']') {\n            return false;\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpqywqd8kr: /tmp/tmpqywqd8kr.cpp:24: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if (string.size() <= 1)\n        return false;\n    int n = (int)string.size();\n\
    \    int left = 0;\n    int right = n - 1;\n    while (left < right) {\n     \
    \   int mid = (left + right) / 2;\n        if (string[mid] == '[') {\n       \
    \     if (mid == 0)\n                return false;\n            left = mid + 1;\n\
    \        } else if (string[mid] == ']') {\n            if (mid == n - 1)\n   \
    \             return false;\n            right = mid;\n        } else {\n    \
    \        return false;\n        }\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmps5kadlkb: /tmp/tmps5kadlkb.cpp:42: int main(): Assertion `candidate((\"\
    [][][[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> stk{};\n    for (char c : string) {\n        if (c == '[')\
    \ {\n            stk.push(c);\n        } else if (c == ']') {\n            if\
    \ (stk.empty()) return false;\n            char last = stk.top();\n          \
    \  if (last == '[' || last == ']') stk.pop();\n        }\n    }\n    return stk.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy17du_xc.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpy17du_xc.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> stk{};\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpy17du_xc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpy17du_xc.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> stk{};\n      |           ^~~~\n\
    /tmp/tmpy17du_xc.cpp:16:13: error: \u2018stk\u2019 was not declared in this scope;\
    \ did you mean \u2018std\u2019?\n   16 |             stk.push(c);\n      |   \
    \          ^~~\n      |             std\n/tmp/tmpy17du_xc.cpp:18:17: error: \u2018\
    stk\u2019 was not declared in this scope; did you mean \u2018std\u2019?\n   18\
    \ |             if (stk.empty()) return false;\n      |                 ^~~\n\
    \      |                 std\n/tmp/tmpy17du_xc.cpp:19:25: error: \u2018stk\u2019\
    \ was not declared in this scope; did you mean \u2018std\u2019?\n   19 |     \
    \        char last = stk.top();\n      |                         ^~~\n      |\
    \                         std\n/tmp/tmpy17du_xc.cpp:23:12: error: \u2018stk\u2019\
    \ was not declared in this scope; did you mean \u2018std\u2019?\n   23 |     return\
    \ stk.empty();\n      |            ^~~\n      |            std\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    bool flag = true;\n    for (int i = 1;\
    \ i < n; i++) {\n        if (string[i - 1] == '[' && string[i] != ']') flag =\
    \ false;\n        if (string[i - 1] != ']' && string[i] == '[') flag = false;\n\
    \    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpk352ije_: /tmp/tmpk352ije_.cpp:23: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::stack<char> brackets;\n    for(int i = 0; i < string.size() - 1;\
    \ i++) {\n        if(brackets.size() == 0 || (string[i] == '[' && string[i + 1]\
    \ == '[') || (string[i] == '{' && string[i + 1] == '{') || (string[i] == '(' &&\
    \ string[i + 1] == '(')) {\n            brackets.push(string[i]);\n        }\n\
    \        if(brackets.size() > 0 && string[i] == brackets.top()) {\n          \
    \  brackets.pop();\n        }\n        if(brackets.size() == 0) {\n          \
    \  return false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmplta36scb: /tmp/tmplta36scb.cpp:29: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    \n    if(string.length()==0) return false;\n    if(string.length()==1)\
    \ return string[0]=='[';\n    for(int i=0;i<string.length()-1;i++){\n        if(string[i]=='['\
    \ && string[i+1]==']'){\n            for(int j=i+2;j<string.length()-1;j++){\n\
    \                if(string[j]==']' && string[j+1]=='[') \n                   \
    \ return true;\n            }\n        }\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpt6r0viob: /tmp/tmpt6r0viob.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n   \n    for (int i = 0; i < string.size(); i++) {\n        \n        if\
    \ ((string[i] == '[') && (string[i + 1] == ']')) {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpp5qbf8pc: /tmp/tmpp5qbf8pc.cpp:25: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\tint n = string.length();\n\tint count[26]={0};\n\tfor(int i=0;i<n;i++){\n\
    \t\tchar c = string[i];\n\t\tif(c == '['){\n\t\t\tcount[c-'a']++;\n\t\t} else\
    \ if(c == ']'){\n\t\t\tcount[c-'a']--;\n\t\t}\n\t}\n\tfor(int i=0;i<26;i++){\n\
    \t\tif(count[i] == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpo6rkk3bu: /tmp/tmpo6rkk3bu.cpp:31: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Base Case\n    if (string == \"[]\") {\n        return true;\n   \
    \ }\n    if (string[0] == '[' && string[string.size()-1] == ']') {\n        return\
    \ is_nested(string+1);\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpbcndlwhg.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpbcndlwhg.cpp:18:32: error: no match for \u2018operator+\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018int\u2019)\n   18 |         return is_nested(string+1);\n      | \
    \                         ~~~~~~^~\n      |                          |      |\n\
    \      |                          |      int\n      |                        \
    \  std::string {aka std::__cxx11::basic_string<char>}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpbcndlwhg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpbcndlwhg.cpp:18:33:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018int\u2019\n   18 |         return is_nested(string+1);\n      |  \
    \                               ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \   "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int count = 0;\n  for (int i = 0; i < string.size(); i++) {\n    if (string[i]\
    \ == '[') {\n      count++;\n    }\n    else if (string[i] == ']') {\n      count--;\n\
    \    }\n    if (count == 0) {\n      return true;\n    }\n  }\n  return false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpilih9szv: /tmp/tmpilih9szv.cpp:30: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int nest = 0;\n    std::string brackets = \"[]\";\n    std::string str\
    \ = string;\n    while (true) {\n        if (nest == str.size() - 1) {\n     \
    \       if (str == brackets) {\n                return true;\n            }\n\
    \            nest += 1;\n        } else {\n            nest += 1;\n        }\n\
    \        str = str.substr(0, nest + 1) + brackets;\n    }\n}\nint main() {\n \
    \   auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    if(string.find(\"[\")!=string::npos) {\n     \
    \   if(string.find(\"[[\")!=string::npos) {\n            if(string.find(\"]]\"\
    )!=string::npos) {\n                if(string.find(\"]]]]\")!=string::npos) {\n\
    \                    if(string.find(\"]]]]]]\")!=string::npos) {\n           \
    \             return true;\n                    } else {\n                   \
    \     return false;\n                    }\n                } else {\n       \
    \             return false;\n                }\n            } else {\n       \
    \         return false;\n            }\n        } else {\n            return false;\n\
    \        }\n    } else {\n        return false;\n    }\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpqw7oqa8x.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpqw7oqa8x.cpp:14:26: error: \u2018string\u2019 is not a class, namespace,\
    \ or enumeration\n   14 |     if(string.find(\"[\")!=string::npos) {\n      |\
    \                          ^~~~~~\n/tmp/tmpqw7oqa8x.cpp:15:31: error: \u2018string\u2019\
    \ is not a class, namespace, or enumeration\n   15 |         if(string.find(\"\
    [[\")!=string::npos) {\n      |                               ^~~~~~\n/tmp/tmpqw7oqa8x.cpp:16:35:\
    \ error: \u2018string\u2019 is not a class, namespace, or enumeration\n   16 |\
    \             if(string.find(\"]]\")!=string::npos) {\n      |               \
    \                    ^~~~~~\n/tmp/tmpqw7oqa8x.cpp:17:41: error: \u2018string\u2019\
    \ is not a class, namespace, or enumeration\n   17 |                 if(string.find(\"\
    ]]]]\")!=string::npos) {\n      |                                         ^~~~~~\n\
    /tmp/tmpqw7oqa8x.cpp:18:47: error: \u2018string\u2019 is not a class, namespace,\
    \ or enumeration\n   18 |                     if(string.find(\"]]]]]]\")!=string::npos)\
    \ {\n      |                                               ^~~~~~\n/tmp/tmpqw7oqa8x.cpp:35:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   35 | }\n\
    \      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> s;\n    for(int i = 0; i<string.size(); i++) {\n        if(string[i]\
    \ == '[') {\n            s.push('[');\n        }\n        else if(string[i] ==\
    \ ']') {\n            if(s.empty() || s.top() != '[') {\n                return\
    \ false;\n            }\n            else {\n                s.pop();\n      \
    \      }\n        }\n    }\n    return !s.empty();\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp213c6cqz.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp213c6cqz.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> s;\n  \
    \    |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp213c6cqz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp213c6cqz.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmp213c6cqz.cpp:16:13: error: \u2018s\u2019 was not declared in this scope\n\
    \   16 |             s.push('[');\n      |             ^\n/tmp/tmp213c6cqz.cpp:19:16:\
    \ error: \u2018s\u2019 was not declared in this scope\n   19 |             if(s.empty()\
    \ || s.top() != '[') {\n      |                ^\n/tmp/tmp213c6cqz.cpp:27:13:\
    \ error: \u2018s\u2019 was not declared in this scope\n   27 |     return !s.empty();\n\
    \      |             ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if (string.size() <= 1)\n        return true; // if string is empty,\
    \ there are no brackets\n    \n    for(int i = 1; i < string.size(); i++) {\n\
    \        if (string[i - 1] == string[i])\n            continue; // if brackets\
    \ are the same, there is another bracket\n        if (string[i] == '[')\n    \
    \        return false; // if the brackets are not the same, then there is no valid\
    \ brackets\n    }\n    \n    return true; // if string is valid, there is a valid\
    \ brackets\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpansinw9t: /tmp/tmpansinw9t.cpp:30: int main(): Assertion `candidate((\"\
    []\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int size = string.length();\n    for (int i = 0; i < size; i++) {\n \
    \       if (string[i] == '[' && string[i + 1] == '[' && string[i + 2] == ']' &&\
    \ string[i + 3] == ']') {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmppq6bie4_: /tmp/tmppq6bie4_.cpp:33: int main(): Assertion `candidate((\"\
    [[][]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> stk;\n    bool res = false;\n    stk.push('<');\n    for\
    \ (char c : string) {\n        if (c == '[') stk.push('[');\n        else if (c\
    \ == '(') stk.push('(');\n        else if (c == ')') stk.push(')');\n        else\
    \ if (c == ']') stk.push(']');\n        else if (c == '<') stk.push('>');\n  \
    \      else stk.pop();\n        res = res || stk.isEmpty();\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpf7jsjupn.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpf7jsjupn.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> stk;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpf7jsjupn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpf7jsjupn.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> stk;\n      |           ^~~~\n\
    /tmp/tmpf7jsjupn.cpp:15:5: error: \u2018stk\u2019 was not declared in this scope;\
    \ did you mean \u2018std\u2019?\n   15 |     stk.push('<');\n      |     ^~~\n\
    \      |     std\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> brackets;\n    string temp = string;\n    for (char c : temp)\
    \ {\n        if (c != '[') {\n            continue;\n        }\n        if (brackets.size()\
    \ >= 2) {\n            return false;\n        }\n        brackets.push('[');\n\
    \    }\n    for (char c : temp) {\n        if (c != ']') {\n            continue;\n\
    \        }\n        if (!brackets.empty()) {\n            if (brackets.top() !=\
    \ '[') {\n                return false;\n            }\n            brackets.pop();\n\
    \        } else {\n            return false;\n        }\n    }\n    return brackets.empty();\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5lv_ksyt.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp5lv_ksyt.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> brackets;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp5lv_ksyt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp5lv_ksyt.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> brackets;\n      |        \
    \   ^~~~\n/tmp/tmp5lv_ksyt.cpp:14:11: error: expected \u2018;\u2019 before \u2018\
    temp\u2019\n   14 |     string temp = string;\n      |           ^~~~~\n     \
    \ |           ;\n/tmp/tmp5lv_ksyt.cpp:15:19: error: \u2018temp\u2019 was not declared\
    \ in this scope\n   15 |     for (char c : temp) {\n      |                  \
    \ ^~~~\n/tmp/tmp5lv_ksyt.cpp:19:13: error: \u2018brackets\u2019 was not declared\
    \ in this scope\n   19 |         if (brackets.size() >= 2) {\n      |        \
    \     ^~~~~~~~\n/tmp/tmp5lv_ksyt.cpp:22:9: error: \u2018brackets\u2019 was not\
    \ declared in this scope\n   22 |         brackets.push('[');\n      |       \
    \  ^~~~~~~~\n/tmp/tmp5lv_ksyt.cpp:24:19: error: \u2018temp\u2019 was not declared\
    \ in this scope\n   24 |     for (char c : temp) {\n      |                  \
    \ ^~~~\n/tmp/tmp5lv_ksyt.cpp:28:14: error: \u2018brackets\u2019 was not declared\
    \ in this scope\n   28 |         if (!brackets.empty()) {\n      |           \
    \   ^~~~~~~~\n/tmp/tmp5lv_ksyt.cpp:37:12: error: \u2018brackets\u2019 was not\
    \ declared in this scope\n   37 |     return brackets.empty();\n      |      \
    \      ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n   \
    \     if(string[i] == '['){\n            count++;\n        }\n        if (string[i]\
    \ == ']') {\n            count--;\n        }\n        if (count == 0)\n      \
    \      return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpd00ko725: /tmp/tmpd00ko725.cpp:29: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    // return 0;\n    // return 1;\n    for (int i\
    \ = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n          \
    \  int counter = 0;\n            bool flag = true;\n            for (int j = i;\
    \ j < string.size(); j++) {\n                if (string[j] == ']') {\n       \
    \             if (flag) {\n                        counter++;\n              \
    \      } else {\n                        counter--;\n                    }\n \
    \                   flag = false;\n                } else {\n                \
    \    flag = true;\n                }\n            }\n            if (counter ==\
    \ 1) {\n                return true;\n            } else {\n                return\
    \ false;\n            }\n        }\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpxxems9es: /tmp/tmpxxems9es.cpp:43: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  // Your code here\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpmgq4cl90: /tmp/tmpmgq4cl90.cpp:17: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Declare and initialize an array with string length as number of brackets.\n\
    \    int brackets[string.length()];\n    // A boolean variable to track if a bracket\
    \ is present or not.\n    bool found = false;\n\n    // Iterate through the string\
    \ and check if the bracket is present or not.\n    // If it does, mark the boolean\
    \ variable as true.\n    for (int i = 0; i < string.length(); i++) {\n       \
    \ if (string[i] == '[') {\n            brackets[i] = 1;\n        } else if (string[i]\
    \ == ']') {\n            // If the bracket is found, it must be paired with an\
    \ opening bracket.\n            // Check for the closing bracket.\n          \
    \  for (int j = 0; j < i; j++) {\n                if (brackets[j] == 1) {\n  \
    \                  // If opening bracket, increment the boolean variable.\n  \
    \                  // If closing bracket, decrement the boolean variable.\n  \
    \                  if (brackets[j] == 1) {\n                        found = true;\n\
    \                    } else {\n                        found = false;\n      \
    \              }\n                    break;\n                }\n            }\n\
    \        }\n    }\n\n    // Return boolean value at the end\n    return found;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpcrqghafs: /tmp/tmpcrqghafs.cpp:47: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> s;\n    for (char c: string) s.push(c);\n    if (s.size()\
    \ != 0) return false; \n    for (char c: s) {\n        if (c == '[' || c == ']'\
    \ || c == '{' || c == '}') return true;\n        if (s.empty() && c == ']') return\
    \ true;\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpul8giflf.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpul8giflf.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> s;\n  \
    \    |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpul8giflf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpul8giflf.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmpul8giflf.cpp:14:26: error: \u2018s\u2019 was not declared in this scope\n\
    \   14 |     for (char c: string) s.push(c);\n      |                        \
    \  ^\n/tmp/tmpul8giflf.cpp:15:9: error: \u2018s\u2019 was not declared in this\
    \ scope\n   15 |     if (s.size() != 0) return false;\n      |         ^\n/tmp/tmpul8giflf.cpp:16:18:\
    \ error: \u2018s\u2019 was not declared in this scope\n   16 |     for (char c:\
    \ s) {\n      |                  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int cnt = 0;\n    for (int i = 0; i < string.size(); i++) {\n       \
    \ if ((string[i] != '[') || (string[i] != ']'))\n            continue;\n     \
    \   for ( ; i < string.size() && string[i] != '['; ++i)\n            if (string[i]\
    \ == '[')\n                cnt++;\n        for ( ; i < string.size() && string[i]\
    \ == ']'; ++i)\n            if (string[i] == ']')\n                --cnt;\n  \
    \      if (cnt)\n            return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp9oqno5ni: /tmp/tmp9oqno5ni.cpp:31: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpnd01mvyi: /tmp/tmpnd01mvyi.cpp:17: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    std::vector<int> bracket_counts;\n    std::vector<int> brackets;\n  \
    \  for (int i=0; i<string.length(); i++) {\n        if (string[i] == '[') {\n\
    \            brackets.push_back(i);\n        } else if (string[i] == ']') {\n\
    \            int last_index = brackets.size() - 1;\n            assert(last_index\
    \ >= 0);\n            int cur = brackets[last_index];\n            bracket_counts.push_back(cur\
    \ - i);\n            brackets.erase(brackets.begin() + last_index);\n        }\
    \ else {\n            assert(false);\n        }\n    }\n    // all brackets are\
    \ nested\n    return brackets.size() == 0;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp07ysyld4: /tmp/tmp07ysyld4.cpp:20: bool is_nested(std::string): Assertion\
    \ `last_index >= 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // code here\n    // return true/false\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpnurp05up: /tmp/tmpnurp05up.cpp:18: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if(string.length() <= 2) return false;\n    for(int i = 1; i < string.length();\
    \ i++) {\n        if(string[i-1] == '[' && string[i] == ']') return true;\n  \
    \      if(string[i-1] == '{' && string[i] == '}') return true;\n        if(string[i-1]\
    \ == '(' && string[i] == ')') return true;\n        if(string[i-1] == '[' && string[i]\
    \ == ']' && string[i+1] == ']') return true;\n        if(string[i-1] == '{' &&\
    \ string[i] == '}' && string[i+1] == '}') return true;\n        if(string[i-1]\
    \ == '(' && string[i] == ')' && string[i+1] == ')') return true;\n        if(string[i-1]\
    \ == '[' && string[i] == ']' && string[i+1] == '[') return true;\n        if(string[i-1]\
    \ == '{' && string[i] == '}' && string[i+1] == '{' && string[i+2] == '}') return\
    \ true;\n        if(string[i-1] == '(' && string[i] == ')' && string[i+1] == ')'\
    \ && string[i+2] == ')') return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpz5biwc4u: /tmp/tmpz5biwc4u.cpp:30: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    for (size_t i = 0; i < string.length() - 1; i++) {\n        if (string[i]\
    \ == '[' && string[i + 1] == ']') {\n            return true;\n        } else\
    \ if (string[i] == '[') {\n            if (string[i + 1] == '[' && string[i +\
    \ 2] == ']' && string[i + 3] == '[' &&\n                string[i + 4] == ']' &&\
    \ string[i + 5] == '[') {\n                return true;\n            }\n     \
    \   }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmptvcfo_kn: /tmp/tmptvcfo_kn.cpp:28: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int brackets = 0; // Tracks number of currently open brackets\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n       \
    \     brackets++;\n        }\n        if(string[i] == ']') {\n            if(brackets\
    \ > 0) {\n                brackets--;\n            }\n        }\n    }\n    return\
    \ (brackets > 0) ? true : false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpsqdj0unr: /tmp/tmpsqdj0unr.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  // Write your code here.\n  std::string string1 = \"[[]\";\n  std::string\
    \ string2 = \"[][]]\";\n  std::string string3 = \"[][]\";\n  std::string string4\
    \ = \"[]\";\n  std::string string5 = \"[[][]]\";\n  std::string string6 = \"[[]]\"\
    ;\n  std::string string7 = \"[[[]]\";\n  std::string string8 = \"[[[]\";\n  std::string\
    \ string9 = \"[[]]\";\n  std::string string10 = \"[[]]\";\n  \n  return string1==string2==string3==string4==string5==string6==string7==string8==string9==string10;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy9fvf_t7.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpy9fvf_t7.cpp:25:26: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__enable_if<true, bool>::__type\u2019 {aka \u2018\
    bool\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   25 |   return string1==string2==string3==string4==string5==string6==string7==string8==string9==string10;\n\
    \      |          ~~~~~~~~~~~~~~~~^~~~~~~~~\n      |                 |       \
    \   |\n      |                 |          std::string {aka std::__cxx11::basic_string<char>}\n\
    \      |                 __gnu_cxx::__enable_if<true, bool>::__type {aka bool}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy9fvf_t7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy9fvf_t7.cpp:25:28:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__enable_if<true, bool>::__type\u2019 {aka \u2018bool\u2019\
    }\n   25 |   return string1==string2==string3==string4==string5==string6==string7==string8==string9==string10;\n\
    \      |                            ^~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy9fvf_t7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::op"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n\t// Return true if the string has no brackets\n\tstring brackets = \"[]\"\
    ;\n\tif(string.find(brackets) != string::npos)\n\t{\n\t\treturn true;\n\t}\n\n\
    \t// Initialize a stack\n\tstack<char> bracket;\n\tbool isValid = false;\n\t\n\
    \t// Remove the first character of the string\n\tstring remainingString = string.substr(1);\n\
    \n\t// If the first character of the string is bracket, remove it and add it to\
    \ the stack\n\tif(remainingString.find(brackets) != string::npos)\n\t{\n\t\tisValid\
    \ = true;\n\t\tbracket.pop();\n\t}\n\n\t// While there are still characters in\
    \ the string\n\twhile(remainingString.find(brackets) != string::npos)\n\t{\n\t\
    \t// If the current character is bracket, remove it and add it to the stack\n\t\
    \tif(remainingString.find(brackets) != string::npos)\n\t\t{\n\t\t\tisValid = true;\n\
    \t\t\tbracket.push(remainingString[0]);\n\t\t\tremainingString = remainingString.substr(1);\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\t// If the current character is something other than\
    \ bracket, add it to the stack\n\t\t\tbracket.push(remainingString[0]);\n\t\t\t\
    remainingString = remainingString.substr(1);\n\t\t}\n\t}\n\n\t// If the string\
    \ has a matching number of closing brackets than opening brackets \n\tif(brackets.size()\
    \ > bracket.size()) \n\t{\n\t\treturn isValid;\n\t}\n\t\n\treturn false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppu72lhbo.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmppu72lhbo.cpp:14:8: error: expected \u2018;\u2019 before \u2018brackets\u2019\
    \n   14 |  string brackets = \"[]\";\n      |        ^~~~~~~~~\n      |      \
    \  ;\n/tmp/tmppu72lhbo.cpp:15:17: error: \u2018brackets\u2019 was not declared\
    \ in this scope\n   15 |  if(string.find(brackets) != string::npos)\n      | \
    \                ^~~~~~~~\n/tmp/tmppu72lhbo.cpp:15:30: error: \u2018string\u2019\
    \ is not a class, namespace, or enumeration\n   15 |  if(string.find(brackets)\
    \ != string::npos)\n      |                              ^~~~~~\n/tmp/tmppu72lhbo.cpp:21:2:\
    \ error: \u2018stack\u2019 was not declared in this scope; did you mean \u2018\
    std::stack\u2019?\n   21 |  stack<char> bracket;\n      |  ^~~~~\n      |  std::stack\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmppu72lhbo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmppu72lhbo.cpp:21:8: error: expected primary-expression\
    \ before \u2018char\u2019\n   21 |  stack<char> bracket;\n      |        ^~~~\n\
    /tmp/tmppu72lhbo.cpp:25:8: error: expected \u2018;\u2019 before \u2018remainingString\u2019\
    \n   25 |  string remainingString = string.substr(1);\n      |        ^~~~~~~~~~~~~~~~\n\
    \      |        ;\n/tmp/tmppu72lhbo.cpp:28:5: error: \u2018remainingString\u2019\
    \ was not declared in this scope\n   28 |  if(remainingString.find(brackets) !=\
    \ string::npos)\n      |     ^~~~~~~~~~~~~~~\n/tmp/tmppu72lhbo.cpp:28:26: error:\
    \ \u2018brackets\u2019 was not declared in this scope\n   28 |  if(remainingString.find(brackets)\
    \ != string::npos)\n      |                          ^~~~~~~~\n/tmp/tmppu72lhbo.cpp:28:39:\
    \ error: \u2018string\u2019 is not a class, namespace, or enumeration\n   28 |\
    \  if(remainingString.find(brackets) != string::npos)\n      |               \
    \                        ^~~~~~\n/tmp/tmppu72lhbo.cpp:31:3: error: \u2018bracket\u2019\
    \ was not declared in this scope\n   31 |   bra"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // TODO\n    return true;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpty0c2_ip: /tmp/tmpty0c2_ip.cpp:19: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int counter = 0;\n  bool is_nested = false;\n  for (char c : string) {\n\
    \    if (c == '[' || c == ']') {\n      counter++;\n    } else {\n      assert(counter\
    \ > 0);\n      if (counter == 1) {\n        is_nested = true;\n      }\n     \
    \ counter = 0;\n    }\n  }\n  return is_nested;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpgkj7_4xd: /tmp/tmpgkj7_4xd.cpp:30: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    auto it = string.begin();\n    for (;it!=string.end() && it!=string.length()\
    \ && isalpha(*it); ++it) {\n        if (*it == '[') {\n            ++it;\n   \
    \         for (;it!=string.end() && it!=string.length() && isalpha(*it); ++it)\
    \ {\n                if (*it == '[') {\n                    ++it;\n          \
    \      }\n            }\n            if (it==string.length()) return false;\n\
    \        } else if (*it == ']') {\n            ++it;\n            for (;it!=string.end()\
    \ && it!=string.length() && isalpha(*it); ++it) {\n                if (*it ==\
    \ ']') {\n                    ++it;\n                }\n            }\n      \
    \      if (it==string.length()) return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfw3j8fgq.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpfw3j8fgq.cpp:14:33: error: no match for \u2018operator!=\u2019 (operand\
    \ types are \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018\
    long unsigned int\u2019})\n   14 |     for (;it!=string.end() && it!=string.length()\
    \ && isalpha(*it); ++it) {\n      |                               ~~^~~~~~~~~~~~~~~~~\n\
    \      |                               |                |\n      |           \
    \                    |                std::__cxx11::basic_string<char>::size_type\
    \ {aka long unsigned int}\n      |                               __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpfw3j8fgq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:900:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  900 |\
    \     operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:900:5:\
    \ note:   template argument deduction/substitution faile"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int open = 1, close = 0;\n  for (int i = 0; i < string.size(); ++i) {\n\
    \    if (string[i] == '[') open++;\n    if (string[i] == ']') close++;\n    if\
    \ (string[i] == '[' && open > close) return true;\n  }\n  return false;\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp_0admnhs: /tmp/tmp_0admnhs.cpp:24: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    bool found = false;\n    bool check = false;\n\
    \    \n    for (int i = 1; i < string.length(); i++) {\n        bool bracket =\
    \ true;\n        \n        for (int j = 0; j < i; j++) {\n            if (string[j]\
    \ == '[' && string[j-1] == ']') {\n                bracket = false;\n        \
    \        break;\n            }\n        }\n        \n        if (bracket) {\n\
    \            found = true;\n            check = true;\n        }\n        else\
    \ {\n            check = false;\n        }\n    }\n    \n    if (check == true)\
    \ {\n        return found;\n    }\n    else {\n        return false;\n    }\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpr7ghoxu1: /tmp/tmpr7ghoxu1.cpp:48: int main(): Assertion `candidate((\"\
    []\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Initialize start as 0, end as string.length-1, and found as false.\n\
    \    int start = 0;\n    int end = string.length() - 1;\n    bool found = false;\n\
    \    // Perform loop while start less than end.\n    while (start < end) {\n \
    \       // Search the position of the left bracket in string.\n        // If found,\
    \ set start to position after the bracket.\n        if (string[start] == '[')\
    \ {\n            start = start + 1;\n            found = true;\n        // Search\
    \ the position of the right bracket in string.\n        // If found, set end to\
    \ position after the bracket.\n        } else if (string[end] == ']') {\n    \
    \        end = end - 1;\n            found = true;\n        // If found is false,\
    \ the substring is not valid.\n        } else {\n            found = false;\n\
    \        }\n    }\n    // If found is true, there is a valid subsequence.\n  \
    \  // Return true, otherwise, return false.\n    return found;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // your code here\n    stack<char> brackets;\n    for(int i = 0; i <\
    \ string.size() ; i++){\n        if(brackets.empty() && string[i] == '['){\n \
    \           brackets.push('[');\n        }\n        else if(brackets.top() ==\
    \ '[' && string[i] == '['){\n            brackets.push('[');\n        }\n    \
    \    else if(brackets.top() == ']' && string[i] == ']'){\n            brackets.pop();\n\
    \        }\n        else if(brackets.top() == ']' && string[i] == '['){\n    \
    \        brackets.pop();\n        }\n        else if(brackets.empty() ){\n   \
    \         return false;\n        }\n        else if(brackets.top() != string[i]){\n\
    \            return false;\n        }\n        else{\n            brackets.pop();\n\
    \        }\n    }\n    return !brackets.empty();\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_q2l482u.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp_q2l482u.cpp:14:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   14 |     stack<char> brackets;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp_q2l482u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp_q2l482u.cpp:14:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   14 |     stack<char> brackets;\n      |        \
    \   ^~~~\n/tmp/tmp_q2l482u.cpp:16:12: error: \u2018brackets\u2019 was not declared\
    \ in this scope\n   16 |         if(brackets.empty() && string[i] == '['){\n \
    \     |            ^~~~~~~~\n/tmp/tmp_q2l482u.cpp:38:13: error: \u2018brackets\u2019\
    \ was not declared in this scope\n   38 |     return !brackets.empty();\n    \
    \  |             ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int len = string.size();\n    int count = 0;\n    for (int i = 0; i <\
    \ len; i++)\n    {\n        // Check for square brackets.\n        if (string[i]\
    \ == '[' || string[i] == ']')\n        {\n            if (string[i] == '[' &&\
    \ string[i+1] != ']')\n            {\n                count++;\n            }\n\
    \            else\n            {\n                if (string[i+1] == ']' && string[i+1]\
    \ != ']')\n                {\n                    count--;\n                }\n\
    \            }\n        }\n    }\n    return count == 0;\n}\nint main() {\n  \
    \  auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpd7tsz48_: /tmp/tmpd7tsz48_.cpp:37: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // code goes here\n    // For each character in the string, we check\
    \ if the string has a closing bracket in the \n    // first index. If not, the\
    \ string does not have a nested bracket so return false\n    \n    for(int i=0;i<string.length();i++)\
    \ {\n        if(string.at(i)=='['){\n            if(string.at(i+1)!=']'){\n  \
    \              return false;\n            }\n        }\n        if(string.at(i)==']'){\n\
    \            if(string.at(i+1)!='['){\n                return false;\n       \
    \     }\n        }\n    }\n    \n    return true;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp16jig3qd: /tmp/tmp16jig3qd.cpp:34: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if(string.length()<2) return false;\n    bool first=true;\n    for(int\
    \ i=0;i<string.length();i++) {\n        if(first) {\n            if(string[i]=='['\
    \ && string[i+1]==']') return true;\n        }\n        else {\n            if(string[i]==']'\
    \ && string[i-1]==']') return true;\n        }\n        first=false;\n    }\n\
    \    return false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp81jxfobu: /tmp/tmp81jxfobu.cpp:29: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int counter = 0;\n    int open = 0;\n    int close = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   open++;\n        }\n        else if(string[i] == ']') {\n            close++;\n\
    \        }\n        else {\n            if((open > close) || (open == close))\
    \ {\n                return false;\n            }\n            open = 0;\n   \
    \         close = 0;\n        }\n    }\n    return true;\n}\nint main() {\n  \
    \  auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpvy_wx4gx: /tmp/tmpvy_wx4gx.cpp:36: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = 0, open_brackets = 0;\n    \n    // Check each character in the\
    \ string\n    for(int i = 0; i < string.size(); i++) {\n        // If character\
    \ is a bracket, increment bracket count\n        if(string[i] == '[') open_brackets++;\n\
    \        else if(string[i] == ']') open_brackets--;\n        // If bracket count\
    \ is zero, check if we have reached a matching bracket in \n        // the string\n\
    \        if(open_brackets == 0) {\n            if(string[i] == '[')\n        \
    \        open_brackets++;\n            else if(string[i] == ']')\n           \
    \     open_brackets--;\n            else\n                break;\n        }\n\
    \        // If we haven't reached a matching bracket, increment character count\n\
    \        else if(string[i] != ')') {\n            n++;\n            if(open_brackets\
    \ == 0) {\n                if(string[i] == '[') open_brackets++;\n           \
    \     else if(string[i] == ']') open_brackets--;\n            }\n        }\n \
    \   }\n    return open_brackets == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpeqb5ev_j: /tmp/tmpeqb5ev_j.cpp:43: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if (string.length() < 2) return true;\n    int counter = 0;\n    int\
    \ left_counts[2] = {0};\n    int right_counts[2] = {0};\n    int left_counter\
    \ = 0;\n    int right_counter = 0;\n    for (int i = 0; i < string.length(); i++)\
    \ {\n        if (string[i] == '[') {\n            if (string[i + 1] == '[') {\n\
    \                if (string[i + 2] == '[') {\n                    if (string[i\
    \ + 3] == '[') {\n                        if (string[i + 4] == '[') return true;\n\
    \                        else counter++;\n                    }\n            \
    \        else if (string[i + 4] == ']') counter++;\n                    else counter--;\n\
    \                }\n                else if (string[i + 2] == ']') counter--;\n\
    \                else if (string[i + 1] == ']') counter--;\n                else\
    \ counter--;\n            }\n            else if (string[i + 1] == '[') {\n  \
    \              if (string[i + 2] == '[') counter--;\n                else counter++;\n\
    \            }\n            else if (string[i + 1] == '[') {\n               \
    \ if (string[i + 2] == '[') counter++;\n                else counter--;\n    \
    \        }\n            else counter--;\n        }\n        else if (string[i]\
    \ == '[') left_counter++;\n        else if (string[i] == ']') right_counter++;\n\
    \        else if (string[i] == '[' && string[i + 1] == ']') left_counts[counter]++;\n\
    \        else if (string[i] == ']' && string[i + 1] == '[') right_counts[counter]++;\n\
    \        else if (string[i] == ']' && string[i + 1] == ']') left_counts[counter]--;\n\
    \        else if (string[i] == '[' && string[i + 1] == '[' && string[i + 2] ==\
    \ ']') right_counts[counter]--;\n        else if (string[i] == '[' && string[i\
    \ + 1] == '[' && string[i + 2] == '[' && string[i + 3] == ']') left_counts[counter]--;\n\
    \        else if (string[i] == '[' && string[i + 1] == '[' && string[i + 2] ==\
    \ '[' && string[i + 3] == '[' && string[i + 4 == ']']) right_counts[counter]--;\n\
    \        else counter--;\n    }\n    if (left_counter + right_counter == 0 &&\
    \ counter == 0) return true;\n    else return false;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpi5ex3d5l: /tmp/tmpi5ex3d5l.cpp:59: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> st;\n    for (char c: string) {\n        if (c == '[' ||\
    \ c == '{' || c == '(') {\n            st.push(c);\n        } else if (c == '}'\
    \ && st.empty()) {\n            return true;\n        } else if (c == ']' && st.empty())\
    \ {\n            return false;\n        } else {\n            bool isClosed =\
    \ false;\n            do {\n                isClosed = true;\n               \
    \ if (c == '}' && st.top() == '{') {\n                    st.pop();\n        \
    \            break;\n                } else if (c == ']' && st.top() == '[') {\n\
    \                    st.pop();\n                    break;\n                }\
    \ else if (c == ')' && st.top() == '(') {\n                    st.pop();\n   \
    \                 break;\n                } else if (c == '[' && st.top() == '[')\
    \ {\n                    st.pop();\n                    break;\n             \
    \   } else {\n                    st.pop();\n                }\n            }\
    \ while (!st.empty());\n            if (!isClosed) {\n                return false;\n\
    \            }\n        }\n    }\n    return st.empty();\n}\nint main() {\n  \
    \  auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp772ilnuo.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp772ilnuo.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> st;\n \
    \     |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp772ilnuo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp772ilnuo.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> st;\n      |           ^~~~\n\
    /tmp/tmp772ilnuo.cpp:16:13: error: \u2018st\u2019 was not declared in this scope;\
    \ did you mean \u2018std\u2019?\n   16 |             st.push(c);\n      |    \
    \         ^~\n      |             std\n/tmp/tmp772ilnuo.cpp:17:32: error: \u2018\
    st\u2019 was not declared in this scope; did you mean \u2018std\u2019?\n   17\
    \ |         } else if (c == '}' && st.empty()) {\n      |                    \
    \            ^~\n      |                                std\n/tmp/tmp772ilnuo.cpp:46:12:\
    \ error: \u2018st\u2019 was not declared in this scope; did you mean \u2018std\u2019\
    ?\n   46 |     return st.empty();\n      |            ^~\n      |            std\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // If string's length is less than 2, return true.\n    // Otherwise,\
    \ return false and print an error message.\n    if (string.size() < 2)\n     \
    \   return true;\n\n    // Create a stack of brackets.\n    std::string brackets;\n\
    \    brackets.push('[');\n    bool bracket = false;\n\n    // Iterate through\
    \ string and check whether it is correct or not.\n    for (char c : string.back())\
    \ {\n        // If we find an opening bracket, push it to the stack\n        //\
    \ and set bracket = true to mark the current character as opening bracket.\n \
    \       if (c == '[') {\n            brackets.push(c);\n            bracket =\
    \ true;\n        }\n        // If we find a closing bracket, pop the stack and\
    \ set the bracket to false.\n        else if (c == ']') {\n            if (!bracket)\
    \ {\n                std::cout << \"The input string contains mismatched closing\
    \ brackets.\" << std::endl;\n                return false;\n            }\n  \
    \          brackets.pop();\n            bracket = false;\n        }\n        //\
    \ If brackets are not balanced then return false.\n        else {\n          \
    \  std::cout << \"The input string contains mismatched brackets.\" << std::endl;\n\
    \            return false;\n        }\n    }\n    // If there is no mismatching\
    \ brackets, then return true.\n    return (brackets.size() == 0);\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2uhml_dh.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp2uhml_dh.cpp:20:14: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018push\u2019\
    \n   20 |     brackets.push('[');\n      |              ^~~~\n/tmp/tmp2uhml_dh.cpp:24:31:\
    \ error: \u2018begin\u2019 was not declared in this scope; did you mean \u2018\
    std::begin\u2019?\n   24 |     for (char c : string.back()) {\n      |       \
    \                        ^\n      |                               std::begin\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp2uhml_dh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:1224:5:\
    \ note: \u2018std::begin\u2019 declared here\n 1224 |     begin(const valarray<_Tp>&\
    \ __va)\n      |     ^~~~~\n/tmp/tmp2uhml_dh.cpp:24:31: error: \u2018end\u2019\
    \ was not declared in this scope; did you mean \u2018std::end\u2019?\n   24 |\
    \     for (char c : string.back()) {\n      |                               ^\n\
    \      |                               std::end\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp2uhml_dh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:1244:5:\
    \ note: \u2018std::end\u2019 declared here\n 1244 |     end(const valarray<_Tp>&\
    \ __va)\n      |     ^~~\n/tmp/tmp2uhml_dh.cpp:28:22: error: \u2018std::string\u2019\
    \ {aka \u2018class std::__cxx11::basic_string<char>\u2019} has no member named\
    \ \u2018push\u2019\n   28 |             brackets.push(c);\n      |           \
    \           ^~~~\n/tmp/tmp2uhml_dh.cpp:37:22: error: \u2018std::string\u2019 {aka\
    \ \u2018class std::__cxx11::basic_string<char>\u2019} has no member named \u2018\
    pop\u2019\n   37 |             brackets.pop();\n      |                      ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open = 0; int close = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        if (string[i] == '[') open++;\n        if (string[i] == ']')\
    \ close++;\n    }\n    return open != close;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpjrpr6li1: /tmp/tmpjrpr6li1.cpp:22: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open = 0;\n    int close = 0;\n    for (auto& c : string) {\n   \
    \     if (c == '[') open++;\n        if (c == ']') close++;\n    }\n    \n   \
    \ if (open == close) return true;\n    \n    return false;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpzuowjq5_: /tmp/tmpzuowjq5_.cpp:28: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> bracket_stack;\n    // TODO: Write your code in here!\n \
    \   bool result = false;\n    for (int i = 0; i < string.size(); i++) {\n    \
    \    if (string[i] == '[') {\n            bracket_stack.push('[');\n        }\
    \ else if (string[i] == ']') {\n            while (!bracket_stack.empty() && bracket_stack.top()\
    \ == '[') {\n                bracket_stack.pop();\n            }\n           \
    \ if (bracket_stack.empty()) {\n                result = true;\n            }\n\
    \        } else if (string[i] == ']' && bracket_stack.top() == '[') {\n      \
    \      bracket_stack.pop();\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptel87okm.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmptel87okm.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> bracket_stack;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmptel87okm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmptel87okm.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> bracket_stack;\n      |   \
    \        ^~~~\n/tmp/tmptel87okm.cpp:18:13: error: \u2018bracket_stack\u2019 was\
    \ not declared in this scope\n   18 |             bracket_stack.push('[');\n \
    \     |             ^~~~~~~~~~~~~\n/tmp/tmptel87okm.cpp:20:21: error: \u2018bracket_stack\u2019\
    \ was not declared in this scope\n   20 |             while (!bracket_stack.empty()\
    \ && bracket_stack.top() == '[') {\n      |                     ^~~~~~~~~~~~~\n\
    /tmp/tmptel87okm.cpp:23:17: error: \u2018bracket_stack\u2019 was not declared\
    \ in this scope\n   23 |             if (bracket_stack.empty()) {\n      |   \
    \              ^~~~~~~~~~~~~\n/tmp/tmptel87okm.cpp:26:40: error: \u2018bracket_stack\u2019\
    \ was not declared in this scope\n   26 |         } else if (string[i] == ']'\
    \ && bracket_stack.top() == '[') {\n      |                                  \
    \      ^~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = 0;\n    int i = 0;\n    while (i < string.size() && string[i]\
    \ == '[') i++;\n    while (i < string.size() && string[i] == ']') i++;\n    while\
    \ (i < string.size() && string[i] == '[') {\n        n++;\n        i++;\n    }\n\
    \    while (i < string.size() && string[i] == ']') {\n        n--;\n        i++;\n\
    \    }\n    if (n == 0) return false;\n    bool ans = (n == 1 && string[0] ==\
    \ '[' && string[string.size() - 1] == ']');\n    return ans;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpy5e9oqk3: /tmp/tmpy5e9oqk3.cpp:31: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for (int i = 0; i < string.length(); i++) {\n   \
    \     if (string[i] == '[' && string[i + 1] == '[' && string[i + 2] == '[') {\n\
    \            count++;\n            if (count == 3) {\n                return true;\n\
    \            }\n        }\n    }\n    return false;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpgfgbuobh: /tmp/tmpgfgbuobh.cpp:26: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open = 0;\n    int close = 0;\n    int len = string.length();\n \
    \   for (int i = 0; i < len; i++) {\n        if (string[i] == '[') {\n       \
    \     open++;\n        }\n        else if (string[i] == ']') {\n            close++;\n\
    \        }\n    }\n    return close >= open;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp2xsermcq: /tmp/tmp2xsermcq.cpp:29: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  int open = 0;\n  int close = 0;\n  bool flag = false;\n  for (int i = 0;\
    \ i < string.size(); ++i) {\n    if (string[i] == '[') {\n      open++;\n    }\n\
    \    else if (string[i] == ']') {\n      close++;\n    }\n    if (open > close)\
    \ {\n      flag = true;\n      break;\n    }\n  }\n  return flag;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpbk7_urpb: /tmp/tmpbk7_urpb.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  stack<char> brackets;\n  bool ret = true;\n\n  for (int i = 0; i < string.length();\
    \ i++) {\n    if (string[i] == '[') {\n      brackets.push('[');\n    }\n    else\
    \ if (string[i] == ']') {\n      if (brackets.top() == '[') {\n        brackets.pop();\n\
    \      }\n      else {\n        ret = false;\n      }\n    }\n  }\n\n  return\
    \ ret;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpre2ll6cr.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpre2ll6cr.cpp:13:3: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |   stack<char> brackets;\n\
    \      |   ^~~~~\n      |   std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpre2ll6cr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpre2ll6cr.cpp:13:9: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |   stack<char> brackets;\n      |         ^~~~\n\
    /tmp/tmpre2ll6cr.cpp:18:7: error: \u2018brackets\u2019 was not declared in this\
    \ scope\n   18 |       brackets.push('[');\n      |       ^~~~~~~~\n/tmp/tmpre2ll6cr.cpp:21:11:\
    \ error: \u2018brackets\u2019 was not declared in this scope\n   21 |       if\
    \ (brackets.top() == '[') {\n      |           ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    return is_nested(string);\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    vector<int> v(string.size());\n    int i = 0;\n    for (auto c : string)\n\
    \        if (c == '[')\n            v[i++] = -1;\n        else if (c == ']') {\n\
    \            if (v[i] == -1)\n                return false;\n            else\n\
    \                v[i]--;\n        }\n        else v[i++] = c - '0';\n    return\
    \ v[i] == -1;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpfpar6cqm.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpfpar6cqm.cpp:13:5: error: \u2018vector\u2019 was not declared in this\
    \ scope; did you mean \u2018std::vector\u2019?\n   13 |     vector<int> v(string.size());\n\
    \      |     ^~~~~~\n      |     std::vector\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpfpar6cqm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:386:11:\
    \ note: \u2018std::vector\u2019 declared here\n  386 |     class vector : protected\
    \ _Vector_base<_Tp, _Alloc>\n      |           ^~~~~~\n/tmp/tmpfpar6cqm.cpp:13:12:\
    \ error: expected primary-expression before \u2018int\u2019\n   13 |     vector<int>\
    \ v(string.size());\n      |            ^~~\n/tmp/tmpfpar6cqm.cpp:17:13: error:\
    \ \u2018v\u2019 was not declared in this scope\n   17 |             v[i++] = -1;\n\
    \      |             ^\n/tmp/tmpfpar6cqm.cpp:19:17: error: \u2018v\u2019 was not\
    \ declared in this scope\n   19 |             if (v[i] == -1)\n      |       \
    \          ^\n/tmp/tmpfpar6cqm.cpp:24:14: error: \u2018v\u2019 was not declared\
    \ in this scope\n   24 |         else v[i++] = c - '0';\n      |             \
    \ ^\n/tmp/tmpfpar6cqm.cpp:25:12: error: \u2018v\u2019 was not declared in this\
    \ scope\n   25 |     return v[i] == -1;\n      |            ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    if (string.empty())\n        return true;\n    int start = 0, end = 0,\
    \ step = 1;\n    while (start < string.length() && end < string.length()) {\n\
    \        if (string.at(start) == '[' && string.at(end) == ']') {\n           \
    \ ++start;\n            ++end;\n            ++step;\n        } else if (string.at(start)\
    \ == '[' && string.at(end) != ']') {\n            ++start;\n            ++end;\n\
    \        } else {\n            ++start;\n        }\n    }\n    return (start >=\
    \ string.length() && end >= string.length() && string.at(start) == string.at(end));\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpd3k2acs4: /tmp/tmpd3k2acs4.cpp:32: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Use a stack to keep track of how many brackets are \"inside\" brackets\n\
    \    stack<char> bracketsStack;\n    // Iterate over the string and keep track\
    \ of how many brackets are \"inside\" brackets\n    for (int i = 0; i < string.size();\
    \ i++) {\n        char c = string[i];\n        // If it's a bracket, push it onto\
    \ the stack\n        if (c == '[' || c == '(')\n            bracketsStack.push(c);\n\
    \        // If it's the same type of bracket, pop it off the stack\n        else\
    \ if (c == ']' || c == ')')\n            bracketsStack.pop();\n        // If the\
    \ stack becomes empty, string contains all nested brackets\n        if (bracketsStack.empty())\n\
    \            return true;\n    }\n    // If the stack contains anything then there\
    \ isn't a valid subsequence\n    return false;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpu46bdgs7.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpu46bdgs7.cpp:14:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   14 |     stack<char> bracketsStack;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpu46bdgs7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpu46bdgs7.cpp:14:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   14 |     stack<char> bracketsStack;\n      |   \
    \        ^~~~\n/tmp/tmpu46bdgs7.cpp:20:13: error: \u2018bracketsStack\u2019 was\
    \ not declared in this scope\n   20 |             bracketsStack.push(c);\n   \
    \   |             ^~~~~~~~~~~~~\n/tmp/tmpu46bdgs7.cpp:23:13: error: \u2018bracketsStack\u2019\
    \ was not declared in this scope\n   23 |             bracketsStack.pop();\n \
    \     |             ^~~~~~~~~~~~~\n/tmp/tmpu46bdgs7.cpp:25:13: error: \u2018bracketsStack\u2019\
    \ was not declared in this scope\n   25 |         if (bracketsStack.empty())\n\
    \      |             ^~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  // Your code here\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpq570ka3u: /tmp/tmpq570ka3u.cpp:17: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    // bool nested = false;\n    // for(int i =0;\
    \ i<string.length(); i++) {\n    //     if(string[i] == string[i+1]) {\n    //\
    \         continue;\n    //     }\n    //     else {\n    //         nested =\
    \ true;\n    //         break;\n    //     }\n    // }\n    // return nested;\n\
    \    bool nested = false;\n    for(int i =0; i<string.length(); i++) {\n     \
    \   if(string[i] == string[i+1]) {\n            nested = true;\n            continue;\n\
    \        }\n    }\n    return nested;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpf957yaco: /tmp/tmpf957yaco.cpp:37: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n  std::string parenthesis = \"()[]{}\";\n  // Find all open and close parenthesis\n\
    \  for (size_t i = 0; i < parenthesis.size(); ++i) {\n    for (size_t j = 0, len\
    \ = string.length(); j < len; ++j) {\n      if (string[j] == '[') j = parenthesis[i].length();\
    \ // Open bracket\n      if (string[j] == ']') j = parenthesis[i].length(); //\
    \ Close bracket\n      if (string[j] == parenthesis[i]) j = parenthesis[i].length();\
    \ // Nested brackets\n    }\n  }\n  assert(string.size() == string.find_last_not_of(parenthesis));\n\
    \  // Check if there are any nested brackets\n  return string.find_last_of(parenthesis)\
    \ != string.length() - 1;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp1sjf0ui1.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp1sjf0ui1.cpp:17:48: error: request for member \u2018length\u2019 in\
    \ \u2018parenthesis.std::__cxx11::basic_string<char>::operator[](i)\u2019, which\
    \ is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   17 |       if (string[j] == '[') j = parenthesis[i].length();\
    \ // Open bracket\n      |                                                ^~~~~~\n\
    /tmp/tmp1sjf0ui1.cpp:18:48: error: request for member \u2018length\u2019 in \u2018\
    parenthesis.std::__cxx11::basic_string<char>::operator[](i)\u2019, which is of\
    \ non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   18 |       if (string[j] == ']') j = parenthesis[i].length();\
    \ // Close bracket\n      |                                                ^~~~~~\n\
    /tmp/tmp1sjf0ui1.cpp:19:59: error: request for member \u2018length\u2019 in \u2018\
    parenthesis.std::__cxx11::basic_string<char>::operator[](i)\u2019, which is of\
    \ non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   19 |       if (string[j] == parenthesis[i]) j = parenthesis[i].length();\
    \ // Nested brackets\n      |                                                \
    \           ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n        \n        \n        int i = 1, j = 0;\n        while(j < string.length())\
    \ {\n                if(string[j] == '[') {\n                        i++;\n  \
    \                      j++;\n                } else if(string[j] == ']') {\n \
    \                       if(i != 0 && string[j-1] != '[') {\n                 \
    \               return false;\n                        } else {\n            \
    \                    i++;\n                                j++;\n            \
    \            }\n                } else if(string[j] == '}') {\n              \
    \          if(i != 0) {\n                                return false;\n     \
    \                   } else {\n                                i++;\n         \
    \                       j++;\n                        }\n                } else\
    \ {\n                        return false;\n                }\n        }\n   \
    \     return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp654pmhy4: /tmp/tmp654pmhy4.cpp:42: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int start = 0, end = 0, level = 1;\n    do {\n        start = end;\n\
    \        end = string.find('[', start);\n        if (end == -1) return false;\n\
    \        level = level + 1;\n    } while (end != -1);\n    do {\n        start\
    \ = end;\n        end = string.find(']', start);\n        if (end == -1) return\
    \ false;\n        level = level - 1;\n    } while (end != -1);\n    return level\
    \ == 1;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Complete this function\n    // Return True if and only if there is\
    \ a valid subsequence of brackets \n    // where at least one bracket in the subsequence\
    \ is nested.\n    int i, n = string.length();\n    for(i = 0; i < n; i++) {\n\
    \        char ch = string[i];\n        if(ch == '[') {\n            int j = i;\n\
    \            int open = 1;\n            while(j < n && string[j] != '['){\n  \
    \              if(string[j] == '[') {\n                    open++;\n         \
    \       } else if(string[j] == ']') {\n                    open--;\n         \
    \       }\n                j++;\n            }\n            if(open == 0 && string[i]\
    \ != ']') {\n                return false;\n            }\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpytxom1xt: /tmp/tmpytxom1xt.cpp:40: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int counter = 0;\n    for (char c: string) {\n        if (c == '[') counter++;\n\
    \        else if (c == ']') counter--;\n        if (counter == 0) return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp0pkdk72t: /tmp/tmp0pkdk72t.cpp:24: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    for (auto c : string) {\n        bool found\
    \ = true;\n        bool bracket = false;\n        for (auto i : {']', '}', '['})\
    \ {\n            if (c == i) {\n                bracket = true;\n            \
    \    break;\n            }\n        }\n        if (bracket == false) {\n     \
    \       found = false;\n            break;\n        }\n    }\n    return found;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpk7i_4j83: /tmp/tmpk7i_4j83.cpp:32: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
