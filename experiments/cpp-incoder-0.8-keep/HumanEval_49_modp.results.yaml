name: HumanEval_49_modp
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p != 0);\n  long q = (long) p / 2;\n\
    \  long r = p - q * 2;\n  long res = q * n + (r % p) * ((r - q * n % p) % p);\n\
    \  assert(res >= 0);\n  return res;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpbrwmtsvt: /tmp/tmpbrwmtsvt.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n >= p) {\n        return n;\n    }\n\
    \    long r = 1;\n    while ((n & 1) != 0) {\n        r = r * 2;\n        n >>=\
    \ 1;\n    }\n    return r % p;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpvd002985: /tmp/tmpvd002985.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = 0, t = n, m;\n  while (t > 0) {\n\
    \    m = (t + p) % p;\n    t -= m;\n    r = r*m + n;\n  }\n  return r;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return ((n+1)%p)*(p+1)/(n+1);\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpvp10p9ea: /tmp/tmpvp10p9ea.cpp:19: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong mod = 0;\n\tlong mask = -1;\n\twhile\
    \ (p != 0) {\n\t\tmod = (mod * n) + ((p & 1) ? p >> 1 : p);\n\t\tmask = mask *\
    \ p + ((mask & 1) ? p >> 1 : p);\n\t\tp = p >> 1;\n\t}\n\treturn ((mod * (mask\
    \ + mask + 1)) >> 1) - mask;\n}\nint main() {\n    auto candidate = modp;\n  \
    \  assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpx2nrfzur: /tmp/tmpx2nrfzur.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < p) {\n        return modp(n % p,\
    \ p) % p;\n    }\n    return n % p;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long x = n;\n    long mod = p;\n    while\
    \ (x != 0) {\n        if (x & 1) {\n            mod += mod;\n        }\n     \
    \   x = x / 2;\n    }\n    return mod;\n}\nint main() {\n    auto candidate =\
    \ modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmprchx3_8z: /tmp/tmprchx3_8z.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\t// If n is less than 0, return 0.\n\tif(n\
    \ < 0) {\n\t\treturn 0;\n\t}\n\t// If p is less than 0, return 0.\n\tif(p < 0)\
    \ {\n\t\treturn 0;\n\t}\n\t// Initialize MOD to 0.\n\tlong mod = 0;\n\t// Initialize\
    \ remainder to 1.\n\tlong remainder = 1;\n\t// Run loop until n is greater than\
    \ 0.\n\twhile(n != 0) {\n\t\t// Divide n by p.\n\t\tremainder = (n % p + remainder)\
    \ % p;\n\t\t// Subtract n from p.\n\t\tn = n / p;\n\t\t// Add 1 to mod.\n\t\t\
    mod = mod + (remainder == 0 ? 1 : 0);\n\t}\n\t// Return mod.\n\treturn mod;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpl7da_3mi: /tmp/tmpl7da_3mi.cpp:41: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // assert(n >= 0 && n <= p);\n  return pow(LONG_MAX,\
    \ n) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvfx1mlfl.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmpvfx1mlfl.cpp:16:27: error: invalid operands of types \u2018double\u2019\
    \ and \u2018long int\u2019 to binary \u2018operator%\u2019\n   16 |   return pow(LONG_MAX,\
    \ n) % p;\n      |          ~~~~~~~~~~~~~~~~ ^ ~\n      |             |      \
    \         |\n      |             double          long int\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(p > 0 && n >= 0);\n\tassert(p > 0 &&\
    \ p <= n);\n\tlong ret = n - (n%p);\n\tassert(0 <= ret && ret <= p);\n\treturn\
    \ ret;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpcr81bx4x: /tmp/tmpcr81bx4x.cpp:16: long int modp(long int, long int):\
    \ Assertion `p > 0 && p <= n' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n >= 0 && p > 0 && p < INT_MAX);\n\
    \  // Special case n==0.\n  if (n == 0) {\n    return 1;\n  }\n  // Special case\
    \ p==1.\n  if (p == 1) {\n    return n;\n  }\n  if (p == 0) {\n    return 1;\n\
    \  }\n  long result = 0;\n  // Special case p==0.\n  if (p == 0) {\n    return\
    \ 1;\n  }\n  // Divide by p until you have reduced down to 1 mod p.\n  while (n\
    \ > p) {\n    n /= p;\n    ++result;\n  }\n  // Multiply by 2^(result mod p) until\
    \ you have reduced down to n.\n  while (n > 1) {\n    result *= 2;\n    --n;\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpi22o5kz6: /tmp/tmpi22o5kz6.cpp:46: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (n) {\n       \
    \ n &= n - 1;\n        res *= p;\n    }\n    return res;\n}\nint main() {\n  \
    \  auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpzv18bcq5: /tmp/tmpzv18bcq5.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    // If n is divisible by p, then n is odd\
    \ and (p - 1) is even.\n    if (p & n) {\n        return (p - 1) & ~(p-1);\n \
    \   }\n    return n;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpcrvud35x: /tmp/tmpcrvud35x.cpp:23: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = n & -p;\n    while (n >> p)\n\
    \        n -= p;\n    return res + p;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpk6uv2mpa: /tmp/tmpk6uv2mpa.cpp:22: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (p < 0)\n\t\treturn 0;\n\tlong a = p %\
    \ n;\n\tlong b = n - p;\n\treturn (a * b + a) % n;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp14a10j20: /tmp/tmp14a10j20.cpp:23: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p != 0 && p < p);\n  long d = 1;\n\
    \  for (int i = 0; i < p; ++i) {\n    d = d * (n / p + 1);\n    n %= p;\n  }\n\
    \  return d;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpshqaojii: /tmp/tmpshqaojii.cpp:15: long int modp(long int, long int):\
    \ Assertion `p != 0 && p < p' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = n;\n  while (n > p) {\n    r = r\
    \ * p % 101;\n    n /= 101;\n  }\n  return r;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp62csuzfm: /tmp/tmp62csuzfm.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r=1, i;\n    for(i=1;i<=n;i++)\n  \
    \      r=(r*p)%p+r;\n    return r;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp_op9etfg: /tmp/tmp_op9etfg.cpp:22: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long res = 1;\n  while(n != 0) {\n    if(n&1)\n\
    \      res = (res*p + n&1) %p;\n    n = (n-1)/2;\n    p = (p*p + 2*n%p) %p;\n\
    \  }\n  return res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp19aakyyn: /tmp/tmp19aakyyn.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = n;\n    long m = 1;\n    long t;\n\
    \    // This should loop until it reaches zero, but we need\n    // to make sure\
    \ to stop before p reaches 2n-1 since the\n    // result would wrap back around\
    \ to 1\n    while (r >= p) {\n        t =  r - p;\n        r = (r - t) % p;\n\
    \        m = (m * t) % p;\n    }\n    return (m * p + r) % p;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpvfvhyrj1: /tmp/tmpvfvhyrj1.cpp:31: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    for (long i = 1; i <\
    \ p; ++i) {\n        res *= p;\n    }\n    return res % n;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpnu2m8lcv: /tmp/tmpnu2m8lcv.cpp:23: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long ans = 1;\n    long temp = n;\n    while(temp\
    \ != 0){\n        ans = temp%p;\n        temp /= p;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpifr625l_: /tmp/tmpifr625l_.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return n % p;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmphkcis7h5: /tmp/tmphkcis7h5.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    int d = n % p;\n    return d * d % p + p\
    \ - (d * d % p);\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpvunedgr0: /tmp/tmpvunedgr0.cpp:20: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long reminder = 0;\n    while (n > 0) {\n\
    \        reminder = (reminder * 10 + n % p) % p;\n        n /= p;\n    }\n   \
    \ return reminder == 0 ? 1 : reminder;\n}\nint main() {\n    auto candidate =\
    \ modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpbeqqncbg: /tmp/tmpbeqqncbg.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p == 0 || n >= p);\n  long q = p /\
    \ p;\n  return n % q == 0 ? q : (n / q) + 1;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpqom96quf: /tmp/tmpqom96quf.cpp:15: long int modp(long int, long int):\
    \ Assertion `p == 0 || n >= p' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return (p^(n+p))%p;\n}\nint main() {\n \
    \   auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpc3laatbu: /tmp/tmpc3laatbu.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tn = n % p;\n\tlong r = p % p - n;\n\twhile\
    \ (p >= r) r = (r + p) % p;\n\treturn r;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  return n % p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp83kjsnr_: /tmp/tmp83kjsnr_.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n <= p / 2)\n    return 2 * n;\n  return\
    \ (p * modp(n - p + 2, p) + p) % p;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpf5vn39l0: /tmp/tmpf5vn39l0.cpp:21: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\treturn (p-1L) % (n+1L);\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpy5o1npfs: /tmp/tmpy5o1npfs.cpp:19: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n   long a = n;\n   long t = p;\n   while( t\
    \ > 0 ) {\n      long d = (a % t);\n      a = t;\n      t = d;\n   }\n   return\
    \ a;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp7n51rfjl: /tmp/tmp7n51rfjl.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong q = p / n;\n\tlong r = p % n;\n\treturn\
    \ (q * q * q + r * r) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpjsz3_l4u: /tmp/tmpjsz3_l4u.cpp:21: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return ((n % p) + p) % p;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpeycqx4o6: /tmp/tmpeycqx4o6.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (p == 1) return 1;\n    if (n == p) return\
    \ 2;\n    if (n % p == 0) return modp(n/p, p) + 1;\n    return modp(n/p, p);\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= 0 && p >= 0);\n    if (n ==\
    \ 0) return 1;\n    // If n is odd, we have |n| / |p| >= 2^(n-1). Since 2^n-1\
    \ == p-1, we can safely subtract p-1 from n.\n    long r1 = (n-1) % (p-1);\n \
    \   long r2 = (r1 * (r1+1)) % (p-1);\n    return r2 - (r1 * r1) / p;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp_0qewo2m: /tmp/tmp_0qewo2m.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (p == 0) {\n        return 1;\n    }\n\
    \    if (n % p == 0) {\n        return modp(n / p, p);\n    }\n    return modp(n\
    \ / p + 1, p) + 1;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong res = 0;\n\twhile (n != 0) {\n\t\tres\
    \ = (res * 31 + n % p);\n\t\tn = n / p;\n\t}\n\treturn res;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp08kci1er: /tmp/tmp08kci1er.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(n>0 && p>0);\n\t\n\tlong res = 1;\n\
    \tlong x = 0;\n\tfor (; n>0; n--) {\n\t\tlong a = x%p;\n\t\tx /= p;\n\t\tres =\
    \ (res * a) % p;\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpphvnjx57: /tmp/tmpphvnjx57.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = 0, x = 0, y;\n    while ((y = n\
    \ / p) != 0) {\n        r = y * p;\n        r = ((x % p) + r) % p;\n        x\
    \ = x;\n        n = n;\n    }\n    return r;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmppi3qasok: /tmp/tmppi3qasok.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  long q = n - p;\n  long\
    \ r = q % p;\n  return q + ((p * r) + p) % p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpgbn5mzq5: /tmp/tmpgbn5mzq5.cpp:22: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = 1;\n    long m = 1;\n    long t\
    \ = (p - 1) % p;\n    long u = 1;\n    long w;\n\n    while (p > 1) {\n      \
    \  w = (n + m) % p;\n        r = r * u % p;\n        m = m + (r * u * t) % p;\n\
    \        u = u * t % p;\n        n = w;\n        t /= p;\n    }\n    return r;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (p < 1)\n        return (n % p);\n  \
    \  else if (p > 1)\n        return (n + (p / p) % p);\n    else\n        return\
    \ n;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp7t21mt13: /tmp/tmp7t21mt13.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n >= 0);\n  assert(p >= 0);\n  // if\
    \ (n == 0 || p == 0) return 1;\n  if (n == p) return 1;\n  if (n <= p) return\
    \ n & (p - 1);\n  int t = modp(n - (p << 1), p);\n  return p + (t < p);\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpe8cc9a1i: /tmp/tmpe8cc9a1i.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p != 0);\n  long m = p-1;\n  long t\
    \ = ((n%p) + m + 1) % p;\n  if (t != 0) return t;\n  while (m != 0) {\n    t =\
    \ ((n%m) + m + 1) % p;\n    if (t != 0) return t;\n    m--;\n  }\n  return n;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp7qwxjyog: /tmp/tmp7qwxjyog.cpp:29: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  return n % p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp6s_96dy9: /tmp/tmp6s_96dy9.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = n % (p - 1);\n    return (r < 0)\
    \ ? r + p : r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp20ho6t6p: /tmp/tmp20ho6t6p.cpp:21: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long result = 0;\n    while (n) {\n    \
    \    if (n % p) {\n            result += (n - 1) / p;\n        }\n        n /=\
    \ p;\n    }\n    return result;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpxx4kepyk: /tmp/tmpxx4kepyk.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long mod = pow(n, (p + 1) >> 1) - 1;\n \
    \   return (n % mod) / mod;\n}\nint main() {\n    auto candidate = modp;\n   \
    \ assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpsos8od0u: /tmp/tmpsos8od0u.cpp:20: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  long res = n >> 1;\n  while\
    \ (res && !(res & p)) res >>= 1;\n  return res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpxxfm7655: /tmp/tmpxxfm7655.cpp:22: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(!n)\n        return 1;\n    long r =\
    \ 1;\n    for(int i = 5; i; i--)\n        if((n&1) != (n&(p-2))) r += n>>(3-i)*i;\n\
    \    return r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp0es3opmx: /tmp/tmp0es3opmx.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1L;\n    while (n) {\n      \
    \  if ((n & 1L) == 0)\n            res = (res % p) + (p - 1L);\n        n >>=\
    \ 1L;\n    }\n    return (res % p);\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpx5qls5h2: /tmp/tmpx5qls5h2.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n >= p) \n\t\treturn n - p;\n\treturn\
    \ n % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpdm218znr: /tmp/tmpdm218znr.cpp:22: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return n%p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpp2o_ox51: /tmp/tmpp2o_ox51.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(n==0) return 0;\n    long ans = 1;\n\
    \    for(long i=1; i<=n; i++) {\n        if((i % p) == 0) ans *= 2;\n        ans\
    \ %= p;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpb564l8hg: /tmp/tmpb564l8hg.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    // Use a signed integer type so that\n \
    \   // the remainder wraps around as needed.\n    typedef long long ll;\n    ll\
    \ ans = 0;\n    while (n > p) ans <<= 1;\n    ans %= p;\n    return ans;\n}\n\
    int main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp8tu3qh6s: /tmp/tmp8tu3qh6s.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = 1;\n  long m = 0;\n  while (n !=\
    \ 0) {\n    if (n & 1)\n      r *= p;\n    m += 1;\n    n >>= 1;\n  }\n  return\
    \ r * powl(2.0, m);\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpp_m385ul: /tmp/tmpp_m385ul.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(n >= 0);\n\tassert(p >= 0);\n\treturn\
    \ (((1ll << p) * n) >> p) % p;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp3hh98gmc: /tmp/tmp3hh98gmc.cpp:22: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long ans = 0;\n    while (n != 0) {\n  \
    \      ans = ans * 2 + n % p;\n        n = n / p;\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmprdd4_98t: /tmp/tmprdd4_98t.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (p & 1)\n     \
    \   res = (res % p + n) % p;\n    return res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while(n != 0) {\n   \
    \     if (n%2 == 1)\n            res = (res * p)%p;\n        n = n/2;\n      \
    \  p = (p*p)%p;\n    }\n    return res;\n}\nint main() {\n    auto candidate =\
    \ modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return n - (n % p);\n}\nint main() {\n \
    \   auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpj92vgimz: /tmp/tmpj92vgimz.cpp:19: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n%p==0)\n    return n;\n  int rem = n%(p-1);\n\
    \  long ret = (rem*(p-1))+(p-1);\n  return ret;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp1fsoohcu: /tmp/tmp1fsoohcu.cpp:23: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return p - (((p * n) % p) + p) % p;\n}\n\
    int main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpetw6uzd0: /tmp/tmpetw6uzd0.cpp:19: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long ret = 1;\n    while (n>0) {\n     \
    \   if (n%p != 0) {\n            ret *= p; // x^p\n        }\n        n /= p;\
    \ // n/x\n        p /= 2; // p/2\n    }\n    return ret;\n}\nint main() {\n  \
    \  auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmppdqzgl7a: /tmp/tmppdqzgl7a.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (p != 1) {\n        return ((n & -p)\
    \ ^ (p & -n)) % p;\n    }\n    return n & -p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp2ret2rqv: /tmp/tmp2ret2rqv.cpp:22: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < p) {\n        return 1;\n    }\n\
    \    long res = n;\n    for(long i = 2; i < p; i++) {\n        res = (res * res)\
    \ % p;\n    }\n    return res;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmphms9c_wh: /tmp/tmphms9c_wh.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p != 0);\n  if (n < 0) {\n    n = (-n);\n\
    \    p = -p;\n  }\n  long result = n;\n  while (n != 0) {\n    if (n % p == 0)\
    \ {\n      result *= p;\n      result %= p;\n    }\n    n /= p;\n  }\n  return\
    \ result;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp0t2n_cl2: /tmp/tmp0t2n_cl2.cpp:33: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (p == 0)\n        return n;\n    if (n\
    \ % p == 0)\n        return n;\n    return (n + (p / p) % p);\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp0q0uc5ud: /tmp/tmp0q0uc5ud.cpp:23: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // Compute 2^n modulo p using exponentiation\
    \ by squaring.\n  long ret = 1;\n  for (int i = 0; i < n; i++) {\n    ret *= p;\n\
    \    ret %= p;\n  }\n  return ret;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpnneqr6rr: /tmp/tmpnneqr6rr.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (p == 0)\n\t\treturn 0;\n\tif (p < 0)\n\
    \t\treturn modp(n, -p);\n\tif (n == 0)\n\t\treturn p;\n\tif (p % 2 == 0)\n\t\t\
    return n * modp(n / 2, p);\n\telse\n\t\treturn ((n - 1) * modp(n, p - 1)) + 1;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpvps9i_yw: /tmp/tmpvps9i_yw.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = 1;\n    while (n) {\n        long\
    \ m = n % p;\n        n = (n - m) % p;\n        r = (r * m % p + r) % p;\n   \
    \ }\n    return r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp0k6ampdo: /tmp/tmp0k6ampdo.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n >= p);\n    if (n == 0)\n     \
    \   return 1;\n    // If n is smaller than p, then n^(p-1) is the same as n.\n\
    \    if (n < p)\n        return n;\n    return n % p;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpl61_kgwb: /tmp/tmpl61_kgwb.cpp:15: long int modp(long int, long int):\
    \ Assertion `n >= p' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n >= p) {\n\t\tlong r = n % p;\n\t\tlong\
    \ m = p % n;\n\t\tif (m == 0)\n\t\t\treturn r;\n\t\telse\n\t\t\treturn (r + (m\
    \ + (n % p)));\n\t} else\n\t\treturn (n);\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpjklvd712: /tmp/tmpjklvd712.cpp:28: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long ans = 1;\n  while (n) {\n    if (n %\
    \ p == 0)\n      ans = (ans * (n - p)) / p;\n    p = p / p;\n    n = n / p;\n\
    \  }\n  return ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return (((n & (p-1))) ? ((n+1) & -p) : (n\
    \ & -p));\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpavl22fz6: /tmp/tmpavl22fz6.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return (n % p + p) % p;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpt0lzhq7d: /tmp/tmpt0lzhq7d.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (p == 0 || n == 0)\n        return 0;\n\
    \    if (n >= p)\n        return 1;\n    if (n == p)\n        return n;\n    if\
    \ (n < p)\n        return modp(n - p, p) + p;\n    // Not possible.\n    long\
    \ r = modp(n - p, p);\n    return (r * r + n) % p;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return (n + p + 1) % (p + 1);\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp3xxmcaw_: /tmp/tmp3xxmcaw_.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(p < 2)\n        return 1;\n    long m\
    \ = (long) n%p;\n    return m==0?1:m;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp8qdjvm4d: /tmp/tmp8qdjvm4d.cpp:23: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long ret = 1;\n    while (n) {\n       \
    \ if (n % p) {\n            ret *= p;\n            ret %= p;\n        }\n    \
    \    n /= p;\n    }\n    return ret;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpm490i5lb: /tmp/tmpm490i5lb.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // Use modular exponentiation as it is very\
    \ fast.\n  // http://www.hackersdelight.org/magic.htm\n  long res = 1;\n  while\
    \ (p > 1) {\n    if (n % p) {\n      res = (res*p) % p;\n    }\n    p /= 2;\n\
    \  }\n  return res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp95rgn_ya: /tmp/tmp95rgn_ya.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long n1 = n % p;\n    long n2 = ((n1 - 1)\
    \ // p) + (n % p);\n    long n3 = (n2 % p) + p;\n    return (n3 // p);\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpanjdwvgx.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmpanjdwvgx.cpp:16:24: error: expected \u2018)\u2019 before \u2018long\u2019\
    \n   16 |     long n2 = ((n1 - 1) // p) + (n % p);\n      |               ~  \
    \      ^\n      |                        )\n   17 |     long n3 = (n2 % p) + p;\n\
    \      |     ~~~~                \n/tmp/tmpanjdwvgx.cpp:18:13: error: \u2018n3\u2019\
    \ was not declared in this scope; did you mean \u2018n2\u2019?\n   18 |     return\
    \ (n3 // p);\n      |             ^~\n      |             n2\n/tmp/tmpanjdwvgx.cpp:18:15:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   18 |     return\
    \ (n3 // p);\n      |            ~  ^\n      |               )\n   19 | }\n  \
    \    | ~              \n/tmp/tmpanjdwvgx.cpp:18:15: error: expected \u2018;\u2019\
    \ before \u2018}\u2019 token\n   18 |     return (n3 // p);\n      |         \
    \      ^\n      |               ;\n   19 | }\n      | ~              \n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (p % 2 == 0) {\n        return (n + 1)\
    \ % (p - 1);\n    } else {\n        return (n + p + 1) % (p - 1);\n    }\n}\n\
    int main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpgwf31h2d: /tmp/tmpgwf31h2d.cpp:23: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(n == 1) return 1;\n    if(n == 2) return\
    \ p;\n    if(n%3 == 0) return modp(modp(n/3, p), p);\n    return (p*modp(n/3,\
    \ p)) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpw787184m: /tmp/tmpw787184m.cpp:22: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    int c = 0;\n    while (p) {\n        if\
    \ ((p & 1) && n) {\n            c = (c + n) % p;\n        }\n        n >>= 1;\n\
    \        p >>= 1;\n    }\n    return c;\n}\nint main() {\n    auto candidate =\
    \ modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp5hoqvhug: /tmp/tmp5hoqvhug.cpp:28: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = 0, div = 0, mod = 0, t = 0, q;\n\
    \    q = n / p;\n    mod = n % p;\n    div = q;\n    while (q > 0) {\n       \
    \ r = r + div;\n        div = div / p;\n        mod = mod % p;\n        q = q\
    \ - 1;\n        t = t + mod;\n    }\n    return r % p;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp_434m_5c: /tmp/tmp_434m_5c.cpp:30: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if(n == 0) {\n    return 1;\n  }\n  \n  int\
    \ res = 1;\n  \n  long modp = p % n;\n  \n  while(modp != 0) {\n    res *= n;\n\
    \    res %= modp;\n    \n    modp /= n;\n  }\n  \n  return res;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp05rhfyhb: /tmp/tmp05rhfyhb.cpp:34: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p != 0);\n  n %= p;\n  long r = n -\
    \ p * ((n / p) % p);\n  return r;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpsu17rqar: /tmp/tmpsu17rqar.cpp:23: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long mod = 1;\n  while(n != 0) {\n    if (n\
    \ % p == 0) {\n      mod = 2 * mod;\n      n = (n / p) - 1;\n    } else {\n  \
    \    mod = (mod * p) + 1;\n    }\n  }\n  return mod;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long ans = 1;\n    while (n > p) {\n   \
    \     ans = (ans * (n % p) + p) % p;\n        n /= p;\n    }\n    return ans %\
    \ p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpve00fkep: /tmp/tmpve00fkep.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n >= p)\n        return 1;\n    int\
    \ r = n % p;\n    return ((n * p + r - 1) / (p + 1)) % p;\n}\nint main() {\n \
    \   auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpr40xql1n: /tmp/tmpr40xql1n.cpp:22: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return (n + p-1) & -p;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp63ym70_5: /tmp/tmp63ym70_5.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return (n%p) + p;\n}\nint main() {\n   \
    \ auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpyv90bhpn: /tmp/tmpyv90bhpn.cpp:19: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return (n + p + 1) % p;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpiv0f691n: /tmp/tmpiv0f691n.cpp:19: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return n%p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpi65m3odu: /tmp/tmpi65m3odu.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (p < 0) return n;\n    if (p > n) return\
    \ 0;\n    if (p == 0) return 1;\n    if (p == 1) return n;\n    long d = p / 2;\n\
    \    long r = n % d;\n    if (r == 0) return modp(n / d, p);\n    return modp(n\
    \ / d, p) * p + r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp5ip__3rx: /tmp/tmp5ip__3rx.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long mod = p; // Use 'mod' since 'p' may\
    \ be negative.\n    long result = 1;\n    while (n != 0) {\n        if (n % 2\
    \ == 1) {\n            result *= mod;\n            mod *= p;\n        }\n    \
    \    n /= 2;\n        mod /= p;\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp6lg_kj8k: /tmp/tmp6lg_kj8k.cpp:29: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return ((n % p) + p) % p;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpt41h1_81: /tmp/tmpt41h1_81.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long ans = 1;\n    long p = p%n;\n    for(int\
    \ i=1; i<p; i++) {\n        ans = ans*2;\n    }\n    return ans % n;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpky_sv16q.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmpky_sv16q.cpp:16:10: error: declaration of \u2018long int p\u2019 shadows\
    \ a parameter\n   16 |     long p = p%n;\n      |          ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n >= 0);\n  assert(p >= 0);\n  long\
    \ c = 1;\n  long r = n;\n  while (r != 0) {\n    long t = r / p;\n    long u =\
    \ r - t * p;\n    r = t;\n    if (r > 0) {\n      c = c + u;\n    }\n  }\n  return\
    \ c;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpxlu9dd15: /tmp/tmpxlu9dd15.cpp:31: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1L;\n    while (res < p) {\n\
    \        res = (res*2L) % p;\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\t// Assert n is positive.\n\tassert(n > 0);\n\
    \t// If n is 1, return p.\n\tif (n == 1)\n\t\treturn p;\n\t// Find largest factor\
    \ <= p.\n\tlong m = p - 1;\n\twhile (m >= 2) {\n\t\tif (n % m == 0)\n\t\t\tbreak;\n\
    \t\tm /= 2;\n\t}\n\t// Compute n / m and reduce by one.\n\tlong r = n / m;\n\t\
    return (r * m) + 1;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpg8zhmrtv: /tmp/tmpg8zhmrtv.cpp:33: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n > p);\n  long r = p - 1;\n  for (;\
    \ n >= r; --r) {\n    r = r * p + (n % r);\n  }\n  return r;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp0e8gs7mt: /tmp/tmp0e8gs7mt.cpp:15: long int modp(long int, long int):\
    \ Assertion `n > p' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  assert(n >= 0);\n  long\
    \ r = 1;\n  for (long i = 0; i < p; i++) {\n    r = (r * n) % p;\n  }\n  return\
    \ r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpyv_825lz: /tmp/tmpyv_825lz.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p != 1);\n  long result = 0;\n  while\
    \ (n) {\n    if (n & 1) {\n      result = result * p + (n % p); // result is odd,\
    \ n is even\n    }\n    n /= p;\n    p /= 2;\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpxp9fkz5i: /tmp/tmpxp9fkz5i.cpp:29: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long a = n >> 35; // a is power of two with\
    \ at most 35 trailing zeros.\n    if (a == 0) {\n        return 1;\n    }\n  \
    \  long b = 31; // b is power of two with at most 31 trailing zeros.\n    if (p\
    \ == 0) {\n        return 0;\n    }\n    long c = p >> 30; // c is power of two\
    \ with at most 30 trailing zeros.\n    if (c == 0) {\n        return 1;\n    }\n\
    \    long d = p >> 29; // d is power of two with at most 29 trailing zeros.\n\
    \    if (d == 0) {\n        return 1;\n    }\n    long r = p >> 28; // r is power\
    \ of two with at most 28 trailing zeros.\n    if (r == 0) {\n        return 1;\n\
    \    }\n    // We are interested in finding r\n    // so r^2 + a^2 = n, with n\
    \ odd and a^2 odd\n    // So we start with a^2 > r^2 > 1\n    long s = 1;\n  \
    \  while ((s << 1) <= n) {\n        s <<= 1;\n    }\n    if (s == n) {\n     \
    \   // We are looking for r\n        // So r^2 + a^2 = n, with n odd and a^2 odd\n\
    \        // r^2 = s^2 - 2*s + 1, s = 2**(r-1)\n        // r^2 = 2*s*(1 + s^2)\
    \ (mod p)\n        // r^2 = (2*s*s + s^2)(mod p)\n        // s = 2**(r-1) * 2^(r-1)\n\
    \        // s = s*(1 + s^2)\n        // s = 2*s*(2*s+1)\n        // s = 2*(2*s+1)\n\
    \        // s = (2*s+1)*(2*s+1)\n        // s = (2*s+1)*(2*s+1)\n        // s\
    \ = 2*(3*s+1)*(2*s+1)\n        // s = 2*(4*s+1)*(2*s+1)\n        // s = (2*s+2)*(2*s+1)\n\
    \        // s = 2*((3*s+2)*(2*s+1)\n        // s = (3*s+3)*(2*s+1)\n        //\
    \ s = (3*s+3)*(2*s+1)\n        // s = (3*s+3)*(2*s+1)\n        // s = 2*((5*s+3)*(2*s+1)\n\
    \        // s = (5*s+5)*(2*s+1)\n        // s = (5*s+5)*(2*s+1)\n        // s\
    \ = (5*s+5)*(2*s+1)\n        // s = (5*s+5)*(2*s+1)\n        // s = (5*s+5)*(2*s+1)\n\
    \        // s = (5*s+5)*(2*s+1)\n        // s = (5*s+5)*(2*s+1)\n        // s\
    \ = (5*s+5)*(2*s+1)\n        // s = (5*s+5)*(2*s+1)\n        // s = (5*s+5)*(2*\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu1c1q0k2.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmpu1c1q0k2.cpp:73:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   73 | int main() {\n      |            ^\n/tmp/tmpu1c1q0k2.cpp:82:1:\
    \ error: expected \u2018}\u2019 at end of input\n   82 | }\n      | ^\n/tmp/tmpu1c1q0k2.cpp:14:27:\
    \ note: to match this \u2018{\u2019\n   14 | long modp(long n, long p) {\n   \
    \   |                           ^\n/tmp/tmpu1c1q0k2.cpp:82:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   82 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return (n % p + p) % p;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp08ym9td_: /tmp/tmp08ym9td_.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p != 0 && p == p);\n  long res = 0;\n\
    \  while(n) {\n    if (n & 1)\n      res = (res * p) + 1;\n    n >>= 1;\n    p\
    \ <<= 1;\n  }\n  return res;\n}\nint main() {\n    auto candidate = modp;\n  \
    \  assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp6k9wjogh: /tmp/tmp6k9wjogh.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p != 1);\n  long res = 1;\n  while\
    \ (n >= p) {\n    res *= p;\n    n -= p;\n  }\n  while (n > 1) {\n    res *= n;\n\
    \    n -= 1;\n  }\n  return res;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpk6tuybht: /tmp/tmpk6tuybht.cpp:29: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(p >= 0);\n\tassert(p < 10);\n\tlong\
    \ q = 0;\n\twhile (n > 0) {\n\t\tlong t = n & -p;\n\t\tn = n;\n\t\tq ^= t;\n\t\
    }\n\treturn q;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = n;\n    while (r != 0) {\n    \
    \    r = r % p;\n    }\n    return r;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(n >= p) {\n        return n;\n    }\n\
    \    long a = n % p;\n    long rem = p % a;\n    if(rem == 0) {\n        return\
    \ n;\n    }\n    if(rem < 0) {\n        return n - p + 1;\n    }\n    return n\
    \ - p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpso5frxo4: /tmp/tmpso5frxo4.cpp:30: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 0;\n  if (p == 0) return\
    \ 1;\n  long r = n & -p;\n  long t = modp(n ^ r, p);\n  return (r ^ t) ^ p;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp_568f972: /tmp/tmp_568f972.cpp:23: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = n % p;\n  return (r < 0) ? r + p\
    \ : r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpgsossf_m: /tmp/tmpgsossf_m.cpp:21: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    // Return 2^n modulo p.\n    long r = 1;\n\
    \    for (long i = n, d = 1; 1; ) {\n        long t = r * n - d;\n        if (t\
    \ > p) {\n            r = n - d;\n        }\n        else if (t < -p) {\n    \
    \        d = r * n;\n        }\n        else {\n            break;\n        }\n\
    \    }\n    return r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpvo0vgbfs: /tmp/tmpvo0vgbfs.cpp:33: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = n;\n    long q = 1;\n    while\
    \ (r > p) {\n        r = r - p;\n        q = q * 2;\n    }\n    return (r == 0\
    \ && q == 1) ? p : q;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpn84_ym1w: /tmp/tmpn84_ym1w.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0 || p == 0)\n\t\treturn 0;\n\tlong\
    \ x = 1;\n\twhile (p--) {\n\t\tx = x * n % p;\n\t\tn = (n / p);\n\t}\n\treturn\
    \ x;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = 1;\n    while (n > 0) {\n     \
    \   if (n % p == 0) {\n            n = n / p;\n            r *= p;\n        }\
    \ else {\n            n = n / p;\n            r *= p % p;\n        }\n    }\n\
    \    return r;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpgy_z1_vq: /tmp/tmpgy_z1_vq.cpp:29: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    int i = 2;\n    while (i <= p) {\n     \
    \   if (n % i == 0) {\n            return n / i;\n        }\n        ++i;\n  \
    \  }\n    return n;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpti8rdccm: /tmp/tmpti8rdccm.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0 || n == p)\n        return n;\n\
    \    if (p % 2 == 1)\n        return n - (n / p) * p;\n    return n - ((n / p)\
    \ % 2) * p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp0aj1yles: /tmp/tmp0aj1yles.cpp:24: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n % p == 0 || p % n == 0);\n  if (p\
    \ > n) std::swap(n, p);\n  long r = 1;\n  while (n) r = ((n % p) != 0) ? ((r *\
    \ n) % p) : (r * n % p), (n *= 2);\n  return r;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpmu0dgaks: /tmp/tmpmu0dgaks.cpp:15: long int modp(long int, long int):\
    \ Assertion `n % p == 0 || p % n == 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n >= 0 && p > 0);\n  long t = p + (n\
    \ / p) % p;\n  return t;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmps__71akc: /tmp/tmps__71akc.cpp:21: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif(n == 0) return 1;\n\tif(n == p) return\
    \ n;\n\tif(n%p == 0) return modp(n/p, p);\n\treturn modp(n/p, p) + p%p;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp3leddh10: /tmp/tmp3leddh10.cpp:22: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n >= 0 && n % p == 0);\n  if (n ==\
    \ 0) return 1;\n  if (n == p) return 2;\n  if (n % p == 0) return modp(n / p,\
    \ p);\n  return modp(n / p, p) + 1;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpktg1wfn0: /tmp/tmpktg1wfn0.cpp:15: long int modp(long int, long int):\
    \ Assertion `n >= 0 && n % p == 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1LL;\n    while (p) {\n     \
    \   if (n % p == 0) {\n            res++;\n            n /= p;\n        }\n  \
    \      else {\n            res %= p;\n            p /= p;\n        }\n    }\n\
    \    return n;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n > 0);\n  long r = n & -p;\n  n =\
    \ n >> p;\n  long k = 1;\n  while (n) {\n    if (n & 1) r += k;\n    k *= 10;\n\
    \    n >>= 1;\n  }\n  return r % p;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpfwmw194x: /tmp/tmpfwmw194x.cpp:29: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong ans = 1L;\n\twhile (p != 0) {\n\t\tans\
    \ = (ans * n) % p;\n\t\tp--;\n\t}\n\treturn ans;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpoy4c2pqg: /tmp/tmpoy4c2pqg.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (p == 0)\n    return 1;\n  long q = (p\
    \ - 1) / p;\n  return (n * q + p) % p;\n}\nint main() {\n    auto candidate =\
    \ modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpbpnp6uh3: /tmp/tmpbpnp6uh3.cpp:22: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    // https://stackoverflow.com/questions/11203057/modular-exponentiation-modpow-for-64-bit\n\
    \    long ret = 1;\n    long m = 3;\n    while(n){\n        // n & 1\n       \
    \ if(n&1){\n            ret *= m;\n        }\n        // n /= 2\n        n = n/2;\n\
    \        m *= m;\n    }\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpb3rglvqx: /tmp/tmpb3rglvqx.cpp:31: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  long ans = 1;\n  while (n\
    \ >= p) {\n    ans = (ans * p + n) % p;\n    n /= p;\n  }\n  return ans;\n}\n\
    int main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpyzjqc6cg: /tmp/tmpyzjqc6cg.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return (1 << (n & 0x1f)) - 1 + p;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpol1kxh02: /tmp/tmpol1kxh02.cpp:19: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n >= 0 && p >= 0);\n  long ret = 0;\n\
    \  while (n > 1) {\n    if (n & 1) {\n      ret = 2 * ret + p;\n      p = p -\
    \ 1;\n    }\n    n = n / 2;\n  }\n  return ret + p;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpj_1h0teh: /tmp/tmpj_1h0teh.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(p==0){\n        return 1;\n    }\n  \
    \  long res = 1;\n    while(n>0){\n        res *= p;\n        res += (n&p)!=p?\
    \ 1 : 0;\n        n /= p;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp7uw9okgk: /tmp/tmp7uw9okgk.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(p > 0);\n\tlong q = n % p;\n\tlong\
    \ r = p - (q * p);\n\treturn q + (r * q);\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp76dg6i_p: /tmp/tmp76dg6i_p.cpp:22: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (p < 2)\n    return 1;\n  if (n >= p)\n\
    \    return modp(n, p / 2);\n  long res = 1L;\n  while (n > p) {\n    long next_res\
    \ = modp(n, p);\n    if (res + next_res > p)\n      return res;\n    res = next_res;\n\
    \    n--;\n  }\n  return res;\n}\nint main() {\n    auto candidate = modp;\n \
    \   assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpwlqyd0b9: /tmp/tmpwlqyd0b9.cpp:31: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    while ((n & 1) == 0)\n        n >>= 1;\n\
    \    for (long k = p; n != 1; n >>= 1)\n        if (n & 1)\n            k %= p;\n\
    \        else\n            k %= p;\n    return k;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpd8m_zefx.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmpd8m_zefx.cpp:22:12: error: \u2018k\u2019 was not declared in this scope\n\
    \   22 |     return k;\n      |            ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long sum = 0;\n    long t = 1;\n    while\
    \ (true) {\n        if (n & 1) sum += t;\n        n >>= 1;\n        if (n == 0)\
    \ {\n            return sum;\n        }\n        t *= p;\n    }\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp7upbkddw: /tmp/tmp7upbkddw.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long q = n / p;\n    long r = n % p;\n \
    \   return (r + p * q + (q << 1) + q * (p << 1)) % p;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpngi6gato: /tmp/tmpngi6gato.cpp:22: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n % p)\n        return 0;\n    else\n\
    \        return n / p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpbgq8o7su: /tmp/tmpbgq8o7su.cpp:22: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong r = 1;\n\tlong m = 0;\n\twhile (m <=\
    \ p) {\n\t\tm = (r * n) % p;\n\t\tr = (r * n) % p;\n\t}\n\treturn r;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    // The last digit of the power of p, plus\
    \ 1.\n    long ret = p - 1;\n    // The remainder of the division of n by p, plus\
    \ 1.\n    while (n > 0)\n    {\n        ret = ret % p + 1;\n        n /= p;\n\
    \    }\n    return ret;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpe4u3zbti: /tmp/tmpe4u3zbti.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    \n    for (int i = 0;\
    \ i < p; i++) {\n        res = (res * n) % p;\n    }\n\n    return res;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpkfeorpq2: /tmp/tmpkfeorpq2.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(!p)\n        return 0;\n    long r =\
    \ n;\n    while(r % p)\n        r = r * p % p;\n    return r / p;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp9cdvo5d9: /tmp/tmp9cdvo5d9.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return ((n & -p) | ((n & p) ^ ~n)) % p;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpl7_xa_av: /tmp/tmpl7_xa_av.cpp:19: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  // assert(p < n);\n  // if (n == 0)\n  //\
    \   return 1;\n  // if (n == p)\n  //   return 1;\n  // return modp(n - p, p)\
    \ + modp(n - p, p);\n  if (n == 0)\n    return 1;\n  if (n == p)\n    return 1;\n\
    \  return modp(n - p, p) + modp(n - p, p);\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return ((n - 1) * (p + 1) + (p + 1)) % p;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpi43tg156: /tmp/tmpi43tg156.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = n;\n    \n    while (res >= p)\
    \ res = (res%p) + p;\n    return res + 1;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpjl4n36sf: /tmp/tmpjl4n36sf.cpp:22: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long\
    \ res = modp(n/p, p);\n    return ((n % p) < res)? res: (n % p);\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpzw_q36nr: /tmp/tmpzw_q36nr.cpp:23: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(n > 0 && p > 0);\n    int res = 1;\n\
    \    for (int i = 2; i <= p; i <<= 1) {\n        if (n & i)\n            res =\
    \ (n - res + p) % p;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpv1erm7zv: /tmp/tmpv1erm7zv.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long ans = 1;\n  while (n > p) {\n    ans\
    \ *= n;\n    n -= p;\n  }\n  return ans;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpymbnl75a: /tmp/tmpymbnl75a.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return n % p;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpumq4j0lw: /tmp/tmpumq4j0lw.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong ans = n;\n\tfor (long i = 2; i <= p;\
    \ i <<= 1) {\n\t\tif (n % i == 0) {\n\t\t\tans += i;\n\t\t\tn /= i;\n\t\t}\n\t\
    }\n\treturn ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpi24qteld: /tmp/tmpi24qteld.cpp:27: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    assert(p%2 == 0);\n    long res = (n % p)\
    \ / p;\n    if(res == 0) res = p;\n    return res;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpepc5rl2z: /tmp/tmpepc5rl2z.cpp:15: long int modp(long int, long int):\
    \ Assertion `p%2 == 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tassert(p != 0);\n\tif (n == 0)\n\t\treturn\
    \ 0;\n\tif (n == p || n == (p-1) )\n\t\treturn n;\n\tlong rem = n % p;\n\tif (rem\
    \ == 0)\n\t\treturn n;\n\treturn (p-rem) + n;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp6kwagpsf: /tmp/tmp6kwagpsf.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long q = p / 2;\n  long r = p - q * 2;\n \
    \ r = q * (p - r + q);\n  r = q * (p - r + q);\n  r = q * (p - r + q);\n  return\
    \ ((n - (n >> 1)) + q) + r;\n}\nint main() {\n    auto candidate = modp;\n   \
    \ assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101)) ==\
    \ (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp4td3fx2j: /tmp/tmp4td3fx2j.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p > 0);\n  long q = n / p;\n  long\
    \ r = n % p;\n  long result = 1;\n  while (result <= q) {\n    result *= p;\n\
    \  }\n  if (r == 0) {\n    return 1;\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp1sv5zbs5: /tmp/tmp1sv5zbs5.cpp:29: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tlong a = 1;\n\tlong b = 1;\n\tlong c = 1;\n\
    \tlong n2 = n;\n\tlong p2 = p;\n\t\n\twhile (true) {\n\t\tlong a3 = a;\n\t\tlong\
    \ b3 = b;\n\t\t\n\t\tlong tmp = n2 / p2;\n\t\tlong q = tmp;\n\t\tlong r = n2 -\
    \ tmp * p2;\n\t\t\n\t\tif (r == 0) {\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tif (q\
    \ == 1) {\n\t\t\tlong u = (long)b;\n\t\t\tlong v = (long)b;\n\t\t\t\n\t\t\tif\
    \ (c < p) {\n\t\t\t\tb = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc *= 2;\n\t\t\t\t\
    b = (long)b;\n\t\t\t}\n\t\t\t\n\t\t\ta = a3 * u + v * c;\n\t\t\tn2 = tmp;\n\t\t\
    }\n\t\telse {\n\t\t\tlong v = (long)b3;\n\t\t\tlong u = (long)b3;\n\t\t\t\n\t\t\
    \tif (c < p2) {\n\t\t\t\tb3 = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc *= 2;\n\t\t\
    \t\tb1 = (long)b3;\n\t\t\t}\n\t\t\t\n\t\t\tb = b1 * u + v * c;\n\t\t\tn2 = q;\n\
    \t\t}\n\t}\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph92iw8lf.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmph92iw8lf.cpp:57:5: error: \u2018b1\u2019 was not declared in this scope;\
    \ did you mean \u2018b3\u2019?\n   57 |     b1 = (long)b3;\n      |     ^~\n \
    \     |     b3\n/tmp/tmph92iw8lf.cpp:60:8: error: \u2018b1\u2019 was not declared\
    \ in this scope; did you mean \u2018b3\u2019?\n   60 |    b = b1 * u + v * c;\n\
    \      |        ^~\n      |        b3\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long rem = n;\n  while (rem != 0) {\n    rem\
    \ = (rem % p) + (rem / p);\n  }\n  return rem;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  return ((n & (p-1)) == 0) ? n+1 : modp(n >>\
    \ 1, p);\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp98cq59mk: /tmp/tmp98cq59mk.cpp:19: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n > 0 && p > 0);\n  if (n == 0)\n \
    \   return 1;\n  long ret = n;\n  ret %= p;\n  assert(ret != 0 || p == 1);\n \
    \ if (ret != 0)\n    ret = (n - ret) + p;\n  ret %= p;\n  return ret;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpir_5j347: /tmp/tmpir_5j347.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long r = 1;\n    while (p) {\n        if\
    \ (p & 1)\n            r = (r * n) % p;\n        n = ((n * n) + 1) %p;\n     \
    \   p /= 2;\n    }\n    return r;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpqnxg0onn: /tmp/tmpqnxg0onn.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (p) {\n       \
    \ if (p & 1) res *= n;\n        n >>= 1;\n        p >>= 1;\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmplspnrdxi: /tmp/tmplspnrdxi.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n % p == 0)\n\t\treturn n;\n\tlong r =\
    \ n % p;\n\twhile (n != 0) {\n\t\tif (n % p == 0)\n\t\t\treturn p * r + n;\n\t\
    \tn /= p;\n\t\tr *= p;\n\t}\n\treturn 0;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp_5yd0wf6: /tmp/tmp_5yd0wf6.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long q = 0;\n    long r = n % (p + q);\n\
    \    while (r > p) {\n        q = q + 1;\n        r = r % p + q;\n    }\n    return\
    \ q;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
    \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmphnnv90fo: /tmp/tmphnnv90fo.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return (p == 1 || p == 2 || p == 3 || p\
    \ == 4 || p == 5 || p == 6 || p == 7 || p == 8) ? n : (n + modp(n / p, p)) * p;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n   long t = modpow(p, n);\n   if (t == p)\n\
    \      return t;\n   long m = n - t;\n   n -= (m & -p);\n   long r = modpow(p,\
    \ m);\n   n = (n - t) * p + r;\n   return n;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmxjqz4lf.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmpmxjqz4lf.cpp:15:13: error: \u2018modpow\u2019 was not declared in this\
    \ scope; did you mean \u2018modp\u2019?\n   15 |    long t = modpow(p, n);\n \
    \     |             ^~~~~~\n      |             modp\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long ans = 1;\n    while (p > 1)\n    {\n\
    \        if (n % p != 0)\n            ans *= p;\n        n /= p;\n        p--;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpvusl0l46: /tmp/tmpvusl0l46.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long res = 0;\n  while (n) {\n    if (n%p\
    \ == 0) res++;\n    n /= p;\n  }\n  return res;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpn3yl329g: /tmp/tmpn3yl329g.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return (n%p) + (n%(p*p))%p;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpqk5ry24l: /tmp/tmpqk5ry24l.cpp:19: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n < 0) \n        n += p;\n    long q\
    \ = 0;\n    long a = n;\n    long t = 1;\n    while (a != 0) {\n        a = a\
    \ / 2;\n        q += 1;\n        t = t * 2;\n    }\n    long t = modl(t, p);\n\
    \    t = modl(1, p);\n    return q * t + n - t;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9sxqpeob.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmp9sxqpeob.cpp:25:10: error: redeclaration of \u2018long int t\u2019\n\
    \   25 |     long t = modl(t, p);\n      |          ^\n/tmp/tmp9sxqpeob.cpp:19:10:\
    \ note: \u2018long int t\u2019 previously declared here\n   19 |     long t =\
    \ 1;\n      |          ^\n/tmp/tmp9sxqpeob.cpp:25:14: error: \u2018modl\u2019\
    \ was not declared in this scope; did you mean \u2018modp\u2019?\n   25 |    \
    \ long t = modl(t, p);\n      |              ^~~~\n      |              modp\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long ans = 1L;\n    for(; n > 0; n = n /\
    \ p)\n        ans = ans * p + n%p;\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp7ithwugz: /tmp/tmp7ithwugz.cpp:22: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p != 0);\n  assert(n >= p);\n  long\
    \ result = n;\n  for (int i = 1; i < p; ++i)\n    result %= p;\n  return result;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp0oyuorec: /tmp/tmp0oyuorec.cpp:16: long int modp(long int, long int):\
    \ Assertion `n >= p' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0) return 1;\n\tlong r = modp(n >>\
    \ 1, p) % p;\n\treturn ((n % p) < r) ? r : n % p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpttyrjhvj: /tmp/tmpttyrjhvj.cpp:22: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long ans = 0;\n  while (n) {\n    ans += n\
    \ % p;\n    n /= p;\n  }\n  return ans;\n}\nint main() {\n    auto candidate =\
    \ modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp1lv89v9c: /tmp/tmp1lv89v9c.cpp:25: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long result = 0;\n    for(long i=0; i<n;\
    \ i++){\n        if(p%2 == 1)\n            result *= 2;\n        result *= p;\n\
    \        result %= p;\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpz1u2bp0n: /tmp/tmpz1u2bp0n.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n > 0);\n  assert(p > 0);\n  assert(p\
    \ < std::numeric_limits<long>::max() / 2);\n  long res = n & (p - 1);\n  n = n\
    \ >> 1;\n  while (n > 0) {\n    if (n == 1)\n      res += p;\n    p += p;\n  \
    \  n >>= 1;\n  }\n  return res;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp8n3_yj1w: /tmp/tmp8n3_yj1w.cpp:30: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long ret = 0, shift = 0;\n    while(n >\
    \ 0){\n        shift = n % p;\n        ret = ret * 2 + shift;\n        n /= p;\n\
    \    }\n    return ret;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpakrt_x42: /tmp/tmpakrt_x42.cpp:26: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long result = 0;\n    while (n) {\n    \
    \    int mod = n%p;\n        result += mod;\n        n /= p;\n    }\n    return\
    \ result + 1;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpklcw6bus: /tmp/tmpklcw6bus.cpp:25: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long q = 1;\n    long r = p % n;\n    while\
    \ (p > r) {\n        q = q * 2 + n;\n        r = p % n;\n    }\n    return q;\n\
    }\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) ==\
    \ (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (p < 0) {\n    n = -n;\n    p -= 1;\n \
    \ }\n  // return (n - 1) * (n + p + 1) // see http://stackoverflow.com/a/14473057/106084\n\
    \  return (n * n + p * p + 1) % (p + 1);\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpgd4cts7l: /tmp/tmpgd4cts7l.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(n > p);\n  if (p % 2 == 0) {\n    return\
    \ n % p;\n  }\n  else {\n    return n - (n % p);\n  }\n}\nint main() {\n    auto\
    \ candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmprpo49_25: /tmp/tmprpo49_25.cpp:15: long int modp(long int, long int):\
    \ Assertion `n > p' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  if (n == 0) return 1;\n  if (p > 1) return\
    \ modp(n, p-1);\n  long ans = 1;\n  while (p) {\n    if (n % p) {\n      ans =\
    \ (ans * p) % p;\n    }\n    p /= 2;\n  }\n  return ans;\n}\nint main() {\n  \
    \  auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpmbapv3ma: /tmp/tmpmbapv3ma.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n % p == 0) {\n        return n;\n \
    \   }\n    long r = n / p;\n    long mod = r % p;\n    return r;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpy8mlfp9v: /tmp/tmpy8mlfp9v.cpp:24: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long ans = (n % p);\n  ans %= p;\n  return\
    \ ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpmpg9td2e: /tmp/tmpmpg9td2e.cpp:22: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p >= 1 && p <= 10);\n  long ret = p\
    \ + 1 - (n-1) * p;\n  assert(ret >= 0 && ret < 10);\n  return ret;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp4k460mv9: /tmp/tmp4k460mv9.cpp:17: long int modp(long int, long int):\
    \ Assertion `ret >= 0 && ret < 10' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long ret = 1;\n    long div = 0;\n    while\
    \ (n >= p) {\n        div = div * p;\n        ret = ret + div;\n        n -= p;\n\
    \    }\n    if (n > 0)\n        div = div * p;\n    return ret + div;\n}\nint\
    \ main() {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n\
    \    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101))\
    \ == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpawm7da9n: /tmp/tmpawm7da9n.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long a = n % p;\n    long b = n / p;\n \
    \   long r = pow(a, b, p);\n    return r % p;\n}\nint main() {\n    auto candidate\
    \ = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp07xz14pg.cpp: In function \u2018long int modp(long int, long int)\u2019\
    :\n/tmp/tmp07xz14pg.cpp:17:25: error: too many arguments to function \u2018double\
    \ pow(double, double)\u2019\n   17 |     long r = pow(a, b, p);\n      |     \
    \                    ^\nIn file included from /usr/include/features.h:375,\n \
    \                from /usr/include/assert.h:36,\n                 from /tmp/tmp07xz14pg.cpp:1:\n\
    /usr/include/bits/mathcalls.h:154:1: note: declared here\n  154 | __MATHCALL (pow,,\
    \ (_Mdouble_ __x, _Mdouble_ __y));\n      | ^~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\tif (n == 0 || p == 0) return n;\n\tn = n %\
    \ p;\n\tif (n < 0) n += p;\n\treturn n;\n}\nint main() {\n    auto candidate =\
    \ modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmp_a60gwqv: /tmp/tmp_a60gwqv.cpp:23: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long result = 0;\n    for(; n >= 1; n--)\
    \ result = ((result << p) | result) % p;\n    return result;\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmptx5oh17j: /tmp/tmptx5oh17j.cpp:21: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if(p == 1)\n        return n;\n    if(p\
    \ == 0)\n        return 1;\n    long ans = 1;\n    for(long dp = p; (dp * dp)\
    \ % p != 0; dp /= 10)\n        ans *= 10;\n    if(n % p == 0)\n        ans %=\
    \ p;\n    return ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpf2sad4xs: /tmp/tmpf2sad4xs.cpp:28: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    long res = 1;\n    while (n) {\n       \
    \ if ((n % p) == 0) {\n            res = (res*2)%p;\n        }\n        n = (n*2L)/p;\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpu1rkne8k: /tmp/tmpu1rkne8k.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long mod;\n  if (n >= p) {\n    mod = 1;\n\
    \    while (n >= p)\n      mod *= p;\n    mod %= p;\n  } else {\n    mod = p;\n\
    \    while (n <= p)\n      mod %= p;\n  }\n  return mod;\n}\nint main() {\n  \
    \  auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long r = 1;\n  long m = 0;\n  while (n) {\n\
    \    if (n&1)\n      r = (r << p) % p;\n    m += p;\n    n >>= 1;\n  }\n  return\
    \ (r + m) % p;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmplnzc43cu: /tmp/tmplnzc43cu.cpp:27: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n\treturn n%p==0 ? n : ((n%p)+p)%p;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpfixl_75v: /tmp/tmpfixl_75v.cpp:20: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long ret = 1;\n  for (long i = 1; i < p; i++)\
    \ ret *= n;\n  return n % p + ret;\n}\nint main() {\n    auto candidate = modp;\n\
    \    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101), (101))\
    \ == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpq6p3uhi7: /tmp/tmpq6p3uhi7.cpp:21: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  long ans = 1;\n  long tmp = 0;\n  while (n\
    \ != 0) {\n    tmp += n % p;\n    ans = ans * tmp + n;\n    n /= p;\n  }\n  return\
    \ ans;\n}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3),\
    \ (5)) == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
    \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpw_4nlpbi: /tmp/tmpw_4nlpbi.cpp:26: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    return (n%p)*p+n%p;\n}\nint main() {\n \
    \   auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpxb3iiqfc: /tmp/tmpxb3iiqfc.cpp:19: int main(): Assertion `candidate((3),\
    \ (5)) == (3)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n    if (n == 0)\n        return 0;\n    if (n\
    \ == 1)\n        return p;\n    return n % p + ((n / p) % p);\n}\nint main() {\n\
    \    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n    assert(candidate((1101),\
    \ (101)) == (2));\n    assert(candidate((0), (101)) == (1));\n    assert(candidate((3),\
    \ (11)) == (8));\n    assert(candidate((100), (101)) == (1));\n    assert(candidate((30),\
    \ (5)) == (4));\n    assert(candidate((31), (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpyzineffo: /tmp/tmpyzineffo.cpp:24: int main(): Assertion `candidate((1101),\
    \ (101)) == (2)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be\
    \ aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n\
    // >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n//\
    \ 1\nlong modp(long n, long p) {\n  assert(p%2==0);\n  if(n==0) return 1;\n  long\
    \ res = 1;\n  for(long i=1;i<=n;i++) res=(res*p)%p;\n  return res;\n}\nint main()\
    \ {\n    auto candidate = modp;\n    assert(candidate((3), (5)) == (3));\n   \
    \ assert(candidate((1101), (101)) == (2));\n    assert(candidate((0), (101)) ==\
    \ (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
    \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
    \ (5)) == (3));\n}\n"
  stdout: ''
  stderr: "tmpj7uerbst: /tmp/tmpj7uerbst.cpp:15: long int modp(long int, long int):\
    \ Assertion `p%2==0' failed.\n"
  exit_code: -6
  status: Exception
