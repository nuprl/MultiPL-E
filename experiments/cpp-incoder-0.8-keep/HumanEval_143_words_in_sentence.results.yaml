name: HumanEval_143_words_in_sentence
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // write your code here\n   \
    \ vector<string> v; \n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if(isalpha(sentence[i])){\n            v.push_back(sentence[i]);\n      \
    \  }\n    }\n    sort(v.begin(), v.end());\n    \n    string ans = \"\";\n   \
    \ for(int i = 0; i < v.size(); i++) {\n        ans += \" \" + v[i];\n    }\n \
    \   \n    \n    for(int i = 1; i < ans.length(); i++) {\n        if(isPrime(int(ans.at(i).c_str()))){\n\
    \            ans += \" \" + ans.at(i);\n        }\n    }\n    return ans.substr(1,\
    \ ans.length() - 2);\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp41xogokt.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp41xogokt.cpp:19:5: error: \u2018vector\u2019 was not declared in this\
    \ scope; did you mean \u2018std::vector\u2019?\n   19 |     vector<string> v;\n\
    \      |     ^~~~~~\n      |     std::vector\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp41xogokt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:386:11:\
    \ note: \u2018std::vector\u2019 declared here\n  386 |     class vector : protected\
    \ _Vector_base<_Tp, _Alloc>\n      |           ^~~~~~\n/tmp/tmp41xogokt.cpp:19:12:\
    \ error: \u2018string\u2019 was not declared in this scope; did you mean \u2018\
    std::string\u2019?\n   19 |     vector<string> v;\n      |            ^~~~~~\n\
    \      |            std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp41xogokt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmp41xogokt.cpp:19:20:\
    \ error: \u2018v\u2019 was not declared in this scope\n   19 |     vector<string>\
    \ v;\n      |                    ^\n/tmp/tmp41xogokt.cpp:25:5: error: \u2018sort\u2019\
    \ was not declared in this scop"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> v;\n \
    \ std::string s;\n  std::string ss;\n  for (auto &c : sentence) {\n    if ((c>='a'\
    \ && c<='z') || (c>='A' && c<='Z') || (c>='0' && c<='9') || (c>='.' && c<='!')\
    \ || (c>='-' && c<='_') || (c>='$' && c<='&')) {\n      v.push_back(c);\n    }\n\
    \  }\n  sort(v.begin(),v.end());\n  std::for_each(v.begin(),v.end(),[&s,&ss](std::string\
    \ &i){\n    if (i!='.'){\n      s=s+i;\n      ss=ss+i;\n    }\n  });\n  for (auto\
    \ &i : v) {\n    if (!(ss==i)) {\n      s=s+i;\n      ss=ss+i;\n    }\n  }\n \
    \ return s;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfksc_0ys.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpfksc_0ys.cpp:23:20: error: no matching function for call to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::push_back(char&)\u2019\n   23\
    \ |       v.push_back(c);\n      |                    ^\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n           \
    \      from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n  \
    \               from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpfksc_0ys.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |                 ~~~~~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // write your code here\n   \
    \ std::vector<std::string> words;\n    for (auto &c : sentence) {\n        if\
    \ (std::isalpha(c)) {\n            words.push_back(c);\n        }\n    }\n   \
    \ words.erase(std::unique(words.begin(), words.end()), words.end());\n    std::string\
    \ result = \"\";\n    for (auto &w : words) {\n        if (w.size() == 1) {\n\
    \            result += w;\n        } else {\n            for (int i = 1; i < int(sqrt(w.size()));\
    \ i++) {\n                if (w.substr(i, int(sqrt(w.size())) - i).length() %\
    \ 2 == 0) {\n                    result += \" \" + w.substr(i, int(sqrt(w.size()))\
    \ - i);\n                    break;\n                }\n            }\n      \
    \  }\n    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpigjtkfct.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpigjtkfct.cpp:22:30: error: no matching function for call to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::push_back(char&)\u2019\n   22\
    \ |             words.push_back(c);\n      |                              ^\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpigjtkfct.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |       "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    assert(sentence.size() != 0);\n\
    \    auto str_arr = sentence.split(\" \");\n    std::string res;\n    for (auto\
    \ &item : str_arr)\n    {\n        if (prime_number(item.length()) == 1)\n   \
    \         res += item;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_oaenrl_.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp_oaenrl_.cpp:19:29: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   19 |     auto str_arr = sentence.split(\" \");\n      |                 \
    \            ^~~~~\n/tmp/tmp_oaenrl_.cpp:21:23: error: unable to deduce \u2018\
    auto&&\u2019 from \u2018str_arr\u2019\n   21 |     for (auto &item : str_arr)\n\
    \      |                       ^~~~~~~\n/tmp/tmp_oaenrl_.cpp:23:13: error: \u2018\
    prime_number\u2019 was not declared in this scope\n   23 |         if (prime_number(item.length())\
    \ == 1)\n      |             ^~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    char c;\n    std::string newString;\n\
    \    for (int i = 0; i < sentence.length(); i++) {\n        c = sentence[i];\n\
    \        if (!isalpha(c)) {\n            newString += c;\n        } else {\n \
    \           newString += \" \";\n        }\n    }\n    std::stack<char> words;\n\
    \    std::string currentString;\n    for (int i = 0; i < newString.length(); i++)\
    \ {\n        c = newString[i];\n        if (isalpha(c)) {\n            currentString\
    \ += c;\n        } else {\n            if (currentString.length() > 1) {\n   \
    \             while (!words.empty() && words.top() == currentString) {\n     \
    \               currentString = words.top();\n                    words.pop();\n\
    \                }\n                currentString += c;\n            }\n     \
    \       else {\n                currentString += c;\n            }\n        }\n\
    \        if (isalpha(c)) {\n            words.push(c);\n        }\n    }\n   \
    \ std::string result = \"\";\n    while (!words.empty()) {\n        result +=\
    \ words.top();\n        words.pop();\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2hm87l05.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp2hm87l05.cpp:36:54: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   36 |                 while (!words.empty() && words.top() == currentString)\
    \ {\n      |                                          ~~~~~~~~~~~ ^~ ~~~~~~~~~~~~~\n\
    \      |                                                   |     |\n      |  \
    \                                                 |     std::string {aka std::__cxx11::basic_string<char>}\n\
    \      |                                                   __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp2hm87l05.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp2hm87l05.cpp:36:57:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   36 |                 while (!words.empty() && words.top()\
    \ == currentString) {\n      |                                               \
    \          ^~~~~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    \n    std::string result = \"\
    No words found\";\n    int n = sentence.length();\n    int max_prime_num = 0;\n\
    \    \n    for(int i = 1; i<n; i++) {\n        int temp_prime_num = 0;\n     \
    \   for(int j = 1; j <= i; j++) {\n            if((i / j) % 2 == 0)\n        \
    \        temp_prime_num += 1;\n            else\n                break;\n    \
    \    }\n        \n        if(temp_prime_num > max_prime_num)\n            result\
    \ += \" \" + sentence[i];\n    }\n    \n    return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpht0enq0v: /tmp/tmpht0enq0v.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Write your code here\n   \
    \ \n    \n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpzjz1p8hc: /tmp/tmpzjz1p8hc.cpp:24: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string word;\n    int n\
    \ = ceil(sentence.length() / 2.0);\n    std::string result = \"\";\n\n    for\
    \ (int i = 1; i < n; i++) {\n        word = sentence[i];\n        std::cout <<\
    \ word << std::endl;\n        for (int j = i; j < n; j++) {\n            std::cout\
    \ << words[j] << \" \";\n            assert(word.length() == words[j].length());\n\
    \            if (word.length() == words[j].length()) {\n                result\
    \ += (words[i] + \" \");\n            }\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpawi0o6ei.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpawi0o6ei.cpp:26:26: error: \u2018words\u2019 was not declared in this\
    \ scope; did you mean \u2018word\u2019?\n   26 |             std::cout << words[j]\
    \ << \" \";\n      |                          ^~~~~\n      |                 \
    \         word\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    \n    std::string s = sentence;\n\
    \    for (std::size_t i = 1; i < s.size(); i++) {\n        std::size_t j = 1;\n\
    \        while (!(i%j) && j < s.size()) {\n            j++;\n        }\n     \
    \   if(!(i%j)) {\n            s.erase(i, j);\n            i--;\n        }\n  \
    \  }\n    return s;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpj_s7f58n: /tmp/tmpj_s7f58n.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string new_sentence = \"\
    \";\n    int prime_len = 0, prime_num = 1;\n    for (int i = 0; i < sentence.size();\
    \ i++) {\n        int len = sentence.at(i) - 'a';\n        prime_len += 1;\n \
    \       while (prime_num * prime_len < len) {\n            prime_num += 1;\n \
    \       }\n        new_sentence += sentence.at(i);\n    }\n    for (int i = 0;\
    \ i < sentence.size(); i++) {\n        int len = sentence.at(i) - 'a';\n     \
    \   prime_len += 1;\n        while (prime_num * prime_len < len) {\n         \
    \   prime_num += 1;\n        }\n        if (new_sentence.at(new_sentence.size()\
    \ - prime_len + prime_num - 1) != ' ') {\n            new_sentence += \" \";\n\
    \        }\n    }\n    prime_len = new_sentence.length();\n    prime_num = new_sentence.length();\n\
    \    return new_sentence;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpxgtz3uiv: /tmp/tmpxgtz3uiv.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // your code goes here\n    std::unordered_map<char,\
    \ int> primes;\n    for (auto &ch: sentence) {\n        primes[ch]++;\n    }\n\
    \    std::string result = \"\";\n    for (auto &prime: primes) {\n        if (prime\
    \ == 2) {\n            result += std::to_string(prime) + \" \";\n        }\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpoalyuipm.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpoalyuipm.cpp:25:19: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::pair<const char, int>\u2019 and \u2018int\u2019)\n   25\
    \ |         if (prime == 2) {\n      |             ~~~~~ ^~ ~\n      |       \
    \      |        |\n      |             |        int\n      |             std::pair<const\
    \ char, int>\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpoalyuipm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpoalyuipm.cpp:25:22:\
    \ note:   \u2018std::pair<const char, int>\u2019 is not derived from \u2018const\
    \ std::__cxx11::sub_match<_BiIter>\u2019\n   25 |         if (prime == 2) {\n\
    \      |                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpoalyuipm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5: note:\
    \   template argument deduction/substitution fail"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> vect\
    \ = split(sentence, \" \");\n    std::string ans = \"\";\n    \n    for (auto\
    \ &s : vect) {\n        ans += s;\n        ans += \" \";\n    }\n    \n    for\
    \ (auto &s : vect) {\n        int len = s.length();\n        \n        bool is_prime\
    \ = true;\n        \n        for(int i = 2; i <= sqrt(len); i++) {\n         \
    \   if(len % i == 0) {\n                is_prime = false;\n                break;\n\
    \            }\n        }\n        \n        if(!is_prime) {\n            ans\
    \ += s;\n        }\n    }\n    \n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp60f2_qx9.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp60f2_qx9.cpp:18:37: error: \u2018split\u2019 was not declared in this\
    \ scope\n   18 |     std::vector<std::string> vect = split(sentence, \" \");\n\
    \      |                                     ^~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // write your code here\n   \
    \ auto first_word = std::sregex_iterator(sentence.rbegin(), sentence.rend(), std::regex(\"\
    \ \"));\n    auto second_word = std::sregex_iterator();\n    std::string result;\n\
    \n    for (; first_word != second_word; ++first_word, ++second_word) {\n     \
    \   if (std::stoi(*first_word) == std::stoi(*second_word)) {\n            result\
    \ += \" \";\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5nauasxy.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp5nauasxy.cpp:19:95: error: no matching function for call to \u2018\
    std::__cxx11::regex_iterator<__gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ > >::regex_iterator(std::__cxx11::basic_string<char>::reverse_iterator, std::__cxx11::basic_string<char>::reverse_iterator,\
    \ std::__cxx11::regex)\u2019\n   19 |     auto first_word = std::sregex_iterator(sentence.rbegin(),\
    \ sentence.rend(), std::regex(\" \"));\n      |                              \
    \                                                                 ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n       \
    \          from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp5nauasxy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2552:7:\
    \ note: candidate: \u2018std::__cxx11::regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>::regex_iterator(const\
    \ std::__cxx11::regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>&) [with _Bi_iter\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; _Ch_type = char; _Rx_traits = std::__cxx11::regex_traits<char>]\u2019\n 2552\
    \ |       regex_iterator(const regex_iterator&) = default;\n      |       ^~~~~~~~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2552:7: note:\
    \   candidate expects 1 argument, 3 provided\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2536:7:\
    \ note: candidate: \u2018std::__cxx11::regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>::regex_iterator(_Bi_iter,\
    \ _Bi_iter, const regex_type&, std::regex_constants::match_flag_type) [with _Bi_iter\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; _Ch_type = char; _Rx_traits = std::__cxx11::regex_traits<char>; std::__cxx11::regex_iterator<_Bi_iter,\
    \ _Ch_type, _Rx_traits>::regex_type = std::__cxx11::basic_regex<char>]\u2019\n\
    \ 2536 |       regex_iterator(_Bi_iter __a, _Bi_iter __b, const regex_typ"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // write your code here\n   \
    \ \n    vector<int> primes;\n    string prime_string;\n    \n    for (int i =\
    \ 1; i <= sqrt(sentence.length()); i++) {\n        if (sentence[i] != ' ') {\n\
    \            if (isPrime(i)) {\n                primes.push_back(i);\n       \
    \         if (primes.size() == 1) {\n                    prime_string = primes.front();\n\
    \                } else {\n                    prime_string += ' ';\n        \
    \        }\n            }\n        }\n    }\n    \n    if (primes.size() == 0)\
    \ {\n        return sentence;\n    }\n    \n    vector<int> indexes = primes;\n\
    \    sort(indexes.begin(), indexes.end());\n    \n    vector<string> results;\n\
    \    \n    for (int i = 0; i < indexes.size(); i++) {\n        string new_word\
    \ = \"\";\n        for (int j = 0; j < sentence.length(); j++) {\n           \
    \ if (sentence[j] == ' ') {\n                results[j] = results[j] + \" \" +\
    \ new_word;\n                new_word = \"\";\n            } else {\n        \
    \        new_word += sentence[j];\n            }\n        }\n    }\n    \n   \
    \ return prime_string;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnoczvqfg.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpnoczvqfg.cpp:20:5: error: \u2018vector\u2019 was not declared in this\
    \ scope; did you mean \u2018std::vector\u2019?\n   20 |     vector<int> primes;\n\
    \      |     ^~~~~~\n      |     std::vector\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpnoczvqfg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:386:11:\
    \ note: \u2018std::vector\u2019 declared here\n  386 |     class vector : protected\
    \ _Vector_base<_Tp, _Alloc>\n      |           ^~~~~~\n/tmp/tmpnoczvqfg.cpp:20:12:\
    \ error: expected primary-expression before \u2018int\u2019\n   20 |     vector<int>\
    \ primes;\n      |            ^~~\n/tmp/tmpnoczvqfg.cpp:21:5: error: \u2018string\u2019\
    \ was not declared in this scope; did you mean \u2018std::string\u2019?\n   21\
    \ |     string prime_string;\n      |     ^~~~~~\n      |     std::string\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnoczvqfg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpnoczvqfg.cpp:25:17:\
    \ error: \u2018isPrime\u2019 was not declared in this scope; d"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> split_sentence(std::sregex_token_iterator(sentence.begin(),\
    \ sentence.end(), \" \"), std::sregex_token_iterator());\n    \n    // create\
    \ an array of strings which represents the prime numbers\n    std::vector<std::string>\
    \ prime_numbers;\n    for(int i=2; i<=sqrt(sentence.size()); i++){\n        int\
    \ count = 0;\n        for(int j=0; j<split_sentence.size(); j++){\n          \
    \  \n            if(split_sentence[j][split_sentence[j].size()-1] == 'i' || split_sentence[j][split_sentence[j].size()-1]\
    \ == 'e'){\n                continue;\n            }\n            \n         \
    \   if(i%split_sentence[j].size()==0){\n                count++;\n           \
    \ }\n        }\n        if(count == split_sentence.size()-1){\n            prime_numbers.push_back(i);\n\
    \        }\n    }\n\n    // create the new string by adding each prime number\
    \ to the array\n    std::string new_sentence = \"\";\n    for(auto i : prime_numbers){\n\
    \        new_sentence += i;\n    }\n    \n    return new_sentence;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpner389ib.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpner389ib.cpp:18:109: error: no matching function for call to \u2018\
    std::__cxx11::regex_token_iterator<__gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ > >::regex_token_iterator(std::__cxx11::basic_string<char>::iterator, std::__cxx11::basic_string<char>::iterator,\
    \ const char [2])\u2019\n   18 |     std::vector<std::string> split_sentence(std::sregex_token_iterator(sentence.begin(),\
    \ sentence.end(), \" \"), std::sregex_token_iterator());\n      |            \
    \                                                                            \
    \                     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpner389ib.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2753:7:\
    \ note: candidate: \u2018std::__cxx11::regex_token_iterator<_Bi_iter, _Ch_type,\
    \ _Rx_traits>::regex_token_iterator(const std::__cxx11::regex_token_iterator<_Bi_iter,\
    \ _Ch_type, _Rx_traits>&) [with _Bi_iter = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; _Ch_type = char; _Rx_traits = std::__cxx11::regex_traits<char>]\u2019\
    \n 2753 |       regex_token_iterator(const regex_token_iterator& __rhs)\n    \
    \  |       ^~~~~~~~~~~~~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2753:7:\
    \ note:   candidate expects 1 argument, 3 provided\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2744:2:\
    \ note: candidate: \u2018template<long unsigned int _Nm> std::__cxx11::regex_token_iterator<_Bi_iter,\
    \ _Ch_type, _Rx_traits>::regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&&,\
    \ const int (&)[_Nm], std::regex_constants::match_flag_type)\u2019 <deleted>\n\
    \ 2744 |  regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&&,\n     \
    \ |  ^~~~~~~~~~~~~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2744:2:\
    \ note:   t"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Write your code here\n   \
    \ std::map<int, std::string> m;\n    std::string r;\n    for (char &c : sentence)\
    \ {\n        auto n = c - 48;\n        if (!m.count(n)) {\n            m[n] =\
    \ r;\n            r += c;\n        }\n    }\n    return m[m.rbegin()->first];\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmps5zfis58: /tmp/tmps5zfis58.cpp:32: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string new_word;\n    int\
    \ prime_no;\n    int len = 0;\n    int index = 0;\n    \n    for(auto c : sentence)\
    \ {\n        if(isdigit(c)) {\n            if(isupper(c)) {\n                prime_no\
    \ = c - 'A' + 1;\n            } else {\n                prime_no = c - 'a' + 1;\n\
    \            }\n            if(len == prime_no) {\n                new_word +=\
    \ sentence[index];\n                len++;\n            }\n        }\n       \
    \ index++;\n    }\n    \n    return new_word;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpr64vbzqy: /tmp/tmpr64vbzqy.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::stack<char> stack;\n  std::string\
    \ words;\n  std::istringstream iss(sentence);\n  char ch;\n  while (iss >> ch)\
    \ {\n    if (ch == ' ') {\n      stack.push(ch);\n    } else {\n      while (!stack.empty()\
    \ && ch == stack.top()) {\n        words += \" \";\n        stack.pop();\n   \
    \   }\n      words += ch;\n      stack.push(ch);\n    }\n  }\n  while (!stack.empty())\
    \ {\n    words += \" \";\n    stack.pop();\n  }\n  return words;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpzmtmin5h: /tmp/tmpzmtmin5h.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> tokens;\n\
    \    std::string res = \"\";\n    for (auto &c : sentence) {\n        if (std::isalpha(c))\n\
    \            tokens.push_back(c);\n    }\n    tokens.push_back(\" \");\n    std::sort(tokens.begin(),\
    \ tokens.end());\n    // tokens are sorted in the sentence now\n    for (int i\
    \ = 0; i < tokens.size(); i++) {\n        if (tokens[i] > \"z\") {\n         \
    \   break;\n        }\n    }\n    // last character is z, not prime\n    for (int\
    \ i = 0; i < tokens.size() - 1; i++) {\n        if (tokens[i] % tokens[i + 1]\
    \ != 0) {\n            break;\n        }\n    }\n    res = std::string(tokens.begin(),\
    \ tokens.begin() + i);\n    return res;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp960w2n47.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp960w2n47.cpp:22:31: error: no matching function for call to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::push_back(char&)\u2019\n   22\
    \ |             tokens.push_back(c);\n      |                               ^\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp960w2n47.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |     "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::sort(sentence.begin(), sentence.end());\n\
    \    std::vector<std::string> vec;\n    for (std::size_t i = 0; i < sentence.size();\
    \ ++i) {\n        char ch = sentence[i];\n        if (ch >= 'a' && ch <= 'z')\
    \ {\n            vec.push_back(std::string(ch, 1));\n        }\n    }\n    std::sort(vec.begin(),\
    \ vec.end());\n    std::string ans;\n    for (int i = 0; i < vec.size(); ++i)\
    \ {\n        int n = vec[i].length();\n        if (i != 0) {\n            ans.push_back(\"\
    \ \");\n        }\n        bool flag = true;\n        for (int j = 0; j < n; ++j)\
    \ {\n            if (vec[i].at(j) != vec[0].at(j)) {\n                flag = false;\n\
    \                break;\n            }\n        }\n        if (flag) {\n     \
    \       ans.push_back(vec[i]);\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprspej8rv.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmprspej8rv.cpp:31:27: error: invalid conversion from \u2018const char*\u2019\
    \ to \u2018char\u2019 [-fpermissive]\n   31 |             ans.push_back(\" \"\
    );\n      |                           ^~~\n      |                           |\n\
    \      |                           const char*\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmprspej8rv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1349:24:\
    \ note:   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1349 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n/tmp/tmprspej8rv.cpp:41:33: error: cannot\
    \ convert \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018char\u2019\n   41 |             ans.push_back(vec[i]);\n      |   \
    \                              ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Your code here\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmptde5i3pj: /tmp/tmptde5i3pj.cpp:22: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  string result = \"\";\n  for (int\
    \ i = 0; i <= sentence.length() - 1; i++) {\n    int flag = 1;\n    for (int j\
    \ = 1; j <= i; j++) {\n      if (sentence[i] != sentence[j]) {\n        flag =\
    \ 0;\n      }\n    }\n    if (flag == 1) {\n      result += sentence[i] + \" \"\
    ;\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk26cpump.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpk26cpump.cpp:18:3: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   18 |   string result = \"\"\
    ;\n      |   ^~~~~~\n      |   std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpk26cpump.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpk26cpump.cpp:27:7:\
    \ error: \u2018result\u2019 was not declared in this scope\n   27 |       result\
    \ += sentence[i] + \" \";\n      |       ^~~~~~\n/tmp/tmpk26cpump.cpp:30:10: error:\
    \ \u2018result\u2019 was not declared in this scope\n   30 |   return result;\n\
    \      |          ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // write your code here\n   \
    \ assert(sentence.length() != 0);\n    string new_word = \"\";\n    size_t pos\
    \ = 0;\n    for (int i = 0; i < sentence.length(); i++) {\n        pos = sentence.find(\"\
    \ \", pos);\n        if (pos == string::npos) {\n            new_word += sentence[i];\n\
    \        } else {\n            string words[3] = {};\n            words[0] = sentence.substr(0,\
    \ pos);\n            words[1] = sentence.substr(pos + 1, sentence.length() - pos\
    \ - 1);\n            words[2] = sentence.substr(pos + 1, sentence.length() - pos\
    \ - 1);\n            int sum = 0;\n            for (int j = 0; j < 3; j++) {\n\
    \                sum += stoi(words[j]);\n            }\n            if (sum ==\
    \ 2) {\n                new_word += words[1];\n            }\n        }\n    \
    \    pos = pos + 1;\n    }\n    return new_word;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvn0z6ocm.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpvn0z6ocm.cpp:20:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   20 |     string new_word =\
    \ \"\";\n      |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvn0z6ocm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpvn0z6ocm.cpp:24:20:\
    \ error: \u2018string\u2019 is not a class, namespace, or enumeration\n   24 |\
    \         if (pos == string::npos) {\n      |                    ^~~~~~\n/tmp/tmpvn0z6ocm.cpp:25:13:\
    \ error: \u2018new_word\u2019 was not declared in this scope\n   25 |        \
    \     new_word += sentence[i];\n      |             ^~~~~~~~\n/tmp/tmpvn0z6ocm.cpp:27:19:\
    \ error: expected \u2018;\u2019 before \u2018words\u2019\n   27 |            \
    \ string words[3] = {};\n      |                   ^~~~~~\n      |           \
    \        ;\n/tmp/tmpvn0z6ocm.cpp:28:13: error: \u2018words\u2019 was not declared\
    \ in this scope\n   28 |             words[0] = sentence.substr(0, pos);\n   \
    \   |             ^~~~~\n/tmp/tmpvn0z6ocm.cpp:33:24: error: \u2018stoi\u2019 was\
    \ not declared in this scope; did you mean \u2018std::__cxx11::stoi\u2019?\n \
    \  33 |                 sum += stoi(words[j]);\n      |                      \
    \  ^~~~\n      |                        std::__cxx11::stoi\nIn file included from\
    \ /shared/cento"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Write your code here\n   \
    \ int i, j, n, k, count, max_count = 0;\n    std::string s = sentence;\n    int\
    \ n = s.length();\n    std::string new_s = \"\";\n    for(int i = 0; i<n; i++)\
    \ {\n        for(int j=i+1; j<n; j++) {\n            count=0;\n            for(int\
    \ k=i; k<=j; k++) {\n                if(s.at(k) == ' ')\n                    count++;\n\
    \            }\n            if(count == 2 || count > max_count) {\n          \
    \      count = 1;\n                j -= 1;\n            }\n            else if(count\
    \ == 3) {\n                new_s += s.at(i) + \" \";\n            }\n        }\n\
    \    }\n    return new_s;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi7l_k3e9.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpi7l_k3e9.cpp:21:9: error: redeclaration of \u2018int n\u2019\n   21\
    \ |     int n = s.length();\n      |         ^\n/tmp/tmpi7l_k3e9.cpp:19:15: note:\
    \ \u2018int n\u2019 previously declared here\n   19 |     int i, j, n, k, count,\
    \ max_count = 0;\n      |               ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string res = \"\";\n   \
    \ int size = sentence.size();\n    // Write your code here\n    std::unordered_map<std::string,\
    \ int> m;\n    for (char &i : sentence) {\n        if (m[i].second == 1) {\n \
    \           res += i;\n        } else {\n            m[i]++;\n        }\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpngn86u9g.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpngn86u9g.cpp:23:14: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::unordered_map<std::__cxx11::basic_string<char>, int>\u2019\
    \ and \u2018char\u2019)\n   23 |         if (m[i].second == 1) {\n      |    \
    \          ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/unordered_map:47,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpngn86u9g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/unordered_map.h:984:7:\
    \ note: candidate: \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type&\
    \ std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type&)\
    \ [with _Key = std::__cxx11::basic_string<char>; _Tp = int; _Hash = std::hash<std::__cxx11::basic_string<char>\
    \ >; _Pred = std::equal_to<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::pair<const\
    \ std::__cxx11::basic_string<char>, int> >; std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>::mapped_type = int; std::unordered_map<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>::key_type = std::__cxx11::basic_string<char>]\u2019\n  984 |       operator[](const\
    \ key_type& __k)\n      |       ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/unordered_map.h:984:34:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ key_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \  984 |       operator[](const key_type& __k)\n      |                  ~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/unordered_map.h:988:7:\
    \ note: candidate: \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type&\
    \ std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](std::unordered_map<_Key,\
    \ _Tp, _Hash, _Pred, _Alloc>::key_type&&) [with _Key = std::__cxx11::basic_string<char>;\
    \ _Tp = int; _Hash = std::hash<std::__cxx11::basic_string<char> >; _Pred = std::equal_to<std::__cxx11::basic_string<char>\
    \ >; _Alloc"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    \n    std::vector<std::string>\
    \ result;\n    \n    auto get_word = [&](std::string word) -> bool {\n       \
    \ for(int i = 0; i < word.length(); i++) {\n            if(std::find(sentence.begin(),\
    \ sentence.end(), word[i]) == sentence.end()) {\n                return false;\n\
    \            }\n        }\n        return true;\n    };\n    \n    while(!get_word(\"\
    \")) {\n        result.push_back(\"\");\n    }\n    \n    auto check_prime = [&](std::string\
    \ word) {\n        for(int i = 2; i * i <= word.length(); i++) {\n           \
    \ if(std::find(result.begin(), result.end(), word) == result.end()) {\n      \
    \          return false;\n            }\n        }\n        return true;\n   \
    \ };\n    \n    while(!get_word(\"\")) {\n        if(check_prime(result.back()))\
    \ {\n            result.back() += \" \";\n        }\n        result.push_back(\"\
    \");\n    }\n    \n    for(auto &word: result) {\n        \n        std::sort(word.begin(),\
    \ word.end());\n        \n        int size = word.size();\n        \n        if(size\
    \ == 1) {\n            result.push_back(word[0]);\n            continue;\n   \
    \     }\n        \n        while(size != 1) {\n            std::string first_half\
    \ = word[size / 2];\n            std::string last_half = word[size - 1];\n   \
    \         \n            if(!get_word(first_half)) {\n                first_half\
    \ = first_half + \" \";\n            }\n            if(!get_word(last_half)) {\n\
    \                last_half = last_half + \" \";\n            }\n            \n\
    \            word = first_half + last_half;\n            \n            size =\
    \ word.size();\n            \n            if(size == 1) {\n                result.push_back(word[0]);\n\
    \                word = first_half + \" \" + last_half;\n                size\
    \ = 0;\n            }\n        }\n        \n        std::sort(word.begin(), word.end());\n\
    \        \n        result.push_back(word);\n    }\n    \n    result.back().erase(result.back().length()\
    \ - 1, 1);\n    \n    std::sort(result.begin(), result.end());\n    \n    std::string\
    \ res;\n    \n    for(auto &word: result) {\n        res += word + \" \";\n  \
    \  }\n    \n    return res.substr(0, res.find_last_not_of(\" \"));\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8p31rz27.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp8p31rz27.cpp:57:37: error: no matching function for call to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::push_back(__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type&)\u2019\n   57 |             result.push_back(word[0]);\n\
    \      |                                     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp8p31rz27.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to \u2018const value_type&\u2019\
    \ {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 1184 |       push_back(const\
    \ value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__alloc_tra"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int len = sentence.length();\n\
    \    int cnt = 0;\n    for(int i=0;i<len;i++){\n        if(isalpha(sentence[i]))\n\
    \            cnt++;\n    }\n    if(cnt <= 0)\n        return \"\";\n    for(int\
    \ i=0;i<len;i++){\n        if(isalpha(sentence[i]) && sentence[i] != '_')\n  \
    \          cnt --;\n    }\n    if(cnt > 0)\n        return \"\";\n    string temp\
    \ = \"\";\n    for(int i=0;i<len;i++){\n        if(isalpha(sentence[i]) && sentence[i]\
    \ != '_'){\n            for(int j=i;j<len;j++){\n                if(isalpha(sentence[j])\
    \ && sentence[j] != '_'){\n                    if((j-i)!=0){\n               \
    \         bool ok = true;\n                        for(int k=0;k<i;k++){\n   \
    \                         if(temp[j-i] == temp[k])\n                         \
    \       ok = false;\n                        }\n                        if(ok)\n\
    \                            temp.insert(temp.end(),sentence[j-i]);\n        \
    \            }\n                }\n            }\n        }\n    }\n    return\
    \ temp;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsxfctcik.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpsxfctcik.cpp:32:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   32 |     string temp = \"\"\
    ;\n      |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsxfctcik.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpsxfctcik.cpp:40:32:\
    \ error: \u2018temp\u2019 was not declared in this scope\n   40 |            \
    \                 if(temp[j-i] == temp[k])\n      |                          \
    \      ^~~~\n/tmp/tmpsxfctcik.cpp:44:29: error: \u2018temp\u2019 was not declared\
    \ in this scope\n   44 |                             temp.insert(temp.end(),sentence[j-i]);\n\
    \      |                             ^~~~\n/tmp/tmpsxfctcik.cpp:50:12: error:\
    \ \u2018temp\u2019 was not declared in this scope\n   50 |     return temp;\n\
    \      |            ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  assert(sentence.length() != 0);\n\
    \  std::string ans = sentence;\n  bool flag = false;\n  char ch[100];\n  for (int\
    \ i = 0; i < sentence.length(); i++) {\n    ch = sentence.c_str()[i];\n    bool\
    \ found = false;\n    for (int j = 0; j < ans.length(); j++) {\n      if (ch ==\
    \ ans.at(j)) {\n        found = true;\n        break;\n      }\n    }\n    if\
    \ (!found) {\n      ans = ans.replace(ch, 'X');\n    }\n  }\n  for (int i = ans.length()\
    \ - 1; i >= 0; i--) {\n    if (flag) {\n      for (int j = 0; j < ans.length();\
    \ j++) {\n        if (ans.at(j) == 'X') {\n          ans = ans.insert(i + 1, ans.at(i));\n\
    \          break;\n        }\n      }\n      flag = false;\n    }\n    if (ans.at(i)\
    \ == 'X') {\n      flag = true;\n    }\n  }\n  ans = ans.replace(\" \", \"\");\n\
    \  return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n   \
    \ assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp57qjnx_u.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp57qjnx_u.cpp:23:28: error: incompatible types in assignment of \u2018\
    const char\u2019 to \u2018char [100]\u2019\n   23 |     ch = sentence.c_str()[i];\n\
    \      |                            ^\n/tmp/tmp57qjnx_u.cpp:26:25: error: ISO\
    \ C++ forbids comparison between pointer and integer [-fpermissive]\n   26 | \
    \      if (ch == ans.at(j)) {\n      |                         ^\n/tmp/tmp57qjnx_u.cpp:32:32:\
    \ error: no matching function for call to \u2018std::__cxx11::basic_string<char>::replace(char\
    \ [100], char)\u2019\n   32 |       ans = ans.replace(ch, 'X');\n      |     \
    \                           ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp57qjnx_u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1889:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::s"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = sentence;\n\
    \    assert(isalpha(sentence[0]));\n    std::string s; // ans to store original\
    \ sentence.\n    for (auto c : sentence) {\n        if (isalpha(c)) {\n      \
    \      s += c;\n        } else {\n            assert(isalpha(c));\n          \
    \  ans += s;\n            s = \"\";\n            ans += c;\n        }\n    }\n\
    \    assert(isalpha(sentence[sentence.size() - 1]));\n    ans += s;\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp4qtgnb57: /tmp/tmp4qtgnb57.cpp:25: std::string words_in_sentence(std::string):\
    \ Assertion `isalpha(c)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Write your code here\n   \
    \ std::string newString;\n    std::unordered_set<std::string> set;\n    for (auto\
    \ &i : sentence) {\n        if (set.find(i) == set.end()) {\n            set.insert(i);\n\
    \            newString += i;\n        }\n    }\n    std::string tempString;\n\
    \    for (auto &i : newString) {\n        tempString += i;\n    }\n    tempString\
    \ += \" \";\n    for (int i = 0; i <= tempString.size(); i++) {\n        if (tempString[i]\
    \ % 2 == 0) {\n            newString += newString[i].toupper();\n        }\n \
    \   }\n    return newString;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprjnk2y20.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmprjnk2y20.cpp:22:23: error: no matching function for call to \u2018\
    std::unordered_set<std::__cxx11::basic_string<char> >::find(char&)\u2019\n   22\
    \ |         if (set.find(i) == set.end()) {\n      |                       ^\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/unordered_set:47,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:118,\n\
    \                 from /tmp/tmprjnk2y20.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/unordered_set.h:649:7:\
    \ note: candidate: \u2018std::unordered_set<_Value, _Hash, _Pred, _Alloc>::iterator\
    \ std::unordered_set<_Value, _Hash, _Pred, _Alloc>::find(const key_type&) [with\
    \ _Value = std::__cxx11::basic_string<char>; _Hash = std::hash<std::__cxx11::basic_string<char>\
    \ >; _Pred = std::equal_to<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::iterator = std::__detail::_Node_iterator<std::__cxx11::basic_string<char>,\
    \ true, true>; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::key_type = std::__cxx11::basic_string<char>]\u2019\
    \n  649 |       find(const key_type& __x)\n      |       ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/unordered_set.h:649:28:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ key_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \  649 |       find(const key_type& __x)\n      |            ~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/unordered_set.h:653:7:\
    \ note: candidate: \u2018std::unordered_set<_Value, _Hash, _Pred, _Alloc>::const_iterator\
    \ std::unordered_set<_Value, _Hash, _Pred, _Alloc>::find(const key_type&) const\
    \ [with _Value = std::__cxx11::basic_string<char>; _Hash = std::hash<std::__cxx11::basic_string<char>\
    \ >; _Pred = std::equal_to<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::unorde"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::sort(sentence.begin(), sentence.end());\n\
    \    int start = 0;\n    int end = sentence.size() - 1;\n    while(start <= end)\
    \ {\n        if(isPrime(sentence.size()-start)) {\n            end = start+1;\n\
    \        } else {\n            start = end+1;\n        }\n    }\n    std::string\
    \ re = \"\";\n    for(int i = start; i <= end; i++) {\n        re += sentence.at(i);\n\
    \    }\n    return re;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp537vg0rn.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp537vg0rn.cpp:22:12: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   22 |         if(isPrime(sentence.size()-start))\
    \ {\n      |            ^~~~~~~\n      |            stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    \n    // Store the original string.\n\
    \    std::string orig = sentence;\n    // Find the index of the first non-space\
    \ character.\n    int idx = sentence.length();\n    while (idx >= 0 && sentence[idx]\
    \ != ' ') --idx;\n    // Store the original string in lower case and append it\
    \ to output string.\n    std::string out = \"\";\n    \n    // If the first non-space\
    \ character was found then get the length\n    // of the string.\n    if (idx\
    \ > 0)\n        out = sentence.substr(0, idx).to_lower();\n    \n    // Iterate\
    \ through the string and remove all repeated words.\n    int last = 1;\n    for\
    \ (auto &c : sentence) {\n        if (std::find(out.begin(), out.end(), c) ==\
    \ out.end()) {\n            // Add the new word into output string.\n        \
    \    out += c;\n            if (last * 2 <= out.length()) {\n                //\
    \ If the length of the word is greater than the output string length,\n      \
    \          // then add the last word of output string.\n                out +=\
    \ out.back();\n            }\n            ++last;\n        }\n    }\n    \n  \
    \  // Remove all repeated words from output string.\n    int last = 1;\n    for\
    \ (auto &c : out) {\n        if (std::find(orig.begin(), orig.end(), c) == orig.end())\
    \ {\n            // Remove the last word from the output string.\n           \
    \ out += '_';\n            ++last;\n        }\n    }\n    \n    return out;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjuro59ga.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpjuro59ga.cpp:30:39: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018to_lower\u2019\n   30 |         out = sentence.substr(0,\
    \ idx).to_lower();\n      |                                       ^~~~~~~~\n/tmp/tmpjuro59ga.cpp:48:9:\
    \ error: redeclaration of \u2018int last\u2019\n   48 |     int last = 1;\n  \
    \    |         ^~~~\n/tmp/tmpjuro59ga.cpp:33:9: note: \u2018int last\u2019 previously\
    \ declared here\n   33 |     int last = 1;\n      |         ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Split sentence into array\
    \ of words\n    std::vector<int> words(std::sregex_token_iterator(sentence.begin(),\
    \ sentence.end(), std::regex(\"\\\\s+\"), -1), std::sregex_token_iterator());\n\
    \n    // Find prime number for each word in array\n    std::map<int, bool> primes;\n\
    \    for (auto word : words) {\n        if (!primes.count(word)) {\n         \
    \   bool is_prime = true;\n            for (int i = 2; i <= word; ++i) {\n   \
    \             if (word % i == 0) {\n                    is_prime = false;\n  \
    \                  break;\n                }\n            }\n            primes[word]\
    \ = is_prime;\n        }\n    }\n\n    // Sort map by key for ordered output\n\
    \    std::map<int, bool>::iterator itr;\n    for (primes.begin(); primes.end()\
    \ != itr; primes.begin()) {\n        auto itr = primes.find(*itr);\n        std::string\
    \ prime = std::to_string(*itr);\n        if (primes.size() == itr->second) {\n\
    \            prime = prime+\" \";\n        }\n        sentence = sentence.substr(0,\
    \ itr->first) + prime + sentence.substr(itr->first+1);\n        primes.erase(itr);\n\
    \    }\n\n    // Find space between words and return string\n    return sentence;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsqrcmj43.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpsqrcmj43.cpp:19:111: error: use of deleted function \u2018std::__cxx11::regex_token_iterator<_Bi_iter,\
    \ _Ch_type, _Rx_traits>::regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&&,\
    \ int, std::regex_constants::match_flag_type) [with _Bi_iter = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; _Ch_type = char; _Rx_traits = std::__cxx11::regex_traits<char>;\
    \ std::__cxx11::regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::regex_type\
    \ = std::__cxx11::basic_regex<char>]\u2019\n   19 |     std::vector<int> words(std::sregex_token_iterator(sentence.begin(),\
    \ sentence.end(), std::regex(\"\\\\s+\"), -1), std::sregex_token_iterator());\n\
    \      |                                                                     \
    \                                          ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsqrcmj43.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2732:7:\
    \ note: declared here\n 2732 |       regex_token_iterator(_Bi_iter, _Bi_iter,\
    \ const regex_type&&, int = 0,\n      |       ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsqrcmj43.cpp:39:33:\
    \ error: use of \u2018itr\u2019 before deduction of \u2018auto\u2019\n   39 |\
    \         auto itr = primes.find(*itr);\n      |                             \
    \    ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string res;\n  int j=0;\n\
    \  for(int i=0; i<sentence.length(); i++){\n    if(isPrime(j) && isAlpha(sentence.at(i))){\n\
    \      res+=sentence.at(i);\n      j++;\n    }\n  }\n  return res;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr1zmhpb7.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpr1zmhpb7.cpp:21:8: error: \u2018isPrime\u2019 was not declared in this\
    \ scope; did you mean \u2018stime\u2019?\n   21 |     if(isPrime(j) && isAlpha(sentence.at(i))){\n\
    \      |        ^~~~~~~\n      |        stime\n/tmp/tmpr1zmhpb7.cpp:21:22: error:\
    \ \u2018isAlpha\u2019 was not declared in this scope; did you mean \u2018isalpha\u2019\
    ?\n   21 |     if(isPrime(j) && isAlpha(sentence.at(i))){\n      |           \
    \           ^~~~~~~\n      |                      isalpha\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::unordered_map<char, size_t>\
    \ word_count;\n    for(char c:sentence) {\n        word_count[c]++;\n    }\n \
    \   for(auto &entry:word_count) {\n        if(entry.second == 1) {\n         \
    \   entry.second = 2;\n        }\n    }\n\n    std::string res;\n    for(auto\
    \ &entry:word_count) {\n        if(entry.second == 2) {\n            res.push_back(\
    \ entry.first );\n        }\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpcn6z3mz8: /tmp/tmpcn6z3mz8.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ words[sentence.size()];\n    for(int i = 0; i<sentence.size(); i++) {\n    \
    \    words[i] = sentence[i];\n    }\n    for(int i = 1; i<101; i++) {\n      \
    \  if(!isPrime(i)) {\n            for(int j = 0; j < i; j++) {\n             \
    \   if(j == 0 || j%words[j-1] != 0) {\n                    words[j] = words[j-1];\n\
    \                }\n                else {\n                    break;\n     \
    \           }\n            }\n            ans += words[i];\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy4_4fgmz.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpy4_4fgmz.cpp:24:13: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   24 |         if(!isPrime(i))\
    \ {\n      |             ^~~~~~~\n      |             stime\n/tmp/tmpy4_4fgmz.cpp:26:31:\
    \ error: no match for \u2018operator%\u2019 (operand types are \u2018int\u2019\
    \ and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   26 |                 if(j == 0 || j%words[j-1] != 0) {\n      |       \
    \                       ~^~~~~~~~~~~\n      |                              | \
    \         |\n      |                              int        std::string {aka\
    \ std::__cxx11::basic_string<char>}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:603,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpy4_4fgmz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/valarray_after.h:409:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__modulus,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__modulus, typename\
    \ _Dom1::value_type>::result_type> std::operator%(const std::_Expr<_Dom1, typename\
    \ _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  409 |     _DEFINE_EXPR_BINARY_OPERATOR(%, __modulus)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/valarray_after.h:409:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy4_4fgmz.cpp:26:41:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018int\u2019\n   26 |                 if(j == 0 || j%words[j-1] != 0)\
    \ {\n      |                                         ^\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:603,\n        \
    \         from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpy4_4fgmz.cpp:2:\n/s"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::unordered_map<char,int> word_count;\n\
    \  std::string result;\n  size_t index = 0;\n  while ((index < sentence.length())\
    \ && (sentence[index] != ' ')) {\n    word_count[sentence[index]] = 1;\n    index++;\n\
    \  }\n  word_count[' '] = 1;\n  index++;\n  while (index < sentence.length())\
    \ {\n    std::string temp = sentence[index];\n    if (word_count.find(temp) !=\
    \ word_count.end()) {\n      result += temp;\n      index++;\n      while (index\
    \ < sentence.length()) {\n        temp += sentence[index];\n        if (word_count.find(temp)\
    \ != word_count.end()) {\n          result += \" \" + temp;\n          index++;\n\
    \        }\n        else {\n          index++;\n        }\n      }\n    }\n  \
    \  index++;\n  }\n  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2dmeq9ro.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp2dmeq9ro.cpp:28:38: error: conversion from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   28 |     std::string\
    \ temp = sentence[index];\n      |                                      ^\n/tmp/tmp2dmeq9ro.cpp:29:29:\
    \ error: no matching function for call to \u2018std::unordered_map<char, int>::find(std::string&)\u2019\
    \n   29 |     if (word_count.find(temp) != word_count.end()) {\n      |      \
    \                       ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/unordered_map:47,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:117,\n\
    \                 from /tmp/tmp2dmeq9ro.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/unordered_map.h:920:7:\
    \ note: candidate: \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator\
    \ std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::find(const key_type&) [with\
    \ _Key = char; _Tp = int; _Hash = std::hash<char>; _Pred = std::equal_to<char>;\
    \ _Alloc = std::allocator<std::pair<const char, int> >; std::unordered_map<_Key,\
    \ _Tp, _Hash, _Pred, _Alloc>::iterator = std::__detail::_Node_iterator<std::pair<const\
    \ char, int>, false, false>; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_type\
    \ = char]\u2019\n  920 |       find(const key_type& __x)\n      |       ^~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/unordered_map.h:920:28:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const key_type&\u2019\
    \ {aka \u2018const char&\u2019}\n  920 |       find(const key_type& __x)\n   \
    \   |            ~~~~~~~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/unordered_map.h:924:7:\
    \ note: candidate: \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator\
    \ std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::find(const key_type&) co"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::map<char, int> cnt;\n  \
    \  for (auto c: sentence)\n        cnt[c]++;\n\n    auto key = [](const char c){\
    \ return c; };\n    \n    auto it = std::min_element(std::begin(cnt), std::end(cnt),\
    \ key);\n    \n    std::string res;\n    for (auto i : it)\n        res += std::to_string(cnt[key(i)])\
    \ + \" \";\n    std::reverse(std::begin(res), std::end(res));\n    return res;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpff38p84g.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpff38p84g.cpp:27:19: error: no matching function for call to \u2018\
    begin(std::_Rb_tree_iterator<std::pair<const char, int> >&)\u2019\n   27 |   \
    \  for (auto i : it)\n      |                   ^~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/range_access.h:36,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:54,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpff38p84g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/initializer_list:89:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp* std::begin(std::initializer_list<_Tp>)\u2019\
    \n   89 |     begin(initializer_list<_Tp> __ils) noexcept\n      |     ^~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/initializer_list:89:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpff38p84g.cpp:27:19:\
    \ note:   \u2018std::_Rb_tree_iterator<std::pair<const char, int> >\u2019 is not\
    \ derived from \u2018std::initializer_list<_Tp>\u2019\n   27 |     for (auto i\
    \ : it)\n      |                   ^~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:54,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylak"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // Write your code here\n  std::stringstream\
    \ ss(sentence);\n  std::string word;\n  std::vector<int> primes;\n  while (ss\
    \ >> word) {\n    // Check whether it's prime\n    int isPrime = 1;\n    for (int\
    \ i = 2; i <= sqrt(word.size()); i++) {\n      if (word % i == 0)\n        isPrime\
    \ = 0;\n    }\n    if (isPrime)\n      primes.push_back(word.size());\n  }\n\n\
    \  std::string result;\n  for (int i = 0; i < primes.size(); i++) {\n    result\
    \ += primes[i];\n    result += \" \";\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpw9d_tsvu.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpw9d_tsvu.cpp:26:16: error: no match for \u2018operator%\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018int\u2019)\n   26 |       if (word % i == 0)\n      |           ~~~~\
    \ ^ ~\n      |           |      |\n      |           |      int\n      |     \
    \      std::string {aka std::__cxx11::basic_string<char>}\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:603,\n        \
    \         from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpw9d_tsvu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/valarray_after.h:409:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__modulus,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__modulus, typename\
    \ _Dom1::value_type>::result_type> std::operator%(const std::_Expr<_Dom1, typename\
    \ _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  409 |     _DEFINE_EXPR_BINARY_OPERATOR(%, __modulus)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/valarray_after.h:409:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpw9d_tsvu.cpp:26:18:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   26 |       if (word % i == 0)\n      |                  ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:603,\n   \
    \              from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpw9d_tsvu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/valarray_after.h:409:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__modulus,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__m"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // write your code here\n   \
    \ \n    std::string newString = \"\";\n    bool flag = true;\n    for(int i =\
    \ 0; i < sentence.size(); i++) {\n        if(!flag) {\n            newString +=\
    \ sentence[i];\n            flag = false;\n        }\n        else {\n       \
    \     if(isPrime(sentence[i])) {\n                newString += sentence[i];\n\
    \                flag = true;\n            }\n        }\n    }\n    return newString;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpriml5tsg.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpriml5tsg.cpp:28:16: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   28 |             if(isPrime(sentence[i]))\
    \ {\n      |                ^~~~~~~\n      |                stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::sort(sentence.begin(), sentence.end());\n\
    \  // Step 1: Find the first non-prime number\n  std::string ret(sentence);\n\
    \  for (int i = 2; i * i <= sentence.length(); ++i) {\n    while (std::find(sentence.begin(),\
    \ sentence.end(), ' ') != sentence.end()) {\n      auto it = sentence.find_first_of(\"\
    \ \");\n      if (it == sentence.end())\n        it = sentence.length();\n   \
    \   auto next = it + 1;\n      if (next < sentence.length()) {\n        if (std::find(sentence.begin(),\
    \ sentence.end(), ' ') != sentence.end()) {\n          std::string temp = sentence.substr(it,\
    \ next - it);\n          assert(std::is_sorted(temp.begin(), temp.end()));\n \
    \         ret += temp + \" \";\n          it = next;\n        }\n      }\n   \
    \ }\n    if (sentence[i] != ' ')\n      break;\n  }\n  assert(std::find(sentence.begin(),\
    \ sentence.end(), ' ') == sentence.end());\n  assert(ret.size() == sentence.size());\n\
    \  return ret;\n}\nint main() {\n    auto candidate = words_in_sentence;\n   \
    \ assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9lc9th6q.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp9lc9th6q.cpp:24:14: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018long unsigned int\u2019 and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   24 |       if (it == sentence.end())\n      |           ~~ ^~\
    \ ~~~~~~~~~~~~~~\n      |           |                 |\n      |           long\
    \ unsigned int std::__cxx11::basic_string<char>::iterator {aka __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9lc9th6q.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:886:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  886 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:886:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9lc9th6q.cpp:24:30:\
    \ note:   mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL,\
    \ _Container>\u2019 and \u2018long unsigned int\u2019\n  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::set<int> s;\n  for (int i\
    \ = 0; i < sentence.size(); i++) {\n    if (s.find(sentence[i]) == s.end()) {\n\
    \      s.insert(sentence[i]);\n    }\n  }\n  std::string ans = \"\";\n  for (std::set<int>::iterator\
    \ it = s.begin(); it != s.end(); ++it) {\n    ans.append(\" \");\n    ans.append(*it);\n\
    \  }\n  return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk7uk51lv.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpk7uk51lv.cpp:27:19: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::append(const int&)\u2019\n   27 |     ans.append(*it);\n\
    \      |                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpk7uk51lv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1263:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::append(const _CharT*) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \ <near match>\n 1263 |       append(const _CharT* __s)\n      |       ^~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1263:7:\
    \ note:   conversion of argument 1 would be ill-formed:\n/tmp/tmpk7uk51lv.cpp:27:16:\
    \ error: invalid conversion from \u2018int\u2019 to \u2018const char*\u2019 [-fpermissive]\n\
    \   27 |     ans.append(*it);\n      |                ^~~\n      |           \
    \     |\n      |                int\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \             "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n\
    \    char c = ' ';\n    int n = sentence.length();\n    for(int i = 1; i < n;\
    \ ++i)\n    {\n        c = sentence.at(i);\n        if((int)c % 2 != 0)\n    \
    \        result += c;\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp0ojbdbef: /tmp/tmp0ojbdbef.cpp:31: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string new_sentence = \"\
    \";\n    int n = sentence.length();\n    int s = 0;\n    string tmp;\n    for\
    \ (int i = 0; i < n; i++) {\n        if (sentence[i] == ' ') {\n            tmp\
    \ = new_sentence;\n            while (tmp.find(\"1 \", tmp.size()) != std::string::npos)\
    \ {\n                new_sentence = tmp;\n                ++s;\n            }\n\
    \            new_sentence.clear();\n        } else {\n            new_sentence\
    \ += sentence[i];\n        }\n    }\n    return new_sentence;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp284xmpsm.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp284xmpsm.cpp:21:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   21 |     string tmp;\n    \
    \  |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp284xmpsm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmp284xmpsm.cpp:24:13:\
    \ error: \u2018tmp\u2019 was not declared in this scope; did you mean \u2018tm\u2019\
    ?\n   24 |             tmp = new_sentence;\n      |             ^~~\n      | \
    \            tm\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n\
    \  std::string word;\n  std::string newSentence;\n  std::istringstream ss(sentence);\n\
    \  while (std::getline(ss, word, ' ')) {\n    if (word.length() == 0) {\n    \
    \  continue;\n    }\n    words.push_back(word);\n  }\n  for (size_t i = 0; i <\
    \ words.size(); i++) {\n    std::string newWord = words[i];\n    if (newWord.length()\
    \ % 2 == 0) {\n      int j = newWord.length() / 2;\n      while (j > 0) {\n  \
    \      if (newWord[j] % 2 == 0) {\n          break;\n        }\n        j--;\n\
    \      }\n      newWord = words[i];\n      int k = j + 1;\n      bool flag = true;\n\
    \      while (k > 0) {\n        if (newWord[k] % 2 == 0) {\n          flag = false;\n\
    \          break;\n        }\n        k--;\n      }\n      if (flag == true) {\n\
    \        newWord = words[i];\n      }\n    }\n    newSentence += newWord + \"\
    \ \";\n  }\n  return newSentence;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpw5at8oxk: /tmp/tmpw5at8oxk.cpp:58: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    const char delimiter = ' ';\n\
    \    // Find the beginning of the sentence.\n    size_t pos = 0;\n    pos = sentence.find(delimiter,\
    \ pos);\n    if (pos != string::npos) {\n        string word = sentence.substr(0,\
    \ pos);\n        string output = word;\n        size_t size = output.length();\n\
    \        vector<int> prime;\n        for (int i = 2; i < size; ++i) {\n      \
    \      if (output.length() == i) {\n                prime = prime_number(word);\n\
    \            }\n            if (output.length() == i) {\n                if (output.length()\
    \ > i) {\n                    string temp = output;\n                    output\
    \ = \"\";\n                    for (int j = 0; j < i; ++j) {\n               \
    \         output += temp.at(j);\n                    }\n                }\n  \
    \              if (output.length() == i) {\n                    output += \" \"\
    ;\n                }\n            }\n        }\n        std::sort(prime.begin(),\
    \ prime.end());\n        output += \" \";\n        return output;\n    }\n   \
    \ return \"\";\n}\nint main() {\n    auto candidate = words_in_sentence;\n   \
    \ assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpd1vv4dfe.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpd1vv4dfe.cpp:22:16: error: \u2018string\u2019 has not been declared\n\
    \   22 |     if (pos != string::npos) {\n      |                ^~~~~~\n/tmp/tmpd1vv4dfe.cpp:23:9:\
    \ error: \u2018string\u2019 was not declared in this scope; did you mean \u2018\
    std::string\u2019?\n   23 |         string word = sentence.substr(0, pos);\n \
    \     |         ^~~~~~\n      |         std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpd1vv4dfe.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpd1vv4dfe.cpp:24:15:\
    \ error: expected \u2018;\u2019 before \u2018output\u2019\n   24 |         string\
    \ output = word;\n      |               ^~~~~~~\n      |               ;\n/tmp/tmpd1vv4dfe.cpp:25:23:\
    \ error: \u2018output\u2019 was not declared in this scope\n   25 |         size_t\
    \ size = output.length();\n      |                       ^~~~~~\n/tmp/tmpd1vv4dfe.cpp:26:9:\
    \ error: \u2018vector\u2019 was not declared in this scope; did you mean \u2018\
    std::vector\u2019?\n   26 |         vector<int> prime;\n      |         ^~~~~~\n\
    \      |         std::vector\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x8"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int len = sentence.length();\n\
    \    int prime_count = 0;\n    std::string ans = \"\";\n    for (int i = 0; i\
    \ < len; i++) {\n        char c = sentence[i];\n        if (isspace(c)) {\n  \
    \          continue;\n        }\n        for (int j = i; j <= len; j++) {\n  \
    \          char d = sentence[j];\n            if (d == c) {\n                prime_count++;\n\
    \            }\n        }\n        if (prime_count <= 1) {\n            ans +=\
    \ c;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp1ojx6sh2: /tmp/tmp1ojx6sh2.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> vs =\
    \ split(sentence, \" \");\n    std::string res = \"\";\n    for (auto it = std::begin(vs);\
    \ it != std::end(vs); it++) {\n        auto x = find_first_not_prime(std::distance(it,\
    \ std::end(vs)));\n        res += *it;\n        if (x == std::end(vs))\n     \
    \       break;\n        res = res.substr(0, x) + \" \";\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphuc0i3q7.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmphuc0i3q7.cpp:18:35: error: \u2018split\u2019 was not declared in this\
    \ scope\n   18 |     std::vector<std::string> vs = split(sentence, \" \");\n \
    \     |                                   ^~~~~\n/tmp/tmphuc0i3q7.cpp:21:18: error:\
    \ \u2018find_first_not_prime\u2019 was not declared in this scope\n   21 |   \
    \      auto x = find_first_not_prime(std::distance(it, std::end(vs)));\n     \
    \ |                  ^~~~~~~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // write your code here\n   \
    \ std::unordered_set<std::string> primes;\n    std::string result = \"\";\n  \
    \  std::string buffer = \"\";\n    // buffer is a temporary string for storing\
    \ \"a\" and its length\n    // this step is required only because string doesn't\
    \ have an append function\n    std::string buffer1 = \"\";\n    int n = sentence.size();\n\
    \    int count = 0;\n    int i = 0;\n\n    while (i < n) {\n        if (buffer.size()\
    \ > 0) {\n            buffer = buffer + \" \";\n            buffer1 = buffer1;\n\
    \        }\n        buffer = buffer + sentence[i];\n        i = i + 1;\n     \
    \   // now buffer has \"a\" and its length\n        buffer1 = buffer1 + sentence[i];\n\
    \        // now buffer1 has \"a \" and its length\n        size_t len1 = buffer1.length();\n\
    \        if (primes.count(buffer1) && len1 == 2) {\n            primes.erase(buffer1);\n\
    \            buffer1 = \"\";\n            count = 0;\n            i = i - 1;\n\
    \        }\n    }\n    // now buffer is \"a t\" its length is 2, so \"a\" is removed.\n\
    \    // buffer1 = \"a t\"\n    // buffer = \"t\"\n    // now buffer is \"t\" its\
    \ length is 2, so \"t\" is removed.\n    // buffer1 = \"t\"\n    // buffer = \"\
    a\"\n    // now buffer is \"a\" its length is 2, so \"a\" is removed.\n    //\
    \ buffer1 = \"\"\n    // buffer = \"\"\n    // now buffer is \"\"\n    // buffer\
    \ = \"a t\"\n    // buffer1 = \"\"\n    // now buffer1 is \"\"\n    int i = 0;\n\
    \    while (i < n) {\n        std::string temp = \"\";\n        // temp is a temporary\
    \ string for storing characters from buffer\n        temp = buffer;\n        //\
    \ now temp is \"a t\"\n        // buffer is \"a t\"\n        // now temp is \"\
    a t \"\n        size_t len1 = temp.length();\n        // now temp is \"a t \"\n\
    \        // buffer1 = \"\"\n        // now temp is \"a\"\n        // now temp\
    \ is \"a a\"\n        // now temp is \"a a a\"\n        // now temp is \"a\"\n\
    \        size_t count = 0;\n        while (i < n) {\n            std::string temp2\
    \ = \"\";\n            temp2 = temp;\n            temp2 = temp2 + temp[i];\n \
    \           // now temp2 is \"a a\"\n            size_t len2 = temp2.length();\n\
    \            // now temp2 is \"a a a\"\n            // now temp2 is \"a a a a\"\
    \n            // now temp2 is \"a a a a a\"\n            if (primes.count(temp2)\
    \ && len2 == len1) {\n                primes.erase(temp2);\n                count++;\n\
    \                // now count is 2\n                temp2 = \"\";\n          \
    \      temp2 = temp + temp[i];\n\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm617wihq.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpm617wihq.cpp:60:9: error: redeclaration of \u2018int i\u2019\n   60\
    \ |     int i = 0;\n      |         ^\n/tmp/tmpm617wihq.cpp:27:9: note: \u2018\
    int i\u2019 previously declared here\n   27 |     int i = 0;\n      |        \
    \ ^\n/tmp/tmpm617wihq.cpp:93:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   93 | int main() {\n      |            ^\n/tmp/tmpm617wihq.cpp:102:1:\
    \ error: expected \u2018}\u2019 at end of input\n  102 | }\n      | ^\n/tmp/tmpm617wihq.cpp:76:23:\
    \ note: to match this \u2018{\u2019\n   76 |         while (i < n) {\n      |\
    \                       ^\n/tmp/tmpm617wihq.cpp:102:1: error: expected \u2018\
    }\u2019 at end of input\n  102 | }\n      | ^\n/tmp/tmpm617wihq.cpp:61:19: note:\
    \ to match this \u2018{\u2019\n   61 |     while (i < n) {\n      |          \
    \         ^\n/tmp/tmpm617wihq.cpp:102:1: error: expected \u2018}\u2019 at end\
    \ of input\n  102 | }\n      | ^\n/tmp/tmpm617wihq.cpp:17:53: note: to match this\
    \ \u2018{\u2019\n   17 | std::string words_in_sentence(std::string sentence) {\n\
    \      |                                                     ^\n/tmp/tmpm617wihq.cpp:102:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  102 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    vector<int>\
    \ primes;\n    for (auto &c: sentence) {\n        if (c == '_') {\n          \
    \  primes.push_back(0);\n        } else {\n            for (int &p: primes) {\n\
    \                if (p != 0 && c % p == 0) {\n                    ans += c;\n\
    \                    break;\n                }\n            }\n            primes.push_back(c);\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpev34xtmz.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpev34xtmz.cpp:19:5: error: \u2018vector\u2019 was not declared in this\
    \ scope; did you mean \u2018std::vector\u2019?\n   19 |     vector<int> primes;\n\
    \      |     ^~~~~~\n      |     std::vector\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpev34xtmz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:386:11:\
    \ note: \u2018std::vector\u2019 declared here\n  386 |     class vector : protected\
    \ _Vector_base<_Tp, _Alloc>\n      |           ^~~~~~\n/tmp/tmpev34xtmz.cpp:19:12:\
    \ error: expected primary-expression before \u2018int\u2019\n   19 |     vector<int>\
    \ primes;\n      |            ^~~\n/tmp/tmpev34xtmz.cpp:22:13: error: \u2018primes\u2019\
    \ was not declared in this scope\n   22 |             primes.push_back(0);\n \
    \     |             ^~~~~~\n/tmp/tmpev34xtmz.cpp:24:26: error: \u2018primes\u2019\
    \ was not declared in this scope\n   24 |             for (int &p: primes) {\n\
    \      |                          ^~~~~~\n/tmp/tmpev34xtmz.cpp:30:13: error: \u2018\
    primes\u2019 was not declared in this scope\n   30 |             primes.push_back(c);\n\
    \      |             ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string new_sentence;\n \
    \   for (int i = 0; i < sentence.length(); i++) {\n        char c = sentence[i];\n\
    \        for (int j = i + 1; j < sentence.length(); j++) {\n            if (wordIsPrime(sentence[j]))\
    \ {\n                if (new_sentence.empty())\n                    new_sentence\
    \ = c;\n                else if (new_sentence != c)\n                    new_sentence\
    \ += \" \" + c;\n            }\n        }\n    }\n    return new_sentence;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg4g10vho.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpg4g10vho.cpp:22:17: error: \u2018wordIsPrime\u2019 was not declared\
    \ in this scope\n   22 |             if (wordIsPrime(sentence[j])) {\n      |\
    \                 ^~~~~~~~~~~\n/tmp/tmpg4g10vho.cpp:25:39: error: no match for\
    \ \u2018operator!=\u2019 (operand types are \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} and \u2018char\u2019)\n   25 |       \
    \          else if (new_sentence != c)\n      |                          ~~~~~~~~~~~~\
    \ ^~ ~\n      |                          |               |\n      |          \
    \                |               char\n      |                          std::string\
    \ {aka std::__cxx11::basic_string<char>}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpg4g10vho.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1037:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1037 |     operator!=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1037:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpg4g10vho.cpp:25:42:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   25\
    \ |                 else if (new_sentence != c)\n      |                     \
    \                     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpg4g10vho.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1112:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ b"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  assert(sentence.length() <= 100);\n\
    \  assert(std::all_of(sentence.begin(), sentence.end(), ::isalpha));\n  \n  std::string\
    \ res;\n  \n  long long ans = 0;\n  long long p = 1;\n  for (auto i : sentence)\
    \ {\n    ans *= p;\n    ans += static_cast<long long>(i);\n    p++;\n  }\n\n \
    \ while (ans % 2 != 0) {\n    ans += 1;\n  }\n\n  while (res.length() < sentence.length())\
    \ {\n    res += \"0\";\n  }\n  for (auto i : sentence) {\n    while (ans > 0 &&\
    \ res.length() % ans != 0) {\n      res += \"0\";\n    }\n    res += i;\n    ans\
    \ /= p;\n    p++;\n  }\n\n  return res;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp06qsamyu: /tmp/tmp06qsamyu.cpp:19: std::string words_in_sentence(std::string):\
    \ Assertion `std::all_of(sentence.begin(), sentence.end(), ::isalpha)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    \n    std::string new_sentence\
    \ = \"\";\n    \n    for(auto &i : sentence){\n        if((i!=' ') && (i!='\\\
    0')){\n            for(int j=0;j<new_sentence.length();j++){\n               \
    \ if((new_sentence[j] == ' ')||(new_sentence[j] == '\\0')){\n                \
    \    new_sentence.push_back(i);\n                    break;\n                }\n\
    \            }\n        }\n    }\n    \n    for(auto &i : new_sentence){\n   \
    \     for(int j=0;j<new_sentence.length();j++){\n            if((new_sentence[j]\
    \ == ' ')||(new_sentence[j] == '\\0')){\n                new_sentence.erase(new_sentence.begin()+j);\n\
    \                break;\n            }\n        }\n    }\n    \n    return new_sentence;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmppomu8otx: /tmp/tmppomu8otx.cpp:45: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Write your code here\n   \
    \ \n    std::vector<int> lengths;\n    int len = sentence.length();\n    for(int\
    \ i=0;i<len;i++) {\n        lengths.push_back(1);\n    }\n    for(int i=1;i<len;i++)\
    \ {\n        for(int j=0;j<i;j++) {\n            int k = lengths[j];\n       \
    \     if(k % i == 0) {\n                lengths[j] = (i*(i+1)/2+i-1);\n      \
    \      }\n        }\n    }\n    \n    std::unordered_map<int, std::list<int>>\
    \ m;\n    std::string ans = \"\";\n    \n    for(int i=0;i<len;i++) {\n      \
    \  int s = lengths[i];\n        if(!m.count(s)) {\n            m.insert(std::pair<int,\
    \ std::list<int>>(s, {i}));\n        } else {\n            auto list = m[s];\n\
    \            for(int j=0;j<list.size();j++) {\n                int t = list[j];\n\
    \                if(!m.count(t+s)) {\n                    m.insert(std::pair<int,\
    \ std::list<int>>(t+s, {i}));\n                    break;\n                }\n\
    \            }\n        }\n    }\n    \n    for(auto it = m.begin();it!=m.end();it++)\
    \ {\n        if(!ans.empty()) {\n            ans += \" \";\n        }\n      \
    \  ans += it->first;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvecoe0pa.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpvecoe0pa.cpp:44:29: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::__cxx11::list<int>\u2019 and \u2018int\u2019)\n   44 |\
    \                 int t = list[j];\n      |                             ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Write your code here\n   \
    \ // Your code goes here\n    \n    std::string result = \"\";\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        int count = 0;\n        for (int j\
    \ = i + 1; j < n; j++) {\n            if (isPrime(sentence.substr(i, j).length()))\
    \ {\n                count++;\n            }\n        }\n        if (count ==\
    \ 1) {\n            result += sentence.substr(i, 1);\n        }\n    }\n    \n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpz3817tdw.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpz3817tdw.cpp:26:17: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   26 |             if (isPrime(sentence.substr(i,\
    \ j).length())) {\n      |                 ^~~~~~~\n      |                 stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int n = sentence.size();\n  \
    \  string ans;\n    bool flag = false;\n    for(int i = 0; i < n; i++) {\n   \
    \     if(flag) {\n            ans += \" \";\n        }\n        ans += sentence[i];\n\
    \        flag = true;\n        for(int j = 0; j < n; j++) {\n            if(j\
    \ == i) {\n                continue;\n            }\n            if(!(i % j ==\
    \ 0)) {\n                flag = false;\n            }\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0s6ujhho.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp0s6ujhho.cpp:19:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   19 |     string ans;\n    \
    \  |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0s6ujhho.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmp0s6ujhho.cpp:23:13:\
    \ error: \u2018ans\u2019 was not declared in this scope; did you mean \u2018abs\u2019\
    ?\n   23 |             ans += \" \";\n      |             ^~~\n      |       \
    \      abs\n/tmp/tmp0s6ujhho.cpp:25:9: error: \u2018ans\u2019 was not declared\
    \ in this scope; did you mean \u2018abs\u2019?\n   25 |         ans += sentence[i];\n\
    \      |         ^~~\n      |         abs\n/tmp/tmp0s6ujhho.cpp:36:12: error:\
    \ \u2018ans\u2019 was not declared in this scope; did you mean \u2018abs\u2019\
    ?\n   36 |     return ans;\n      |            ^~~\n      |            abs\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string s = sentence;\n \
    \   std::string t = s;\n    // split string into words\n    s.erase(std::remove(s.begin(),\
    \ s.end(), '\\n'), s.end()); // remove the newline char from the string\n    std::vector<std::string>\
    \ v;\n    std::string word;\n    for (std::string::iterator i = s.begin(); i !=\
    \ s.end(); i++) {\n        v.push_back(*i);\n    }\n    // count prime number\n\
    \    int count = 0;\n    int size = v.size();\n    \n    // find first prime number\n\
    \    for (int i = 0; i < v.size(); i++) {\n        while (v[count] % v[i] != 0)\
    \ {\n            count++;\n        }\n    }\n    \n    // print prime number\n\
    \    for (int i = 1; i <= count; i++) {\n        if (v[i] > 1 && v[i] % 2 == 0\
    \ && v[i] % v[i - 1] == 0 && v[i] % v[i + 1] == 0) {\n            \n         \
    \   // delete first prime number and print new\n            std::string word1;\n\
    \            std::cout << v[i];\n            std::cout << \" \";\n           \
    \ for (std::string::iterator i = t.begin(); i != t.end(); i++) {\n           \
    \     word1 += *i;\n                std::cout << v[i];\n                std::cout\
    \ << \" \";\n            }\n            std::string word2 = word1;\n         \
    \   \n            \n            \n            // delete last prime number and\
    \ print new\n            std::string word3;\n            std::cout << v[i - 1];\n\
    \            std::cout << \" \";\n            for (std::string::iterator i = t.begin();\
    \ i != t.end(); i++) {\n                word3 += *i;\n                std::cout\
    \ << v[i - 1];\n                std::cout << \" \";\n            }\n         \
    \   std::string word4 = word3;\n            \n            \n            // delete\
    \ middle prime numbers and print new\n            std::string word5;\n       \
    \     std::cout << v[i - 1];\n            std::cout << \" \";\n            for\
    \ (std::string::iterator i = t.begin() + i; i != t.end(); i += 2) {\n        \
    \        word5 += *i;\n                std::cout << v[i - 1];\n              \
    \  std::cout << \" \";\n            }\n            std::string word6 = word5;\n\
    \            \n            // delete middle prime numbers and print new\n    \
    \        std::string word7;\n            std::cout << v[i - 1];\n            std::cout\
    \ << \" \";\n            for (std::string::iterator i = t.begin() + i; i != t.end();\
    \ i += 2) {\n                word7 += *i;\n                std::cout << v[i -\
    \ 1];\n                std::cout << \" \";\n            }\n            std::string\
    \ word8 = word7;\n            \n            // delete middle prime numbers and\
    \ print new\n            std::string word9;\n            std::cout << v[i - 1];\n\
    \            std::cout << \" \";\n            for (std::string::iterator i = t.begin()\
    \ + i; i != t.end(); i += 2) {\n                word9 += \n}\nint main() {\n \
    \   auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjcqtn1v6.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpjcqtn1v6.cpp:25:23: error: no matching function for call to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::push_back(char&)\u2019\n   25\
    \ |         v.push_back(*i);\n      |                       ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpjcqtn1v6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |                 ~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<bool> v(sentence.begin(),\
    \ sentence.end());\n    std::sort(v.begin(), v.end());\n    int sum = 0;\n   \
    \ for (auto i : v)\n    {\n        if (i == true)\n            sum += i;\n   \
    \ }\n    std::sort(v.begin(), v.end());\n    int size = v.size();\n    if (sum\
    \ % size == 0)\n    {\n        int sum2 = 0;\n        for (auto i : v)\n     \
    \   {\n            if (i == true)\n                sum2 += i;\n        }\n   \
    \     return sentence.substr(0, sentence.find(\" \", 0));\n    }\n    return \"\
    \";\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp8nfbccrn: /tmp/tmp8nfbccrn.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Code here\n    int n = sentence.length();\n\
    \    int a[n];\n    for(int i=0;i<n;i++){\n        a[i]=0;\n    }\n    for(int\
    \ i=0;i<n;i++){\n        if((sentence[i]>='a' && sentence[i]<='z') || (sentence[i]>='A'\
    \ && sentence[i]<='Z')){\n            for(int j=i;j<n;j++){\n                if((sentence[i]==sentence[j])\
    \ || (sentence[i]==sentence[j-1])){\n                    a[j]=a[j-1]+1;\n    \
    \                for(int k=0;k<i;k++){\n                        a[k]=a[k]+a[k+1];\n\
    \                    }\n                    break;\n                }\n      \
    \      }\n        }\n    }\n    std::string s = \"\";\n    for(int i=0;i<n;i++){\n\
    \        if(a[i]==0){\n            s+=\" \";\n        }\n        else{\n     \
    \       s+=sentence[i];\n        }\n    }\n    return s;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpsp5r3epo: /tmp/tmpsp5r3epo.cpp:50: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n\
    \    // Write your code here\n    int len = sentence.length();\n    for (int i\
    \ = 0; i < len; i++) {\n        std::cout << i << std::endl;\n        int count\
    \ = 0;\n        for (int j = i; j < len; j++) {\n            if (sentence[i] ==\
    \ sentence[j]) {\n                count++;\n            }\n        }\n       \
    \ if (count == i) {\n            result += sentence[i];\n        }\n    }\n  \
    \  return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: "0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n"
  stderr: "tmp1ppjqof2: /tmp/tmp1ppjqof2.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<bool> primes(10000,\
    \ true);\n    std::string ret = \"\";\n    for (auto &c : sentence)\n        if\
    \ (c == '_')\n            continue;\n        else if (primes[c]) {\n         \
    \   if (primes[ret.length()]) {\n                std::swap(ret, ret);\n      \
    \          std::swap(ret, ret);\n            }\n            else {\n         \
    \       ret.append(c);\n            }\n            primes[c] = false;\n      \
    \      primes[ret.length()] = false;\n        }\n        else if (c != ' ')\n\
    \            ret += c;\n    return ret;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbj9ukr3n.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpbj9ukr3n.cpp:29:29: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::append(char&)\u2019\n   29 |               \
    \  ret.append(c);\n      |                             ^\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n           \
    \      from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpbj9ukr3n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1263:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::append(const _CharT*) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \ <near match>\n 1263 |       append(const _CharT* __s)\n      |       ^~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1263:7:\
    \ note:   conversion of argument 1 would be ill-formed:\n/tmp/tmpbj9ukr3n.cpp:29:28:\
    \ error: invalid conversion from \u2018char\u2019 to \u2018const char*\u2019 [-fpermissive]\n\
    \   29 |                 ret.append(c);\n      |                            ^\n\
    \      |                            |\n      |                            char\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skyl"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Your code here\n    std::string\
    \ res;\n    bool flag = false;\n    int n = 1;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        int j = i + 1;\n        while (j < sentence.length() && !flag)\
    \ {\n            if (sentence[i] == sentence[j] && (!isalpha(sentence[i]) && !isalpha(sentence[j])))\
    \ {\n                flag = true;\n            } else {\n                j++;\n\
    \            }\n        }\n        if (flag) {\n            res += sentence.substr(i,\
    \ j - i);\n            flag = false;\n            n = 1;\n            i = j;\n\
    \        } else {\n            n += 1;\n        }\n    }\n    return res;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp15acu4mu: /tmp/tmp15acu4mu.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    \n    std::string ans = \"\"\
    ;\n    \n    // split string to array of words\n    std::vector < std::string\
    \ > string_words;\n    std::stringstream sstream(sentence);\n    for (std::string\
    \ word; std::getline(sstream, word, ' ');)\n        string_words.push_back(word);\n\
    \    \n    // sort array of words by length\n    std::sort(string_words.begin(),\
    \ string_words.end(), [](const std::string& left, const std::string& right){\n\
    \        return left.length() > right.length();\n    });\n    \n    int prime_counter\
    \ = 0;\n    for (auto& s : string_words)\n    {\n        if (s.length() > 1) {\n\
    \            prime_counter++;\n        }\n    }\n    \n    // generate new string\n\
    \    for (auto& s : string_words) {\n        if (prime_counter > 0 && s.length()\
    \ == prime_counter) {\n            ans += s;\n        }\n    }\n    \n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpwkojhymq: /tmp/tmpwkojhymq.cpp:51: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int n = 0;\n    std::unordered_map<char,\
    \ int> primes;\n    // prime numbers are divisible by 2 or 3\n    for (int i =\
    \ 2; i <= (int)sqrt(sentence.size()); i++) {\n        while (n % i == 0) {\n \
    \           if (primes.find(i) == primes.end()) {\n                primes[i] =\
    \ 1;\n                for (int j = i * i; j <= n; j++) {\n                   \
    \ primes[j] = 0;\n                }\n            } else {\n                primes[i]++;\n\
    \            }\n            n++;\n        }\n    }\n    std::string res = \"\"\
    ;\n    for (char c: sentence) {\n        if (primes.find(c) != primes.end()) {\n\
    \            res += c;\n        }\n    }\n    return res;\n}\nint main() {\n \
    \   auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpu9zsy50v: /tmp/tmpu9zsy50v.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string res;\n  std::string\
    \ word;\n  for (int i = 0; i < sentence.length(); i++) {\n    if (sentence[i]\
    \ == ' ') {\n      res.push_back(word);\n      word.clear();\n    } else {\n \
    \     word.push_back(sentence[i]);\n    }\n  }\n  res.push_back(word);\n  return\
    \ res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr4tkufym.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpr4tkufym.cpp:22:21: error: cannot convert \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018char\u2019\n   22 | \
    \      res.push_back(word);\n      |                     ^~~~\n      |       \
    \              |\n      |                     std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpr4tkufym.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1349:24:\
    \ note:   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1349 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n/tmp/tmpr4tkufym.cpp:28:17: error: cannot\
    \ convert \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018char\u2019\n   28 |   res.push_back(word);\n      |               \
    \  ^~~~\n      |                 |\n      |                 std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Your code here\n    \n   \
    \ size_t start = 0, end = 0, size = 1;\n    \n    while(1) {\n        \n     \
    \   std::string word = sentence[start];\n        \n        if(start == end)\n\
    \            break;\n        \n        while(sentence[end] != ' ' && end < sentence.size()-1)\
    \ {\n            \n            end++;\n        }\n        \n        std::string\
    \ sub_word = sentence.substr(start, end-start+1);\n        \n        bool is_prime\
    \ = true;\n        \n        for(size_t i = 1; i < sub_word.length(); i++) {\n\
    \            if(sub_word[i] != sub_word[i-1]) {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n        \n        if(is_prime)\
    \ {\n            size++;\n        }\n        \n        start = end;\n    }\n \
    \   \n    std::string new_sentence;\n    \n    for(size_t i = 0; i < size; i++)\
    \ {\n        new_sentence.push_back(sentence[i]);\n    }\n    \n    return new_sentence;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp67wyadm_.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp67wyadm_.cpp:24:42: error: conversion from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   24 |      \
    \   std::string word = sentence[start];\n      |                             \
    \             ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // code here\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpy1pgcxej: /tmp/tmpy1pgcxej.cpp:22: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    bool flag = true;\n    std::string\
    \ ret = \"\";\n    for (auto i : sentence)\n    {\n        if (flag)\n       \
    \ {\n            for (auto j : ret)\n            {\n                if (i == j)\n\
    \                {\n                    flag = false;\n                    break;\n\
    \                }\n            }\n        }\n        else\n        {\n      \
    \      for (auto j : ret)\n            {\n                if (i == j)\n      \
    \          {\n                    flag = true;\n                    break;\n \
    \               }\n            }\n        }\n    }\n    return ret;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpe41cv2iw: /tmp/tmpe41cv2iw.cpp:49: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::set<std::string> primes;\n\
    \    std::string ans = \"\";\n    for (int i = 0; i < sentence.length(); i++)\
    \ {\n        std::string word;\n        auto c = sentence.at(i);\n        if (c\
    \ == ' ') {\n            primes.insert(word);\n            continue;\n       \
    \ }\n        if (isalpha(c)) {\n            word = c + 1;\n        }\n       \
    \ else {\n            word = \"\";\n        }\n        std::cout << word << '\
    \ ';\n    }\n    for (auto p: primes) {\n        ans += p;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: 'U i j t j t b u f t u '
  stderr: "tmpwztvvasy: /tmp/tmpwztvvasy.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> new_words;\n\
    \    std::string word;\n    bool prime = true;\n    int cnt = 0;\n    for (auto\
    \ &c: sentence) {\n        if (!isalpha(c)) {\n            prime = false;\n  \
    \          break;\n        }\n    }\n    for (auto &c: sentence) {\n        if\
    \ (isalpha(c)) {\n            word = word + c;\n        }\n    }\n    for (auto\
    \ &c: sentence) {\n        if (isalpha(c)) {\n            new_words.push_back(word);\n\
    \            word = \"\";\n        }\n    }\n    // count prime\n    for (auto\
    \ &c: new_words) {\n        int cnt = 0;\n        for (auto &d: new_words) {\n\
    \            if (d == c) {\n                cnt++;\n            }\n        }\n\
    \        if (cnt % 2 != 0) {\n            prime = false;\n            break;\n\
    \        }\n    }\n    std::reverse(std::begin(new_words), std::end(new_words));\n\
    \    if (prime) {\n        return sentence;\n    }\n    std::string ans;\n   \
    \ std::for_each(std::begin(new_words), std::end(new_words), [&ans](std::string\
    \ s) {\n        ans = ans + s + \" \";\n    });\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpf9hmy66n: /tmp/tmpf9hmy66n.cpp:64: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector <int> new_list(sentence.begin(),\
    \ sentence.end());\n  std::sort(new_list.begin(), new_list.end());\n  new_list.erase(new_list.begin()+1,\
    \ new_list.end());\n  std::unordered_set<int> prime_list;\n  prime_list.reserve(new_list.size());\n\
    \  int new_list_size = new_list.size();\n  for (int i = 0; i < new_list_size;\
    \ i++) {\n    int cur_prime = 1;\n    for (int j = 1; j <= i; j++) {\n      if\
    \ (i % j == 0) {\n        cur_prime = 0;\n        break;\n      }\n    }\n   \
    \ if (cur_prime == 1) {\n      prime_list.insert(new_list[i]);\n    }\n  }\n\n\
    \  std::string result = \"\";\n  for (int i = 2; i < new_list_size; i++) {\n \
    \   if (prime_list.count(i)) {\n      result += new_list[i];\n    }\n  }\n  return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_k6imdck: /tmp/tmp_k6imdck.cpp:47: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string words;\n    for (int\
    \ i = 0; i < sentence.size(); i++) {\n        int n = i + 1;\n        for (int\
    \ j = 0; j < sentence.size(); j++)\n            if (i != j && std::isprime(n -\
    \ sentence[j]))\n                n = n - sentence[j];\n        words += sentence[i]\
    \ + \" \";\n    }\n    return words;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppdgs20zf.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmppdgs20zf.cpp:22:32: error: \u2018isprime\u2019 is not a member of \u2018\
    std\u2019; did you mean \u2018isprint\u2019?\n   22 |             if (i != j &&\
    \ std::isprime(n - sentence[j]))\n      |                                ^~~~~~~\n\
    \      |                                isprint\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::pair<int, int>>\
    \ primes;\n    primes.push_back(std::make_pair(1, 0));\n    primes.push_back(std::make_pair(2,\
    \ 1));\n    for (int i = 3; i < 100000; i = i * 3 + 1) {\n        for (int j =\
    \ 0; j < primes.size(); j++) {\n            if (i % primes[j].first == 0) {\n\
    \                primes[j].second = i;\n                break;\n            }\n\
    \        }\n    }\n    std::string result;\n    std::set<int> uniqueWords;\n \
    \   for (auto &prime : primes) {\n        if (uniqueWords.find(prime.second) ==\
    \ uniqueWords.end()) {\n            uniqueWords.insert(prime.second);\n      \
    \      result += std::to_string(prime.first) + \" \" + std::to_string(prime.second)\
    \ + \" \";\n        }\n    }\n    for (auto &prime : uniqueWords) {\n        result\
    \ += std::to_string(prime) + \" \";\n    }\n    std::cout << result << std::endl;\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: "1 68890 2 1 1 68890 \n"
  stderr: "tmp4jw3x8rc: /tmp/tmp4jw3x8rc.cpp:45: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int len = sentence.length();\n\
    \    std::string ans = \"\";\n    for (int i = 0; i < len; ++i) {\n        int\
    \ j = 0, flag = 1;\n        std::string tmp = \"\";\n        while (j < len) {\n\
    \            int k = j + 1;\n            while (k < (len)) {\n               \
    \ if (flag) {\n                    if (sentence[i] == '_') {\n               \
    \         tmp += \" \";\n                        k++;\n                    } else\
    \ {\n                        if (sentence[i] == sentence[k]) {\n             \
    \               flag = 0;\n                            j++;\n                \
    \            k++;\n                        } else {\n                        \
    \    flag = 1;\n                            j++;\n                        }\n\
    \                    }\n                } else {\n                    if (sentence[i]\
    \ != sentence[k]) {\n                        flag = 0;\n                     \
    \   k++;\n                    } else {\n                        flag = 1;\n  \
    \                      k++;\n                    }\n                }\n      \
    \      }\n            ans += tmp;\n            tmp = \" \";\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Your code here\n    std::string\
    \ result = \"\";\n    for(int i = 0; i < sentence.length(); i++) {\n        result\
    \ += sentence.substr(i, 1);\n    }\n    std::sort(result.begin(), result.end());\n\
    \    \n    // Write your code here\n    \n    return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpmmxyj_sc: /tmp/tmpmmxyj_sc.cpp:31: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // write your code here\n  std::string\
    \ res=\"\";\n  int m=(int)sqrt(sentence.size()),n=(int)sqrt(sentence.size()),i,j;\n\
    \  char arr[m][n];\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++){\n     \
    \ arr[i][j]=sentence[i];\n    }\n  }\n  for(int i=0;i<m;i++){\n    for(int j=1;j<n;j++){\n\
    \      if(arr[i][j]==arr[i][j-1])\n      {\n        if(j==n)\n        {\n    \
    \      res+=arr[i][j-1];\n          break;\n        }\n        for(int k=0;k<n;k++)\n\
    \        {\n          arr[i][k]=arr[i][k+1];\n        }\n      }\n    }\n  }\n\
    \  return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n   \
    \ assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpol732rp5: /tmp/tmpol732rp5.cpp:47: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<int> primes;\n  \
    \  std::string result;\n    int max_i = -1;\n    for (char c : sentence) {\n \
    \       if (c == ' ') {\n            primes.push_back(0);\n            max_i++;\n\
    \        } else {\n            assert(c >= 'a' && c <= 'z');\n            int\
    \ num = c - 'a' + 1;\n            if (max_i == -1) {\n                max_i =\
    \ num;\n            }\n            assert(max_i <= num);\n            primes.push_back(max_i);\n\
    \            max_i = num;\n        }\n    }\n    assert(max_i > 1);\n    primes.push_back(max_i\
    \ + 1);\n    for (int i = 0; i < primes.size(); i++) {\n        while (i > 0 &&\
    \ primes[i] == primes[i - 1] - 1) {\n            primes[i - 1]++;\n        }\n\
    \        result += std::to_string(primes[i]) + \" \";\n    }\n    result.erase(result.length()\
    \ - 1, 1);\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpctk670h_: /tmp/tmpctk670h_.cpp:26: std::string words_in_sentence(std::string):\
    \ Assertion `c >= 'a' && c <= 'z'' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Write your code here\n   \
    \ std::string temp(sentence);\n    std::string output=\"\";\n    \n    for(int\
    \ i=0;i<temp.size();i++) {\n        int j=temp[i]-'a';\n        if((j%2==1) &&\
    \ (output.length()!=0)){\n            output+=' ';\n        }\n        output+=temp[i];\n\
    \    }\n    return output;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpk_6g1i9c: /tmp/tmpk_6g1i9c.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // Write your code here.\n  std::map<int,\
    \ int> primes;\n  std::string res;\n  std::string word;\n  for (int i = 1; i <\
    \ sentence.length(); i++) {\n    if (sentence[i] != ' ') {\n      if (primes[sentence[i]]\
    \ == 0) {\n        primes[sentence[i]] = 1;\n        word = sentence[i];\n   \
    \   }\n      else {\n        while (primes[word] <= sentence[i]) {\n         \
    \ primes[word] += 1;\n          word += sentence[i];\n        }\n      }\n   \
    \ }\n  }\n  primes.erase(' ');\n  for (auto& prime: primes) {\n    res += word;\n\
    \  }\n  return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbof827ic.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpbof827ic.cpp:29:22: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::map<int, int>\u2019 and \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019})\n   29 |         while (primes[word]\
    \ <= sentence[i]) {\n      |                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/map:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpbof827ic.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:490:7:\
    \ note: candidate: \u2018std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type& std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::operator[](const key_type&) [with _Key = int; _Tp =\
    \ int; _Compare = std::less<int>; _Alloc = std::allocator<std::pair<const int,\
    \ int> >; std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type = int; std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::key_type = int]\u2019\n  490 |       operator[](const\
    \ key_type& __k)\n      |       ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:490:34:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const key_type&\u2019\
    \ {aka \u2018const int&\u2019}\n  490 |       operator[](const key_type& __k)\n\
    \      |                  ~~~~~~~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:510:7:\
    \ note: candidate: \u2018std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type& std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::operator[](std::map<_Key, _Tp, _Compare, _Alloc>::key_type&&)\
    \ [with _Key = int; _Tp = int; _Compare = std::less<int>; _Alloc = std::allocator<std::pair<const\
    \ int, int> >; std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type = int; std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::key_type = int]\u2019\n  510 |       operator[](key_type&&\
    \ __k)\n      |       ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:510:29:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> sorted_words;\n\
    \    std::set<std::string> unique_words;\n    for (auto &word : sentence.split(\"\
    \ \")) {\n        if (!unique_words.count(word)) {\n            unique_words.insert(word);\n\
    \            sorted_words.push_back(word);\n        }\n    }\n    std::string\
    \ result;\n    for (auto &word : sorted_words) {\n        std::cout << word <<\
    \ \" \";\n        if (std::next_permutation(result.begin(), result.end(), [&word](std::string\
    \ &elem) {\n            return elem == word;\n        })) {\n            return\
    \ result;\n        }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb8onomna.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpb8onomna.cpp:20:32: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   20 |     for (auto &word : sentence.split(\" \")) {\n      |            \
    \                    ^~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:71,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpb8onomna.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/predefined_ops.h:\
    \ In instantiation of \u2018constexpr bool __gnu_cxx::__ops::_Iter_comp_iter<_Compare>::operator()(_Iterator1,\
    \ _Iterator2) [with _Iterator1 = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Iterator2 = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Compare = words_in_sentence(std::string)::<lambda(std::string&)>]\u2019\
    :\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:2915:14:\
    \   required from \u2018bool std::__next_permutation(_BidirectionalIterator, _BidirectionalIterator,\
    \ _Compare) [with _BidirectionalIterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; _Compare = __gnu_cxx::__ops::_Iter_comp_iter<words_in_sentence(std::string)::<lambda(std::string&)>\
    \ >]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:2993:2:\
    \   required from \u2018bool std::next_permutation(_BIter, _BIter, _Compa"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  int n = std::distance(sentence.begin(),\
    \ std::find(sentence.begin(), sentence.end(), ' '));\n  std::unordered_map<int,\
    \ int> map;\n  for (int i = 0; i < n; ++i) {\n    if (map[sentence[i]] == 0) {\n\
    \      map[sentence[i]] = i + 1;\n      map[sentence[i]] += 1;\n    }\n  }\n \
    \ std::string res = \"\";\n  for (auto itr = map.begin(); itr != map.end(); ++itr)\
    \ {\n    if (itr->second == 2) {\n      res += std::to_string(itr->first);\n \
    \     break;\n    }\n  }\n  return res;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpvlens774: /tmp/tmpvlens774.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Write your code here.\n  \
    \  std::vector<std::string> res;\n    bool flag = false;\n    for (std::string\
    \ word : sentence)\n    {\n        if (!flag)\n        {\n            std::string\
    \ temp = word;\n            flag = true;\n        }\n        \n        else if\
    \ ((word == temp) && (word != \" \"))\n        {\n            res.push_back(word);\n\
    \        }\n    }\n    \n    std::sort(res.begin(), res.end());\n    std::string\
    \ str = res.front();\n    for (int i = 0; i < str.length(); i++)\n    {\n    \
    \    for (int j = i + 1; j < str.length(); j++)\n        {\n            if (str[i]\
    \ == str[j])\n            {\n                res.erase(res.begin() + j);\n   \
    \         }\n        }\n    }\n    std::reverse(std::begin(res), std::end(res));\n\
    \    \n    return str;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwf8rsxck.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpwf8rsxck.cpp:21:29: error: conversion from \u2018char\u2019 to non-scalar\
    \ type \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } requested\n   21 |     for (std::string word : sentence)\n      |          \
    \                   ^~~~~~~~\n/tmp/tmpwf8rsxck.cpp:29:27: error: \u2018temp\u2019\
    \ was not declared in this scope\n   29 |         else if ((word == temp) && (word\
    \ != \" \"))\n      |                           ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string res;\n    for(int\
    \ i = 0; i < sentence.size(); i++) {\n        for(int j = i + 1; j < sentence.size();\
    \ j++) {\n            char c = sentence[i];\n            char d = sentence[j];\n\
    \            if((c > 'z' || c < 'a') || (d > 'z' || d < 'a')) {\n            \
    \    if((c > 'z' || d > 'z') && (d > c)) {\n                    res[i] = d;\n\
    \                    res[j] = c;\n                }\n            }\n        }\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp6s6nctbx: /tmp/tmp6s6nctbx.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // Your code goes here\n  \n  \n\
    \  return sentence;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp0rbt4ujv: /tmp/tmp0rbt4ujv.cpp:25: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string new_sentence = \"\"\
    ;\n  std::set<char> set_of_characters;\n  std::string temp_word = \"\";\n  bool\
    \ flag = false;\n  for (char c : sentence) {\n    if (set_of_characters.count(c))\
    \ {\n      flag = true;\n      temp_word += c;\n    } else {\n      if (!flag)\
    \ {\n        new_sentence += temp_word;\n        temp_word = \"\";\n        flag\
    \ = true;\n      }\n    }\n    set_of_characters.insert(c);\n  }\n  new_sentence\
    \ += temp_word;\n  return new_sentence;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpgizz0k8d: /tmp/tmpgizz0k8d.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result;\n  for (int\
    \ i = 0; i < sentence.size(); i++) {\n    result += \" \";\n    for (int j = i;\
    \ j < sentence.size(); j++) {\n      result += sentence[j];\n      std::sort(result.begin(),\
    \ result.end());\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp2w0inl1n: /tmp/tmp2w0inl1n.cpp:31: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string::size_type firstIndex\
    \ = sentence.find_first_not_of(\" \");\n    std::string::size_type lastIndex =\
    \ sentence.find_last_not_of(\" \");\n    std::string::size_type middleIndex =\
    \ sentence.length() - (lastIndex - firstIndex);\n    std::string newSentence =\
    \ sentence.substr(firstIndex, middleIndex);\n    std::string newSentence2 = sentence.substr(middleIndex,\
    \ lastIndex);\n    std::string newSentence3 = newSentence + \" \" + newSentence2;\n\
    \    std::string newSentence4 = newSentence3 + \" \" + newSentence2;\n    std::string\
    \ newSentence5 = newSentence4 + \" \" + newSentence2;\n    int primesNum = 0;\n\
    \    std::string primeNumbers = \"\";\n    for (int i = 0; i < newSentence5.length();\
    \ i++) {\n        if (primeNumbers.find(newSentence5[i]) == std::string::npos)\
    \ {\n            primeNumbers += newSentence5[i];\n            primesNum++;\n\
    \        }\n    }\n    for (int i = primesNum; i < newSentence5.length(); i++)\
    \ {\n        newSentence3 += \" \" + newSentence5[i];\n    }\n    return newSentence3;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp8it8aaf2: /tmp/tmp8it8aaf2.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  int n = sentence.size();\n  std::string\
    \ res;\n  // Your code here\n  if(n % 2 == 0){\n    int sum = 0;\n    for(int\
    \ i = 0; i < n; i++){\n      sum += (sentence.at(i)-'a') * (i+1)%26;\n    }\n\
    \    if(sum % 2 != 0){\n      return \"None\";\n    }\n    int start = n/2-1;\n\
    \    for(int i = 0; i < start; i++){\n      sum -= (sentence.at(i)-'a') * (i+1)%26;\n\
    \      if(sum % 2 != 0){\n        return \"None\";\n      }\n    }\n    for(int\
    \ i = 0; i < start; i++){\n      sum += (sentence.at(i)-'a') * (i+1)%26;\n   \
    \   if(sum % 2 != 0){\n        return \"None\";\n      }\n    }\n    int end =\
    \ n/2;\n    for(int i = end-1; i >= 0; i--){\n      sum -= (sentence.at(i)-'a')\
    \ * (i+1)%26;\n      if(sum % 2 != 0){\n        return \"None\";\n      }\n  \
    \  }\n    res.assign(sentence.begin() + start, sentence.begin() + end);\n  }\n\
    \  else{\n    int sum = 0;\n    for(int i = 0; i < n; i++){\n      sum += (sentence.at(i)-'a')\
    \ * (i+1)%26;\n    }\n    if(sum % 2 != 0){\n      return \"None\";\n    }\n \
    \   int start = n/2-1;\n    for(int i = 0; i < start; i++){\n      sum -= (sentence.at(i)-'a')\
    \ * (i+1)%26;\n      if(sum % 2 != 0){\n        return \"None\";\n      }\n  \
    \  }\n    for(int i = 0; i < start; i++){\n      sum += (sentence.at(i)-'a') *\
    \ (i+1)%26;\n      if(sum % 2 != 0){\n        return \"None\";\n      }\n    }\n\
    \    int end = n/2;\n    for(int i = end-1; i >= 0; i--){\n      sum -= (sentence.at(i)-'a')\
    \ * (i+1)%26;\n      if(sum % 2 != 0){\n        return \"None\";\n      }\n  \
    \  }\n    res.assign(sentence.begin() + start, sentence.begin() + end);\n  }\n\
    \  return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n   \
    \ assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpmu7s5wtl: /tmp/tmpmu7s5wtl.cpp:85: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stack<char> word_stack;\n\
    \    for (char c : sentence)\n    {\n        if (c == ' ')\n        {\n      \
    \      word_stack.push(c);\n        }\n        else if (!isalpha(c))\n       \
    \ {\n            break;\n        }\n        else\n        {\n            while\
    \ (word_stack.empty() && !isalpha(c))\n            {\n                word_stack.push(c);\n\
    \            }\n            if (word_stack.empty())\n            {\n         \
    \       break;\n            }\n            int wordLen = (word_stack.top() - '0');\n\
    \            if (!isPrime(wordLen))\n            {\n                break;\n \
    \           }\n            word_stack.pop();\n        }\n    }\n    return word_stack.empty()\
    \ ? \"\" : word_stack.top();\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgi3b2yj_.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpgi3b2yj_.cpp:40:18: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   40 |             if (!isPrime(wordLen))\n\
    \      |                  ^~~~~~~\n      |                  stime\n/tmp/tmpgi3b2yj_.cpp:47:31:\
    \ error: operands to ?: have different types \u2018const char*\u2019 and \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018\
    char\u2019}\n   47 |     return word_stack.empty() ? \"\" : word_stack.top();\n\
    \      |            ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // your code goes here\n    std::unordered_map<int,\
    \ bool> visited;\n    std::string results;\n    for (char &i: sentence)\n    {\n\
    \        if (visited[i])\n        {\n            continue;\n        }\n      \
    \  visited[i] = true;\n        std::string temp;\n        std::set<int> primes;\n\
    \        for (char &j: sentence)\n        {\n            if (j == ' ')\n     \
    \       {\n                break;\n            }\n            primes.insert(j);\n\
    \            if (primes.count(j))\n            {\n                temp.push_back(j);\n\
    \            }\n        }\n        results.insert(results.end(), temp.begin(),\
    \ temp.end());\n    }\n    return results;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmppyp6j6o2: /tmp/tmppyp6j6o2.cpp:48: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string word_ = \"\";\n \
    \   bool isPrime = true;\n\n    for (int i = 3; i <= sqrt(sentence.size()); i++)\
    \ {\n        if (isPrime && isPrime(sentence.size(), i)) {\n            isPrime\
    \ = true;\n            word_ += \" \" + sentence[i];\n        } else if (isPrime)\
    \ {\n            isPrime = false;\n            word_ += \" \" + sentence[i];\n\
    \        } else {\n            word_ += \" \" + sentence[i];\n        }\n    }\n\
    \    return word_;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzs93z4a5.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpzs93z4a5.cpp:22:50: error: \u2018isPrime\u2019 cannot be used as a\
    \ function\n   22 |         if (isPrime && isPrime(sentence.size(), i)) {\n  \
    \    |                                                  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Write your code here.\n  \
    \  std::string s;\n    std::istringstream iss(sentence);\n    while (iss) {\n\
    \        std::string temp;\n        is >> temp;\n        temp += ' ';\n      \
    \  s += temp;\n        iss.ignore();\n    }\n    std::istringstream iss1(s);\n\
    \    while (iss1) {\n        std::string temp;\n        iss1 >> temp;\n      \
    \  if (!std::any_of(temp.begin(), temp.end(), ::isdigit))\n            s += temp\
    \ + ' ';\n        else\n            s += temp;\n        iss1.ignore();\n    }\n\
    \    std::string s1(s);\n    for (int i = 0; i < s.length(); i++)\n    {\n   \
    \     int count = 0;\n        for(int j=0;j<s1.length();j++)\n        {\n    \
    \        if(s[i]==s1[j])\n                count++;\n        }\n        if(count==1)\n\
    \            s1.erase(i--,1);\n    }\n    return s1;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8rym286i.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp8rym286i.cpp:23:9: error: \u2018is\u2019 was not declared in this scope;\
    \ did you mean \u2018iss\u2019?\n   23 |         is >> temp;\n      |        \
    \ ^~\n      |         iss\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string res;\n    auto it\
    \ = sentence.begin();\n    for (; it != sentence.end(); ++it) {\n        int len\
    \ = 2;\n        for (int i = 0; i <= len; ++i) {\n            int flag = 1;\n\
    \            for (int j = 0; j < len; ++j) {\n                if (*it == ' ')\
    \ {\n                    break;\n                }\n                if (*it !=\
    \ *((it + j + 1))) {\n                    flag = 0;\n                    break;\n\
    \                }\n            }\n            if (flag) {\n                len\
    \ = i + 1;\n            }\n        }\n        res.push_back(std::to_string(len));\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvh51i5kx.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpvh51i5kx.cpp:37:37: error: cannot convert \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018char\u2019\n   37 | \
    \        res.push_back(std::to_string(len));\n      |                       ~~~~~~~~~~~~~~^~~~~\n\
    \      |                                     |\n      |                      \
    \               std::string {aka std::__cxx11::basic_string<char>}\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvh51i5kx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1349:24:\
    \ note:   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1349 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::sort(sentence.begin(), sentence.end());\n\
    \    std::string result = \"\";\n    int n = 1;\n    for (int i = 0; i < sentence.length();\
    \ ++i) {\n        for (int j = i; j < sentence.length(); ++j) {\n            if\
    \ (n%sentence[j] == 0) {\n                result += sentence[j];\n           \
    \     break;\n            }\n        }\n        ++n;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpxej9dtr9: /tmp/tmpxej9dtr9.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::sort(sentence.begin(), sentence.end());\n\
    \  \n  std::vector<int> prime_numbers;\n  for (auto &word:sentence) {\n    word\
    \ = std::tolower(word);\n    if (word == ' ') {\n      if (prime_numbers.empty())\
    \ {\n        prime_numbers.push_back(1);\n      }\n      else {\n        prime_numbers.push_back(prime_numbers[0]);\n\
    \      }\n    }\n    else {\n      int n = prime_numbers[0];\n      for (int i\
    \ = prime_numbers.size() - 1; i >= 0; i--) {\n        n = pow(n, i) + 1;\n   \
    \     if (prime_numbers[i] < n) {\n          prime_numbers[i] = n;\n         \
    \ break;\n        }\n      }\n    }\n  }\n\n  std::ostringstream os;\n  std::copy(prime_numbers.begin(),\
    \ prime_numbers.end(), std::ostream_iterator<int>(os, \" \"));\n\n  return os.str();\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpcwguug72: /tmp/tmpcwguug72.cpp:50: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n\t\n\tstd::stack<std::string> st;\n\
    \tfor (char &ch : sentence)\n\t{\n\t\tif (isalpha(ch))\n\t\t{\n\t\t\tchar ch1\
    \ = ch;\n\t\t\tst.push(ch1);\n\t\t}\n\t}\n\t\n\tstd::string ans = \"\";\n\twhile\
    \ (!st.empty())\n\t{\n\t\tint n = st.top();\n\t\tst.pop();\n\t\tans = ans + \"\
    \ \" + n;\n\t}\n\t\n\tstd::string res = ans.substr(1);\n\t\n\treturn res;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3rltpa5v.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp3rltpa5v.cpp:25:15: error: no matching function for call to \u2018\
    std::stack<std::__cxx11::basic_string<char> >::push(char&)\u2019\n   25 |    st.push(ch1);\n\
    \      |               ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp3rltpa5v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:233:7:\
    \ note: candidate: \u2018void std::stack<_Tp, _Sequence>::push(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Sequence = std::deque<std::__cxx11::basic_string<char>,\
    \ std::allocator<std::__cxx11::basic_string<char> > >; std::stack<_Tp, _Sequence>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n  233 |       push(const value_type&\
    \ __x)\n      |       ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:233:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \  233 |       push(const value_type& __x)\n      |            ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:238:7: note:\
    \ candidate: \u2018void std::stack<_Tp, _Sequence>::push(std::stack<_Tp, _Sequence>::value_type&&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Sequence = std::deque<std::__cxx11::basic_string<char>,\
    \ std::allocator<std::__cxx11::basic_string<char> > >; std::stack<_Tp, _Sequence>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n  238 |       push(value_type&& __x)\n\
    \      |       ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:238:25:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::stack<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \  238 |       push(value_type&& __x)\n      |            ~~~~~~~~~~~~~^~~\n/tmp/tmp3rltpa5v.cpp:32:17:\
    \ error: cannot c"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string new_sentence = \"\
    \";\n    char character;\n    for (char c: sentence) {\n        if (c == ' ')\
    \ {\n            for (int i = 0; i <= 3; i++) {\n                character = sentence[i];\n\
    \                if (isprime(i) && c != character) {\n                    new_sentence\
    \ += c;\n                }\n            }\n        }\n    }\n    return new_sentence;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr5mo1yyz.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpr5mo1yyz.cpp:24:21: error: \u2018isprime\u2019 was not declared in\
    \ this scope; did you mean \u2018isprint\u2019?\n   24 |                 if (isprime(i)\
    \ && c != character) {\n      |                     ^~~~~~~\n      |         \
    \            isprint\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    string answer;\n    for(auto\
    \ itr = sentence.begin(); itr != sentence.end(); ++itr) {\n        char c = *itr;\n\
    \        std::unordered_set<char> s;\n        for(auto itr = sentence.begin();\
    \ itr != sentence.end(); ++itr) {\n            if(s.find(*itr) == s.end()) {\n\
    \                if(c == *itr) {\n                    s.insert(*itr);\n      \
    \          }\n            }\n        }\n        answer += s;\n    }\n    std::reverse(answer.begin(),\
    \ answer.end());\n    return answer;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpf6p704pc.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpf6p704pc.cpp:18:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   18 |     string answer;\n \
    \     |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpf6p704pc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpf6p704pc.cpp:29:9:\
    \ error: \u2018answer\u2019 was not declared in this scope\n   29 |         answer\
    \ += s;\n      |         ^~~~~~\n/tmp/tmpf6p704pc.cpp:31:18: error: \u2018answer\u2019\
    \ was not declared in this scope\n   31 |     std::reverse(answer.begin(), answer.end());\n\
    \      |                  ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    //write your code here\n    std::vector<int>\
    \ v;\n    for(auto &i: sentence){\n        if(isalpha(i)){\n            v.push_back(i);\n\
    \        }\n    }\n    for(int i = 1 ; i <= std::sqrt(v.size());i++){\n      \
    \  if(v.at(i) % i != 0){\n            for(auto &i: v){\n                assert(isalpha(i));\n\
    \            }\n            return sentence.substr(0,i);\n        }\n    }\n \
    \   for(auto &i: v){\n        assert(isalpha(i));\n    }\n    return sentence;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpf4hnz31w: /tmp/tmpf4hnz31w.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  assert(sentence.size() <= 100);\n\
    \  auto res = \"\";\n  auto n = 1;\n  auto primes = primeFactors(n);\n  for (auto\
    \ &prime : primes) {\n    for (auto &c : sentence) {\n      if (c == ' ') {\n\
    \        continue;\n      }\n      if (n % prime == 0) {\n        res += c;\n\
    \        break;\n      }\n    }\n  }\n  return res;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4kl4c4ho.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp4kl4c4ho.cpp:21:17: error: \u2018primeFactors\u2019 was not declared\
    \ in this scope\n   21 |   auto primes = primeFactors(n);\n      |           \
    \      ^~~~~~~~~~~~\n/tmp/tmp4kl4c4ho.cpp:22:22: error: unable to deduce \u2018\
    auto&&\u2019 from \u2018primes\u2019\n   22 |   for (auto &prime : primes) {\n\
    \      |                      ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // your code here\n    std::string\
    \ out;\n    for (size_t i = 0; i < sentence.length(); i++) {\n        if (is_prime_number(sentence.length()))\
    \ {\n            if (i != 0) {\n                out += \"\\n\";\n            }\n\
    \            out += sentence[i];\n        }\n    }\n    return out;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpalyo3ovu.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpalyo3ovu.cpp:21:13: error: \u2018is_prime_number\u2019 was not declared\
    \ in this scope\n   21 |         if (is_prime_number(sentence.length())) {\n \
    \     |             ^~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    for\
    \ (char c : sentence) {\n        if (c >= 'a' && c <= 'z') {\n            result\
    \ += c;\n        }\n    }\n    size_t new_length = result.length();\n    std::string\
    \ new_result;\n    while (new_length % 2 == 0) {\n        new_result += \"0\"\
    ;\n    }\n    for (auto it = result.begin(); it != result.end(); ++it) {\n   \
    \     if (std::find(result.begin(), result.end(), *it) != result.end()) {\n  \
    \          new_result += *it;\n        }\n    }\n    return new_result;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::map<std::string, int> map;\n\
    \    for (auto &it : map) {\n        it = 0;\n    }\n    std::string res = \"\"\
    ;\n    bool flag = false;\n    for (auto &it : map) {\n        flag = true;\n\
    \        for (auto &jt : it) {\n            if (jt > 1) {\n                flag\
    \ = false;\n            }\n        }\n        if (flag) {\n            res +=\
    \ it.first + \" \";\n        }\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnkwr0vap.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpnkwr0vap.cpp:20:14: error: no match for \u2018operator=\u2019 (operand\
    \ types are \u2018std::pair<const std::__cxx11::basic_string<char>, int>\u2019\
    \ and \u2018int\u2019)\n   20 |         it = 0;\n      |              ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:64,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnkwr0vap.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_pair.h:378:7:\
    \ note: candidate: \u2018std::pair<_T1, _T2>& std::pair<_T1, _T2>::operator=(typename\
    \ std::conditional<std::__and_<std::is_copy_assignable<_T1>, std::is_copy_assignable<_T2>\
    \ >::value, const std::pair<_T1, _T2>&, const std::__nonesuch_no_braces&>::type)\
    \ [with _T1 = const std::__cxx11::basic_string<char>; _T2 = int; typename std::conditional<std::__and_<std::is_copy_assignable<_T1>,\
    \ std::is_copy_assignable<_T2> >::value, const std::pair<_T1, _T2>&, const std::__nonesuch_no_braces&>::type\
    \ = const std::__nonesuch_no_braces&]\u2019\n  378 |       operator=(typename\
    \ conditional<\n      |       ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_pair.h:381:51:\
    \ note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018std::conditional<false,\
    \ const std::pair<const std::__cxx11::basic_string<char>, int>&, const std::__nonesuch_no_braces&>::type\u2019\
    \ {aka \u2018const std::__nonesuch_no_braces&\u2019}\n  378 |       operator=(ty"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    vector<string> temp;\n    vector<int>\
    \ prime_numbers;\n    int cnt = 0;\n    for (auto i : sentence) {\n        if\
    \ (isalnum(i)) {\n            temp.push_back(i);\n            prime_numbers.push_back(cnt);\n\
    \        }\n        cnt++;\n    }\n    sort(temp.begin(), temp.end());\n    int\
    \ last_prime = 0;\n    string answer;\n    for (auto i : temp) {\n        int\
    \ cnt = 1;\n        for (auto j : prime_numbers) {\n            if (j < i) {\n\
    \                cnt++;\n            }\n        }\n        if (cnt > 1) {\n  \
    \          answer.push_back(i);\n            last_prime = i;\n        }\n    }\n\
    \    for (auto i : prime_numbers) {\n        while (last_prime % i != 0) {\n \
    \           last_prime++;\n        }\n    }\n    return answer;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt3pdjel9.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpt3pdjel9.cpp:18:5: error: \u2018vector\u2019 was not declared in this\
    \ scope; did you mean \u2018std::vector\u2019?\n   18 |     vector<string> temp;\n\
    \      |     ^~~~~~\n      |     std::vector\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpt3pdjel9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:386:11:\
    \ note: \u2018std::vector\u2019 declared here\n  386 |     class vector : protected\
    \ _Vector_base<_Tp, _Alloc>\n      |           ^~~~~~\n/tmp/tmpt3pdjel9.cpp:18:12:\
    \ error: \u2018string\u2019 was not declared in this scope; did you mean \u2018\
    std::string\u2019?\n   18 |     vector<string> temp;\n      |            ^~~~~~\n\
    \      |            std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpt3pdjel9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpt3pdjel9.cpp:18:20:\
    \ error: \u2018temp\u2019 was not declared in this scope\n   18 |     vector<string>\
    \ temp;\n      |                    ^~~~\n/tmp/tmpt3pdjel9.cpp:19:12: error: expected\
    \ primary-exp"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    assert(sentence.length() <= 100);\n\
    \    \n    auto new_string = sentence.substr(0, sentence.find_first_not_of(' '));\n\
    \    \n    for (size_t i = 1; i < sentence.length(); i++) {\n        \n      \
    \  while (i % new_string.length() == 0) {\n            if (new_string.length()\
    \ % i == 0) {\n                new_string += \" \";\n            }\n         \
    \   i += 1;\n        }\n        new_string += sentence.substr(i, 1);\n    }\n\
    \    \n    return new_string;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string temp = \"\";\n  for(int\
    \ i = 0; i <= 100; i++) {\n    bool isPrime = true;\n    for (int j = 2; j < i;\
    \ j++) {\n      if (i % j == 0) {\n        isPrime = false;\n        break;\n\
    \      }\n    }\n    if (isPrime) {\n      temp += \" \";\n      temp += i;\n\
    \    }\n  }\n  int count = 0, size = 0;\n  for(int i = 0; i <= temp.length();\
    \ i++) {\n    if(temp.substr(i, 1).length() == 0) {\n      count++;\n    }\n \
    \   if(temp.substr(i, 1).length() == 1) {\n      size++;\n    }\n  }\n  std::stringstream\
    \ ss;\n  ss << count;\n  std::string str = ss.str();\n  ss << size;\n  str = ss.str();\n\
    \  std::string newstr = str.substr(0, str.length() - 1);\n  for(int i = 0; i <=\
    \ temp.length(); i++) {\n    if(temp.substr(i, 1).length() == 0) {\n      newstr\
    \ += \" \";\n    }\n    if(temp.substr(i, 1).length() == 1) {\n      newstr +=\
    \ temp.substr(i, 1);\n    }\n  }\n  return newstr;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp85uyts0t: /tmp/tmp85uyts0t.cpp:59: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int n = 0;\n    int l = 0;\n\
    \    int count[100];\n    for (char c: sentence) {\n        if (c >= 'a' && c\
    \ <= 'z') {\n            count[l]++;\n            l++;\n        } else {\n   \
    \         n++;\n        }\n    }\n    int prime[100], flag = 0;\n    for (int\
    \ i = 0; i <= n; i++) {\n        prime[i] = i;\n        if (count[i] > 1) {\n\
    \            for (int j = 2; j < count[i]; j++) {\n                if (prime[j]\
    \ != prime[prime[j]]) {\n                    flag = 1;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    if (flag == 0) {\n  \
    \      return sentence;\n    } else {\n        std::stringstream ss;\n       \
    \ ss << sentence << std::flush;\n        std::string result;\n        while ((ss\
    \ >> result)) {\n            std::cout << result << std::endl;\n        }\n  \
    \  }\n    return \"\";\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpkk_7jeei: /tmp/tmpkk_7jeei.cpp:55: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // your code here\n  std::string\
    \ words;\n  int len = sentence.length();\n  for (int i = 0; i < len / 2; i++)\
    \ {\n    int count = 0;\n    for (int j = i * 2; j < (i + 1) * 2; j++)\n     \
    \ if (sentence[j] == '_')\n        count++;\n    if (count % 2 == 0)\n      words\
    \ += sentence.substr(i * 2, i);\n  }\n  return words;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpot172oib: /tmp/tmpot172oib.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // code here\n    int n = sentence.size();\n\
    \    std::string ans = \"\";\n    for (int i = 0; i < n; ++i) {\n        int count\
    \ = 0;\n        for (int j = 0; j < n; ++j) {\n            if (i == j) continue;\n\
    \            if (sentence[i] == sentence[j]) count++;\n        }\n        if (count\
    \ > 1) {\n            ans += sentence[i];\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpa7ix68pd: /tmp/tmpa7ix68pd.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string words[100];\n    std::string word = \"\";\n    int n = 0, p = 0,\
    \ n2 = 0, p2 = 0, n3 = 0, p3 = 0;\n    for (int i = 0; i <= sentence.length()\
    \ - 1; i++) {\n        if (!isalpha(sentence[i])) {\n            n = n + 1;\n\
    \            words[n] = word;\n        }\n        if (i == sentence.length() -\
    \ 1) {\n            n = n + 1;\n            words[n] = word;\n        } else {\n\
    \            word = sentence[i];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        if (isalpha(words[i])) {\n            p2 = words[i].length();\n\
    \        }\n    }\n    for (int i = 1; i < n; i++) {\n        if (isalpha(words[i]))\
    \ {\n            p3 = words[i].length();\n        }\n    }\n    for (int i = 0;\
    \ i <= sentence.length() - 1; i++) {\n        if (!isalpha(sentence[i])) {\n \
    \           ans += sentence[i];\n        }\n        if (i == sentence.length()\
    \ - 1) {\n            ans += sentence[i];\n        } else {\n            ans +=\
    \ \" \";\n        }\n    }\n    for (int i = 0; i <= sentence.length() - 1; i++)\
    \ {\n        if (!isalpha(sentence[i])) {\n            ans += \" \";\n       \
    \ }\n    }\n    for (int i = 0; i <= sentence.length() - 1; i++) {\n        if\
    \ (!isalpha(sentence[i])) {\n            ans += \" \";\n        }\n    }\n   \
    \ for (int i = 0; i <= sentence.length() - 1; i++) {\n        if (!isalpha(sentence[i]))\
    \ {\n            ans += \" \";\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpig8kxrmp.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpig8kxrmp.cpp:35:29: error: no matching function for call to \u2018\
    isalpha(std::string&)\u2019\n   35 |         if (isalpha(words[i])) {\n      |\
    \                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cctype:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:35,\n\
    \                 from /tmp/tmpig8kxrmp.cpp:2:\n/usr/include/ctype.h:112:1: note:\
    \ candidate: \u2018int isalpha(int)\u2019\n  112 | __exctype (isalpha);\n    \
    \  | ^~~~~~~~~\n/usr/include/ctype.h:112:1: note:   no known conversion for argument\
    \ 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018int\u2019\n  112 | __exctype (isalpha);\n      | ^~~~~~~~~\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_ios.h:37,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpig8kxrmp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_facets.h:2599:5:\
    \ note: candidate: \u2018template<class _CharT> bool std::isalpha(_CharT, const\
    \ std::locale&)\u2019\n 2599 |     isalpha(_CharT __c, const locale& __loc)\n\
    \      |     ^~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_facets.h:2599:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpig8kxrmp.cpp:35:29:\
    \ note:   candidate expects 2 arguments, 1 provided\n   35 |         if (isalpha(words[i]))\
    \ {\n      |                             ^\n/tmp/tmpig8kxrmp.cpp:40:29: error:\
    \ no m"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Write your code here\n   \
    \ std::vector<std::string> words;\n    std::string words_str;\n    std::stringstream\
    \ ss(sentence);\n    for (std::string word; std::getline(ss, word, ' '); ) {\n\
    \        if (words.empty() || words.size() > 1) {\n            words.push_back(word);\n\
    \        } else {\n            if (words[0] == word) {\n                words_str\
    \ += word + \" \";\n            } else {\n                words_str += words[0]\
    \ + \" \";\n                words.clear();\n            }\n        }\n    }\n\
    \    if (!words.empty())\n        words_str += words[0];\n    return words_str;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp5zhi_qqn: /tmp/tmp5zhi_qqn.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::unordered_set<long long> s;\n\
    \  long long n = 1;\n  for (auto &c : sentence) {\n    s.insert(c);\n    n +=\
    \ (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') ? 2 : 1;\n  }\n \
    \ std::vector<std::string> result;\n  while (s.size() >= 2) {\n    result.push_back(s.begin()->first);\n\
    \    s.pop_back();\n  }\n  for (auto &c : s) {\n    result.push_back(c);\n  }\n\
    \  return std::accumulate(result.begin(), result.end(), std::string(), [](const\
    \ std::string &a, const std::string &b) {\n    return a + b;\n  });\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp88kwiq9l.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp88kwiq9l.cpp:26:33: error: request for member \u2018first\u2019 in\
    \ \u2018* s.std::unordered_set<long long int>::begin().std::__detail::_Node_iterator<long\
    \ long int, true, false>::operator->()\u2019, which is of non-class type \u2018\
    const long long int\u2019\n   26 |     result.push_back(s.begin()->first);\n \
    \     |                                 ^~~~~\n/tmp/tmp88kwiq9l.cpp:27:7: error:\
    \ \u2018class std::unordered_set<long long int>\u2019 has no member named \u2018\
    pop_back\u2019\n   27 |     s.pop_back();\n      |       ^~~~~~~~\n/tmp/tmp88kwiq9l.cpp:30:23:\
    \ error: no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(const long long int&)\u2019\n   30 |     result.push_back(c);\n\
    \      |                       ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp88kwiq9l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018const long long int\u2019\
    \ to \u2018const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    \n    // Your code goes here\n\
    \    std::string result=\"\";\n    int i=0,j=0;\n    int n=sentence.size();\n\
    \    for(i=0;i< n;i++)\n    {\n        if((i%2)==0)\n        {\n            int\
    \ k=0;\n            while(i<n && sentence[i]!=' ')\n            {\n          \
    \      k++;\n                i++;\n            }\n            result+=sentence[i];\n\
    \            i++;\n            while(i<n && sentence[i]!=' ')\n            {\n\
    \                j+=k;\n                i++;\n            }\n        }\n     \
    \   else\n        {\n            int k=0;\n            while(i<n && sentence[i]!='\
    \ ')\n            {\n                k++;\n                i++;\n            }\n\
    \            result+=sentence[i];\n            j+=k;\n            i++;\n     \
    \       while(i<n && sentence[i]!=' ')\n            {\n                result+=sentence[i];\n\
    \                i++;\n            }\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpqo_kykh5: /tmp/tmpqo_kykh5.cpp:63: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<int> primes;\n  \
    \  primes.push_back(0);\n    primes.push_back(1);\n    primes.push_back(2);\n\
    \    primes.push_back(3);\n    for (int i = 4; i < std::sqrt(static_cast<double>(primes.size()));\
    \ i += 2)\n        primes.push_back(i);\n    std::string res;\n    for (auto it\
    \ : primes)\n    {\n        std::string str = \" \" + sentence;\n        int x\
    \ = std::find(str.begin(), str.end(), it);\n        if (x == str.end())\n    \
    \    {\n            continue;\n        }\n        res += sentence[x];\n      \
    \  str = \" \" + sentence;\n        sentence = str.erase(0, x);\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpszjg1_dw.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpszjg1_dw.cpp:29:26: error: cannot convert \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018int\u2019 in initialization\n\
    \   29 |         int x = std::find(str.begin(), str.end(), it);\n      |     \
    \            ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                  \
    \        |\n      |                          __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\n/tmp/tmpszjg1_dw.cpp:30:15: error: no match\
    \ for \u2018operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   30 |         if (x == str.end())\n      |             ~ ^~ ~~~~~~~~~\n\
    \      |             |           |\n      |             int         std::__cxx11::basic_string<char>::iterator\
    \ {aka __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpszjg1_dw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:886:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Contai"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int n = sentence.length();\n\
    \    std::string res = \"\";\n    for (int i = 0; i < n; i++) {\n        int j\
    \ = 0, k = 1;\n        while (j + 1 < n && k <= i) {\n            if (i == j +\
    \ 1) break;\n            if (sentence[j] == ' ') j++;\n            else j++;\n\
    \            k++;\n        }\n        if (i == j + 1) {\n            res += sentence[i];\n\
    \            i++;\n        }\n        if (i + 1 < n) {\n            res += \"\
    \ \" + sentence[i];\n            i++;\n        }\n    }\n    return res;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpw7hwupkx: /tmp/tmpw7hwupkx.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result = \"NULL\"\
    ;\n    int n = sentence.length();\n    if (n < 2) {\n        return result;\n\
    \    }\n    std::set<int> primes;\n    primes.insert(2);\n    for (auto it = sentence.begin();\
    \ it < sentence.end(); it++) {\n        int next = it+1;\n        if (next ==\
    \ sentence.end()) {\n            next = sentence.begin();\n        }\n       \
    \ int flag = 1;\n        while (next < sentence.end()) {\n            int cur_prime\
    \ = 1;\n            for (auto it_prime = primes.begin(); it_prime != primes.end();\
    \ it_prime++) {\n                int cur = *it_prime;\n                while (cur\
    \ >= next && flag) {\n                    cur /= next;\n                    flag\
    \ = 0;\n                }\n                if (cur % next == 0) {\n          \
    \          cur_prime *= cur % next;\n                    flag = 1;\n         \
    \       }\n            }\n            if (cur_prime != 1) {\n                primes.insert(next);\n\
    \                break;\n            }\n            ++next;\n        }\n    }\n\
    \    for (auto it = primes.begin(); it != primes.end(); it++) {\n        result\
    \ += ' ';\n        result += *it;\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp323n8xdk.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp323n8xdk.cpp:26:22: error: cannot convert \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018int\u2019 in initialization\n\
    \   26 |         int next = it+1;\n      |                    ~~^~\n      |  \
    \                    |\n      |                      __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\n/tmp/tmp323n8xdk.cpp:27:18: error: no match\
    \ for \u2018operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   27 |         if (next == sentence.end()) {\n      |          \
    \   ~~~~ ^~ ~~~~~~~~~~~~~~\n      |             |                   |\n      |\
    \             int                 std::__cxx11::basic_string<char>::iterator {aka\
    \ __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >}\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp323n8xdk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:886:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  886 |\
    \     operator==(con"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stack<std::string> st;\n\
    \    std::stack<size_t> stp;\n    std::string res;\n    int n = sentence.length();\n\
    \    for(int i = 0; i < n; i++)\n    {\n        if(!isalpha(sentence[i]))\n  \
    \      {\n            res += sentence[i];\n            continue;\n        }\n\
    \        stp.push(i);\n        if(isalpha(sentence[i]))\n        {\n         \
    \   while(!stp.empty() && isalpha(sentence[stp.top()]))\n            {\n     \
    \           stp.pop();\n                stp.push(i);\n            }\n        }\n\
    \        while(!stp.empty())\n        {\n            int left = stp.top();\n \
    \           stp.pop();\n            int right = i;\n            while(left < right)\n\
    \            {\n                if(isalpha(sentence[left]) && isalpha(sentence[right]))\n\
    \                {\n                    while(stp.top() < right)\n           \
    \         {\n                        stp.pop();\n                    }\n     \
    \               while(!stp.empty() && isalpha(sentence[stp.top()]))\n        \
    \            {\n                        stp.pop();\n                        stp.push(i);\n\
    \                    }\n                }\n                else if(isalpha(sentence[left])\
    \ && !isalpha(sentence[right]))\n                {\n                    break;\n\
    \                }\n                else if(isalpha(sentence[right]) && !isalpha(sentence[left]))\n\
    \                {\n                    break;\n                }\n          \
    \      else if(sentence[left] == sentence[right])\n                {\n       \
    \             left = stp.top() + 1;\n                }\n                else\n\
    \                {\n                    break;\n                }\n          \
    \  }\n        }\n        stp.push(i);\n        res += sentence[i];\n    }\n  \
    \  return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n   \
    \ assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"is\";\n \
    \   for (int i = 0; i < sentence.length(); i++) {\n        if (i % 2 != 0 && i\
    \ > 1) {\n            ans += \" \";\n        }\n        bool isPrime = false;\n\
    \        for (int j = i; j < i + 100; j++) {\n            if (j % i == 0) {\n\
    \                isPrime = true;\n            }\n        }\n        if (isPrime)\
    \ {\n            ans += sentence[i];\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    \n    int ans[10][10][10][10][10][10][10][10][10];\n\
    \    \n    for (int i = 0; i < sentence.length(); i++) {\n        char ch = sentence[i];\n\
    \        if (ch == ' ') {\n            continue;\n        }\n        for (int\
    \ j = 0; j < 10; j++) {\n            ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch]\
    \ = 1;\n        }\n    }\n    \n    for (int i = 0; i < 10; i++) {\n        for\
    \ (int j = 0; j < 10; j++) {\n            for (char ch = 'a'; ch <= 'z'; ch++)\
    \ {\n                for (int k = 0; k < 10; k++) {\n                    for (int\
    \ l = 0; l < 10; l++) {\n                        for (int m = 0; m < 10; m++)\
    \ {\n                            for (int n = 0; n < 10; n++) {\n            \
    \                    for (int o = 0; o < 10; o++) {\n                        \
    \            for (int p = 0; p < 10; p++) {\n                                \
    \        for (int q = 0; q < 10; q++) {\n                                    \
    \        for (int r = 0; r < 10; r++) {\n                                    \
    \            for (int s = 0; s < 10; s++) {\n                                \
    \                    for (int t = 0; t < 10; t++) {\n                        \
    \                                for (int u = 0; u < 10; u++) {\n            \
    \                                                for (int v = 0; v < 10; v++)\
    \ {\n                                                                for (int\
    \ w = 0; w < 10; w++) {\n                                                    \
    \                for (int x = 0; x < 10; x++) {\n                            \
    \                                            for (int y = 0; y < 10; y++) {\n\
    \                                                                            for\
    \ (int z = 0; z < 10; z++) {\n                                               \
    \                                 if (ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch]\
    \ == 1) {\n                                                                  \
    \                  ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch]\
    \ = ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch];\n     \
    \                                                                           }\n\
    \                                                                            }\n\
    \                                                                        }\n \
    \                                                                   }\n      \
    \                                                          }\n               \
    \                                             }\n                            \
    \                            }\n                                             \
    \       }\n                                                }\n               \
    \                             }\n                                            if\
    \ (ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch] == 1) {\n   \
    \                                             if (i == 0) {\n                \
    \                                    ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch]\
    \ = ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqy4dvpix.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpqy4dvpix.cpp:27:53: error: invalid types \u2018int[char]\u2019 for\
    \ array subscript\n   27 |             ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch]\
    \ = 1;\n      |                                                     ^\n/tmp/tmpqy4dvpix.cpp:50:125:\
    \ error: invalid types \u2018int[char]\u2019 for array subscript\n   50 |    \
    \                                                                            \
    \ if (ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch] == 1) {\n    \
    \  |                                                                         \
    \                                                    ^\n/tmp/tmpqy4dvpix.cpp:51:125:\
    \ error: invalid types \u2018int[char]\u2019 for array subscript\n   51 |    \
    \                                                                            \
    \     ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch] = ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch];\n\
    \      |                                                                     \
    \                                                        ^\n/tmp/tmpqy4dvpix.cpp:51:189:\
    \ error: invalid types \u2018int[char]\u2019 for array subscript\n   51 |    \
    \                                                                            \
    \     ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch] = ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch];\n\
    \      |                                                                     \
    \                                                                            \
    \                                            ^\n/tmp/tmpqy4dvpix.cpp:62:89: error:\
    \ invalid types \u2018int[char]\u2019 for array subscript\n   62 |           \
    \                                  if (ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch]\
    \ == 1) {\n      |                                                           \
    \                              ^\n/tmp/tmpqy4dvpix.cpp:64:93: error: invalid types\
    \ \u2018int[char]\u2019 for array subscript\n   64 |                         \
    \                        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::stack<char> st;\n  std::stack<char>\
    \ st2;\n  std::string res;\n  for (auto s : sentence) {\n    if (st2.empty())\
    \ st.push(s);\n    else if (st2.top() == s) {\n      st2.pop();\n    } else {\n\
    \      while (!st2.empty() && st2.top() != s) st2.pop();\n      if (st2.empty())\
    \ st.push(s);\n      else st.push(s);\n    }\n  }\n  while (!st.empty()) {\n \
    \   res += st.top();\n    st.pop();\n  }\n  return res;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpt78yqu24: /tmp/tmpt78yqu24.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Write your code here\n   \
    \ std::string str;\n    int n = static_cast<int>(sentence.size()) / 2;\n    \n\
    \    bool flag = true;\n    bool flag2 = false;\n    \n    for (int i = 0; i <\
    \ n; i++){\n        for (int j = i + 1; j < n; j++){\n            if (sentence[i]\
    \ == sentence[j]){\n                flag = true;\n                flag2 = true;\n\
    \            }\n        }\n        if (flag){\n            str += sentence[i];\n\
    \            flag = false;\n        }\n    }\n    \n    \n    bool flag3 = true;\n\
    \    \n    for (int i = 0; i < n; i++){\n        for (int j = i + 1; j < n; j++){\n\
    \            if (flag2){\n                flag3 = true;\n            }\n     \
    \       if (sentence[i] == sentence[j]){\n                flag3 = false;\n   \
    \         }\n        }\n        if (flag3){\n            str += \" \" + sentence[i];\n\
    \            flag3 = false;\n        }\n    }\n    \n    \n    return str;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpp4jc39nf: /tmp/tmpp4jc39nf.cpp:61: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // write your code here\n   \
    \ assert(sentence.size()>0);\n    std::stack<bool> st;\n    std::string ans=\"\
    \";\n    for (char c:sentence){\n        if (!st.empty() && st.pop()){\n     \
    \       ans.push_back(c);\n        }\n        else if(!isalpha(c)){\n        \
    \    st.push(false);\n        }\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdsc4has7.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpdsc4has7.cpp:23:34: error: could not convert \u2018st.std::stack<bool>::pop()\u2019\
    \ from \u2018void\u2019 to \u2018bool\u2019\n   23 |         if (!st.empty() &&\
    \ st.pop()){\n      |                            ~~~~~~^~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // Write your code here\n  bool\
    \ prime[] = {false, false};\n  int n = sentence.length();\n  vector<int> prime_count(n);\n\
    \  int num_count = 0;\n  for (int i = 0; i < n; i++) {\n    std::string temp =\
    \ sentence;\n    if (i % 2 == 1) {\n      temp = temp.substr(0, i) + temp.substr(i\
    \ + 1);\n    }\n    // Check if it can be divided evenly with any number\n   \
    \ for (int j = 0; j < i; j++) {\n      if (temp[j] == ' ') {\n        prime[j]\
    \ = true;\n        break;\n      }\n    }\n    if (prime[i]) {\n      prime_count[num_count++]\
    \ = i;\n    }\n  }\n  assert(num_count > 0);\n  // print out the result\n  string\
    \ ans = \"\";\n  for (int i = 0; i < n; i++) {\n    if (prime_count[i] % 2 ==\
    \ 0) {\n      ans += sentence[i];\n    }\n  }\n  return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8hpniv2p.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp8hpniv2p.cpp:21:3: error: \u2018vector\u2019 was not declared in this\
    \ scope; did you mean \u2018std::vector\u2019?\n   21 |   vector<int> prime_count(n);\n\
    \      |   ^~~~~~\n      |   std::vector\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp8hpniv2p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:386:11:\
    \ note: \u2018std::vector\u2019 declared here\n  386 |     class vector : protected\
    \ _Vector_base<_Tp, _Alloc>\n      |           ^~~~~~\n/tmp/tmp8hpniv2p.cpp:21:10:\
    \ error: expected primary-expression before \u2018int\u2019\n   21 |   vector<int>\
    \ prime_count(n);\n      |          ^~~\n/tmp/tmp8hpniv2p.cpp:36:7: error: \u2018\
    prime_count\u2019 was not declared in this scope; did you mean \u2018num_count\u2019\
    ?\n   36 |       prime_count[num_count++] = i;\n      |       ^~~~~~~~~~~\n  \
    \    |       num_count\n/tmp/tmp8hpniv2p.cpp:41:3: error: \u2018string\u2019 was\
    \ not declared in this scope; did you mean \u2018std::string\u2019?\n   41 | \
    \  string ans = \"\";\n      |   ^~~~~~\n      |   std::string\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp8hpniv2p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std:"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    size_t\
    \ i, len = sentence.length();\n    \n    // You can either use unordered_map or\
    \ unordered_set\n    std::unordered_set<int> prime;\n    for (i = 0; i < len;\
    \ i++)\n        if (std::all_of(sentence.begin() + i, sentence.begin() + i + 1,\
    \ ::isspace))\n            ++i;\n        else\n            prime[i] = false;\n\
    \    \n    for (i = 1; i < len; ++i)\n        if (prime[i])\n            result.push_back(sentence.begin()\
    \ + i);\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpplesl_jf.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpplesl_jf.cpp:27:18: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::unordered_set<int>\u2019 and \u2018size_t\u2019 {aka \u2018\
    long unsigned int\u2019})\n   27 |             prime[i] = false;\n      |    \
    \              ^\n/tmp/tmpplesl_jf.cpp:30:18: error: no match for \u2018operator[]\u2019\
    \ (operand types are \u2018std::unordered_set<int>\u2019 and \u2018size_t\u2019\
    \ {aka \u2018long unsigned int\u2019})\n   30 |         if (prime[i])\n      |\
    \                  ^\n/tmp/tmpplesl_jf.cpp:31:47: error: cannot convert \u2018\
    __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >\u2019 to\
    \ \u2018char\u2019\n   31 |             result.push_back(sentence.begin() + i);\n\
    \      |                              ~~~~~~~~~~~~~~~~~^~~\n      |          \
    \                                     |\n      |                             \
    \                  __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpplesl_jf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1349:24:\
    \ note:   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = s"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n\
    \    std::istringstream stream(sentence);\n    std::string word;\n    while (stream\
    \ >> word)\n        words.push_back(word);\n    sort(words.begin(), words.end());\n\
    \    std::string ans;\n    for (int i = 0; i < words.size(); i++)\n        ans\
    \ += words[i];\n    for (int i = 0; i < words.size() ; i++) {\n        if (ans[i]\
    \ != '_') {\n            int j = 1;\n            for (int k = i; k < words.size()\
    \ && j < words[k].length(); k++) {\n                if (ans[k] != words[k].at(j))\
    \ {\n                    break;\n                }\n                j++;\n   \
    \         }\n            if (j == words[k].length()) {\n                ans +=\
    \ words[k];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm3ceox2y.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpm3ceox2y.cpp:36:28: error: \u2018k\u2019 was not declared in this scope\n\
    \   36 |             if (j == words[k].length()) {\n      |                  \
    \          ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string rev_sentence;\n \
    \   std::reverse(sentence.begin(), sentence.end());\n    rev_sentence.resize(sentence.size());\n\
    \    std::reverse(rev_sentence.begin(), rev_sentence.end());\n    std::stringstream\
    \ ss(sentence);\n    std::string tmp;\n    std::string res;\n    while (std::getline(ss,\
    \ tmp, ' ')) {\n        res += \" \" + tmp;\n    }\n    std::reverse(res.begin(),\
    \ res.end());\n    return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpdop_9v2x: /tmp/tmpdop_9v2x.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int n = sentence.length();\n\
    \    std::string result = \"\";\n    // To make sure we are checking prime numbers\
    \ only\n    // We will take the first character of the sentence\n    // and check\
    \ if the length is 1 or not\n    // If it is 1 then it is not a prime number\n\
    \    // If it is 2, 3 or 5 then it is a prime number\n    // Else we will continue\
    \ checking other characters of sentence\n    for (int i = 0; i < n; i++) {\n \
    \       if (sentence[i] == 1) {\n            // If we find 1 then we will not\
    \ check\n            // other characters \n            if (i == 0) {\n       \
    \         // If this is the first character then\n                // the length\
    \ of the string is not prime number\n                // If this is the last character\
    \ then\n                // the length of the string is prime number\n        \
    \        result += sentence[i];\n            } else {\n                // If this\
    \ is not the first character then \n                // the length of the string\
    \ is prime number\n                // Checking the rest of characters\n      \
    \          for (int j = i; j < n; j++) {\n                    if (sentence[j]\
    \ == 1) {\n                        // If 1 then this is not a prime number\n \
    \                       result += sentence[j];\n                        break;\n\
    \                    }\n                    // If 1 then this is not a prime number\n\
    \                    result += sentence[j];\n                }\n            }\n\
    \        } else {\n            // If this is not the first character then \n \
    \           // the length of the string is prime number\n            // Checking\
    \ the rest of characters\n            for (int j = i; j < n; j++) {\n        \
    \        if (sentence[j] != 1) {\n                    // If not 1 then this is\
    \ not a prime number\n                    result += sentence[j];\n           \
    \         break;\n                }\n                // If not 1 then this is\
    \ not a prime number\n                result += sentence[j];\n            }\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmparfz97w5: /tmp/tmparfz97w5.cpp:69: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string words;\n    \n  \
    \  for(int i = 0; sentence[i] != '\\0'; i++){\n        if(sentence[i] >= 'a' &&\
    \ sentence[i] <= 'z'){\n            words += sentence[i];\n        }\n    }\n\n\
    \    int prime_lengths[100] = {0};\n\n    for(int i = 0; words[i] != ' '; i++){\n\
    \        int length = words[i].length();\n        if(length >= 2){\n         \
    \   prime_lengths[length] += 1;\n        }\n    }\n\n    for(int i = 1; i <= 100;\
    \ i++){\n        if(prime_lengths[i] == 0){\n            words += ' ';\n     \
    \   }\n    }\n\n    return words;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1xg2tvjt.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp1xg2tvjt.cpp:29:31: error: request for member \u2018length\u2019 in\
    \ \u2018words.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   29 |         int length =\
    \ words[i].length();\n      |                               ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n\
    \    int len = sentence.length();\n    for (int i = 0; i < len; i++) {\n     \
    \   int length = 1;\n        bool is_prime = true;\n        for (int j = 0; j\
    \ < i; j++) {\n            if (sentence[j] != ' ') {\n                if (sentence[j]\
    \ != sentence[i]) {\n                    is_prime = false;\n                 \
    \   break;\n                }\n            } else {\n                break;\n\
    \            }\n        }\n        if (is_prime) {\n            result += sentence[i];\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpigw_cfm6: /tmp/tmpigw_cfm6.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::unordered_map<char, int> map;\n\
    \  // create a string for output and initialize all to 0\n  std::string output(sentence.length(),\
    \ 0);\n  for (auto c : sentence) {\n    map[c]++;\n  }\n  for (auto it=map.begin();\
    \ it!=map.end(); it++) {\n    if(it->second==1)\n      output+=it->first;\n  }\n\
    \  return output;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp3eipbogt: /tmp/tmp3eipbogt.cpp:32: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // code here\n    std::string\
    \ ret = \"\";\n    for (int i = 0; i < sentence.size(); i++) {\n        bool is_prime\
    \ = false;\n        for (int j = 2 * i; j < sentence.length(); j++) {\n      \
    \      if (sentence[j] % i == 0) {\n                is_prime = true;\n       \
    \         break;\n            }\n        }\n        if (is_prime) {\n        \
    \    ret += sentence[i] + \" \";\n        }\n    }\n    return ret;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string::iterator it;\n \
    \   std::string ans;\n    int len = sentence.length();\n    for(int i = 0; i<len;\
    \ i++){\n        it = sentence.begin();\n        while(it != sentence.end() &&\
    \ !isspace(*it)){\n            it++;\n        }\n        if(it == sentence.end())\n\
    \            break;\n        ans.push_back(*it);\n    }\n    int an = 0;\n   \
    \ for(int i = 0; i<len; i++){\n        if(isPrime(len-i)){\n            ans.push_back(i+1);\n\
    \            an++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1pgh7ovl.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp1pgh7ovl.cpp:32:12: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   32 |         if(isPrime(len-i)){\n\
    \      |            ^~~~~~~\n      |            stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string res;\n    int len\
    \ = 0;\n    for (auto s : sentence)\n    {\n        if (s.isalpha())\n       \
    \ {\n            len++;\n        }\n    }\n    if (len == 0)\n    {\n        std::cout\
    \ << \"No letters in sentence\" << std::endl;\n        return res;\n    }\n  \
    \  int num = 2;\n    while (true)\n    {\n        res = \"\";\n        for (auto\
    \ s : sentence)\n        {\n            if (s.isalpha())\n            {\n    \
    \            if (num == len)\n                {\n                    res += s;\n\
    \                }\n                else\n                {\n                \
    \    if (isPrime(num))\n                    {\n                        if (num\
    \ * 2 == len)\n                        {\n                            res += s;\n\
    \                        }\n                        else\n                   \
    \     {\n                            res += s + \" \";\n                     \
    \   }\n                    }\n                    else\n                    {\n\
    \                        res += s + \" \";\n                    }\n          \
    \      }\n                num++;\n            }\n        }\n        if (res.empty())\n\
    \        {\n            break;\n        }\n        len--;\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpa6700ah7.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpa6700ah7.cpp:22:15: error: request for member \u2018isalpha\u2019 in\
    \ \u2018s\u2019, which is of non-class type \u2018char\u2019\n   22 |        \
    \ if (s.isalpha())\n      |               ^~~~~~~\n/tmp/tmpa6700ah7.cpp:38:19:\
    \ error: request for member \u2018isalpha\u2019 in \u2018s\u2019, which is of\
    \ non-class type \u2018char\u2019\n   38 |             if (s.isalpha())\n    \
    \  |                   ^~~~~~~\n/tmp/tmpa6700ah7.cpp:46:25: error: \u2018isPrime\u2019\
    \ was not declared in this scope; did you mean \u2018stime\u2019?\n   46 |   \
    \                  if (isPrime(num))\n      |                         ^~~~~~~\n\
    \      |                         stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n\
    \    std::string result;\n    while(true) {\n        std::string next;\n     \
    \   ss >> next;\n        if (ss.eof()) {\n            break;\n        }\n    \
    \    if (next.length() > 2) {\n            result += (\" \" + next);\n       \
    \ }\n    }\n    return result.substr(2);\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp888jiz8v: /tmp/tmp888jiz8v.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Write your code here\n   \
    \ std::string ans = \"\";\n    for (auto &it : sentence) {\n        if (std::isalpha(it))\
    \ {\n            ans = ans + \" \" + it;\n        }\n    }\n    for (auto &it\
    \ : ans) {\n        if (!std::isalpha(it) && it.length() > 1) {\n            ans\
    \ = ans + \" \" + it;\n        }\n    }\n    for (auto &it : ans) {\n        if\
    \ (std::isalpha(it)) {\n            auto it = ans.find(it);\n            while\
    \ (it != std::string::npos) {\n                if (isPrime(it)) {\n          \
    \          ans = ans.replace(it, \"\");\n                }\n                it\
    \ = ans.find(it, it);\n            }\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpax4efus2.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpax4efus2.cpp:26:37: error: request for member \u2018length\u2019 in\
    \ \u2018it\u2019, which is of non-class type \u2018char\u2019\n   26 |       \
    \  if (!std::isalpha(it) && it.length() > 1) {\n      |                      \
    \               ^~~~~~\n/tmp/tmpax4efus2.cpp:32:32: error: use of \u2018it\u2019\
    \ before deduction of \u2018auto\u2019\n   32 |             auto it = ans.find(it);\n\
    \      |                                ^~\n/tmp/tmpax4efus2.cpp:34:21: error:\
    \ \u2018isPrime\u2019 was not declared in this scope; did you mean \u2018stime\u2019\
    ?\n   34 |                 if (isPrime(it)) {\n      |                     ^~~~~~~\n\
    \      |                     stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n\
    \    int num = 0;\n    for (char &c: sentence) {\n        if (is_prime(atoi(&c)))\
    \ {\n            result += c;\n        } else {\n            num += 1;\n     \
    \   }\n    }\n    std::cout << result << std::endl;\n    return result;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmd0q0d86.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpmd0q0d86.cpp:21:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   21 |         if (is_prime(atoi(&c))) {\n      |             ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::sort(sentence.begin(), sentence.end());\n\
    \    std::string new_str;\n    std::string word = \"\";\n    int length = sentence.length();\n\
    \    for (int i = 0; i<length; i++) {\n        std::size_t index = sentence.find_first_of(\
    \ ' ', i );\n        if (index != std::string::npos) {\n            word = sentence.substr(index,\
    \ index+1);\n            while (new_str.find(word) != std::string::npos) {\n \
    \               new_str = new_str.replace( word, new_str.find(word) + 1 );\n \
    \           }\n        }\n    }\n    return new_str;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8f91ohx7.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp8f91ohx7.cpp:27:73: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::replace(std::string&, std::__cxx11::basic_string<char>::size_type)\u2019\
    \n   27 |                 new_str = new_str.replace( word, new_str.find(word)\
    \ + 1 );\n      |                                                            \
    \             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp8f91ohx7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1889:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type = long unsigned int]\u2019\n 1889 |       replace(size_type\
    \ __pos, size_type __n, const basic_string& __str)\n      |       ^~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1889:7:\
    \ note:   candid"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::stack<char> st;\n    std::string\
    \ ans = \"is\";\n    for (auto ch : sentence) {\n        if (ch == ' ') {\n  \
    \          while (st.empty() && (ch = sentence[st.top()]) != ' ') {\n        \
    \        st.pop();\n            }\n            if (st.empty()) ans += ch;\n  \
    \      } else {\n            ans += ch;\n            st.push(ch);\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpkwiz7vas: /tmp/tmpkwiz7vas.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // write your code here\n   \
    \ std::string answer;\n    bool prime_found = false;\n    int count_prime = 0;\n\
    \    bool no_prime = false;\n    for (int i = 0; i < sentence.length(); i++) {\n\
    \        char c = sentence[i];\n        int count = 0;\n        for (size_t j\
    \ = 0; j < answer.size(); j++) {\n            if (answer[j] == c) {\n        \
    \        count++;\n            }\n        }\n        if (count != 0) {\n     \
    \       if (count % 2 == 0) {\n                prime_found = true;\n         \
    \       answer.push_back(c);\n                count_prime++;\n            } else\
    \ {\n                no_prime = true;\n                answer.push_back(c);\n\
    \            }\n        } else {\n            no_prime = true;\n        }\n  \
    \  }\n    if (prime_found == true) {\n        if (count_prime == 0) {\n      \
    \      no_prime = true;\n        }\n    } else if (no_prime == true) {\n     \
    \   int count = 0;\n        for (int i = 0; i < answer.size(); i++) {\n      \
    \      count++;\n            if (count % 2 == 0) {\n                answer.erase(answer.begin()\
    \ + i);\n            }\n        }\n    }\n    return answer;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp31t50vcs: /tmp/tmp31t50vcs.cpp:61: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::pair<int, int>\
    \ > primes;\n    std::string output;\n    int counter = 1;\n    for (auto letter\
    \ : sentence) {\n        if (std::find(primes.begin(), primes.end(), std::pair{counter,\
    \ (int)letter}) == primes.end()) {\n            primes.push_back(std::pair{counter,\
    \ (int)letter});\n            counter++;\n        }\n    }\n    for (auto it =\
    \ primes.begin(); it != primes.end(); ++it) {\n        auto first_prime = (*it).first;\n\
    \        int last_prime = (*it).second - 1;\n        std::set<int> words;\n  \
    \      std::string first_word = sentence;\n        std::string last_word = sentence;\n\
    \        for (int i = first_prime; i <= last_prime; ++i) {\n            std::string\
    \ current_word = first_word;\n            int count = 0;\n            for (auto\
    \ letter : current_word) {\n                if (std::find(words.begin(), words.end(),\
    \ i) == words.end()) {\n                    words.insert(i);\n               \
    \     current_word += letter;\n                    count++;\n                }\n\
    \            }\n            if (count == first_word.size()) {\n              \
    \  first_word += i;\n            } else {\n                last_word += i;\n \
    \           }\n        }\n        std::sort(words.begin(), words.end());\n   \
    \     std::copy(words.begin(), words.end(), std::back_inserter(output));\n   \
    \ }\n    return output;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7d5ehfom.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp7d5ehfom.cpp:22:62: error: missing template arguments before \u2018\
    {\u2019 token\n   22 |         if (std::find(primes.begin(), primes.end(), std::pair{counter,\
    \ (int)letter}) == primes.end()) {\n      |                                  \
    \                            ^\n/tmp/tmp7d5ehfom.cpp:23:39: error: missing template\
    \ arguments before \u2018{\u2019 token\n   23 |             primes.push_back(std::pair{counter,\
    \ (int)letter});\n      |                                       ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n   \
    \              from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7d5ehfom.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:\
    \ In instantiation of \u2018void std::__sort(_RandomAccessIterator, _RandomAccessIterator,\
    \ _Compare) [with _RandomAccessIterator = std::_Rb_tree_const_iterator<int>; _Compare\
    \ = __gnu_cxx::__ops::_Iter_less_iter]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:4828:18:\
    \   required from \u2018void std::sort(_RAIter, _RAIter) [with _RAIter = std::_Rb_tree_const_iterator<int>]\u2019\
    \n/tmp/tmp7d5ehfom.cpp:49:45:   required from here\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:1968:22:\
    \ error: no match for \u2018operator-\u2019 (operand types are \u2018std::_Rb_tree_const_iterator<int>\u2019\
    \ and \u2018std::_Rb_tree_const_iterator<int>\u2019)\n 1968 |     std::__lg(__last\
    \ - __first) * 2,\n      |               ~~~~~~~^~~~~~~~~\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 fro"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int len = sentence.length();\n\
    \    std::unordered_map<int, int> prime_nums;\n    for (int i = 3; i < len; i\
    \ += 2) {\n        bool flag = false;\n        for (int j = i; j < (2 * i); ++j)\
    \ {\n            if (i == j) {\n                continue;\n            }\n   \
    \         if (isPrime(j)) {\n                flag = true;\n                prime_nums[j]\
    \ = 1;\n                prime_nums[j + 1] = 1;\n                prime_nums[j +\
    \ 2] = 1;\n                prime_nums[j + 3] = 1;\n            }\n        }\n\
    \        if (!flag) {\n            prime_nums[len] = 1;\n        }\n    }\n  \
    \  std::string res;\n    for (int i = 0; i < len; ++i) {\n        if (prime_nums[i]\
    \ > 1) {\n            res += sentence.at(i);\n            prime_nums[i] -= 1;\n\
    \        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy1m8v36y.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpy1m8v36y.cpp:26:17: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   26 |             if (isPrime(j))\
    \ {\n      |                 ^~~~~~~\n      |                 stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // write your code here\n  assert(sentence.length()<100\
    \ && \"sentence length too big\");\n  std::string ret = \"\";\n  for (int i =\
    \ 0; i<sentence.length()-1; i++) {\n    if (isprime(sentence.at(i).length()) &&\
    \ isprime(sentence.at(i+1).length())) {\n      ret += sentence.at(i);\n      ret\
    \ += sentence.at(i+1);\n    }\n  }\n  return ret;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptp1yi07b.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmptp1yi07b.cpp:22:32: error: request for member \u2018length\u2019 in\
    \ \u2018sentence.std::__cxx11::basic_string<char>::at(((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   22 |     if (isprime(sentence.at(i).length())\
    \ && isprime(sentence.at(i+1).length())) {\n      |                          \
    \      ^~~~~~\n/tmp/tmptp1yi07b.cpp:22:9: error: \u2018isprime\u2019 was not declared\
    \ in this scope; did you mean \u2018isprint\u2019?\n   22 |     if (isprime(sentence.at(i).length())\
    \ && isprime(sentence.at(i+1).length())) {\n      |         ^~~~~~~\n      | \
    \        isprint\n/tmp/tmptp1yi07b.cpp:22:70: error: request for member \u2018\
    length\u2019 in \u2018sentence.std::__cxx11::basic_string<char>::at(((std::__cxx11::basic_string<char>::size_type)(i\
    \ + 1)))\u2019, which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   22 |     if (isprime(sentence.at(i).length())\
    \ && isprime(sentence.at(i+1).length())) {\n      |                          \
    \                                            ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  struct Solution {\n    std::string\
    \ res = {\"\"};\n    bool is_prime = true;\n    std::string res;\n    int n;\n\
    \    Solution(std::string sentence) {\n      n = strlen(sentence);\n      vector<int>\
    \ prime_number_arr(n + 1, 1);\n      prime_number_arr[0] = 2;\n      prime_number_arr[1]\
    \ = 3;\n      for (int i = 2; i < n; i++) {\n        if (prime_number_arr[i] ==\
    \ 0) {\n          for (int j = i * i; j < n; j += i) {\n            prime_number_arr[j]\
    \ = i;\n          }\n        }\n      }\n      for (int i = 2; i < n; i++) {\n\
    \        if (prime_number_arr[i] != 0) {\n          for (int j = 2 * i; j < n;\
    \ j += i) {\n            if (j % prime_number_arr[i] == 0) {\n              is_prime\
    \ = false;\n            }\n          }\n        }\n      }\n      for (int i =\
    \ 0; i <= n; i++) {\n        if (prime_number_arr[i] != 0) {\n          res.push_back(sentence[i]);\n\
    \        }\n      }\n    }\n\n    void get_new_str(int n) {\n      int j = 0;\n\
    \      for (int i = 2; i < n; i++) {\n        if (j % i == 0) {\n          is_prime\
    \ = false;\n          break;\n        }\n        j += i;\n      }\n      for (int\
    \ i = 2; i < n; i++) {\n        if (j % i == 0) {\n          is_prime = false;\n\
    \          break;\n        }\n        j += i;\n      }\n    }\n  };\n  int n =\
    \ strlen(sentence);\n  Solution sol(sentence);\n  sol.get_new_str(n);\n  std::string\
    \ s = sol.res.substr(0, n);\n  sol.res[n - 1] = '\\0';\n  return s;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_5asnhsn.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp_5asnhsn.cpp:21:17: error: redeclaration of \u2018std::string words_in_sentence(std::string)::Solution::res\u2019\
    \n   21 |     std::string res;\n      |                 ^~~\n/tmp/tmp_5asnhsn.cpp:19:17:\
    \ note: previous declaration \u2018std::string words_in_sentence(std::string)::Solution::res\u2019\
    \n   19 |     std::string res = {\"\"};\n      |                 ^~~\n/tmp/tmp_5asnhsn.cpp:\
    \ In constructor \u2018words_in_sentence(std::string)::Solution::Solution(std::string)\u2019\
    :\n/tmp/tmp_5asnhsn.cpp:24:18: error: cannot convert \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const char*\u2019\n \
    \  24 |       n = strlen(sentence);\n      |                  ^~~~~~~~\n     \
    \ |                  |\n      |                  std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cstring:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:48,\n\
    \                 from /tmp/tmp_5asnhsn.cpp:2:\n/usr/include/string.h:395:35:\
    \ note:   initializing argument 1 of \u2018size_t strlen(const char*)\u2019\n\
    \  395 | extern size_t strlen (const char *__s)\n      |                     \
    \  ~~~~~~~~~~~~^~~\n/tmp/tmp_5asnhsn.cpp:25:7: error: \u2018vector\u2019 was not\
    \ declared in this scope; did you mean \u2018std::vector\u2019?\n   25 |     \
    \  vector<int> prime_number_arr(n + 1, 1);\n      |       ^~~~~~\n      |    \
    \   std::vector\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp_5asnhsn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:386:11:\
    \ note: \u2018std::vector\u2019 declared here\n  386 |     class vector : protected\
    \ _Vector_base<_Tp, _Alloc>\n      |           ^~~~~~\n/tmp/tmp_5asnhsn.cpp:25:14:\
    \ error: expected primary-express"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> ans;\n\
    \    std::string firstword;\n    std::string lastword;\n    std::string temp;\n\
    \    std::stringstream ss;\n    std::vector<std::string> words;\n    // Your code\
    \ here\n    int l = 0;\n    for (auto &i: sentence) {\n        if (i == ' ') {\n\
    \            words.push_back(temp);\n            temp.clear();\n        } else\
    \ {\n            temp += i;\n        }\n    }\n    for (auto &i: words) {\n  \
    \      if (std::all_of(i.begin(), i.end(), ::isdigit)) {\n            std::string\
    \ ws = i;\n            std::sort(ws.begin(), ws.end());\n            if (ws.size()\
    \ == 2) {\n                ans.push_back(firstword);\n                ans.push_back(i);\n\
    \                firstword.clear();\n                lastword.clear();\n     \
    \       } else {\n                if (ws.size() % 2 == 0) {\n                \
    \    ans.push_back(firstword);\n                    firstword = ws;\n        \
    \        } else {\n                    lastword = ws;\n                }\n   \
    \         }\n        }\n    }\n    if (lastword.empty()) {\n        ans.push_back(firstword);\n\
    \    }\n    // Your code here\n    std::string an;\n    for (auto &i: ans) {\n\
    \        std::reverse(i.begin(), i.end());\n        std::cout << i << \" \";\n\
    \    }\n    std::cout << std::endl;\n    return an;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: " \n"
  stderr: "tmp0k8k3n76: /tmp/tmp0k8k3n76.cpp:67: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::map<char, int> map;\n  \
    \  for (char &c: sentence) {\n        map[c]++;\n    }\n    std::string result\
    \ = \"\";\n    for (auto p: map) {\n        while (p.second != 1) {\n        \
    \    p.second--;\n            result = p.first + \" \" + result;\n        }\n\
    \    }\n    std::sort(result.begin(), result.end());\n    return result;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpgz0_gt0_: /tmp/tmpgz0_gt0_.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string res;\n    int len\
    \ = 0;\n    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i]\
    \ == ' ') {\n            res.append(sentence.substr(i, len - i + 1));\n      \
    \      len = i + 1;\n        }\n    }\n    for (int i = 0; i < len - 1; i++) {\n\
    \        int len2 = i;\n        for (int j = i + 1; j < len; j++) {\n        \
    \    if (len % j == 0) {\n                len2 = j;\n                break;\n\
    \            }\n        }\n        if (len2 > len) {\n            len = len2;\n\
    \        }\n    }\n    for (int i = 1; i < len; i++) {\n        if (std::gcd(len,\
    \ i) == 1) {\n            res.append(sentence.substr(i, len - i));\n         \
    \   break;\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpks73yg46.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpks73yg46.cpp:39:18: error: \u2018gcd\u2019 is not a member of \u2018\
    std\u2019\n   39 |         if (std::gcd(len, i) == 1) {\n      |             \
    \     ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // code here\n    std::vector<std::string>\
    \ new_sentence;\n    for(auto &x:sentence.split(\" \"))\n    {\n        bool is_prime\
    \ = true;\n        int length = 1;\n        std::string new_word = x;\n      \
    \  while(length<new_word.size() && is_prime)\n        {\n            if(new_word.at(length)=='#')\n\
    \            {\n                is_prime = false;\n            }\n           \
    \ length++;\n        }\n        if(is_prime)\n        {\n            new_sentence.push_back(x);\n\
    \        }\n    }\n    return \" \".join(new_sentence);\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1atni22d.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp1atni22d.cpp:20:26: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   20 |     for(auto &x:sentence.split(\" \"))\n      |                    \
    \      ^~~~~\n/tmp/tmp1atni22d.cpp:38:16: error: request for member \u2018join\u2019\
    \ in \u2018\" \"\u2019, which is of non-class type \u2018const char [2]\u2019\n\
    \   38 |     return \" \".join(new_sentence);\n      |                ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  int n = sentence.length();\n  //\
    \ find how many numbers are there in the input\n  int count = 0;\n  for(auto &i\
    \ : sentence)\n    if(isdigit(i))\n      count++;\n  \n  // if there are any numbers,\
    \ find out the count of prime numbers inside the input\n  if(count > 0)\n  {\n\
    \    // find out the count of primes\n    int count_primes = 0;\n    \n    //\
    \ find the max number of primes inside the input\n    int max_num = count;\n \
    \   \n    // find the max number of digits in the input\n    int max_digits =\
    \ n;\n    \n    // loop until all characters are processed \n    while(count_primes\
    \ < max_num)\n    {\n      int i = 2;\n      \n      // keep checking till the\
    \ max number of digits is found\n      while(i < max_digits && i < max_num)\n\
    \      {\n        // if the current number is divisible by all numbers less than\
    \ max_num,\n        // then the number is prime\n        if(max_num % i == 0)\n\
    \          count_primes++;\n        \n        // add one to i\n        i++;\n\
    \      }\n      \n      // once the number is greater than max_digits, we need\
    \ to reduce max_digits\n      max_digits -= 1;\n      \n      // if there are\
    \ no more digits to be found (meaning there are no more characters),\n      //\
    \ we can break out of the loop\n      if(max_digits == 0)\n        break;\n  \
    \  }\n  }\n  \n  // create a string that stores the words\n  std::string words;\n\
    \  \n  // check if there are any numbers in the string\n  if(count > 0)\n  {\n\
    \    // keep looping through the string and append the words that are prime to\
    \ the word\n    for(int i = 0; i < n; i++)\n    {\n      std::string temp;\n \
    \     if(sentence[i] == ' ')\n        temp += ' ';\n      else\n      {\n    \
    \    if(isalpha(sentence[i]))\n        {\n          for(auto &j : sentence)\n\
    \            if(!isalpha(j))\n              break;\n            \n          //\
    \ if it is a letter, append it to the temp string\n          if(j != ' ' && j\
    \ != ' ' && j != ' ')\n            temp += j;\n        }\n      }\n      \n  \
    \    // check if the number is prime and append it to the words string if it is\n\
    \      if(isPrime(atoi(temp.c_str())))\n        words += temp;\n      \n     \
    \ // check if there are any numbers and break the loop if there are\n      if(count\
    \ > 0)\n        break;\n    }\n  }\n  \n  // return string\n  return words;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfb4pxdxg.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpfb4pxdxg.cpp:85:14: error: \u2018j\u2019 was not declared in this scope\n\
    \   85 |           if(j != ' ' && j != ' ' && j != ' ')\n      |             \
    \ ^\n/tmp/tmpfb4pxdxg.cpp:91:10: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   91 |       if(isPrime(atoi(temp.c_str())))\n\
    \      |          ^~~~~~~\n      |          stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::stack<int> s;\n  std::stack<int>\
    \ t;\n  int size = sentence.size(); // length of sentence\n  for (int i = 0; i\
    \ < size; i++) { // for each character in the sentence\n    t.push(0); // empty\
    \ stack\n    while (!t.empty() && t.top() != i && !s.empty()) { \n      s.pop();\
    \ \n    }\n    t.push(i); // push current char into stack\n    while (!s.empty()\
    \ && s.top() != i && !t.empty()) {\n      s.push(t.top());\n      t.pop();\n \
    \   }\n  }\n  std::string res; // resulting string\n  while (!t.empty()) { \n\
    \    res = s + \" \" + std::to_string(t.top());\n    t.pop();\n  }\n  return res;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptcd5w6r3.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmptcd5w6r3.cpp:34:13: error: no match for \u2018operator+\u2019 (operand\
    \ types are \u2018std::stack<int>\u2019 and \u2018const char [2]\u2019)\n   34\
    \ |     res = s + \" \" + std::to_string(t.top());\n      |           ~ ^ ~~~\n\
    \      |           |   |\n      |           |   const char [2]\n      |      \
    \     std::stack<int>\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptcd5w6r3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptcd5w6r3.cpp:34:15:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018const char [2]\u2019\n   34 |     res = s + \" \" + std::to_string(t.top());\n\
    \      |               ^~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string new_word;\n    std::string\
    \ old_word;\n    int flag = 0;\n    for (char c : sentence) {\n        if (c ==\
    \ '/') {\n            flag = 1;\n            new_word = old_word;\n          \
    \  old_word = c;\n        } else {\n            if (flag == 1) {\n           \
    \     old_word += c;\n            }\n        }\n    }\n    if (flag == 1) {\n\
    \        new_word += old_word;\n    }\n    return new_word;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpxgywqy_5: /tmp/tmpxgywqy_5.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // your code goes here\n    bool\
    \ flag = false;\n    int n = sentence.length();\n    std::string ans = \"empty\"\
    ;\n    int count = 0;\n    for(int i = 0; i<n; i++)\n    {\n        if(isalpha(sentence[i]))\n\
    \        {\n            if(flag)\n            {\n                ans += ' ';\n\
    \                flag = false;\n                count ++;\n            }\n   \
    \         ans += sentence[i];\n            flag = true;\n        }\n        else\n\
    \        {\n            flag = false;\n        }\n    }\n    while(count < n)\n\
    \    {\n        int i2 = 1;\n        int j = 0;\n        for(int j = 0; j<n-count;\
    \ j++)\n        {\n            if(i2*(j+count) > n)\n                break;\n\
    \            if(i2*(j+count) < n)\n            {\n                i2 = i2 * j;\n\
    \                ans += \" \";\n                j++;\n            }\n        }\n\
    \        ans += \" \";\n        count++;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_v9p67fk: /tmp/tmp_v9p67fk.cpp:63: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    for\
    \ (int i = 0; i < sentence.length(); i++)\n    {\n        if (isprime(sentence.at(i)))\n\
    \        {\n            result.push_back(sentence.at(i));\n        }\n    }\n\
    \    return result.empty() ? sentence : result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpiqiwz7ck.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpiqiwz7ck.cpp:21:13: error: \u2018isprime\u2019 was not declared in\
    \ this scope; did you mean \u2018isprint\u2019?\n   21 |         if (isprime(sentence.at(i)))\n\
    \      |             ^~~~~~~\n      |             isprint\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // write your code here\n   \
    \ bool isPrime[105];\n    std::fill(isPrime,isPrime+105,0);\n    std::string newStr\
    \ = \"\";\n    for(int i=0;i<sentence.size();i++)\n    {\n        if(isPrime[sentence[i]])\n\
    \            newStr += sentence[i];\n    }\n    return newStr;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpr8u0_56g: /tmp/tmpr8u0_56g.cpp:31: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> split(sentence);\n\
    \    std::string res = \"{\";\n    for(int i = 0; i < split.size(); i++) {\n \
    \       for(int j = i; j < split.size(); j++) {\n            if((split[i].length()>1\
    \ &&split[j].length()>1) || split[i].length()==1 || split[j].length()==1){\n \
    \               if(split[i].length() == split[j].length() && split[i][0] == split[j][0]){\n\
    \                    res += split[j];\n                    res += split[i];\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    res += \"}\"; // \"}\"\n    return res;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnoo3vvbv.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpnoo3vvbv.cpp:18:44: error: no matching function for call to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::vector(std::string&)\u2019\n \
    \  18 |     std::vector<std::string> split(sentence);\n      |               \
    \                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpnoo3vvbv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:650:2:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::vector<_Tp,\
    \ _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&)\u2019\
    \n  650 |  vector(_InputIterator __first, _InputIterator __last,\n      |  ^~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:650:2: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpnoo3vvbv.cpp:18:44:\
    \ note:   candidate expects 3 arguments, 1 provided\n   18 |     std::vector<std::string>\
    \ split(sentence);\n      |                                            ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpnoo3vvbv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:622:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>,\
    \ const allocator_type&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::allocator_type\
    \ = std::allocator<std::__cxx11::basic_string<char> >]\u2019\n  622 |       vector(initializer_list<value_type>\
    \ __l,\n      |      "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string words = sentence;\n\
    \    std::string::size_type pos = 0;\n    while (pos != std::string::npos) {\n\
    \        pos = words.find(' ', pos + 1);\n        words.erase(0, pos + 1);\n \
    \   }\n\n    std::string answer = words;\n    // Write your code here\n    for\
    \ (int i = 0; i <= answer.size(); i++) {\n        bool isPrime = true;\n     \
    \   for (int j = 2; j <= answer.size(); j++) {\n            if (answer.substr(i,\
    \ 2).find(j, 0) != std::string::npos) {\n                isPrime = false;\n  \
    \          }\n        }\n        if (isPrime) {\n            answer.erase(i, 1);\n\
    \        }\n    }\n    return answer;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpcxyfw8qh: /tmp/tmpcxyfw8qh.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Your code goes here\n    vector<string>\
    \ vec;\n    for(int i=0;i<sentence.size();i++){\n        vec.push_back(sentence[i]);\n\
    \    }\n    sort(vec.begin(),vec.end());\n    string ans=\"\";\n    for(int i=0;i<vec.size();i++){\n\
    \        ans += vec[i];\n    }\n    for(int i=0;i<vec.size();i++){\n        int\
    \ count=0;\n        for(int j=0;j<vec.size();j++){\n            if(vec[i]==vec[j]){\n\
    \                count++;\n            }\n        }\n        if(count%2==0)\n\
    \            ans+=vec[i];\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphj1qfqjj.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmphj1qfqjj.cpp:19:5: error: \u2018vector\u2019 was not declared in this\
    \ scope; did you mean \u2018std::vector\u2019?\n   19 |     vector<string> vec;\n\
    \      |     ^~~~~~\n      |     std::vector\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmphj1qfqjj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:386:11:\
    \ note: \u2018std::vector\u2019 declared here\n  386 |     class vector : protected\
    \ _Vector_base<_Tp, _Alloc>\n      |           ^~~~~~\n/tmp/tmphj1qfqjj.cpp:19:12:\
    \ error: \u2018string\u2019 was not declared in this scope; did you mean \u2018\
    std::string\u2019?\n   19 |     vector<string> vec;\n      |            ^~~~~~\n\
    \      |            std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmphj1qfqjj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmphj1qfqjj.cpp:19:20:\
    \ error: \u2018vec\u2019 was not declared in this scope\n   19 |     vector<string>\
    \ vec;\n      |                    ^~~\n/tmp/tmphj1qfqjj.cpp:23:5: error: \u2018\
    sort\u2019 was not declared in"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string res = \"\";\n   \
    \ int n = sentence.length();\n    for (int i = 0; i < n; ++i) {\n        // get\
    \ the character of the sentence\n        char c = sentence[i];\n        // remove\
    \ whitespaces, newlines, tabs, and other special characters\n        std::string\
    \ w = std::string{ c };\n        for (int j = i - 1; j >= 0; --j) {\n        \
    \    if (c == ' ' || c == '\\n' || c == '\\t' || c == '\\v' || c == '\\f') {\n\
    \                w = w.substr(0, j + 1);\n                break;\n           \
    \ }\n        }\n        if (std::find(w.begin(), w.end(), '\\n') != w.end() &&\
    \ std::find(w.begin(), w.end(), '\\t') != w.end() && std::find(w.begin(), w.end(),\
    \ '\\v') != w.end() && std::find(w.begin(), w.end(), '\\f') != w.end() && std::find(w.begin(),\
    \ w.end(), '\\v') != w.end()) {\n            w = w.substr(0, w.size() - 1);\n\
    \        }\n        // if the length of the word is prime\n        int m = std::sqrt(w.size());\n\
    \        for (int ii = 2; ii <= m; ii++) {\n            if (ii % w == 0) {\n \
    \               // if prime found then add it to the output string\n         \
    \       res += i + '\\n';\n                break;\n            }\n        }\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp14ahepvl.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp14ahepvl.cpp:37:20: error: no match for \u2018operator%\u2019 (operand\
    \ types are \u2018int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   37 |             if (ii % w == 0) {\n      |                 ~~ ^ ~\n \
    \     |                 |    |\n      |                 int  std::string {aka\
    \ std::__cxx11::basic_string<char>}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:603,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp14ahepvl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/valarray_after.h:409:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__modulus,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__modulus, typename\
    \ _Dom1::value_type>::result_type> std::operator%(const std::_Expr<_Dom1, typename\
    \ _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  409 |     _DEFINE_EXPR_BINARY_OPERATOR(%, __modulus)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/valarray_after.h:409:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp14ahepvl.cpp:37:22:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018int\u2019\n   37 |             if (ii % w == 0) {\n      |       \
    \               ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:603,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp14ahepvl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/valarray_after.h:409:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__modulus,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__modulus,\
    \ typename _Dom1::value_type>::resul"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string res;\n    std::stack<char>\
    \ st;\n    for (int i = 0; i < sentence.length(); i++) {\n        if (st.empty())\
    \ {\n            st.push(sentence[i]);\n        } else if (std::find(sentence.begin(),\
    \ sentence.end(), st.top()) == sentence.end()) {\n            st.push(sentence[i]);\n\
    \        } else {\n            st.pop();\n        }\n    }\n    while (!st.empty())\
    \ {\n        res += st.top();\n        st.pop();\n    }\n    return res;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpehju7ycv: /tmp/tmpehju7ycv.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Write your code here\n   \
    \ int size = sentence.size();\n    int count = 0;\n    for (int i = 0; i < size;\
    \ i++) {\n        if (sentence[i] != ' ') {\n            count++;\n        }\n\
    \    }\n    std::string ans = \"\";\n    int index = 0;\n    for (int i = 0; i\
    \ < size; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \            index++;\n        }\n        if (index == (2 * count + 1)) {\n  \
    \          ans += \" \";\n            index = 0;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpy3tkxyo4: /tmp/tmpy3tkxyo4.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::set<std::string> prime_words;\n\
    \    std::set<std::string> ordered_words;\n\n    for (char &c : sentence)\n  \
    \      c = tolower(c);\n\n    for (char c : sentence)\n        if (isalpha(c))\
    \ {\n            std::set<std::string>::iterator it = prime_words.find(c);\n \
    \           if (it != prime_words.end())\n                ordered_words.insert(it->c_str());\n\
    \            else\n                prime_words.insert(c);\n        }\n\n    std::string\
    \ ans = \"\";\n    for (std::string &s : ordered_words) {\n        std::sort(s.begin(),\
    \ s.end());\n        ans += \" \";\n        for (std::string &o : ordered_words)\
    \ {\n            if (s.find(o) == s.end())\n                ans += o;\n      \
    \  }\n    }\n    std::reverse(ans.begin(), ans.end());\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp626skfp3.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp626skfp3.cpp:26:68: error: no matching function for call to \u2018\
    std::set<std::__cxx11::basic_string<char> >::find(char&)\u2019\n   26 |      \
    \       std::set<std::string>::iterator it = prime_words.find(c);\n      |   \
    \                                                                 ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/set:61,\n         \
    \        from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:87,\n\
    \                 from /tmp/tmp626skfp3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_set.h:794:7:\
    \ note: candidate: \u2018std::set<_Key, _Compare, _Alloc>::iterator std::set<_Key,\
    \ _Compare, _Alloc>::find(const key_type&) [with _Key = std::__cxx11::basic_string<char>;\
    \ _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::set<_Key, _Compare, _Alloc>::iterator = std::_Rb_tree_const_iterator<std::__cxx11::basic_string<char>\
    \ >; std::set<_Key, _Compare, _Alloc>::key_type = std::__cxx11::basic_string<char>]\u2019\
    \n  794 |       find(const key_type& __x)\n      |       ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_set.h:794:28:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ key_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \  794 |       find(const key_type& __x)\n      |            ~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_set.h:798:7: note:\
    \ candidate: \u2018std::set<_Key, _Compare, _Alloc>::const_iterator std::set<_Key,\
    \ _Compare, _Alloc>::find(const key_type&) const [with _Key = std::__cxx11::basic_string<char>;\
    \ _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::set<_Key, _Compare, _Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::__cxx11::basic_string<char>\
    \ >; std::set<_Key, _Compare, _Alloc>::key_type = std::__cxx11::basic_string<char>]\u2019\
    \n "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // code here\n    int len = strlen(sentence.c_str());\n\
    \    std::string res = \"\";\n    int cnt = 0;\n    for (int i = 0; i < len; i++)\
    \ {\n        char c = sentence[i];\n        if (std::count(res.begin(), res.end(),\
    \ c) > 0){\n            continue;\n        }\n        int flag = 1;\n        for\
    \ (int j = 0; j < i; j++) {\n            char d = sentence[j];\n            if\
    \ (c == d) {\n                cnt++;\n                flag = 0;\n            \
    \    break;\n            }\n        }\n        if (flag) {\n            res +=\
    \ c;\n        }\n    }\n    if (cnt % 2 == 0) {\n        return res;\n    }\n\
    \    return \"\";\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp9d61ky5b: /tmp/tmp9d61ky5b.cpp:47: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::unordered_set<char> prime_chars;\n\
    \  for (auto &c : sentence) {\n    if (prime_chars.count(c) == 0) {\n      prime_chars.insert(c);\n\
    \    }\n  }\n  assert(prime_chars.size() == 26);\n  std::string ans;\n  std::string\
    \ cur_word;\n  for (auto &c : sentence) {\n    cur_word.push_back(c);\n    if\
    \ (cur_word.size() > 1) {\n      if (prime_chars.count(cur_word[0])) {\n     \
    \   ans.insert(ans.end(), cur_word.begin(), cur_word.end());\n      }\n      cur_word.clear();\n\
    \    }\n  }\n  if (cur_word.size() > 1) {\n    ans.insert(ans.end(), cur_word.begin(),\
    \ cur_word.end());\n  }\n  return ans;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp1ch8ek4q: /tmp/tmp1ch8ek4q.cpp:24: std::string words_in_sentence(std::string):\
    \ Assertion `prime_chars.size() == 26' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::sort(sentence.begin(), sentence.end());\n\
    \    std::string result{\"\"};\n    for (size_t i = 0; i < sentence.length();\
    \ i++) {\n        auto it = sentence.find(\" \");\n        if (it == sentence.end())\n\
    \            result.push_back(sentence[i]);\n        else {\n            auto\
    \ first = it;\n            auto last = it;\n            while (first != std::string::npos)\
    \ {\n                first++;\n                last = it;\n                while\
    \ (first != std::string::npos && first + 1 != last) {\n                    auto\
    \ next = sentence.find(\" \", first);\n                    if (next == std::string::npos)\n\
    \                        result.push_back(sentence[first]);\n                \
    \    else {\n                        if (sentence[first] == sentence[next - 1])\n\
    \                            result.push_back(sentence[first]);\n            \
    \            first = next + 1;\n                    }\n                }\n   \
    \         }\n        }\n    }\n    std::sort(result.begin(), result.end());\n\
    \    std::string ret{\"\"};\n    for (auto ele : result)\n        ret += ele;\n\
    \    return ret;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4py0946z.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp4py0946z.cpp:22:16: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018long unsigned int\u2019 and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   22 |         if (it == sentence.end())\n      |             ~~\
    \ ^~ ~~~~~~~~~~~~~~\n      |             |                 |\n      |        \
    \     long unsigned int std::__cxx11::basic_string<char>::iterator {aka __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp4py0946z.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:886:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  886 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:886:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp4py0946z.cpp:22:32:\
    \ note:   mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL,\
    \ _Container>\u2019 and \u2018long unsigned"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    assert(sentence.length() >= 1);\n\
    \    int flag = 1;\n    std::string temp = \"\";\n    std::string res = \"\";\n\
    \    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i] ==\
    \ ' ') {\n            if (!flag) {\n                flag = 1;\n              \
    \  temp = temp + \" \";\n            } else {\n                flag = 0;\n   \
    \         }\n        } else {\n            if (flag) {\n                temp +=\
    \ sentence[i];\n            } else {\n                res += temp + \" \" + sentence[i];\n\
    \                temp = sentence[i];\n            }\n        }\n    }\n    for\
    \ (int i = temp.length(); i > 0; i--) {\n        if (isPrime(i)) {\n         \
    \   res += temp[i];\n        }\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy54hr4gm.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpy54hr4gm.cpp:40:13: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   40 |         if (isPrime(i))\
    \ {\n      |             ^~~~~~~\n      |             stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ // Write your code here\n    std::stack<std::string> s;\n    for(const auto\
    \ &it: sentence) {\n        if(isalpha(it)) {\n            s.push(it);\n     \
    \   }\n    }\n\n    while(!s.empty()) {\n        std::string str = s.top();\n\
    \        s.pop();\n        if(str.length() == 2) {\n            ans += str;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_qp10jg_.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp_qp10jg_.cpp:23:22: error: no matching function for call to \u2018\
    std::stack<std::__cxx11::basic_string<char> >::push(const char&)\u2019\n   23\
    \ |             s.push(it);\n      |                      ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n       \
    \          from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp_qp10jg_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:233:7:\
    \ note: candidate: \u2018void std::stack<_Tp, _Sequence>::push(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Sequence = std::deque<std::__cxx11::basic_string<char>,\
    \ std::allocator<std::__cxx11::basic_string<char> > >; std::stack<_Tp, _Sequence>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n  233 |       push(const value_type&\
    \ __x)\n      |       ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:233:30:\
    \ note:   no known conversion for argument 1 from \u2018const char\u2019 to \u2018\
    const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n  233 |       push(const value_type& __x)\n      |            ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:238:7: note:\
    \ candidate: \u2018void std::stack<_Tp, _Sequence>::push(std::stack<_Tp, _Sequence>::value_type&&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Sequence = std::deque<std::__cxx11::basic_string<char>,\
    \ std::allocator<std::__cxx11::basic_string<char> > >; std::stack<_Tp, _Sequence>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n  238 |       push(value_type&& __x)\n\
    \      |       ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:238:25:\
    \ note:   no known conversion for argument 1 from \u2018const char\u2019 to \u2018\
    std::stack<std::__cxx11::basic_string<char> >::value_type&&\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>&&\u2019}\n  238 |       push(value_type&& __x)\n\
    \      |            ~~~~~~~~~~~~~^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words(std::sregex_token_iterator(sentence.begin(),sentence.end(),\"\
    \ \"),\n                                  std::sregex_token_iterator());\n   \
    \ // You are not allowed to use any other data structures.\n    // Only STL containers\
    \ are allowed.\n    std::string result(\"\",0);\n    for (auto &i : words) {\n\
    \        // You are not allowed to use any other data structures.\n        //\
    \ Only STL containers are allowed.\n        int count = 1;\n        while (i.size()\
    \ % count == 0)\n            ++count;\n        std::string tmp(\"\",0);\n    \
    \    for (int j = 0; j < i.size(); ++j)\n            tmp += i[j];\n        if\
    \ (is_prime(tmp.size()))\n            result += tmp;\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdrcpsisg.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpdrcpsisg.cpp:18:98: error: no matching function for call to \u2018\
    std::__cxx11::regex_token_iterator<__gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ > >::regex_token_iterator(std::__cxx11::basic_string<char>::iterator, std::__cxx11::basic_string<char>::iterator,\
    \ const char [2])\u2019\n   18 |     std::vector<std::string> words(std::sregex_token_iterator(sentence.begin(),sentence.end(),\"\
    \ \"),\n      |                                                              \
    \                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdrcpsisg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2753:7:\
    \ note: candidate: \u2018std::__cxx11::regex_token_iterator<_Bi_iter, _Ch_type,\
    \ _Rx_traits>::regex_token_iterator(const std::__cxx11::regex_token_iterator<_Bi_iter,\
    \ _Ch_type, _Rx_traits>&) [with _Bi_iter = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; _Ch_type = char; _Rx_traits = std::__cxx11::regex_traits<char>]\u2019\
    \n 2753 |       regex_token_iterator(const regex_token_iterator& __rhs)\n    \
    \  |       ^~~~~~~~~~~~~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2753:7:\
    \ note:   candidate expects 1 argument, 3 provided\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2744:2:\
    \ note: candidate: \u2018template<long unsigned int _Nm> std::__cxx11::regex_token_iterator<_Bi_iter,\
    \ _Ch_type, _Rx_traits>::regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&&,\
    \ const int (&)[_Nm], std::regex_constants::match_flag_type)\u2019 <deleted>\n\
    \ 2744 |  regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&&,\n     \
    \ |  ^~~~~~~~~~~~~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2744:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/t"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // write your code here\n   \
    \ string res;\n    int len = sentence.length();\n    vector<string> words;\n \
    \   for (int i = 0; i < len; i++) {\n        if (sentence.at(i) == ' ') {\n  \
    \          words.push_back(sentence.substr(0, i));\n            sentence.erase(0,\
    \ i + 1);\n        }\n    }\n    int count = 1;\n    for (int i = 0; i < len;\
    \ i++) {\n        for (int j = 0; j < len; j++) {\n            if (words.at(i)\
    \ == words.at(j)) {\n                count++;\n            }\n        }\n    }\n\
    \    for (int i = 0; i < len; i++) {\n        if (words.at(i) == words.at(i))\
    \ {\n            count++;\n        }\n    }\n    for (int i = 0; i < len; i++)\
    \ {\n        for (int j = i + 1; j < len; j++) {\n            if (words.at(i)\
    \ == words.at(j)) {\n                count++;\n            }\n        }\n    }\n\
    \    for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j < len; j++)\
    \ {\n            for (int k = j + 1; k < len; k++) {\n                if (words.at(i)\
    \ == words.at(j) && words.at(i) == words.at(k)\n                        && words.at(i)\
    \ == words.at(j) && words.at(j) == words.at(k)\n                        && words.at(j)\
    \ == words.at(k)\n                        && words.at(j) == words.at(i) && words.at(j)\
    \ == words.at(i)) {\n                    count++;\n                }\n       \
    \     }\n        }\n    }\n    for (int i = 0; i < len; i++) {\n        for (int\
    \ j = i + 1; j < len; j++) {\n            for (int k = j + 1; k < len; k++) {\n\
    \                if (words.at(i) == words.at(j) && words.at(i) == words.at(k)\n\
    \                        && words.at(i) == words.at(j) && words.at(j) == words.at(k)\n\
    \                        && words.at(j) == words.at(k)\n                     \
    \   && words.at(j) == words.at(i) && words.at(j) == words.at(i)) {\n         \
    \           count++;\n                }\n            }\n        }\n    }\n   \
    \ for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j < len; j++) {\n\
    \            for (int k = j + 1; k < len; k++) {\n                if (words.at(i)\
    \ == words.at(j) && words.at(i) == words.at(k)\n                        && words.at(i)\
    \ == words.at(j) && words.at(j) == words.at(k)\n                        && words.at(j)\
    \ == words.at(k)\n                        && words.at(j) == words.at(i) && words.at(j)\
    \ == words.at(i)) {\n                    count++;\n                }\n       \
    \     }\n        }\n    }\n    for (int i = 0; i < len; i++) {\n        for (int\
    \ j = i + 1; j < len; j++) {\n            for (int k = j + 1; k < len; k++) {\n\
    \                if (words.at(i) == words.at(j) && words.at(i) == words.at(k)\n\
    \                        && words.at(i) == words.at(j) && words.at(j) == words.at(k)\n\
    \                        && words.at(j) == \n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpij3abtz7.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpij3abtz7.cpp:19:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   19 |     string res;\n    \
    \  |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpij3abtz7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpij3abtz7.cpp:21:5:\
    \ error: \u2018vector\u2019 was not declared in this scope; did you mean \u2018\
    std::vector\u2019?\n   21 |     vector<string> words;\n      |     ^~~~~~\n  \
    \    |     std::vector\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpij3abtz7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:386:11:\
    \ note: \u2018std::vector\u2019 declared here\n  386 |     class vector : protected\
    \ _Vector_base<_Tp, _Alloc>\n      |           ^~~~~~\n/tmp/tmpij3abtz7.cpp:21:20:\
    \ error: \u2018words\u2019 was not declared in this scope\n   21 |     vector<string>\
    \ words;\n      |                    ^~~~~\n/tmp/tmpij3abtz7.cpp:90:1: error:\
    \ expected primary-expression before \u2018}\u2019 to"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::map<int, bool> divisibles;\n\
    \    std::set<int> primes;\n    for (int i = 0; i < sentence.length(); i++) {\n\
    \        if (!divisibles.count(sentence[i]) && isalpha(sentence[i])) {\n     \
    \       divisibles[sentence[i]] = true;\n        }\n    }\n    for (int i = 1;\
    \ i <= std::sqrt(sentence.length()); i++) {\n        if (divisibles.count(i))\
    \ {\n            primes.insert(i);\n        }\n    }\n    std::unordered_map<char,\
    \ int> chars;\n    std::string output;\n    for (char c : sentence) {\n      \
    \  if (chars.count(c)) {\n            output.append(c);\n        }\n        else\
    \ {\n            output.push_back(c);\n        }\n        if (chars.count(c))\
    \ {\n            chars[c]++;\n        }\n        else {\n            chars[c]\
    \ = 1;\n        }\n    }\n    for (auto it = primes.begin(); it != primes.end();\
    \ ++it) {\n        bool found = true;\n        for (auto it2 = output.begin();\
    \ it2 != output.end(); ++it2) {\n            if (it2[it2 - 1] != *it) {\n    \
    \            found = false;\n            }\n        }\n        if (found) {\n\
    \            return output;\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp72jk_cak.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp72jk_cak.cpp:34:28: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::append(char&)\u2019\n   34 |             output.append(c);\n\
    \      |                            ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp72jk_cak.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1263:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::append(const _CharT*) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \ <near match>\n 1263 |       append(const _CharT* __s)\n      |       ^~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1263:7:\
    \ note:   conversion of argument 1 would be ill-formed:\n/tmp/tmp72jk_cak.cpp:34:27:\
    \ error: invalid conversion from \u2018char\u2019 to \u2018const char*\u2019 [-fpermissive]\n\
    \   34 |             output.append(c);\n      |                           ^\n\
    \      |                           |\n      |                           char\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/in"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int n = sentence.length();\n\
    \    vector<int> prime(n + 1, 2);\n    for (int i = 0; i <= n; i++) {\n      \
    \  prime[i] = 1;\n    }\n    for (int i = 2; i <= n; i++) {\n        while (prime[i]\
    \ < n) {\n            if (sentence[n - prime[i]] == ' ') {\n                prime[i]\
    \ = n;\n                prime[n] = i;\n                break;\n            }\n\
    \            i++;\n        }\n    }\n    string ans = sentence;\n    for (int\
    \ i = 0; i <= n; i++) {\n        if (prime[i] == 0) {\n            ans = ans +\
    \ \" \";\n        } else {\n            ans = ans + sentence.substr(n - prime[i],\
    \ prime[i]);\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjw4ekjc3.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpjw4ekjc3.cpp:19:5: error: \u2018vector\u2019 was not declared in this\
    \ scope; did you mean \u2018std::vector\u2019?\n   19 |     vector<int> prime(n\
    \ + 1, 2);\n      |     ^~~~~~\n      |     std::vector\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n           \
    \      from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n  \
    \               from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpjw4ekjc3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:386:11:\
    \ note: \u2018std::vector\u2019 declared here\n  386 |     class vector : protected\
    \ _Vector_base<_Tp, _Alloc>\n      |           ^~~~~~\n/tmp/tmpjw4ekjc3.cpp:19:12:\
    \ error: expected primary-expression before \u2018int\u2019\n   19 |     vector<int>\
    \ prime(n + 1, 2);\n      |            ^~~\n/tmp/tmpjw4ekjc3.cpp:21:9: error:\
    \ \u2018prime\u2019 was not declared in this scope\n   21 |         prime[i] =\
    \ 1;\n      |         ^~~~~\n/tmp/tmpjw4ekjc3.cpp:24:16: error: \u2018prime\u2019\
    \ was not declared in this scope\n   24 |         while (prime[i] < n) {\n   \
    \   |                ^~~~~\n/tmp/tmpjw4ekjc3.cpp:33:5: error: \u2018string\u2019\
    \ was not declared in this scope; did you mean \u2018std::string\u2019?\n   33\
    \ |     string ans = sentence;\n      |     ^~~~~~\n      |     std::string\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpjw4ekjc3.cpp"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::map<int, bool> prime;\n\
    \    for (auto c : sentence) {\n        prime[(int)c] = true;\n    }\n    std::string\
    \ res = \"\";\n    for (auto c : sentence) {\n        if (prime[(int)c]) {\n \
    \           res += c;\n        }\n    }\n    return res;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_elvy253: /tmp/tmp_elvy253.cpp:32: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    string ans;\n    int len = sentence.length();\n\
    \    string pre;\n    for (int i = 0; i < len; i++)\n    {\n        pre = sentence[i];\n\
    \        for (int j = i; j < len; j++)\n        {\n            if (sentence[j]\
    \ == pre)\n            {\n                if (j - i == 1)\n                {\n\
    \                    ans += pre;\n                }\n                else if (j\
    \ - i == 3)\n                {\n                    ans += pre + \" \";\n    \
    \            }\n                else if (j - i == 5)\n                {\n    \
    \                ans += pre + \" \";\n                }\n                else\
    \ if (j - i == 7)\n                {\n                    ans += pre + \" \";\n\
    \                }\n                else\n                {\n                \
    \    ans += pre + \" \";\n                }\n            }\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpv25ultyw.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpv25ultyw.cpp:18:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   18 |     string ans;\n    \
    \  |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpv25ultyw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpv25ultyw.cpp:20:11:\
    \ error: expected \u2018;\u2019 before \u2018pre\u2019\n   20 |     string pre;\n\
    \      |           ^~~~\n      |           ;\n/tmp/tmpv25ultyw.cpp:23:9: error:\
    \ \u2018pre\u2019 was not declared in this scope\n   23 |         pre = sentence[i];\n\
    \      |         ^~~\n/tmp/tmpv25ultyw.cpp:30:21: error: \u2018ans\u2019 was not\
    \ declared in this scope; did you mean \u2018abs\u2019?\n   30 |             \
    \        ans += pre;\n      |                     ^~~\n      |               \
    \      abs\n/tmp/tmpv25ultyw.cpp:34:21: error: \u2018ans\u2019 was not declared\
    \ in this scope; did you mean \u2018abs\u2019?\n   34 |                     ans\
    \ += pre + \" \";\n      |                     ^~~\n      |                  \
    \   abs\n/tmp/tmpv25ultyw.cpp:38:21: error: \u2018ans\u2019 was not declared in\
    \ this scope; did you mean \u2018abs\u2019?\n   38 |                     ans +=\
    \ pre + \" \";\n      |                     ^~~\n      |                     abs\n\
    /tmp/tmpv25ultyw.cpp:42:21: error: \u2018ans\u2019 was not declared in this "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int n = sentence.length();\n\
    \    std::string ans;\n    \n    for(int i = 2; i < n; i++){\n        int flag\
    \ = 1;\n        for(int j = i; j < n; j++){\n            if(sentence[i] != sentence[j]){\n\
    \                flag = 0;\n            }\n        }\n        if(flag == 1){\n\
    \            ans.push_back(sentence[i]);\n        }\n    }\n    \n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp3jlg0knw: /tmp/tmp3jlg0knw.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    \n    std::stack<std::pair<int,\
    \ int>> minStack;\n    std::stack<std::pair<int, int>> maxStack;\n    \n    bool\
    \ push = false;\n    \n    int min = INT_MAX, max = INT_MIN;\n    \n    // Push\
    \ the current min and max into the stack\n    minStack.push({INT_MAX, INT_MAX});\n\
    \    maxStack.push({INT_MIN, INT_MIN});\n    \n    int length = sentence.length();\n\
    \    \n    // Iterate over the given sentence\n    for (int i = 0; i < length;\
    \ i++) {\n        \n        // Get the current word in the given sentence\n  \
    \      char c = sentence[i];\n        \n        // push the current min\n    \
    \    if (push)\n            minStack.push({min, min + 1});\n        \n       \
    \ // push the current max\n        else\n            maxStack.push({max, max +\
    \ 1});\n        \n        // Push the current word into the stack\n        push\
    \ = c;\n    }\n    \n    // Iterate over the stack and append the words into the\
    \ result string\n    std::string result;\n    \n    while (!minStack.empty())\
    \ {\n        std::pair<int, int> current = minStack.top();\n        \n       \
    \ // Append the current min into the result\n        if (current.first > 0)\n\
    \            result += \" \";\n        \n        if (current.second == length)\
    \ {\n            result += current.first;\n            break;\n        }\n   \
    \     \n        result += current.first;\n        \n        minStack.pop();\n\
    \    }\n    \n    while (!maxStack.empty()) {\n        std::pair<int, int> current\
    \ = maxStack.top();\n        \n        // Append the current max into the result\n\
    \        if (current.second > 0)\n            result += \" \";\n        \n   \
    \     if (current.first == 0) {\n            result += current.second;\n     \
    \       break;\n        }\n        \n        result += current.second;\n     \
    \   maxStack.pop();\n    }\n    \n    return result;\n    \n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpjiem6ki9: /tmp/tmpjiem6ki9.cpp:91: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  int n = sentence.length();\n  int\
    \ ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (is_prime(i)) {\n      ans\
    \ += 1;\n    }\n  }\n  ans *= n;\n  std::string anscopy(ans, '\\0');\n  std::copy(sentence.begin(),\
    \ sentence.end(), anscopy.begin());\n  return anscopy;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6tsj6b92.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp6tsj6b92.cpp:21:9: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   21 |     if (is_prime(i)) {\n      |         ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> split_sentence;\n\
    \    std::string word = \"\";\n    for (char c : sentence) {\n        if (c ==\
    \ ' ') {\n            if (word.empty())\n                continue;\n         \
    \   split_sentence.push_back(word);\n            word.clear();\n        } else\
    \ {\n            word += c;\n        }\n    }\n    if (word.empty())\n       \
    \ split_sentence.push_back(word);\n    std::string result = \"\";\n    for (std::string\
    \ s: split_sentence) {\n        if (std::all_of(s.cbegin(), s.cend(), ::isdigit))\n\
    \            continue;\n        std::string temp = \"\";\n        for (int i =\
    \ 0; i < s.size(); i++) {\n            if (s[s.size() - i - 1] == '.' && s[s.size()\
    \ - i] != 'e') {\n                temp += s.substr(s.size() - i - 1, 1) + s[i];\n\
    \            }\n        }\n        if (std::all_of(temp.cbegin(), temp.cend(),\
    \ ::isdigit))\n            continue;\n        if (s.size() < 3) {\n          \
    \  temp += std::to_string(s.size());\n        }\n        result += \" \" + temp;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_21smnnf: /tmp/tmp_21smnnf.cpp:53: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    if (sentence.empty()) return\
    \ std::string();\n    std::stack<std::string> st;\n    for (int i = 0; sentence[i]\
    \ != '\\0'; i++) {\n        if (sentence[i] >= 'a' && sentence[i] <= 'z') {\n\
    \            st.push(sentence[i]);\n        }\n        if (st.size() == 2) {\n\
    \            if (st[0] == \"go\" && st[1] == \"for\") {\n                st.pop();\n\
    \            }\n            if (st[0] == \"let\" && st[1] == \"go\" && st[2] ==\
    \ \"for\") {\n                st.pop();\n            }\n            if (st[0]\
    \ == \"swim\" && st[1] == \"for\") {\n                st.pop();\n            }\n\
    \            if (st[0] == \"for\" && st[1] == \"swim\" && st[2] == \"go\") {\n\
    \                st.pop();\n            }\n        }\n        if (st.size() !=\
    \ 1 && st.size() != 2 && st.size() != 3 && st.size() != 4 && st.size() != 5) {\n\
    \            st.clear();\n        }\n    }\n    if (st.size() != 1) {\n      \
    \  return std::string();\n    }\n    std::string word;\n    while (st.top() ==\
    \ \"go\") {\n        st.pop();\n        word += \" go\";\n    }\n    while (st.top()\
    \ == \"for\") {\n        st.pop();\n        word += \" for\";\n    }\n    while\
    \ (st.top() == \"let\") {\n        st.pop();\n        word += \" let\";\n    }\n\
    \    while (st.top() == \"swim\") {\n        st.pop();\n        word += \" swim\"\
    ;\n    }\n    while (st.top() == \"for\") {\n        st.pop();\n        word +=\
    \ \" for\";\n    }\n    while (st.size() != 0) {\n        word += \" \";\n   \
    \ }\n    return word;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptxt2r8h8.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmptxt2r8h8.cpp:22:32: error: no matching function for call to \u2018\
    std::stack<std::__cxx11::basic_string<char> >::push(__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type&)\u2019\n   22 |             st.push(sentence[i]);\n     \
    \ |                                ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmptxt2r8h8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:233:7:\
    \ note: candidate: \u2018void std::stack<_Tp, _Sequence>::push(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Sequence = std::deque<std::__cxx11::basic_string<char>,\
    \ std::allocator<std::__cxx11::basic_string<char> > >; std::stack<_Tp, _Sequence>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n  233 |       push(const value_type&\
    \ __x)\n      |       ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:233:30:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to \u2018const value_type&\u2019\
    \ {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n  233 |       push(const\
    \ value_type& __x)\n      |            ~~~~~~~~~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:238:7:\
    \ note: candidate: \u2018void std::stack<_Tp, _Sequence>::push(std::stack<_Tp,\
    \ _Sequence>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Sequence\
    \ = std::deque<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char>\
    \ > >; std::stack<_Tp, _Sequence>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n  238 |       push(value_type&& __x)\n      |       ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:238:25:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::sort(sentence.begin(), sentence.end());\n\
    \    bool isPrime(size_t n) {\n        double d = sqrt(n);\n        double factor\
    \ = 1;\n        for (double i = 1; i < d; ++i) {\n            if (n % i == 0)\
    \ {\n                factor = i;\n                break;\n            }\n    \
    \    }\n        return (n == 1 || (n % factor) == 0);\n    }\n    std::string\
    \ words;\n    size_t size = 0;\n    size_t start = 0;\n    while (true) {\n  \
    \      if (isPrime(size)) {\n            size += 2;\n            continue;\n \
    \       }\n        words[start] = sentence[size - 2];\n        words[start + 1]\
    \ = sentence[size - 1];\n        size += 1;\n        if (size % 2 == 0) {\n  \
    \          start++;\n        }\n        if (size % 3 == 0) {\n            start++;\n\
    \        }\n    }\n    return words;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6btlv1fi.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp6btlv1fi.cpp:19:28: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   19 |     bool isPrime(size_t n) {\n      |  \
    \                          ^\n/tmp/tmp6btlv1fi.cpp:34:13: error: \u2018isPrime\u2019\
    \ was not declared in this scope; did you mean \u2018stime\u2019?\n   34 |   \
    \      if (isPrime(size)) {\n      |             ^~~~~~~\n      |            \
    \ stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> word_vec\
    \ = split(sentence, \" \");\n    std::vector<std::string> res;\n    std::string\
    \ temp;\n    for (std::string word : word_vec) {\n        if (is_prime(word.length()))\
    \ {\n            res.push_back(word);\n        }\n    }\n    for (std::string\
    \ word : res) {\n        temp = temp + \" \" + word;\n    }\n    return temp;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb8r0vu6l.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpb8r0vu6l.cpp:18:41: error: \u2018split\u2019 was not declared in this\
    \ scope\n   18 |     std::vector<std::string> word_vec = split(sentence, \" \"\
    );\n      |                                         ^~~~~\n/tmp/tmpb8r0vu6l.cpp:22:13:\
    \ error: \u2018is_prime\u2019 was not declared in this scope\n   22 |        \
    \ if (is_prime(word.length())) {\n      |             ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<int> primes;\n  \
    \  for (int i = 0; i < 100; ++i) {\n        if (primes[i]) {\n            primes.push_back(false);\n\
    \        }\n    }\n    int prime_counter = 0;\n    for (auto const &word : sentence)\
    \ {\n        bool word_is_prime = true;\n        for (int i = 0; i < primes.size();\
    \ ++i) {\n            if (word.length() > i && !primes[i]) {\n               \
    \ word_is_prime = false;\n            }\n        }\n        if (word_is_prime)\
    \ {\n            primes[word.length()] = true;\n            ++prime_counter;\n\
    \        }\n    }\n    if (prime_counter < 2) {\n        return \"Invalid input\"\
    ;\n    }\n    std::string new_sentence;\n    for (int i = 0; i < 100; ++i) {\n\
    \        if (primes[i]) {\n            new_sentence.insert(new_sentence.size(),\
    \ ' ');\n        }\n    }\n    for (auto const &word : sentence) {\n        int\
    \ word_length = word.length();\n        for (int i = 0; i < 100; ++i) {\n    \
    \        if (primes[i]) {\n                new_sentence.insert(new_sentence.size(),\
    \ word[i]);\n            }\n        }\n    }\n    for (auto const &word : new_sentence)\
    \ {\n        if (new_sentence[word.length() - 1] != ' ') {\n            new_sentence.insert(new_sentence.size(),\
    \ ' ');\n        }\n    }\n    return new_sentence;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpemu6uba8.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpemu6uba8.cpp:28:22: error: request for member \u2018length\u2019 in\
    \ \u2018word\u2019, which is of non-class type \u2018const char\u2019\n   28 |\
    \             if (word.length() > i && !primes[i]) {\n      |                \
    \      ^~~~~~\n/tmp/tmpemu6uba8.cpp:33:25: error: request for member \u2018length\u2019\
    \ in \u2018word\u2019, which is of non-class type \u2018const char\u2019\n   33\
    \ |             primes[word.length()] = true;\n      |                       \
    \  ^~~~~~\n/tmp/tmpemu6uba8.cpp:43:57: error: no matching function for call to\
    \ \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::size_type,\
    \ char)\u2019\n   43 |             new_sentence.insert(new_sentence.size(), '\
    \ ');\n      |                                                         ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpemu6uba8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1534:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // write your code here\n   \
    \ int i = 0;\n    std::string word = \"\";\n    while(sentence[i] != ' ') {\n\
    \        word = word + sentence[i];\n        i++;\n    }\n    std::string result\
    \ = \"\";\n    for(auto iter = word.rbegin(); iter != word.rend(); ++iter) {\n\
    \        result += (std::to_string(*iter) + \" \");\n    }\n    return result\
    \ + \" \";\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp243588u3: /tmp/tmp243588u3.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  assert(sentence.length() != 0);\n\
    \  \n  const auto words = sentence.cbegin(), end = sentence.cend();\n  std::string\
    \ word;\n  bool is_prime = true;\n  while (words != end) {\n    word.assign((*words));\n\
    \    ++words;\n    bool is_odd_num = false;\n    for(auto &c : word) {\n     \
    \ if(isdigit(c)) {\n        is_odd_num = true;\n        break;\n      }\n    }\n\
    \    if(!is_odd_num) {\n      is_prime = false;\n      break;\n    }\n  }\n  return\
    \ is_prime ? word : \"\";\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzs846edd.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpzs846edd.cpp:24:25: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::assign(const char&)\u2019\n   24 |     word.assign((*words));\n\
    \      |                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpzs846edd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1435:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::assign(const _CharT*) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \ <near match>\n 1435 |       assign(const _CharT* __s)\n      |       ^~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1435:7:\
    \ note:   conversion of argument 1 would be ill-formed:\n/tmp/tmpzs846edd.cpp:24:18:\
    \ error: invalid conversion from \u2018char\u2019 to \u2018const char*\u2019 [-fpermissive]\n\
    \   24 |     word.assign((*words));\n      |                 ~^~~~~~~\n      |\
    \                  |\n      |                  char\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/loc"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> all_words;\n\
    \    std::string word;\n    std::string new_word;\n    for (auto i : sentence)\
    \ {\n        char letter = i;\n        if (std::isalpha(letter)) {\n         \
    \   all_words.push_back(word);\n            word.clear();\n        }\n       \
    \ word += letter;\n    }\n    for (auto i : all_words) {\n        auto found =\
    \ std::find(all_words.begin(), all_words.end(), i);\n        assert(found != all_words.end());\n\
    \        std::string temp = i;\n        std::sort(temp.begin(), temp.end());\n\
    \        for (auto j = temp.size() - 1; j >= 2; --j) {\n            auto result\
    \ = std::find(temp.begin(), temp.end(), temp.substr(j, j));\n            if (result\
    \ != temp.end()) {\n                new_word += \" \";\n            }\n      \
    \  }\n        new_word += \" \";\n    }\n    std::reverse(all_words.begin(), all_words.end());\n\
    \    return new_word;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:71,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpuqw34auf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_equals_val<_Value>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Value = const std::__cxx11::basic_string<char>]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:120:14:\
    \   required from \u2018_RandomAccessIterator std::__find_if(_RandomAccessIterator,\
    \ _RandomAccessIterator, _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Predicate\
    \ = __gnu_cxx::__ops::_Iter_equals_val<const std::__cxx11::basic_string<char>\
    \ >]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:161:23:\
    \   required from \u2018_Iterator std::__find_if(_Iterator, _Iterator, _Predicate)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Predicate = __gnu_cxx::__ops::_Iter_equals_val<const std::__cxx11::basic_string<char>\
    \ >]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3899:28:\
    \   required from \u2018_IIter std::find(_IIter, _IIter, const _Tp&) [with _IIter\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_str"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Split sentence into a vector.\n\
    \    std::vector<std::string> sentence_split(sentence);\n    std::string result;\
    \ // the result string\n    for (int i = 0; i < sentence_split.size(); i++) {\n\
    \        // Check each word if the length is prime number.\n        if (std::isposint(std::sqrt(sentence_split[i].length())))\
    \ {\n            // If not, add the word and space to result string.\n       \
    \     result += sentence_split[i] + ' ';\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvyutuand.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpvyutuand.cpp:19:53: error: no matching function for call to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::vector(std::string&)\u2019\n \
    \  19 |     std::vector<std::string> sentence_split(sentence);\n      |      \
    \                                               ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpvyutuand.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:650:2:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::vector<_Tp,\
    \ _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&)\u2019\
    \n  650 |  vector(_InputIterator __first, _InputIterator __last,\n      |  ^~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:650:2: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvyutuand.cpp:19:53:\
    \ note:   candidate expects 3 arguments, 1 provided\n   19 |     std::vector<std::string>\
    \ sentence_split(sentence);\n      |                                         \
    \            ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpvyutuand.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:622:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>,\
    \ const allocator_type&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::allocator_type\
    \ = std::allocator<std::__cxx11::basic_string<char> >]\u2019\n  622 |       vector(initializer"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    string new_word;\n    for(int\
    \ i=0;i<=sentence.length()-1;i++){\n        if(!isPrime(sentence.length())){\n\
    \            new_word.push_back(*sentence.begin());\n        }\n    }\n    return\
    \ new_word;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0ee4ubsh.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp0ee4ubsh.cpp:18:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   18 |     string new_word;\n\
    \      |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0ee4ubsh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmp0ee4ubsh.cpp:20:13:\
    \ error: \u2018isPrime\u2019 was not declared in this scope; did you mean \u2018\
    stime\u2019?\n   20 |         if(!isPrime(sentence.length())){\n      |      \
    \       ^~~~~~~\n      |             stime\n/tmp/tmp0ee4ubsh.cpp:21:13: error:\
    \ \u2018new_word\u2019 was not declared in this scope\n   21 |             new_word.push_back(*sentence.begin());\n\
    \      |             ^~~~~~~~\n/tmp/tmp0ee4ubsh.cpp:24:12: error: \u2018new_word\u2019\
    \ was not declared in this scope\n   24 |     return new_word;\n      |      \
    \      ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    int n = sentence.size(); // length\
    \ of the sentence\n    vector<int> primes; // store the prime numbers\n    primes.resize(n);\
    \ // preallocate the array for the prime numbers\n    for (int i = 0; i < n; i++)\
    \ {\n        if (primes[i] != 1 && sentence[i] == ' ') {\n            primes[i]\
    \ = 2;\n        } else {\n            primes[i] = 1;\n        }\n    }\n    int\
    \ n = primes.size();\n    string new_sentence;\n    for (int i = 0; i < n; i++)\
    \ {\n        while (i < n && primes[i] != 0) {\n            if (sentence[i - 1]\
    \ != ' ' && sentence[i - 1] != '-' && sentence[i - 1] != '!' && sentence[i - 1]\
    \ != '.') {\n                new_sentence += sentence[i - 1];\n              \
    \  primes[i]++;\n            }\n            i++;\n        }\n        if (primes[i]\
    \ == 0) {\n            new_sentence += ' ';\n        }\n    }\n    return new_sentence;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzdvs0at1.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpzdvs0at1.cpp:19:5: error: \u2018vector\u2019 was not declared in this\
    \ scope; did you mean \u2018std::vector\u2019?\n   19 |     vector<int> primes;\
    \ // store the prime numbers\n      |     ^~~~~~\n      |     std::vector\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpzdvs0at1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:386:11:\
    \ note: \u2018std::vector\u2019 declared here\n  386 |     class vector : protected\
    \ _Vector_base<_Tp, _Alloc>\n      |           ^~~~~~\n/tmp/tmpzdvs0at1.cpp:19:12:\
    \ error: expected primary-expression before \u2018int\u2019\n   19 |     vector<int>\
    \ primes; // store the prime numbers\n      |            ^~~\n/tmp/tmpzdvs0at1.cpp:20:5:\
    \ error: \u2018primes\u2019 was not declared in this scope\n   20 |     primes.resize(n);\
    \ // preallocate the array for the prime numbers\n      |     ^~~~~~\n/tmp/tmpzdvs0at1.cpp:28:9:\
    \ error: redeclaration of \u2018int n\u2019\n   28 |     int n = primes.size();\n\
    \      |         ^\n/tmp/tmpzdvs0at1.cpp:18:9: note: \u2018int n\u2019 previously\
    \ declared here\n   18 |     int n = sentence.size(); // length of the sentence\n\
    \      |         ^\n/tmp/tmpzdvs0at1.cpp:29:5: error: \u2018string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::string\u2019?\n   29 |     string\
    \ new_sentence;\n      |     ^~~~~~\n      |     std::string\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector <std::string> splitted;\n\
    \    std::string new_sentence = \"\";\n    \n    std::istringstream is(sentence);\n\
    \    \n    while (is) {\n        std::string word;\n        is >> word;\n    \
    \    splitted.push_back(word);\n    }\n    \n    for (std::vector <std::string>::iterator\
    \ it = splitted.begin(); it != splitted.end(); ++it) {\n        std::sort(splitted.begin(),\
    \ splitted.end(), [it](std::string s1, std::string s2) -> bool {\n           \
    \ return (s1.length() < s2.length());\n        });\n        \n        bool is_prime\
    \ = true;\n        for (int i = 1; i < splitted.size(); i++) {\n            if\
    \ ((*it).length() != splitted.at(i).length() || (*it) != splitted.at(i)) {\n \
    \               is_prime = false;\n                break;\n            }\n   \
    \     }\n        \n        if (is_prime) {\n            new_sentence += *it +\
    \ \" \";\n        }\n    }\n    return new_sentence;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp36b_pn3h: /tmp/tmp36b_pn3h.cpp:50: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n\
    \    std::map<char,int> word_freq;\n    for(int i=0; i<sentence.length(); ++i){\n\
    \        char c = sentence[i];\n        if(c>='A' && c<='Z'){\n            if(c\
    \ in word_freq)\n                ++word_freq[c];\n            else\n         \
    \       word_freq[c] = 1;\n        }\n        else if(c==' ' || c=='\\n'){\n \
    \           auto it = word_freq.find(c);\n            while(it != word_freq.end()){\n\
    \                if((result+\" \").length()==sentence.length()){\n           \
    \         result += it->first;\n                    break;\n                }\n\
    \                ++it;\n            }\n            word_freq.erase(c);\n     \
    \   }\n    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyewdhq7i.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpyewdhq7i.cpp:23:17: error: expected \u2018)\u2019 before \u2018in\u2019\
    \n   23 |             if(c in word_freq)\n      |               ~ ^~~\n      |\
    \                 )\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ word;\n    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i]\
    \ == 'a' || sentence[i] == 'e' || sentence[i] == 'i' || sentence[i] == 'o' ||\
    \ sentence[i] == 'u') {\n            if (ans.length() != 0) {\n              \
    \  ans += \" \";\n            }\n            ans += sentence[i];\n        }\n\
    \    }\n    std::reverse(ans.begin(), ans.end());\n    for (int i = 3; i < ans.length();\
    \ i++) {\n        std::set<std::string> primes;\n        for (int j = 1; j < i;\
    \ j++) {\n            if (ans[j] % i == 0) {\n                primes.insert(ans.substr(j,\
    \ i - j));\n                break;\n            }\n        }\n        for (std::string\
    \ s : primes) {\n            ans.replace(ans.find(s), ans.length(), s);\n    \
    \    }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpv9afaifw: /tmp/tmpv9afaifw.cpp:45: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::vector<std::string> res;\n\
    \  std::stack<std::pair<int, int>> s;\n  int pos = 0;\n  int n = 0;\n  for (auto\
    \ x : sentence) {\n    if (x == '.') {\n      continue;\n    }\n    if (x == '-')\
    \ {\n      if (s.empty() || s.top().first > pos) {\n        s.push(std::make_pair(pos,\
    \ n));\n      }\n      n = 0;\n    } else {\n      n++;\n    }\n    pos = n;\n\
    \  }\n  while (!s.empty()) {\n    s.push(std::make_pair(s.top().first, n));\n\
    \  }\n  while (!s.empty()) {\n    if (s.top().second != 0) {\n      res.push_back(s.top().second);\n\
    \      s.pop();\n    }\n  }\n  return res;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuvyal7ou.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpuvyal7ou.cpp:41:35: error: no matching function for call to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::push_back(int&)\u2019\n   41 |\
    \       res.push_back(s.top().second);\n      |                              \
    \     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpuvyal7ou.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<int> length_prime;\n\
    \    std::string answer;\n    \n    // Get the prime numbers in length\n    for\
    \ (auto i = 0; i < sentence.length(); i++)\n    {\n        if (length_prime.count(i)\
    \ > 0)\n        {\n            length_prime.erase(length_prime.begin()+i);\n \
    \       }\n        else\n        {\n            length_prime.push_back(i);\n \
    \       }\n    }\n    // Sort the length of prime\n    std::sort(length_prime.begin(),length_prime.end());\n\
    \    \n    // Iterate through each word, find the corresponding prime number\n\
    \    for (auto i = 0; i < sentence.length(); i++)\n    {\n        // If it is\
    \ found\n        if (length_prime.count(sentence[i]) == 1)\n        {\n      \
    \      // Add the corresponding prime number to answer\n            answer.append(length_prime[sentence[i]]);\n\
    \            // Remove the corresponding prime number from length_prime\n    \
    \        length_prime.erase(length_prime.begin()+i);\n        }\n    }\n    //\
    \ If there are still primes in the length_prime, append them to the answer\n \
    \   for (auto i = 0; i < length_prime.size(); i++)\n    {\n        answer.append(length_prime[i]);\n\
    \    }\n    return answer;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjffcgz2_.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpjffcgz2_.cpp:24:26: error: \u2018class std::vector<int>\u2019 has no\
    \ member named \u2018count\u2019\n   24 |         if (length_prime.count(i) >\
    \ 0)\n      |                          ^~~~~\n/tmp/tmpjffcgz2_.cpp:40:26: error:\
    \ \u2018class std::vector<int>\u2019 has no member named \u2018count\u2019\n \
    \  40 |         if (length_prime.count(sentence[i]) == 1)\n      |           \
    \               ^~~~~\n/tmp/tmpjffcgz2_.cpp:43:52: error: no matching function\
    \ for call to \u2018std::__cxx11::basic_string<char>::append(__gnu_cxx::__alloc_traits<std::allocator<int>,\
    \ int>::value_type&)\u2019\n   43 |             answer.append(length_prime[sentence[i]]);\n\
    \      |                                                    ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpjffcgz2_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1263:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::append(const _CharT*) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \ <near match>\n 1263 |       append(const _CharT* __s)\n      |       ^~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/b"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  int n = static_cast<int>(sentence.length());\n\
    \  std::unordered_map<int, int> primes_map;\n  primes_map[1] = 1;\n  primes_map[2]\
    \ = 2;\n  primes_map[3] = 5;\n  primes_map[5] = 1;\n  primes_map[7] = 2;\n  primes_map[11]\
    \ = 3;\n  primes_map[13] = 3;\n  primes_map[17] = 2;\n  primes_map[19] = 3;\n\
    \  primes_map[23] = 2;\n  primes_map[29] = 5;\n  primes_map[37] = 7;\n  primes_map[53]\
    \ = 3;\n  primes_map[59] = 5;\n  primes_map[673] = 7;\n  primes_map[823] = 5;\n\
    \  primes_map[891] = 7;\n  primes_map[919] = 5;\n  primes_map[1059] = 3;\n  primes_map[1123]\
    \ = 3;\n  primes_map[1151] = 7;\n  primes_map[1279] = 3;\n  primes_map[1343] =\
    \ 3;\n  primes_map[1391] = 7;\n  primes_map[1447] = 3;\n  primes_map[1511] = 3;\n\
    \  primes_map[1559] = 3;\n  primes_map[1599] = 3;\n  primes_map[1647] = 3;\n \
    \ primes_map[1711] = 3;\n  primes_map[1759] = 3;\n  primes_map[1799] = 3;\n  primes_map[1847]\
    \ = 3;\n  primes_map[1911] = 3;\n  primes_map[1959] = 3;\n  primes_map[1991] =\
    \ 3;\n  primes_map[2047] = 3;\n  primes_map[2111] = 3;\n  primes_map[2175] = 3;\n\
    \  primes_map[2223] = 3;\n  primes_map[2277] = 3;\n  primes_map[2323] = 3;\n \
    \ primes_map[2377] = 3;\n  primes_map[2413] = 3;\n  primes_map[2467] = 3;\n  primes_map[2523]\
    \ = 3;\n  primes_map[2579] = 3;\n  primes_map[2613] = 3;\n  primes_map[2667] =\
    \ 3;\n  primes_map[2723] = 3;\n  primes_map[2779] = 3;\n  primes_map[2823] = 3;\n\
    \  primes_map[2877] = 3;\n  primes_map[2923] = 3;\n  primes_map[2967] = 3;\n \
    \ primes_map[3023] = 3;\n  primes_map[3079] = 3;\n  primes_map[3131] = 3;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpfkdotgph: /tmp/tmpfkdotgph.cpp:81: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::vector<std::string> words(std::sregex_token_iterator(sentence.begin(),\
    \ sentence.end(), \n        std::sregex_token_iterator(), \n        std::sregex_token_iterator()));\n\
    \    std::string ans;\n    for (int i = 1; i <= sqrt(words.size()); i++) {\n \
    \       if (words.size() % i > 0) {\n            std::swap(words[words.size()\
    \ % i], words[words.size() % i + 1]);\n        }\n    }\n    for (auto w : words)\
    \ {\n        ans.push_back(w);\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpz29vn0x5.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpz29vn0x5.cpp:20:37: error: no matching function for call to \u2018\
    std::__cxx11::regex_token_iterator<__gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ > >::regex_token_iterator(std::__cxx11::basic_string<char>::iterator, std::__cxx11::basic_string<char>::iterator,\
    \ std::__cxx11::sregex_token_iterator, std::__cxx11::sregex_token_iterator)\u2019\
    \n   20 |         std::sregex_token_iterator()));\n      |                   \
    \                  ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpz29vn0x5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2753:7:\
    \ note: candidate: \u2018std::__cxx11::regex_token_iterator<_Bi_iter, _Ch_type,\
    \ _Rx_traits>::regex_token_iterator(const std::__cxx11::regex_token_iterator<_Bi_iter,\
    \ _Ch_type, _Rx_traits>&) [with _Bi_iter = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; _Ch_type = char; _Rx_traits = std::__cxx11::regex_traits<char>]\u2019\
    \n 2753 |       regex_token_iterator(const regex_token_iterator& __rhs)\n    \
    \  |       ^~~~~~~~~~~~~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2753:7:\
    \ note:   candidate expects 1 argument, 4 provided\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2744:2:\
    \ note: candidate: \u2018template<long unsigned int _Nm> std::__cxx11::regex_token_iterator<_Bi_iter,\
    \ _Ch_type, _Rx_traits>::regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&&,\
    \ const int (&)[_Nm], std::regex_constants::match_flag_type)\u2019 <deleted>\n\
    \ 2744 |  regex_token_iterator(_Bi_iter, _Bi_iter, const regex_type&&,\n     \
    \ |  ^~~~~~~~~~~~~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2744:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpz29vn0x5.cpp:20:37:\
    \ note:   mismatched types \u2018const int [_Nm]"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  std::string result = \"\";\n  assert(1\
    \ <= sentence.length() &&\n         sentence.length() <= 100 &&\n         std::all_of(sentence.begin(),\
    \ sentence.end(), ::isalpha));\n  std::set<std::string> set;\n  // split string\
    \ by space\n  std::stringstream ss(sentence);\n  while (std::getline(ss, word,\
    \ ' ')) {\n    set.insert(word);\n  }\n  // check all words in set\n  for (const\
    \ auto &word : set) {\n    if (!std::sqrt(word.length()).isPrime()) {\n      continue;\n\
    \    }\n    result += \" \" + word;\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfn8l6w5d.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpfn8l6w5d.cpp:25:27: error: \u2018word\u2019 was not declared in this\
    \ scope\n   25 |   while (std::getline(ss, word, ' ')) {\n      |            \
    \               ^~~~\n/tmp/tmpfn8l6w5d.cpp:30:35: error: request for member \u2018\
    isPrime\u2019 in \u2018std::sqrt<long unsigned int>((& word)->std::__cxx11::basic_string<char>::length())\u2019\
    , which is of non-class type \u2018__gnu_cxx::__enable_if<true, double>::__type\u2019\
    \ {aka \u2018double\u2019}\n   30 |     if (!std::sqrt(word.length()).isPrime())\
    \ {\n      |                                   ^~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result = \"\";\n\
    \    // Split sentence into words\n    std::vector<std::string> sentenceSplit(sentence.begin(),\
    \ sentence.end());\n    std::sort(sentenceSplit.begin(), sentenceSplit.end(),\
    \ [] (std::string a, std::string b) { return a.size() < b.size(); });\n    //\
    \ Iterate through each word\n    for (auto it = sentenceSplit.begin(); it != sentenceSplit.end();\
    \ ++it) {\n        // Check if word is prime\n        bool prime = true;\n   \
    \     for (int i = 2; i < it->size(); ++i) {\n            int div = it->size()\
    \ / i;\n            if (it->size() % i == 0) {\n                prime = false;\n\
    \                break;\n            }\n        }\n        // If word is not prime\n\
    \        if (!prime) {\n            result += it->at(0);\n        }\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_tempbuf.h:60,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphnldeujy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_construct.h:\
    \ In instantiation of \u2018void std::_Construct(_T1*, _Args&& ...) [with _T1\
    \ = std::__cxx11::basic_string<char>; _Args = {char&}]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_uninitialized.h:83:18:\
    \   required from \u2018static _ForwardIterator std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator,\
    \ _InputIterator, _ForwardIterator) [with _InputIterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; _ForwardIterator = std::__cxx11::basic_string<char>*;\
    \ bool _TrivialValueTypes = false]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_uninitialized.h:134:15:\
    \   required from \u2018_ForwardIterator std::uninitialized_copy(_InputIterator,\
    \ _InputIterator, _ForwardIterator) [with _InputIterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; _ForwardIterator = std::__cxx11::basic_string<char>*]\u2019\
    \n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_uninitialized.h:289:37:\
    \   required from \u2018_ForwardIterator std::__uninitialized_copy_a(_InputIterator,\
    \ _InputIterator, _ForwardIterator, std::allocator<_Tp>&) [with _InputIterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _ForwardIterator\
    \ = std::__cxx11::basic_string<char>*; _Tp = std::__cxx11::basic_string<char>]\u2019\
    \n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1582:33:\
    \   required from \u2018void std::vector<_Tp, _Alloc>::_M_range_initialize(_ForwardIterator,\
    \ _ForwardIterator, std::forward_iterator_tag) [with _ForwardIterator = __gnu"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    auto new_string = \"\";\n   \
    \ std::string word = \" \";\n    std::string new_string_temp = sentence;\n   \
    \ for (auto &i : new_string_temp) {\n        if (!std::isalpha(i)) {\n       \
    \     word += i + \" \";\n        } else {\n            if (std::find(sentence.begin(),\
    \ sentence.end(), word) != sentence.end()) {\n                word += new_string;\n\
    \            }\n        }\n    }\n    return new_string;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:71,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpxjsdy2io.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_equals_val<_Value>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Value = const std::__cxx11::basic_string<char>]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:120:14:\
    \   required from \u2018_RandomAccessIterator std::__find_if(_RandomAccessIterator,\
    \ _RandomAccessIterator, _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Predicate\
    \ = __gnu_cxx::__ops::_Iter_equals_val<const std::__cxx11::basic_string<char>\
    \ >]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:161:23:\
    \   required from \u2018_Iterator std::__find_if(_Iterator, _Iterator, _Predicate)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Predicate = __gnu_cxx::__ops::_Iter_equals_val<const std::__cxx11::basic_string<char>\
    \ >]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3899:28:\
    \   required from \u2018_IIter std::find(_IIter, _IIter, const _Tp&) [with _IIter\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_str"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    auto\
    \ words = std::sregex_token_iterator(sentence.begin(), sentence.end(), \n    \
    \    std::sregex(\" \"), std::regex_constants::match_flag_eol);\n    \n    auto\
    \ words_end = std::sregex_token_iterator();\n    \n    for (; words != words_end;\
    \ ++words)\n        result += *words;\n    \n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4s7isuwk.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp4s7isuwk.cpp:20:14: error: \u2018sregex\u2019 is not a member of \u2018\
    std\u2019\n   20 |         std::sregex(\" \"), std::regex_constants::match_flag_eol);\n\
    \      |              ^~~~~~\n/tmp/tmp4s7isuwk.cpp:20:49: error: \u2018match_flag_eol\u2019\
    \ is not a member of \u2018std::regex_constants\u2019; did you mean \u2018match_not_eol\u2019\
    ?\n   20 |         std::sregex(\" \"), std::regex_constants::match_flag_eol);\n\
    \      |                                                 ^~~~~~~~~~~~~~\n    \
    \  |                                                 match_not_eol\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    // Your code here\n    std::string\
    \ ans;\n    int flag = 0;\n    int i = 1;\n    while (!sentence.empty()) {\n \
    \       if (sentence[0] == 'o') {\n            flag = 1;\n        }\n        for\
    \ (int j = 0; j < sentence.size(); j++) {\n            if (sentence[j] != ' ')\
    \ {\n                if (flag == 1) {\n                    ans = ans + sentence.substr(i,\
    \ 1);\n                    i += j;\n                }\n                break;\n\
    \            }\n        }\n        i += sentence.find(\" \");\n        flag =\
    \ 0;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  assert( sentence.find_first_not_of(\"\
    1234567890-=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\") == \"1234567890-=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    \ );\n  \n  int primes[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n  std::string ret = \"\";\n\
    \  for (int i=0;i<10;i++) ret += \" \";\n  \n  for (auto n : sentence){\n    //\
    \ Find the index where n is prime number\n    auto idx = std::find(primes, primes+10,\
    \ n);\n    \n    // If it is a prime number then append it to ret\n    if (idx\
    \ != primes+10)\n      ret += n;\n  }\n  return ret;\n}\nint main() {\n    auto\
    \ candidate = words_in_sentence;\n    assert(candidate((\"This is a test\")) ==\
    \ (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmr0x7cps.cpp:2:\n/tmp/tmpmr0x7cps.cpp: In function\
    \ \u2018std::string words_in_sentence(std::string)\u2019:\n/tmp/tmpmr0x7cps.cpp:18:109:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \   18 |   assert( sentence.find_first_not_of(\"1234567890-=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    ) == \"1234567890-=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" );\n\
    \      |                                                                     \
    \                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmr0x7cps.cpp:20:115: error: too many initializers for \u2018int [10]\u2019\
    \n   20 |   int primes[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n      |                  \
    \                                                                            \
    \                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    bool prime[100] = {0};\n    for\
    \ (char &c : sentence) {\n        c = tolower(c); // To convert all characters\
    \ to lower case\n    }\n    std::string result;\n    std::string word;\n    for\
    \ (int i = 0; i < sentence.size(); i++) {\n        word = sentence[i];\n     \
    \   while (true) {\n            if (prime[word.length()] == 0) {\n           \
    \     prime[word.length()] = true;\n                result.append(word);\n   \
    \             break;\n            }\n            word++;\n        }\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpndbfc2q6.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpndbfc2q6.cpp:32:17: error: no \u2018operator++(int)\u2019 declared\
    \ for postfix \u2018++\u2019 [-fpermissive]\n   32 |             word++;\n   \
    \   |             ~~~~^~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n  // Your code here\n  assert(sentence.length()\
    \ <= 100);\n  std::string res;\n  \n  for (auto &c: sentence)\n  {\n    if (std::isspace(c))\n\
    \    {\n      if (res.empty())\n      {\n        res.push_back(c);\n      }\n\
    \      else\n      {\n        auto it = res.find(c);\n        if (it != res.end())\n\
    \        {\n          res.erase(it);\n        }\n        else\n        {\n   \
    \       res.push_back(c);\n        }\n      }\n    }\n    else\n    {\n      auto\
    \ it = res.find(c);\n      if (it == res.end())\n      {\n        res.push_back(c);\n\
    \      }\n    }\n  }\n\n  std::sort(res.begin(), res.end());\n\n  int size = res.size();\n\
    \  for (int i = 0; i < size - 1; i++)\n  {\n    for (int j = i + 1; j < size;\
    \ j++)\n    {\n      if (res[i] * res[j] % size == 0)\n      {\n        auto it\
    \ = std::find(res.begin(), res.end(), res[i] * res[j] % size);\n        res.erase(it);\n\
    \      }\n    }\n  }\n  \n  return res;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_evchmcu.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp_evchmcu.cpp:33:16: error: no match for \u2018operator!=\u2019 (operand\
    \ types are \u2018long unsigned int\u2019 and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   33 |         if (it != res.end())\n      |             ~~ ^~ ~~~~~~~~~\n\
    \      |             |            |\n      |             |            std::__cxx11::basic_string<char>::iterator\
    \ {aka __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >}\n\
    \      |             long unsigned int\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp_evchmcu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:900:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  900 |\
    \     operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:900:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp_evchmcu.cpp:33:27:\
    \ note:   mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL,\
    \ _Container>\u2019 "
  exit_code: 1
  status: SyntaxError
