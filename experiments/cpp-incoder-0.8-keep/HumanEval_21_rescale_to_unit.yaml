name: HumanEval_21_rescale_to_unit
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers (of\
  \ at least two elements), apply a linear transform to that list,\n// such that the\
  \ smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0,\
  \ 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nstd::vector<float> rescale_to_unit(std::vector<float>\
  \ numbers) {\n"
tests: "}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({2.0,\
  \ 49.9}))) == (std::vector<float>({0.0, 1.0})));\n    assert(candidate((std::vector<float>({100.0,\
  \ 49.9}))) == (std::vector<float>({1.0, 0.0})));\n    assert(candidate((std::vector<float>({1.0,\
  \ 2.0, 3.0, 4.0, 5.0}))) == (std::vector<float>({0.0, 0.25, 0.5, 0.75, 1.0})));\n\
  \    assert(candidate((std::vector<float>({2.0, 1.0, 5.0, 3.0, 4.0}))) == (std::vector<float>({0.25,\
  \ 0.0, 1.0, 0.5, 0.75})));\n    assert(candidate((std::vector<float>({12.0, 11.0,\
  \ 15.0, 13.0, 14.0}))) == (std::vector<float>({0.25, 0.0, 1.0, 0.5, 0.75})));\n\
  }\n"
completions: ["    std::vector<float> result;\n    float min = numbers.front();\n\
    \    float max = numbers.back();\n    for (auto i : numbers)\n        result.resize(i\
    \ + 1);\n        result[0] = (i - min) / (max - min);\n        for (int i = 1;\
    \ i < result.size(); i++)\n            result[i] = result[i - 1] + result[i];\n\
    \    return result;", "    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\
    \    std::vector<float> result(n);\n    std::transform(numbers.begin(), numbers.end(),\
    \ results.begin(), [](float x) {return std::fmod(x, 1.0f);});\n    std::transform(results.begin(),\
    \ results.end(), results.begin(), [](float x) {return (1.0f / x) + 0.5;});\n \
    \   return results;", "    std::vector<float> results;\n    std::transform(numbers.begin(),\
    \ numbers.end(), results.begin(), [](float number) {\n        return number /\
    \ (1.0f - number);\n    });\n    return results;", "    // Initialize a vector\
    \ of length n to store the transformed numbers\n    std::vector<float> results(numbers.size(),\
    \ 0);\n    // Get the largest number\n    auto largest = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    // Iterate through all numbers\n    for (auto number :\
    \ numbers) {\n        // Calculate the new result\n        results[number] = number\
    \ / largest;\n    }\n    // Return the result\n    return results;", "    std::vector<float>\
    \ rescaled;\n    rescaled.push_back(numbers[0]);\n    rescaled.push_back(numbers[0]);\n\
    \    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] > rescaled[rescaled.size()\
    \ - 2]) {\n            rescaled.resize(rescaled.size() + 2);\n            rescaled.push_back(numbers[i]);\n\
    \        }\n        else if (numbers[i] < rescaled[rescaled.size() - 2]) {\n \
    \           rescaled.resize(rescaled.size() + 2);\n            rescaled.push_back(numbers[i]);\n\
    \        }\n        else if (numbers[i] == rescaled[rescaled.size() - 2]) {\n\
    \            rescaled.resize(rescaled.size() + 2);\n            rescaled.push_back(numbers[i]);\n\
    \        }\n    }\n    return rescaled;", "    assert(numbers.size() > 1);\n \
    \   float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float scale =\
    \ 1.0f / (max - min);\n    for (auto number : numbers) {\n        number *= scale;\n\
    \    }\n    return numbers;", "    std::vector<float> res(numbers.begin(), numbers.end());\n\
    \    // Find first number with value greater than 1\n    auto it_min = std::max_element(numbers.begin(),\
    \ numbers.end());\n    res[it_min] = std::min((float)numbers[it_min], 1.0);\n\
    \    // Find last number with value less than 1\n    auto it_max = std::min_element(numbers.begin(),\
    \ numbers.end());\n    res[it_max] = std::max((float)numbers[it_max], 0.0);\n\
    \    return res;", "    std::vector<float> scaled = numbers; // copy the input\
    \ to allow mutable operations\n    scaled.reserve(numbers.size());\n\n    float\
    \ total = std::accumulate(numbers.begin(), numbers.end(), 0.0f);\n    std::vector<float>\
    \ scales = { 0.25f, 0.75f };\n\n    for (float number : numbers) {\n        float\
    \ rescaled = number / total;\n        for (float scale : scales) {\n         \
    \   float scaled_number = rescaled * scale;\n            scaled.push_back(scaled_number);\n\
    \        }\n    }\n    return scaled;", "    std::vector<float> rescaled;\n  \
    \  rescaled.reserve(numbers.size());\n    for(auto num : numbers) rescaled.push_back(num\
    \ / numbers.front());\n    return rescaled;", "    assert(numbers.size() > 0);\n\
    \    std::vector<float> result;\n    float prev_min = 0.f;\n    float curr_min\
    \ = numbers[0];\n    float curr_max = numbers[0];\n    float next_max = numbers[0];\n\
    \    for (std::vector<float>::size_type i = 1; i < numbers.size(); i++) {\n  \
    \      if (numbers[i] < curr_min) {\n            prev_min = curr_min;\n      \
    \      curr_min = numbers[i];\n        } else if (numbers[i] > curr_max) {\n \
    \           curr_max = numbers[i];\n        } else {\n            next_max = numbers[i];\n\
    \        }\n    }\n    result.push_back(0.0f);\n    result.push_back(1.0f - prev_min\
    \ / next_max);\n    return result;", "\tassert(numbers.size() >= 2);\n\n\tstd::vector<float>\
    \ rescaled;\n\n\t// Sort the elements and add first element to array\n\tstd::sort(numbers.begin(),\
    \ numbers.end());\n\trescaled.push_back(numbers[0]);\n\n\tfor (auto number : numbers)\
    \ {\n\t\trescaled.push_back((number - rescaled[rescaled.size() - 1]) / rescaled[rescaled.size()\
    \ - 1]);\n\t}\n\n\treturn rescaled;", "\tassert(numbers.size() > 1);\n\tstd::vector<float>\
    \ result(numbers.size());\n\tfor (size_t i = 0; i < numbers.size(); ++i) {\n\t\
    \tresult[i] = numbers[i] / std::min(numbers[i], 1.0);\n\t}\n\treturn result;",
  "    std::vector<float> result;\n    // We need to find the min/max to scale them\
    \ accordingly\n    const auto min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    const auto max = *std::max_element(numbers.begin(), numbers.end());\n   \
    \ // Apply the transformation to the values\n    for (const auto& number : numbers)\
    \ {\n        result.push_back(number * (max - min) / float(numbers.size()));\n\
    \    }\n    return result;", "    // Create output vector\n    std::vector<float>\
    \ output(numbers.begin(), numbers.end());\n    // Iterate through each element\n\
    \    for (int i = 0; i < numbers.size(); i++) {\n        // Calculate linear weighting\n\
    \        const float w = numbers[i] - numbers[i - 1];\n        // Calculate index\
    \ to place this element in output vector\n        const int idx = (i - 1) * (1.0\
    \ / numbers.size()) + i;\n        // Apply linear weighting\n        output[idx]\
    \ = w * numbers[idx];\n    }\n    return output;", "    // Check list length\n\
    \    if (numbers.empty()) {\n        std::cout << \"Nothing to rescale!\" << std::endl;\n\
    \        return {};\n    }\n    // Find minimum\n    auto min = std::numeric_limits<float>::min();\n\
    \    // Iterate through list\n    for (size_t i = 0; i < numbers.size(); ++i)\
    \ {\n        // Check if the number is bigger than the minimum\n        if (numbers[i]\
    \ < min) {\n            min = numbers[i];\n        }\n    }\n    // Iterate through\
    \ list\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        // Check if\
    \ the number is smaller than the maximum\n        if (numbers[i] > min) {\n  \
    \          numbers[i] /= (max - min);\n        }\n    }\n    return numbers;",
  "    if (numbers.empty())\n        return {};\n\n    // If we have 1 element to\
    \ begin with, we can always return a unit vector with length 1\n    if (numbers.size()\
    \ == 1)\n        return std::vector<float>{1.0};\n\n    // Calculate the length\
    \ of this vector\n    auto length = std::accumulate(numbers.begin(), numbers.end(),\
    \ 0.0f);\n\n    // If the first element is zero, we need to return a unit vector\
    \ with length 1\n    if (numbers[0] == 0)\n        return std::vector<float>{1.0};\n\
    \n    // If the length of this vector is zero, we need to return a unit vector\
    \ with length 1\n    if (length == 0)\n        return std::vector<float>{1.0};\n\
    \n    // Now we will calculate the scale factor\n    auto scale = 1.0f / length;\n\
    \n    // Now we will scale the numbers, multiply them by the scale factor, and\
    \ add the result to the vector\n    std::vector<float> scaled;\n    scaled.reserve(numbers.size());\n\
    \    for (auto n : numbers)\n        scaled.push_back(scale * n);\n\n    return\
    \ scaled;", "    std::vector<float> res(numbers.begin(), numbers.end());\n   \
    \ std::transform(numbers.begin(), numbers.end(), res.begin(), [](float x) { return\
    \ (x - min()) / max() - 1; });\n    return res;", "    assert(numbers.size() >\
    \ 1);\n    auto smallest = std::min_element(numbers.begin(), numbers.end());\n\
    \    auto largest = std::max_element(numbers.begin(), numbers.end());\n    auto\
    \ range = std::distance(numbers.begin(), largest);\n    std::transform(numbers.begin(),\
    \ numbers.end(), numbers.begin(), [largest](int x) -> float {\n        return\
    \ x / range;\n    });\n    // Scale down to [0,1]\n    numbers.erase(numbers.begin(),\
    \ largest);\n    numbers.insert(numbers.begin(), 0.0f);\n    numbers.insert(numbers.end(),\
    \ 1.0f);\n    return numbers;", "    auto min = std::numeric_limits<float>::min();\n\
    \    auto max = std::numeric_limits<float>::max();\n    size_t N = numbers.size();\n\
    \n    std::vector<float> result;\n    result.reserve(N);\n    for (size_t i =\
    \ 0; i < N; i++) {\n        float x = numbers[i];\n        result.push_back((x\
    \ - min) / (max - min));\n    }\n\n    return result;", "    float min = std::numeric_limits<float>::min();\n\
    \    float max = std::numeric_limits<float>::max();\n    float diff = max - min;\n\
    \n    float scale = 1.0f / (diff + 1.0f);\n    numbers.reserve(numbers.size()\
    \ + 2); // +2 is for 0 and 1.0\n    numbers.push_back(0.0f);\n    numbers.push_back(1.0f);\n\
    \n    for (auto &val : numbers) {\n        val = val * scale;\n    }\n\n    return\
    \ numbers;", "    assert(numbers.size() >= 2);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end()); // Smallest number in the list\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end()); // Largest number in the list\n\n    // Calculate the scaled\
    \ values\n    std::vector<float> scaled_numbers;\n    scaled_numbers.reserve(numbers.size());\
    \ // Reserve memory for the new array\n    for (float number : numbers) {\n  \
    \      scaled_numbers.push_back(std::clamp(number, min, max));\n    }\n    return\
    \ scaled_numbers;", "    std::vector<float> output(numbers.size());\n    float\
    \ minVal = min(numbers);\n    float maxVal = max(numbers);\n    for (float & number\
    \ : output) number = (number - minVal) * (1.0 / maxVal - 1.0f);\n    return output;",
  "    std::vector<float> transformed;\n    transformed.push_back(numbers[0]);\n \
    \   for (float number : numbers) {\n        transformed.push_back(number / std::min(transformed[0],\
    \ number));\n    }\n    return transformed;", "    std::vector<float> new_numbers(numbers.size());\n\
    \    for (size_t i = 0; i < numbers.size(); i++) {\n        new_numbers[i] = numbers[i]\
    \ / numbers[0];\n    }\n    return new_numbers;", "    std::vector<float> result;\n\
    \    result.push_back(numbers[0]);\n    float max = numbers[0];\n    for(int i\
    \ = 1; i < numbers.size(); i++) {\n        float number = numbers[i];\n      \
    \  result.push_back(number/max);\n        max = std::max(number, max);\n    }\n\
    \    return result;", "    // Your code here\n    std::vector<float> rescaled_numbers;\n\
    \    for (auto &x : numbers) {\n        rescaled_numbers.push_back((x - numbers.min())\
    \ / (numbers.max() - numbers.min()));\n    }\n    return rescaled_numbers;", " \
    \   size_t N = numbers.size();\n    std::vector<float> scaled(N);\n\n    // Find\
    \ the minimum and maximum numbers and rescale them accordingly.\n    for (size_t\
    \ i = 0; i < N; ++i) {\n        scaled[i] = (numbers[i] - numbers.at(0)) / (numbers.at(0)\
    \ + numbers.at(i));\n    }\n    // Normalize by max of scaled numbers - min of\
    \ scaled numbers\n    float max_val = std::abs(numbers.at(0)) + std::abs(numbers.at(1));\n\
    \    for (size_t i = 0; i < N; ++i) {\n        scaled[i] /= max_val;\n    }\n\
    \    // Normalize by min of scaled numbers - max of scaled numbers\n    max_val\
    \ = std::abs(numbers.at(0)) - std::abs(numbers.at(1));\n    for (size_t i = 0;\
    \ i < N; ++i) {\n        scaled[i] /= max_val;\n    }\n    // Normalize by max\
    \ of scaled numbers - min of scaled numbers\n    max_val = std::abs(numbers.at(0))\
    \ + std::abs(numbers.at(1));\n    for (size_t i = 0; i < N; ++i) {\n        scaled[i]\
    \ *= 2.0;\n    }\n    // Normalize by min of scaled numbers - max of scaled numbers\n\
    \    max_val = std::abs(numbers.at(0)) - std::abs(numbers.at(1));\n    for (size_t\
    \ i = 0; i < N; ++i) {\n        scaled[i] *= 2.0;\n    }\n\n    return scaled;",
  "    std::sort(numbers.begin(), numbers.end());\n    float min_val = numbers[0];\n\
    \    float max_val = numbers[0];\n    for (auto ele : numbers) {\n        if (ele\
    \ < min_val) min_val = ele;\n        if (ele > max_val) max_val = ele;\n    }\n\
    \    std::vector<float> res = {min_val, max_val};\n    for (auto ele : numbers)\
    \ res.push_back(ele);\n    return res;", "    // If all numbers are the same,\
    \ return a single zero\n    if (numbers.size() < 2) {\n        numbers.push_back(0.);\n\
    \        return numbers;\n    }\n    std::vector<float> res(numbers.begin(), numbers.end());\n\
    \    std::sort(res.begin(), res.end());\n    float inv_sum = 0.;\n    for (float\
    \ x : res) {\n        inv_sum += 1 / x;\n    }\n    for (int i = 0; i < res.size();\
    \ ++i) {\n        res[i] *= inv_sum;\n    }\n    return res;", "    assert(numbers.size()\
    \ > 1);\n    float largest = std::max_element(numbers.begin(), numbers.end())\
    \ - numbers.begin();\n    float smallest = std::min_element(numbers.begin(), numbers.end())\
    \ - numbers.begin();\n\n    // apply linear transform\n    std::vector<float>\
    \ result;\n    for (float number : numbers) {\n        float diff = number - smallest;\n\
    \        float ratio = diff / largest;\n        result.push_back(ratio);\n   \
    \ }\n\n    // reverse the resulting vector\n    std::reverse(result.begin(), result.end());\n\
    \    return result;", "    std::vector<float> rescaled_numbers = numbers;\n  \
    \  float min_number = std::min(numbers.begin(), numbers.end()); // Largest number\
    \ in the list is smaller\n    float max_number = std::max(numbers.begin(), numbers.end());\
    \ // Smallest number in the list is bigger\n    rescaled_numbers.front() = min_number\
    \ / (max_number - min_number); // Make first number in the list equal to min_number\n\
    \    rescaled_numbers.back() = (max_number - min_number) / (max_number - min_number);\
    \ // Make last number in the list equal to max_number\n    return rescaled_numbers;",
  "    assert(numbers.size() > 2);\n    numbers.sort([](float a, float b) {\n    \
    \    return std::abs(a) < std::abs(b);\n    });\n    auto min_num = std::abs(numbers[0]);\n\
    \    auto max_num = std::abs(numbers[0]);\n    for (auto num : numbers) {\n  \
    \      min_num = std::min(min_num, num);\n        max_num = std::max(max_num,\
    \ num);\n    }\n    std::vector<float> results(numbers.size());\n    for (auto\
    \ i = 0u; i < numbers.size(); i++) {\n        results[i] = numbers[i] / min_num;\n\
    \    }\n    if (max_num != 0.0f) {\n        float scale = 1.0f / max_num;\n  \
    \      for (auto i = 0u; i < results.size(); i++) {\n            results[i] =\
    \ scale * results[i];\n        }\n    }\n    return results;", "    std::vector<float>\
    \ result;\n    assert(numbers.size() >= 2);\n    float min = std::numeric_limits<float>::max();\n\
    \    float max = std::numeric_limits<float>::min();\n    for (auto n : numbers)\
    \ {\n        min = std::min(min, n);\n        max = std::max(max, n);\n    }\n\
    \    for (float n : numbers) {\n        result.push_back((n - min) / (max - min));\n\
    \    }\n    return result;", "  // Get min and max from numbers\n  float max_val\
    \ = *std::max_element(numbers.begin(), numbers.end());\n  float min_val = *std::min_element(numbers.begin(),\
    \ numbers.end());\n  // If all numbers are the same, return the same thing\n \
    \ if (max_val == min_val) return numbers;\n  // Otherwise, we have to scale the\
    \ numbers to [0, 1]\n  return numbers / max_val * (max_val - min_val) + min_val;",
  "    int n = numbers.size();\n    if (n == 0) return {};\n    int i = 0;\n    while\
    \ (i < n - 1 && numbers[i] < numbers[i - 1]) i++;\n    std::vector<float> new_numbers\
    \ = numbers;\n    new_numbers.resize(i);\n    for (int j = 0; j < i; j++)\n  \
    \      new_numbers[j] = numbers[j] / numbers[i - 1];\n    for (int j = i - 1;\
    \ j >= 0; j--)\n        new_numbers[j] = new_numbers[j] * numbers[i];\n    return\
    \ new_numbers;", "    numbers.reserve(numbers.size() + 1);\n    std::transform(numbers.begin(),\
    \ numbers.end(), numbers.begin(), [](float x){return (x - x) / (float)(numbers.size()\
    \ - 1);});\n    numbers.push_back(1.0f);\n    return numbers;", "    assert(numbers.size()\
    \ >= 2);\n    const float min_number = numbers[0];\n    const float max_number\
    \ = numbers[0];\n    for (int i = 1; i < numbers.size(); i++) {\n        const\
    \ float number = numbers[i];\n        min_number = std::min(min_number, number);\n\
    \        max_number = std::max(max_number, number);\n    }\n    // Scale linearly\
    \ between 0 to 1.\n    std::vector<float> rescaled(numbers.size());\n    for (int\
    \ i = 0; i < numbers.size(); i++) {\n        rescaled[i] = ((numbers[i] - min_number)\
    \ / (max_number - min_number));\n    }\n    return rescaled;", "  // Assert at\
    \ least one input number exists\n  assert(numbers.size() >= 2);\n  std::vector<float>\
    \ ret(numbers.size());\n  for (int i = 0; i < ret.size(); i++) {\n    ret[i] =\
    \ numbers[i] / numbers[0];\n  }\n  return ret;", "    assert(numbers.size() >=\
    \ 2);\n    std::vector<float> rescaled(numbers.size() - 1);\n    for (int i =\
    \ 0; i < numbers.size() - 1; ++i) {\n        rescaled[i] = numbers[i + 1] / numbers[i];\n\
    \    }\n    return rescaled;", "    std::sort(numbers.begin(), numbers.end());\n\
    \    std::vector<float> newnumbers(numbers.begin(), numbers.end());\n    auto\
    \ min = std::min_element(newnumbers.begin(), newnumbers.end());\n    auto max\
    \ = std::max_element(newnumbers.begin(), newnumbers.end());\n    newnumbers[min]\
    \ = 0.0f;\n    newnumbers[max] = 1.0f;\n    return newnumbers;", "    std::vector<float>\
    \ result;\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ delta = max - min;\n    float target_min = min - delta / 2.0f;\n    float target_max\
    \ = max + delta / 2.0f;\n    for (int i = 0; i < numbers.size(); i++) {\n    \
    \    result.push_back(numbers[i] * (target_max - target_min) / delta + target_min);\n\
    \    }\n    return result;", "    std::vector<float> results;\n    float min,\
    \ max;\n    for (float number : numbers) {\n        min = max = number;\n    \
    \    for (float i : numbers) {\n            if (i < min) {\n                min\
    \ = i;\n            }\n            if (i > max) {\n                max = i;\n\
    \            }\n        }\n        results.push_back(float(max - min) / (1.0f\
    \ - min));\n    }\n    return results;", "    assert(numbers.size() > 1);\n  \
    \  // Calculate the scaling factor by dividing the maximum value by all values\
    \ in the list.\n    float scalingFactor = std::max_element(numbers.begin(), numbers.end())\
    \ - numbers.begin();\n    // Multiply all values by this scaling factor.\n   \
    \ std::vector<float> rescaledNumbers(numbers.begin(), numbers.end());\n    for\
    \ (auto& num : rescaledNumbers)\n        num *= scalingFactor;\n    return rescaledNumbers;",
  "    std::vector<float> out;\n    int n = numbers.size();\n    assert(n >= 2);\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 1;\
    \ i < n; i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n\
    \        }\n        if (numbers[i] < min) {\n            min = numbers[i];\n \
    \       }\n    }\n\n    float m = (max - min);\n    float s = 0.0;\n    for (int\
    \ i = 0; i < n; i++) {\n        s += numbers[i];\n    }\n    float scale = (m\
    \ == 0) ? 1.0 : m / s;\n\n    for (int i = 0; i < n; i++) {\n        out.push_back(numbers[i]\
    \ * scale);\n    }\n    return out;", "\tstd::vector<float> res(numbers.begin(),\
    \ numbers.end());\n\tfloat min = *std::min_element(numbers.begin(), numbers.end());\n\
    \tfloat max = *std::max_element(numbers.begin(), numbers.end());\n\tassert(min\
    \ < max);\n\tfloat factor = max - min;\n\tif (factor > 1e-6) {\n\t\tfloat scaling_factor\
    \ = 1.0;\n\t\tif (factor > 1e-4) {\n\t\t\tscaling_factor = factor;\n\t\t} else\
    \ if (factor > 1e-3) {\n\t\t\tscaling_factor = factor;\n\t\t} else {\n\t\t\tscaling_factor\
    \ = factor;\n\t\t}\n\t\tfor (size_t i = 0; i < numbers.size(); i++) {\n\t\t\t\
    res[i] = numbers[i] - min * scaling_factor;\n\t\t}\n\t} else {\n\t\tfor (size_t\
    \ i = 0; i < numbers.size(); i++) {\n\t\t\tres[i] = 0;\n\t\t}\n\t}\n\treturn res;",
  "    std::vector<float> rescaled_numbers = numbers;\n    assert(numbers.size() >\
    \ 0);\n    float smallest_number = numbers[0];\n    float largest = numbers[0];\n\
    \    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] < smallest_number)\
    \ {\n            smallest_number = numbers[i];\n        }\n        if (numbers[i]\
    \ > largest) {\n            largest = numbers[i];\n        }\n    }\n    rescaled_numbers[0]\
    \ = smallest_number;\n    rescaled_numbers[rescaled_numbers.size() - 1] = largest;\n\
    \    // Scale from [-1,1] to [0,1]\n    std::vector<float> scaled_numbers(rescaled_numbers.size());\n\
    \    for (int i = 0; i < rescaled_numbers.size(); i++) {\n        scaled_numbers[i]\
    \ = rescaled_numbers[i] * (1.0f / (float)(numbers.size() - 1));\n    }\n    return\
    \ scaled_numbers;", "  // Initialize new vector with initial values\n  std::vector<float>\
    \ rescaled(numbers.size());\n  for (size_t i = 0; i < numbers.size(); ++i) {\n\
    \    rescaled[i] = numbers[i] / numbers.front();\n  }\n  // Find the smallest\
    \ and largest number\n  float min_value = rescaled[0];\n  float max_value = rescaled[0];\n\
    \  for (size_t i = 1; i < numbers.size(); ++i) {\n    if (rescaled[i] < min_value)\
    \ {\n      min_value = rescaled[i];\n    } else if (rescaled[i] > max_value) {\n\
    \      max_value = rescaled[i];\n    }\n  }\n  // Make sure min and max values\
    \ are the original values\n  assert(max_value - min_value >= 1e-10);\n  assert(numbers.front()\
    \ == min_value);\n  assert(numbers.back() == max_value);\n  // Rescale original\
    \ numbers to range [0, 1]\n  for (size_t i = 0; i < numbers.size(); ++i) {\n \
    \   rescaled[i] = (numbers[i] - min_value) / (max_value - min_value);\n  }\n \
    \ return rescaled;", "    if (numbers.empty() || numbers.front() <= 0) {\n   \
    \     throw std::runtime_error(\"Cannot rescale empty or negative numbers!\");\n\
    \    }\n\n    std::vector<float> out(numbers.begin(), numbers.end());\n    float\
    \ range = *(&(out[1] - &(out[0])));\n\n    // calculate new min and max\n    auto\
    \ smallest_float = std::min_element(std::begin(out), std::end(out));\n    auto\
    \ largest = std::max_element(std::begin(out), std::end(out));\n\n    // calculate\
    \ new min\n    float new_min = smallest_float - range * 0.5;\n\n    // calculate\
    \ new max\n    float new_max = largest + range * 0.5;\n\n    for (auto number\
    \ : out) {\n        number = number / range;\n    }\n    return out;", "    //\
    \ Initialize result to 0\n    std::vector<float> result;\n    // Initialize minimum\
    \ number to 0\n    float min = numbers[0];\n    // Initialize maximum number to\
    \ 1\n    float max = numbers[0];\n    // Initialize number of elements in list\n\
    \    int n = numbers.size();\n    // Iterate through every element\n    for (int\
    \ i = 0; i < n; i++) {\n        // Update minimum\n        if (numbers[i] < min)\
    \ {\n            min = numbers[i];\n        }\n        // Update maximum\n   \
    \     if (numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n\
    \    // Initialize current number\n    float cur = 0;\n    // Iterate through\
    \ every element in the list\n    for (int i = 0; i < n; i++) {\n        // Update\
    \ current number\n        cur = (cur * (n - i)) / (i + 1) + numbers[i];\n    \
    \    // Update result\n        result.push_back(cur);\n    }\n    // Return result\n\
    \    return result;", "  assert(numbers.size() >= 2);\n  // First find min and\
    \ max of the input numbers\n  auto min_element = *std::min_element(numbers.begin(),\
    \ numbers.end());\n  auto max_element = *std::max_element(numbers.begin(), numbers.end());\n\
    \n  // Calculate the new min and max\n  auto new_min = max_element - std::min(min_element,\
    \ 1.0f);\n  auto new_max = 1.0f - std::max(max_element, 1.0f);\n\n  // Now calculate\
    \ the new scale factor for each number\n  std::vector<float> scale_factors(numbers.size(),\
    \ 1.0f);\n  for (size_t index = 0; index < numbers.size(); index++) {\n    scale_factors[index]\
    \ = new_min + (new_max - new_min) * numbers[index] / max_element;\n  }\n  return\
    \ scale_factors;", "    std::sort(numbers.begin(), numbers.end());\n    float\
    \ max_val = *std::max_element(numbers.begin(), numbers.end()); // get max value\n\
    \    numbers.erase(std::remove_if(numbers.begin(), numbers.end(), [max_val](int\
    \ n) { return n>max_val; }), numbers.end()); // remove max value\n    numbers.insert(numbers.begin(),\
    \ 0.0);\n    numbers.push_back(1.0); // add 1\n    return numbers;", "  // Sort\
    \ all the numbers in increasing order\n  std::sort(numbers.begin(), numbers.end());\n\
    \  // If the largest number is 0, make its next number 1\n  if(numbers[numbers.size()\
    \ - 1] == 0) {\n    numbers[numbers.size() - 1] = 1;\n  }\n  // If the smallest\
    \ number is 0, make its next number 0\n  if(numbers[0] == 0) {\n    numbers[0]\
    \ = 1;\n  }\n  // Multiply all the numbers by the smallest number (the one)\n\
    \  float scaler = numbers[0];\n  numbers.erase(std::remove(numbers.begin(), numbers.end(),\
    \ 0), numbers.end());\n  for(int i = 0; i < numbers.size(); ++i) {\n    scaler\
    \ *= numbers[i];\n  }\n  // Divide each number by that number\n  for(float number\
    \ : numbers) {\n    number /= scaler;\n  }\n  // Return the scaled numbers\n \
    \ return numbers;", "    std::vector<float> new_numbers;\n    for (size_t i =\
    \ 0; i < numbers.size(); i++) {\n        new_numbers.push_back(numbers[i] - min(numbers));\n\
    \    }\n    float max_number = max(new_numbers);\n    float min_number = min(new_numbers);\n\
    \    for (size_t i = 0; i < new_numbers.size(); i++) {\n        new_numbers[i]\
    \ = (new_numbers[i] - min_number) / (max_number - min_number);\n    }\n    return\
    \ new_numbers;", "  // Store the original min and max\n  const float min_value\
    \ = *std::min_element(numbers.begin(), numbers.end());\n  const float max_value\
    \ = *std::max_element(numbers.begin(), numbers.end());\n\n  // Compute the range\
    \ from 0 to 1\n  const float delta = (max_value - min_value) / (numbers.size()\
    \ - 1);\n  std::vector<float> res(numbers.begin(), numbers.end());\n\n  // Make\
    \ sure to scale the smallest number to 0, and the largest to 1\n  for (int i =\
    \ 0; i < numbers.size(); ++i) {\n    res[i] = (numbers[i] - min_value) / delta;\n\
    \  }\n  return res;", "    std::vector<float> new_numbers;\n    if (numbers.empty())\
    \ return new_numbers;\n    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (auto &num : numbers) {\n        if (num < smallest) smallest = num;\n\
    \        if (num > largest) largest = num;\n    }\n    for (float num : numbers)\
    \ {\n        if (num < smallest) num -= smallest / largest * num;\n        new_numbers.push_back(num);\n\
    \    }\n    return new_numbers;", "    assert(numbers.size() > 1);\n    int N\
    \ = numbers.size();\n    std::vector<float> ret(N);\n    for (int i = 0; i < N;\
    \ i++)\n        ret[i] = numbers[i] / std::max(numbers[i - 1], numbers[i]);\n\
    \    return ret;", "    numbers.sort();\n    std::vector<float> unit;\n    float\
    \ last_number = 0.0;\n    float last_unit_number = 0.0;\n    float unit_number\
    \ = 0.0;\n    for (float num : numbers) {\n        if (num != last_number) {\n\
    \            unit.push_back(unit_number);\n            unit_number = 0.0;\n  \
    \          last_unit_number = last_number;\n        }\n        last_number = num;\n\
    \        unit_number += last_number;\n    }\n    unit.push_back(unit_number);\n\
    \    return unit;", "  std::transform(numbers.begin(), numbers.end(), numbers.begin(),\
    \ [](float x) { return (x / 2.0f); });\n  return numbers;", "    assert(numbers.size()\
    \ >= 2);\n    auto first = numbers.begin();\n    auto last = numbers.end();\n\
    \    std::transform(first, last, numbers.begin(),\n                    [](float\
    \ x) { return std::min(std::max(x, 0.0f), 1.0f); });\n    return numbers;", " \
    \   std::sort(numbers.begin(), numbers.end());\n    if (numbers.size() <= 1) {\n\
    \        return numbers;\n    }\n    numbers.erase(std::unique(numbers.begin(),\
    \ numbers.end()), numbers.end());\n    numbers.resize(numbers.size() / 2);\n \
    \   std::vector<float> results;\n    std::transform(numbers.begin(), numbers.end(),\
    \ std::back_inserter(results),\n                   [&](float value) {\n      \
    \                 return (value - numbers[0]) / (numbers[numbers.size() / 2] -\
    \ numbers[0]);\n                   });\n    return results;", "    int N = numbers.size();\n\
    \    assert(N > 2);\n    std::vector<float> newVec;\n    newVec.resize(N, 0);\n\
    \    float sumOfNumbers = numbers[0];\n    float sumOfSquares = numbers[0] * numbers[0];\n\
    \    for (size_t i = 1; i < N; i++) {\n        float element = numbers[i];\n \
    \       sumOfNumbers += element;\n        sumOfSquares += element * element;\n\
    \    }\n    float scale = sumOfNumbers / (sumOfNumbers * sumOfNumbers);\n    float\
    \ sumOfNewNumbers = 0;\n    float newSumOfSquares = 0;\n    for (size_t i = 0;\
    \ i < N; i++) {\n        float element = numbers[i];\n        newSumOfSquares\
    \ += element*element;\n        float temp = (element - sumOfNumbers) * scale *\
    \ scale;\n        newSumOfNewNumbers += temp;\n        newVec[i] = temp;\n   \
    \ }\n    newVec[N-1] = newSumOfNewNumbers;\n    return newVec;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> newNumbers = numbers;\n    newNumbers[0] = 0;\n\
    \    newNumbers.back = 1;\n    auto length = newNumbers.size();\n    auto sumOfSquaredDiffs\
    \ = newNumbers.cwiseProduct(newNumbers) - length * sumOfSquares(newNumbers);\n\
    \    auto scaleFactor = sumOfSquaredDiffs.sum() / sumOfSquares(newNumbers);\n\
    \    auto scaledNewNumbers = newNumbers.cwiseProduct(scaleFactor);\n    return\
    \ scaledNewNumbers;", "    std::sort(numbers.begin(), numbers.end());\n\n    //\
    \ Find smallest and largest elements\n    auto smallest = numbers.front();\n \
    \   auto largest = numbers.back();\n\n    // Scale elements to unit interval\n\
    \    std::vector<float> scaled = numbers;\n    for (auto number : scaled) {\n\
    \        number *= (1.0f / largest);\n        smallest += number;\n    }\n   \
    \ return scaled;", "    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ range = max - min;\n    std::vector<float> scaled;\n    scaled.push_back(min);\n\
    \    for (float number : numbers)\n        scaled.push_back(number * range / (max\
    \ - min));\n    return scaled;", "    if (numbers.size() < 2) return numbers;\n\
    \    std::sort(numbers.begin(), numbers.end());\n    float maximum = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float minimum = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float delta = (maximum - minimum) / static_cast<float>(numbers.size() - 1);\n\
    \    for (auto number : numbers) {\n        number *= delta;\n    }\n    return\
    \ numbers;", "    std::vector<float> scaled;\n    float maxval = std::numeric_limits<float>::max();\n\
    \    float minval = std::numeric_limits<float>::min();\n    for (auto x : numbers)\
    \ {\n        maxval = std::max(maxval, x);\n        minval = std::min(minval,\
    \ x);\n    }\n    for (auto x : numbers) {\n        scaled.push_back(x / maxval\
    \ - minval);\n    }\n    return scaled;", "    std::sort(numbers.begin(), numbers.end());\n\
    \    float minimum = numbers[0];\n    float maximum = numbers[0];\n    for (float\
    \ val : numbers) {\n        minimum = std::min(minimum, val);\n        maximum\
    \ = std::max(maximum, val);\n    }\n    std::cout << \"minimum = \" << minimum\
    \ << std::endl;\n    std::cout << \"maximum = \" << maximum << std::endl;\n  \
    \  std::vector<float> result(numbers.size());\n    for (float val : numbers) {\n\
    \        float ratio = val / maximum;\n        result[numbers.size() - 1 - std::find_if(numbers.begin()\
    \ + 1, numbers.end(), [ratio](float v)\n        {\n            return v / ratio;\n\
    \        }) - 1] = val;\n    }\n    return result;", "    // Sort numbers in ascending\
    \ order\n    std::sort(numbers.begin(), numbers.end());\n    double current_min\
    \ = numbers[0];\n    double current_max = numbers[0];\n    std::vector<float>\
    \ results;\n    // Perform linear transform (min - current_min) / (max - current_max),\
    \ for all numbers in list\n    for (auto& x : numbers) {\n        double current_value\
    \ = x - current_min;\n        double new_value = current_value / (current_max\
    \ - current_min);\n        results.push_back(new_value);\n        current_min\
    \ = current_min;\n        current_max = current_value;\n    }\n    return results;",
  "    assert(numbers.size() > 1);\n    std::vector<float> result;\n    // For each\
    \ number, determine the index of the smallest non-zero element\n    size_t best_index\
    \ = 0;\n    float smallest_non_zero = numbers[0];\n    for (size_t i = 1; i <\
    \ numbers.size(); ++i) {\n        if (numbers[i] != 0.0f) {\n            if (smallest_non_zero\
    \ > numbers[i]) {\n                best_index = i;\n                smallest_non_zero\
    \ = numbers[i];\n            }\n        }\n    }\n    std::vector<float>::iterator\
    \ best_element_iter = numbers.begin() + best_index;\n    std::vector<float>::iterator\
    \ max_element_iter = numbers.begin();\n    // Iterate through all numbers except\
    \ the best_element_iter, find max and min elements\n    for (size_t i = 1; i <\
    \ numbers.size(); ++i) {\n        if (numbers[i] != 0.0f) {\n            float\
    \ new_max = max_element_iter[0];\n            float new_min = min_element_iter[0];\n\
    \            if (numbers[i] > new_max) {\n                new_max = numbers[i];\n\
    \            }\n            if (numbers[i] < new_min) {\n                new_min\
    \ = numbers[i];\n            }\n            result.push_back(new_max - new_min);\n\
    \        }\n        max_element_iter = std::min(max_element_iter, numbers.begin()\
    \ + i);\n        min_element_iter = std::max(min_element_iter, numbers.begin()\
    \ + i);\n    }\n    return result;", "    assert(numbers.size() >= 2);\n    float\
    \ largest = numbers[0];\n    float smallest = numbers[0];\n    for (auto number\
    \ : numbers) {\n        if (number > largest) largest = number;\n        if (number\
    \ < smallest) smallest = number;\n    }\n    std::vector<float> out(numbers.size());\n\
    \    std::vector<float> scale(numbers.size());\n    float ratio = largest/smallest;\n\
    \    float minus_inf = -1/std::numeric_limits<float>::infinity();\n    float plus_inf\
    \ = +std::numeric_limits<float>::infinity();\n    float minus_0 = -1.0;\n    float\
    \ plus_0 = +1.0;\n    for (int i = 0; i < numbers.size(); i++) {\n        scale[i]\
    \ = ratio;\n        scale[i] = std::min(minus_inf, std::max(-minus_0, scale[i]));\n\
    \        scale[i] = std::min(plus_inf, std::max(plus_0, scale[i]));\n        out[i]\
    \ = numbers[i] * scale[i];\n    }\n    return out;", "    assert(numbers.size()\
    \ >= 2);\n    assert(numbers.size() % 2 == 0);\n    auto middle = (numbers.size()\
    \ / 2) + 1;\n    std::array<float, middle> minmax_elements;\n    for (int i =\
    \ 0; i < middle; ++i) {\n        minmax_elements[i] = numbers[2 * i] + numbers[2\
    \ * i + 1];\n    }\n    // minmax_elements[i] = numbers[i] - numbers[i + 1]; //\
    \ this is better\n    minmax_elements[middle] = numbers[middle] - numbers[middle\
    \ - 1];\n    // minmax_elements[middle] = numbers[middle]; // this is better\n\
    \    auto max_index = minmax_elements[middle];\n    auto min_index = minmax_elements[middle\
    \ - 1];\n    for (int i = 0; i < numbers.size(); ++i) {\n        numbers[i] =\
    \ numbers[i] - min_index;\n        numbers[i + 1] = numbers[i + 1] - max_index;\n\
    \    }\n    return numbers;", "  // Initialize variables\n  float max = numbers[0];\n\
    \  float min = numbers[0];\n  // Loop through each number\n  for (float number\
    \ : numbers) {\n    // If this number is bigger than the previous max and smaller\
    \ than the previous min,\n    // then update the min and max variables\n    if\
    \ (number > max) {\n      max = number;\n    } else if (number < min) {\n    \
    \  min = number;\n    }\n  }\n  // Initialize a vector to store the new numbers\n\
    \  std::vector<float> new_numbers;\n  // Loop through each number\n  for (float\
    \ number : numbers) {\n    // If this number is bigger than the previous max and\
    \ smaller than the previous min,\n    // then append a new number to the new_numbers\
    \ vector\n    if (number > max) {\n      new_numbers.push_back(0.0);\n    } else\
    \ if (number < min) {\n      new_numbers.push_back(1.0);\n    } else {\n     \
    \ new_numbers.push_back(number);\n    }\n  }\n  return new_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto & n : numbers) {\n        rescaled_numbers.push_back((n - numbers[0])\
    \ / (numbers[1] - numbers[0]));\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ > 2);\n    int min_index = 0, max_index = numbers.size() - 1;\n    float min_element\
    \ = numbers[min_index], max_element = numbers[max_index];\n    while (numbers[min_index]\
    \ != numbers[max_index]) {\n        if (numbers[min_index] < numbers[max_index])\
    \ {\n            ++min_index;\n        } else {\n            --max_index;\n  \
    \      }\n        min_element = numbers[min_index];\n        max_element = numbers[max_index];\n\
    \    }\n    std::vector<float> newVector;\n    for (int i = 0; i < numbers.size()\
    \ - 1; i++) {\n        if (numbers[i] > numbers[i + 1]) {\n            newVector.push_back(1.0f\
    \ - max_element / min_element);\n            max_element = 1.0f - min_element;\n\
    \            min_element = 0.0f;\n        } else if (numbers[i] < numbers[i +\
    \ 1]) {\n            newVector.push_back(0.0f - min_element / max_element);\n\
    \            min_element = 0.0f;\n            max_element = 1.0f - max_element;\n\
    \        }\n    }\n    newVector.push_back(1.0f - max_element / min_element);\n\
    \    return newVector;", "    // Sort numbers in ascending order\n    numbers.sort([](float\
    \ n1, float n2) { return n1 < n2; });\n    auto prev_n = numbers[0];\n    numbers.erase(numbers.begin());\n\
    \    for (float n : numbers) {\n        if (n < prev_n) throw std::runtime_error(\"\
    [rescale_to_unit] Numbers cannot be ordered\");\n        prev_n = n;\n    }\n\
    \    // Apply linear transformation to the sorted numbers\n    auto min_val =\
    \ prev_n;\n    auto max_val = prev_n;\n    for (auto n : numbers) {\n        min_val\
    \ = std::min(min_val, n);\n        max_val = std::max(max_val, n);\n    }\n  \
    \  // Compute scaling factor\n    auto scale = max_val - min_val;\n    // Rescale\
    \ numbers\n    std::vector<float> out;\n    for (auto n : numbers) {\n       \
    \ out.push_back((n - min_val) * scale);\n    }\n    // Check output range\n  \
    \  if (out[0] < 0.0f || out[0] > 1.0f) throw std::runtime_error(\"[rescale_to_unit]\
    \ Numbers are not in range\");\n    if (out[1] > 1.0f) out.push_back(1.0f);\n\
    \    return out;", "    assert(numbers.size() > 2);\n    std::vector<float> result;\n\
    \    result.reserve(numbers.size());\n    float smallest = FLT_MAX;\n    float\
    \ largest = -FLT_MAX;\n    float scale = 1.0f / (numbers.size() - 1);\n    for\
    \ (size_t i = 0; i < numbers.size(); ++i) {\n        smallest =\n            \
    \    std::min(smallest, numbers[i]);\n        largest =\n                std::max(largest,\
    \ numbers[i]);\n        result.push_back((numbers[i] - smallest) * scale);\n \
    \   }\n    result.push_back(largest * scale);\n    return result;", "    assert(numbers.size()\
    \ >= 2);\n    // std::cout << \"numbers.size(): \" << numbers.size() << std::endl;\n\
    \    float min_x = numbers[0];\n    float max_x = numbers[0];\n    for (auto num\
    \ : numbers) {\n        if (num < min_x) {\n            min_x = num;\n       \
    \ }\n        if (num > max_x) {\n            max_x = num;\n        }\n    }\n\
    \    // std::cout << \"min_x: \" << min_x << std::endl;\n    // std::cout << \"\
    max_x: \" << max_x << std::endl;\n    float scale = (max_x - min_x) / (numbers.size()\
    \ - 1);\n    // std::cout << \"scale: \" << scale << std::endl;\n    std::vector<float>\
    \ scaled_numbers;\n    scaled_numbers.reserve(numbers.size());\n    for (auto\
    \ num : numbers) {\n        scaled_numbers.push_back(static_cast<float>(num -\
    \ min_x) * scale);\n    }\n    // std::cout << \"scaled_numbers: \" << scaled_numbers.size()\
    \ << std::endl;\n    return scaled_numbers;", "    assert(numbers.size() >= 2);\n\
    \    // The list must be sorted in increasing order.\n    std::vector<float> result(numbers.size());\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (int i = 1;\
    \ i < numbers.size(); i++) {\n        if (numbers[i] < min) {\n            min\
    \ = numbers[i];\n        } else if (numbers[i] > max) {\n            max = numbers[i];\n\
    \        }\n        result[i] = (numbers[i] - min) / (max - min);\n    }\n   \
    \ return result;", "    if (numbers.empty()) {\n        return numbers;\n    }\n\
    \    float min_number = numbers[0];\n    float max_number = numbers[0];\n    for\
    \ (size_t i = 1; i < numbers.size(); i++) {\n        min_number = std::min(min_number,\
    \ numbers[i]);\n        max_number = std::max(max_number, numbers[i]);\n    }\n\
    \    float diff = max_number - min_number;\n    if (diff == 0.0) {\n        return\
    \ numbers;\n    }\n    if (diff > 0.0) {\n        std::reverse(numbers.begin(),\
    \ numbers.end());\n    }\n    numbers.clear();\n    for (float number : numbers)\
    \ {\n        numbers.push_back((number - min_number) / diff);\n    }\n    return\
    \ numbers;", "    // The linear transform will map numbers 0, 1, 2, 3, ... to\
    \ values 0, 1/2, 2/3, ... and so on.\n    std::vector<float> rescaled_numbers(numbers.size());\n\
    \    for (size_t i = 0; i < numbers.size(); i++) {\n        rescaled_numbers[i]\
    \ = static_cast<float>(i) / (float)numbers.size();\n    }\n    return rescaled_numbers;",
  "  std::vector<float> rescaled_numbers(numbers.begin(), numbers.end());\n  for (int\
    \ i = 0; i < rescaled_numbers.size(); i++) {\n    rescaled_numbers[i] = numbers[i]\
    \ / rescaled_numbers[i - 1];\n  }\n  return rescaled_numbers;", "    assert(numbers.size()\
    \ > 1);\n    assert(numbers.front() >= numbers[1].front());\n    assert(numbers.back()\
    \ <= numbers[1].back());\n    std::vector<float> output(numbers.size(), numbers[0].front());\n\
    \    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = 0;\
    \ j < numbers.size(); ++j) {\n            if (j > i) output[i] = output[i] + numbers[i][j]\
    \ - numbers[i][j - 1];\n        }\n    }\n    // If the smallest number in the\
    \ original set is 0, then output it as\n    // 0. Otherwise, output it as 1\n\
    \    return output[numbers.size()-1];", "    std::vector<float> new_numbers;\n\
    \    auto new_max = numbers[0];\n    for (auto &num : numbers)\n        new_max\
    \ =  std::max(num, new_max);\n    new_numbers.reserve(numbers.size());\n    for\
    \ (auto &num : numbers)\n        new_numbers.push_back(((float)num - new_max)\
    \ / (new_max - 1));\n    return new_numbers;", "    if (numbers.empty() || numbers.size()\
    \ == 1)\n        return numbers;\n    numbers.sort();\n\n    auto min_val = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    auto max_val = *std::max_element(numbers.begin(), numbers.end());\n\
    \n    for (auto val : numbers)\n        val = ((val - min_val) / (max_val - min_val))\
    \ * 2.0 + 0.5;\n\n    return numbers;", "    // Find the min and max of the list,\
    \ if they are equal, return them\n    const float min_number = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    const float max_number = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled_numbers.push_back(number\
    \ * (max_number - min_number) / (numbers.back() - numbers.front()));\n    }\n\
    \    return rescaled_numbers;", "  std::stable_sort(numbers.begin(), numbers.end());\n\
    \  // Sort in decreasing order of magnitude\n  while (numbers.size() > 1) {\n\
    \    float left = numbers[numbers.size() - 1];\n    float right = numbers[0];\n\
    \    // If the magnitude of right is smaller than left (which means they are all\
    \ equal), break\n    if (right < left) {\n      break;\n    }\n    // Scale the\
    \ left such that it is zero\n    numbers.erase(numbers.begin());\n    numbers.push_back(left\
    \ / right);\n  }\n  // Sort the vector from smallest to largest\n  std::stable_sort(numbers.begin(),\
    \ numbers.end());\n  // Return the resulting list\n  return numbers;", "\tassert(numbers.size()\
    \ > 1);\n\tstd::vector<float> rescaled(numbers.begin(), numbers.end());\n\tfloat\
    \ max_val = *std::max_element(rescaled.begin(), rescaled.end());\n\trescaled.insert(rescaled.begin(),\
    \ 0.0);\n\trescaled.insert(rescaled.end(), max_val - max_val + 1.0);\n\treturn\
    \ rescaled;", "    std::vector<float> result;\n    int size = numbers.size();\n\
    \    for (int i = 0; i < size; i++) {\n        result.push_back(numbers[i]/numbers[size]);\n\
    \    }\n    return result;", "  if (numbers.empty()) {\n    return {};\n  }\n\
    \  // Normalize numbers\n  auto min_number = numbers[0];\n  auto max_number =\
    \ numbers[0];\n  for (auto number : numbers) {\n    min_number = std::min(number,\
    \ min_number);\n    max_number = std::max(number, max_number);\n  }\n  auto min_diff\
    \ = fabs(min_number - max_number);\n  auto max_diff = fabs(max_number - min_number);\n\
    \  auto min_ratio = 1.0;\n  auto max_ratio = 2.0;\n  if (min_diff > max_diff)\
    \ {\n    min_ratio = 2.0 / min_diff;\n  } else {\n    max_ratio = 1.0 / max_diff;\n\
    \  }\n  auto scaled_numbers = std::vector<float>();\n  // Rescale numbers until\
    \ they fall in [0, 1]\n  auto ratio = min_ratio;\n  for (auto number : numbers)\
    \ {\n    scaled_numbers.push_back(number * ratio);\n    ratio += 1.0;\n  }\n \
    \ return scaled_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ result(numbers.size());\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    for (int i = 0; i < numbers.size(); i++) {\n        result[i] = (float)(numbers[i]\
    \ - min) / (max - min);\n    }\n    return result;", "    assert(numbers.size()\
    \ > 0);\n    // Compute the mean and standard deviation of the input numbers\n\
    \    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n\
    \    float variance = std::accumulate(numbers.begin(), numbers.end(), 0.0f) /\
    \ numbers.size()\n            - mean * mean;\n    float stdev = std::sqrt(variance);\n\
    \n    // Compute the rescaling factors for each element of the list\n    // >>>\
    \ rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    // [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    \    std::vector<float> rescale(numbers.size());\n    float scaling_factor = stdev\
    \ / mean;\n    for (int i = 0; i < numbers.size(); i++) {\n        rescale[i]\
    \ = numbers[i] * scaling_factor;\n    }\n    return rescale;", "    std::vector<float>\
    \ new_numbers(numbers.size());\n    int min_idx = 0;\n    int max_idx = 0;\n \
    \   float max_value = numbers[0];\n    for (size_t i = 0; i < numbers.size();\
    \ i++) {\n        if (numbers[i] < max_value) {\n            max_value = numbers[i];\n\
    \            max_idx = i;\n        }\n    }\n    new_numbers[max_idx] = 0.0;\n\
    \    for (size_t i = 0; i < numbers.size(); i++) {\n        if (numbers[i] > max_value)\
    \ {\n            new_numbers[max_idx] = 1.0;\n            max_value = numbers[i];\n\
    \            max_idx = i;\n        }\n        new_numbers[i] = numbers[i] - max_value;\n\
    \    }\n    return new_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ output(numbers.begin(), numbers.end());\n    float minval = output[0];\n   \
    \ float maxval = output[0];\n    for (const auto& x : output) {\n        if (x\
    \ < minval) minval = x;\n        if (x > maxval) maxval = x;\n    }\n    // Now\
    \ minval == 0, maxval == 1\n    // Apply linear transform to each element in the\
    \ list\n    for (const auto& x : output) {\n        x = (x-minval)/(maxval-minval);\n\
    \    }\n    return output;", '  // Your code here', "    if (numbers.size() <\
    \ 2) \n        return numbers;\n    numbers.insert(numbers.begin(), 0.0f);\n \
    \   numbers.insert(numbers.end(), 1.0f);\n    numbers.resize((int)numbers.size()\
    \ * 2);\n    float largest = numbers[0];\n    float smallest = numbers[0];\n \
    \   for (size_t i = 1; i < numbers.size(); ++i) {\n        float tmp = numbers[i];\n\
    \        largest = std::max(largest, tmp);\n        smallest = std::min(smallest,\
    \ tmp);\n    }\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        numbers[i]\
    \ -= smallest - largest;\n        numbers[i] *= (float)numbers.size() / numbers.size();\n\
    \    }\n    return numbers;", "    std::vector<float> scaled_numbers(numbers.size());\n\
    \    std::transform(numbers.begin(), numbers.end(), scaled_numbers.begin(), [](float\
    \ x) {\n        return (x * 1.0f / std::min(1.0f, x));\n    });\n    return scaled_numbers;",
  "    float largest = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ smallest = *std::min_element(numbers.begin(), numbers.end());\n    float scale\
    \ = largest / std::max(smallest, 1.0f);\n    for (float number : numbers) {\n\
    \        number *= scale;\n    }\n    return numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> unit(numbers.size() - 1, 0.0f);\n    for (auto\
    \ i : numbers) {\n        float min_index = i;\n        float max_index = i;\n\
    \        for (auto j = i + 1; j < numbers.size(); ++j) {\n            if (numbers[j]\
    \ < min_index) {\n                min_index = j;\n            }\n            if\
    \ (numbers[j] > max_index) {\n                max_index = j;\n            }\n\
    \        }\n        unit[i] = (numbers[i] - min_index) / (max_index - min_index);\n\
    \    }\n    return unit;", "  if (numbers.empty()) {\n    return {};\n  }\n\n\
    \  auto minval = numbers[0];\n  auto maxval = numbers[0];\n  for (auto i : numbers)\
    \ {\n    if (i < minval) {\n      minval = i;\n    }\n    if (i > maxval) {\n\
    \      maxval = i;\n    }\n  }\n\n  auto range = (maxval - minval);\n  auto min_nonzero\
    \ = (std::min)(range, 1.0);\n  auto max_nonzero = std::max(range, 0.0);\n\n  std::vector<float>\
    \ transformed_numbers = numbers;\n\n  auto scaled_minval = minval - min_nonzero;\n\
    \  auto scaled_maxval = maxval + max_nonzero;\n  for (auto i : transformed_numbers)\
    \ {\n    i = (i - scaled_minval) / (scaled_maxval - scaled_minval);\n  }\n\n \
    \ return transformed_numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ unit(numbers.size());\n    std::transform(numbers.begin(), numbers.end(), unit.begin(),\n\
    \                   [](float x) { return (x - numbers.at(0) / (numbers.at(0) +\
    \ numbers.at(1))); });\n    return unit;", "  // Write your code here\n  for (size_t\
    \ i = 0; i < numbers.size(); ++i) {\n    float rescale = (numbers[i] - min(numbers))\
    \ / max(numbers);\n    rescale *= 1.0f / numbers.size(); // normalize the rescale\n\
    \    rescale += 0.0; // offset the rescale to be in the range [0, 1]\n    numbers[i]\
    \ = rescale;\n  }\n  return numbers;", "    std::vector<float> normalized_numbers;\n\
    \    normalized_numbers.reserve(numbers.size());\n    double min_val = std::numeric_limits<float>::min();\n\
    \    double max_val = std::numeric_limits<float>::max();\n\n    for (float number\
    \ : numbers) {\n        normalized_numbers.push_back(number);\n        normalized_numbers.push_back(number);\n\
    \    }\n\n    for (float number : normalized_numbers) {\n        normalized_numbers[0]\
    \ -= min_val;\n        normalized_numbers[1] -= min_val;\n    }\n\n    for (float\
    \ number : normalized_numbers) {\n        if (number < 0) {\n            normalized_numbers[0]\
    \ += max_val;\n            normalized_numbers[1] += max_val;\n        } else {\n\
    \            normalized_numbers[0] += max_val;\n            normalized_numbers[1]\
    \ += max_val;\n        }\n    }\n\n    return normalized_numbers;", "    size_t\
    \ size = numbers.size();\n    std::vector<float> rescaled_numbers(size);\n   \
    \ for (size_t i = 0; i < size; i++) {\n        rescaled_numbers[i] = numbers[i]\
    \ / static_cast<float>(size);\n    }\n    return rescaled_numbers;", "    // Sort\
    \ the list\n    numbers.sort(std::greater<float>());\n    std::vector<float> rescaled_numbers;\n\
    \    for (int i = 0; i < numbers.size(); i++) {\n        rescaled_numbers.push_back(numbers[i]\
    \ / numbers.back());\n    }\n    return rescaled_numbers;", "    // Find min and\
    \ max elements\n    float min_ = FLT_MAX;\n    float max_ = FLT_MIN;\n    for\
    \ (auto n : numbers) {\n        if (n < min_) min_ = n;\n        if (n > max_)\
    \ max_ = n;\n    }\n    // If range is too small, rescale to allow more numbers\n\
    \    if (max_ - min_ < FLT_EPSILON) {\n        float rescale = (max_ - min_) /\
    \ (FLT_EPSILON - FLT_EPSILON);\n        for (auto n : numbers) {\n           \
    \ n /= rescale;\n        }\n    }\n    // Rescale\n    std::vector<float> scaled(numbers.begin(),\
    \ numbers.end());\n    for (auto n : scaled) {\n        n = (n - min_) / (max_\
    \ - min_);\n    }\n    return scaled;", "  assert(numbers.size()>1);\n  std::for_each(numbers.begin(),\
    \ numbers.end(), [&](float num) {\n    float smallest_num = (std::min)(num, numbers.back());\n\
    \    numbers.back() = smallest_num;\n  });\n  numbers.push_back(1.0f);\n  return\
    \ numbers;", "  // sort them in increasing order so that we can start from left\
    \ side and make the\n  // next number in line to 0\n  std::sort(numbers.begin(),\
    \ numbers.end());\n\n  // we will accumulate the difference between the two numbers\
    \ by adding them with\n  // smallest number from the list to the difference between\
    \ the two numbers. When the\n  // difference is smaller than 0.1 then we will\
    \ subtract the smallest number from the\n  // list (so it will be 0)\n  std::vector<float>\
    \ differences(numbers.size() - 1, 0);\n\n  for (size_t i = 0; i < numbers.size()\
    \ - 1; i++) {\n    float difference = numbers[i + 1] - numbers[i];\n    // if\
    \ the difference is smaller than 0.1 then subtract the smallest number from\n\
    \    // the list (so it will be 0)\n    if (difference <= 0.1f) {\n      difference\
    \ -= numbers[i];\n    }\n    differences[i] = difference;\n  }\n\n  // if the\
    \ difference is still not between 0 and 1 then we would have divided it\n  //\
    \ by 0, the thing we can do is just return 0 since we have already scaled every\n\
    \  // number to 0\n  if (std::abs(differences[0]) != 1.0f) {\n    return {};\n\
    \  }\n  std::vector<float> new_numbers(numbers);\n  for (size_t i = 0; i < differences.size();\
    \ i++) {\n    new_numbers[i + 1] -= differences[i];\n  }\n  return new_numbers;",
  "    // Compute the sum of numbers\n    auto sum = accumulate(numbers.begin(), numbers.end(),\
    \ 0.0);\n\n    // Calculate the mean of the list\n    auto mean = sum / numbers.size();\n\
    \n    // Now scale the list such that the smallest element becomes 0, the largest\
    \ becomes 1\n    auto scaled = std::vector<float>(numbers.size());\n    for (size_t\
    \ i = 0; i < numbers.size() - 1; i++) {\n        scaled[i] = numbers[i] - (numbers[i]\
    \ - mean);\n    }\n\n    // Add the mean back in\n    scaled.push_back(numbers[numbers.size()\
    \ - 1]);\n\n    // Return the scaled list\n    return scaled;", "    std::vector<float>\
    \ res(numbers.size());\n    for(size_t i = 0; i < numbers.size(); i++) {\n   \
    \     res[i] = numbers[i] / numbers[numbers.size()-1];\n    }\n    return res;",
  "    assert(numbers.size() >= 2);\n    float sum = float(numbers.at(0));\n    for\
    \ (float number : numbers)\n        sum += number;\n    std::vector<float> scaled;\n\
    \    scaled.push_back(numbers[0]);\n    for (float number : numbers) {\n     \
    \   float factor = number / sum;\n        scaled.push_back(factor);\n    }\n \
    \   return scaled;", "  std::vector<float> transformed_numbers;\n  assert(numbers.size()\
    \ > 0);\n  assert(numbers.size() >= 2);\n  float min = numbers.at(0);\n  float\
    \ max = numbers.at(0);\n  for (auto number : numbers) {\n    float new_min = std::min(min,\
    \ number);\n    float new_max = std::max(max, number);\n    min = new_min;\n \
    \   max = new_max;\n  }\n\n  float diff = max - min;\n  if (diff == 0) {\n   \
    \ transformed_numbers.push_back(0);\n  } else {\n    transformed_numbers.push_back((numbers[0]\
    \ - min) / diff);\n    for (auto number : numbers) {\n      transformed_numbers.push_back(transformed_numbers.back()\
    \ + (number - min) / diff);\n    }\n  }\n\n  return transformed_numbers;", " \
    \   assert(numbers.size() > 2);\n    std::vector<float> scaled(numbers.size());\n\
    \    for (size_t i = 0; i < numbers.size(); ++i) {\n        scaled[i] = (numbers[i]\
    \ - numbers[0]) / (numbers[1] - numbers[0]);\n    }\n    return scaled;", "  \
    \  std::vector<float> unit(numbers.begin(), numbers.end());\n    float m = *std::min_element(unit.begin(),\
    \ unit.end());\n    *std::max_element(unit.begin(), unit.end()) = 1.0;\n    for\
    \ (float x : numbers) {\n        x /= m;\n    }\n    return unit;", "    // We\
    \ sort the numbers in ascending order because we want to keep the smallest number\
    \ as 0.\n    numbers.sort();\n    // The largest number should be 1, so we just\
    \ have to subtract 1 from the sorted list and append it at the end.\n    numbers.push_back(numbers[0]\
    \ - 1);\n    return numbers;", "    // Sort the list from largest to smallest\n\
    \    std::sort(numbers.begin(), numbers.end());\n    // Calculate the difference\
    \ between smallest and largest number\n    float largest = numbers[0];\n    float\
    \ smallest = numbers[0];\n    float difference = largest - smallest;\n    // Iterate\
    \ over the list adding 1 to smallest number each time a larger number occurs\n\
    \    for (float number : numbers) {\n        if (number > largest) {\n       \
    \     smallest = number;\n        } else if (number < largest) {\n           \
    \ largest = number;\n        }\n    }\n    // Return scaled list of 0s and 1s\n\
    \    std::vector<float> scaled;\n    float scale = (largest - smallest) / difference;\n\
    \    float offset = (smallest + largest) / 2.0f;\n    float new_max = 1.0f;\n\
    \    if (scale != 0.0f) {\n        new_max = scale * difference + offset;\n  \
    \  }\n    float new_min = smallest;\n    if (scale != 0.0f) {\n        new_min\
    \ = offset - new_max;\n    }\n    for (float number : numbers) {\n        scaled.push_back((number\
    \ - new_min) / new_max);\n    }\n    return scaled;", "    assert(numbers.size()\
    \ >= 2);\n    auto mid = numbers.size() / 2;\n    std::nth_element(numbers.begin(),\
    \ numbers.begin() + mid, numbers.end());\n    float mid1 = numbers[mid];\n   \
    \ float mid2 = numbers[mid + 1];\n\n    float min = std::numeric_limits<float>::lowest();\n\
    \    float max = std::numeric_limits<float>::max();\n\n    std::vector<float>\
    \ out(numbers.begin(), numbers.end());\n    float old_min = out[0];\n    float\
    \ old_max = out[0];\n\n    for (int i = 1; i < out.size(); i++) {\n        float\
    \ diff = out[i] - out[i - 1];\n        if (diff > max) {\n            max = diff;\n\
    \        }\n        if (diff < min) {\n            min = diff;\n        }\n  \
    \  }\n\n    if (min == 0.0 && max == 1.0) {\n        return numbers;\n    }\n\n\
    \    if (min == 0.0) {\n        out[0] = 0.0;\n        out[mid] = 0.0;\n     \
    \   out[mid + 1] = 0.0;\n        return out;\n    }\n\n    if (max == 1.0) {\n\
    \        out[mid] = 0.0;\n        out[mid + 1] = 0.0;\n        out[0] = 1.0;\n\
    \        return out;\n    }\n\n    float scale = 1.0 / (max - min);\n    out[0]\
    \ = scale;\n    out[mid] = scale * mid1;\n    out[mid + 1] = scale * mid2;\n \
    \   return out;", "    assert(numbers.size() > 0);\n    std::vector<float> rescaled\
    \ = numbers;\n    rescaled[0] = 0;\n    rescaled.resize(rescaled.size() - 1);\n\
    \    std::vector<float> result = {};\n    float min = rescaled[0];\n    float\
    \ max = rescaled[rescaled.size() - 1];\n    for (int i = 1; i < rescaled.size()\
    \ - 1; i++) {\n        rescaled[i] = (rescaled[i] - min) / (max - min);\n    }\n\
    \    for (int i = 0; i < rescaled.size(); i++) {\n        float x = rescaled[i];\n\
    \        result.push_back(round(x));\n    }\n    return result;", "  assert(numbers.size()\
    \ >= 2);\n\n  std::vector<float> transformedNumbers(numbers.begin() + 1, numbers.end());\n\
    \  transformedNumbers[0] = numbers[0] / numbers[1];\n  transformedNumbers[1] =\
    \ (numbers[1] - numbers[0]) / numbers[1];\n\n  // assert(transformedNumbers[0]\
    \ >= 0.0f && transformedNumbers[0] <= 1.0f);\n  // assert(transformedNumbers[1]\
    \ >= 0.0f && transformedNumbers[1] <= 1.0f);\n\n  return transformedNumbers;",
  "\tassert(numbers.size() >= 2);\n\n\tfloat sum = 0;\n\tfor (auto number : numbers)\
    \ {\n\t\tsum += number;\n\t}\n\tfor (auto number : numbers) {\n\t\tnumber *= 1.0\
    \ / sum;\n\t}\n\treturn numbers;", "  std::vector<float> unit;\n  // Rescale all\
    \ numbers to [0, 1]\n  for (auto x : numbers)\n    unit.push_back((x - numbers[0])\
    \ / (numbers[1] - numbers[0]));\n  // Scale smallest number if all numbers are\
    \ positive\n  if (unit.back() <= 0) {\n    unit.push_back(unit.back());\n    unit.front()\
    \ = 0;\n  }\n  return unit;", "\tstd::vector<float> unit;\n\t// Sort all numbers\
    \ in ascending order\n\tstd::sort(numbers.begin(), numbers.end(), [](const float&\
    \ n1, const float& n2) { return n1 < n2; });\n\t// Find the first 0 and the last\
    \ 1 element in ascending order\n\tfloat first = *std::min_element(numbers.begin(),\
    \ numbers.end());\n\tfloat last = *std::max_element(numbers.begin(), numbers.end());\n\
    \t// Calculate the new interval\n\tfloat interval = last - first;\n\t// Normalize\
    \ the input numbers\n\tnumbers.erase(std::remove_if(numbers.begin(), numbers.end(),\
    \ [](const float& n) {\n\t\treturn n >= first - 0.5;\n\t}), numbers.end());\n\t\
    while (!numbers.empty()) {\n\t\tnumbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](const float& n) {\n\t\t\treturn n <= last + 0.5;\n\t\t}),\
    \ numbers.end());\n\t}\n\t// Add the min and max element\n\tnumbers.push_back(first);\n\
    \tnumbers.push_back(last);\n\t// Find the interval to which each new element will\
    \ fall\n\t// We use linear interpolation to get the interval\n\tfloat interval_left\
    \ = first;\n\tfloat interval_right = last;\n\tfloat current = first;\n\tfloat\
    \ prev = last;\n\twhile (!numbers.empty()) {\n\t\tfloat next = current + (numbers.back()\
    \ - current) / numbers.size();\n\t\tif (interval_right < next) {\n\t\t\tinterval_right\
    \ = next;\n\t\t}\n\t\tcurrent = next;\n\t\tprev = current;\n\t\tnumbers.erase(numbers.begin());\n\
    \t}\n\t// Create the output numbers\n\tunit.clear();\n\tunit.push_back(first);\n\
    \twhile (!unit.empty()) {\n\t\tunit.push_back(interval_left + unit.back() / unit.size());\n\
    \t}\n\tunit.push_back(last);\n\treturn unit;", "    assert(numbers.size() >= 2);\n\
    \    float smallest_number = numbers[0];\n    float max_number = numbers[0];\n\
    \    for (auto& number : numbers) {\n        if (number > max_number) max_number\
    \ = number;\n        if (number < smallest_number) smallest_number = number;\n\
    \    }\n    std::vector<float> result;\n    result.push_back(0.0f);\n    result.push_back(max_number\
    \ - smallest_number);\n    float scaling_factor = result.back();\n    for (auto&\
    \ number : numbers) {\n        result.push_back(scaling_factor * (number - smallest_number));\n\
    \    }\n    return result;", "    std::vector<float> output(numbers.size(), 0.0f);\n\
    \    float min = numbers.front();\n    float max = numbers.back();\n    for (size_t\
    \ i = 0; i < numbers.size(); i++) {\n        output[i] = numbers[i] - min;\n \
    \   }\n    for (size_t i = 0; i < numbers.size(); i++) {\n        output[i] =\
    \ (output[i] - min) / (max - min);\n    }\n    return output;", "    float min\
    \ = 0.0f;\n    float max = 0.0f;\n    for (float f : numbers) {\n        min =\
    \ std::min(min, f);\n        max = std::max(max, f);\n    }\n    float scale =\
    \ 1.0f / (max - min);\n    for (float f : numbers) {\n        f *= scale;\n  \
    \  }\n    return numbers;", "  std::sort(numbers.begin(), numbers.end());\n  const\
    \ float min = *std::min_element(numbers.begin(), numbers.end());\n  const float\
    \ max = *std::max_element(numbers.begin(), numbers.end());\n  std::vector<float>\
    \ result{min, max};\n  if (min == max) {\n    return {};\n  }\n  const float span\
    \ = (max - min) / (numbers.size() - 1);\n  for (int i = 1; i < numbers.size();\
    \ ++i) {\n    const float val = numbers[i] - min;\n    result[i] = result[i-1]\
    \ + val * span;\n  }\n  return result;", "  // Create empty array\n  std::vector<float>\
    \ transformed(numbers.begin(), numbers.end());\n  // Initialize min and max values\n\
    \  float min = *std::min_element(transformed.begin(), transformed.end()); // min\
    \ element -> 0\n  float max = *std::max_element(transformed.begin(), transformed.end());\
    \ // max element -> 1\n  // Iterate over all elements\n  for (float number : transformed)\
    \ {\n    // if number is between 0 and 1, multiply by min/max and add 0\n    if\
    \ (number >= 0 && number <= 1) {\n      number *= (max - min) + min;\n    }\n\
    \  }\n  return transformed;", "  std::vector<float> rescaled_numbers;\n  rescaled_numbers.reserve(numbers.size());\n\
    \  for (float number : numbers) {\n    rescaled_numbers.push_back(std::min(number,\
    \ 1.0));\n    rescaled_numbers.push_back(std::max(number, 0.0));\n  }\n  return\
    \ rescaled_numbers;", "    // Your code here\n    // return numbers;\n    float\
    \ min=0;\n    float max=0;\n    for (auto n : numbers)\n    {\n        if(min>n)\n\
    \            min=n;\n        if(max<n)\n            max=n;\n    }\n    float scale=(max-min)/(numbers.size()-1);\n\
    \    for (auto n : numbers)\n    {\n        n=(n-min)/scale;\n    }\n    return\
    \ numbers;", "    float minVal = std::numeric_limits<float>::min();\n    float\
    \ maxVal = std::numeric_limits<float>::max();\n    int minValIndex = 0;\n    int\
    \ maxValIndex = 0;\n    int i;\n\n    for (i = 0; i < numbers.size(); i++) {\n\
    \        if (numbers[i] < minVal) {\n            minValIndex = i;\n        }\n\
    \        if (numbers[i] > maxVal) {\n            maxValIndex = i;\n        }\n\
    \    }\n\n    if (maxValIndex == minValIndex) {\n        throw std::invalid_argument(\"\
    the smallest number is not bigger than the biggest!\");\n    }\n\n    if (minValIndex\
    \ == maxValIndex) {\n        std::vector<float> unitVector;\n        unitVector.reserve(numbers.size());\n\
    \        for (i = 0; i < numbers.size(); i++) {\n            unitVector.push_back(numbers[i]);\n\
    \        }\n        return unitVector;\n    }\n\n    std::vector<float> unitVector;\n\
    \    unitVector.reserve(maxValIndex - minValIndex + 1);\n\n    for (i = minValIndex;\
    \ i <= maxValIndex; i++) {\n        float currentVal = numbers[i - 1];\n     \
    \   float newVal = (currentVal - minVal) / (maxVal - minVal);\n        unitVector.push_back(newVal);\n\
    \    }\n\n    return unitVector;", "  // Get min and max\n  float min = FLT_MIN;\n\
    \  float max = FLT_MAX;\n  for (auto& n : numbers)\n    if (n < min)\n      min\
    \ = n;\n    else if (n > max)\n      max = n;\n\n  // Convert to unit interval\n\
    \  float unit = (max - min) / 2;\n  float old_min = min;\n  float old_max = max;\n\
    \  std::vector<float> result;\n  for (auto& n : numbers)\n    result.push_back(old_min\
    \ + (n - old_min) * unit / len);\n  return result;", "\tif (numbers.size() < 2)\
    \ return numbers;\n\tstd::vector<float> rescaled_numbers;\n\tfor (float number\
    \ : numbers) {\n\t\trescaled_numbers.push_back((number - numbers.at(0)) / (numbers.at(1)\
    \ - numbers.at(0)));\n\t}\n\treturn rescaled_numbers;", "    if (numbers.empty())\
    \ return numbers;\n\n    std::vector<float> rescaled;\n    rescaled.reserve(numbers.size());\n\
    \n    for (float number : numbers) {\n        rescaled.push_back(number/numbers[0]);\n\
    \    }\n\n    return rescaled;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ result(numbers.begin(), numbers.begin() + numbers.size() / 2);\n    for (int\
    \ i = 1; i < numbers.size(); i++) {\n        result[i] = result[i-1] + (numbers[i]\
    \ - result[i-1]) / (numbers[i-1] + numbers[i]);\n    }\n    return result;", "\t\
    assert(numbers.size() >= 2);\n\tfloat maximum = numbers[0];\n\tfor (auto& number\
    \ : numbers) {\n\t\tif (number > maximum) {\n\t\t\tmaximum = number;\n\t\t}\n\t\
    }\n\tstd::vector<float> result;\n\tfor (auto& number : numbers) {\n\t\tresult.push_back(number\
    \ / maximum);\n\t}\n\treturn result;", "    // assert(numbers.size() > 0);\n \
    \   std::vector<float> transformed;\n    float scale = 1;\n    float min = 0;\n\
    \    float max = 1;\n\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(transformed),\n\
    \                   [scale, &min, &max](float x) { return (x - min) / (max - min)\
    \ * scale; });\n    return transformed;", "    std::vector<float> scaled_numbers(numbers.size());\n\
    \    float sum = 0;\n    for (size_t i = 0; i < numbers.size(); i++) {\n     \
    \   sum += numbers[i];\n        scaled_numbers[i] = sum / numbers.size();\n  \
    \  }\n    return scaled_numbers;", "    assert(numbers.size() > 2);\n    std::vector<float>\
    \ newUnit = numbers;\n    newUnit[0] = 0.0f;\n    newUnit[1] = 1.0f;\n    std::transform(newUnit.begin()\
    \ + 2, newUnit.end(), newUnit.begin(), [](float f) {return f / 2.0f;});\n    std::sort(newUnit.begin(),\
    \ newUnit.end());\n    return newUnit;", "    std::vector<float> out(numbers.begin(),\
    \ numbers.end());\n    std::transform(out.begin(), out.end(), out.begin(), [](float\
    \ a){return a * (1.f / 3.f);});\n    return out;", "    assert(numbers.size()\
    \ > 0);\n    std::vector<float> rescaled(numbers.size());\n    // Initialize smallest\
    \ number to zero\n    rescaled[0] = numbers[0];\n    // Initialize largest number\
    \ to one\n    rescaled[numbers.size()-1] = numbers[numbers.size() - 1];\n    for(size_t\
    \ i = 1; i < numbers.size(); i++) {\n        rescaled[i] = rescaled[i-1] + numbers[i]/numbers[i\
    \ - 1];\n    }\n    return rescaled;", "  // assert(numbers.size() >= 2);\n  std::sort(numbers.begin(),\
    \ numbers.end());\n  float min = (float)std::numeric_limits<float>::min();\n \
    \ float max = (float)std::numeric_limits<float>::max();\n  float scaled = (max\
    \ - min) / (numbers.size() - 1);\n  for (int i = 0; i < numbers.size(); i++) {\n\
    \    numbers[i] = (numbers[i] - min) / scaled;\n  }\n  return numbers;", "\tstd::vector<float>\
    \ result;\n\tfloat min=0, max=0;\n\tfor (int i=0; i<numbers.size(); i++) {\n\t\
    \tmin = std::min(min, numbers[i]);\n\t\tmax = std::max(max, numbers[i]);\n\t}\n\
    \tfor (int i=0; i<numbers.size(); i++) {\n\t\tresult.push_back(numbers[i]/((max-min)/numbers.size()));\n\
    \t}\n\treturn result;", "  // We need at least two elements to apply the transform\n\
    \  if (numbers.size() <= 1) return numbers;\n  // We need to compute the mean\
    \ value of all the numbers\n  double sum_of_numbers = std::accumulate(numbers.begin(),\
    \ numbers.end(), 0.0);\n  double mean_value = sum_of_numbers / numbers.size();\n\
    \  // We need to rescale the numbers\n  std::vector<float> rescaled_numbers;\n\
    \  rescaled_numbers.reserve(numbers.size());\n  for (std::size_t i = 0; i < numbers.size();\
    \ i++) {\n    rescaled_numbers.push_back(numbers[i] - mean_value);\n  }\n  //\
    \ We need to apply the rescale to the rescaled numbers\n  double smallest_number\
    \ = std::accumulate(rescaled_numbers.begin(), rescaled_numbers.end(), 0.0);\n\
    \  std::vector<float> rescaled_rescaled_numbers;\n  rescaled_rescaled_numbers.reserve(rescaled_numbers.size());\n\
    \  for (std::size_t i = 0; i < rescaled_numbers.size(); i++) {\n    rescaled_rescaled_numbers.push_back(rescaled_numbers[i]\
    \ * rescaled_numbers[i]);\n  }\n  std::vector<float> rescaled_rescaled_numbers_squared;\n\
    \  rescaled_rescaled_numbers_squared.reserve(rescaled_rescaled_numbers.size());\n\
    \  for (std::size_t i = 0; i < rescaled_rescaled_numbers.size(); i++) {\n    rescaled_rescaled_numbers_squared.push_back(rescaled_rescaled_numbers[i]\
    \ * rescaled_rescaled_numbers[i]);\n  }\n  double scale = smallest_number / std::sqrt(std::accumulate(rescaled_rescaled_numbers_squared.begin(),\n\
    \                                                             rescaled_rescaled_numbers_squared.end(),\
    \ 0.0));\n  for (std::size_t i = 0; i < rescaled_rescaled_numbers.size(); i++)\
    \ {\n    rescaled_rescaled_numbers[i] *= scale;\n  }\n  // We need to return the\
    \ result to Python\n  std::vector<float> rescaled_rescaled_numbers_squared_py;\n\
    \  rescaled_rescaled_numbers_squared_py.reserve(rescaled_rescaled_numbers_squared.size());\n\
    \  for (std::size_t i = 0; i < rescaled_rescaled_numbers_squared.size(); i++)\
    \ {\n    rescaled_rescaled_numbers_squared_py.push_back(rescaled_rescaled_numbers_squared[i]);\n\
    \  }\n  return rescaled_rescaled_numbers_squared_py;", "    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (auto\
    \ i = 0; i < numbers.size(); i++) {\n        rescaled_numbers.push_back((numbers[i]\
    \ - numbers[0]) / (numbers[i - 1] - numbers[0]));\n    }\n    return rescaled_numbers;",
  "    assert(numbers.size() >= 2);\n\n    std::vector<float> rescaled = numbers;\n\
    \    // If all numbers are small, scale to 0\n    if (rescaled[0] == rescaled[1])\
    \ {\n        return {};\n    }\n\n    const auto min_num = *std::min_element(rescaled.begin()\
    \ + 1, rescaled.end());\n    const auto max_num = *std::max_element(rescaled.begin()\
    \ + 1, rescaled.end());\n\n    std::vector<float> unit;\n    unit.push_back((max_num\
    \ - min_num) / rescaled[0]);\n\n    unit.push_back(max_num);\n\n    // If all\
    \ numbers are large, scale to 1\n    if (rescaled[0] == 1.0) {\n        return\
    \ unit;\n    }\n\n    unit.push_back((*std::min_element(rescaled.begin() + 1,\
    \ rescaled.end()) - max_num) / rescaled[0]);\n\n    unit.push_back(min_num);\n\
    \n    return unit;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ scales(numbers.begin(), numbers.end());\n    // If numbers[0] == 0, then set\
    \ scale on numbers[0] to 1\n    if (scales[0] == 0) {\n        scales[0] = 1;\n\
    \    }\n    // If numbers[numbers.size() - 1] == 0, then set scale on numbers[numbers.size()\
    \ - 1] to 1\n    if (scales[scales.size() - 1] == 0) {\n        scales[scales.size()\
    \ - 1] = 1;\n    }\n    float max_scale = std::max(scales.begin(), scales.end());\
    \ // Find maximum scale factor in array of numbers\n    float min_scale = std::min(scales.begin(),\
    \ scales.end()); // Find minimum scale factor in array of numbers\n    std::vector<float>\
    \ new_scales;\n    // If max and min scale factors are same, return original numbers\n\
    \    if (max_scale == min_scale) {\n        return new_scales;\n    }\n    //\
    \ If min scale factor is less than max scale factor, then scale down by dividing\
    \ by max_scale factor\n    else if (min_scale < max_scale) {\n        for (float\
    \ scale : scales) {\n            new_scales.push_back(scale / max_scale);\n  \
    \      }\n        return new_scales;\n    }\n    // If max scale factor is less\
    \ than min scale factor, then scale up by multiplying by min_scale factor\n  \
    \  else {\n        for (float scale : scales) {\n            new_scales.push_back(scale\
    \ * min_scale);\n        }\n        return new_scales;\n    }", "    float minimum\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    float maximum = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        rescaled_numbers.push_back(number/maximum\
    \ - minimum);\n    }\n    return rescaled_numbers;", "    if (numbers.empty())\n\
    \        return numbers;\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    for (float\
    \ number : numbers)\n        number *= (max - min) / (numbers.size() - 1);\n \
    \   return numbers;", "    std::vector<float> scaled_numbers;\n    scaled_numbers.reserve(numbers.size());\n\
    \    scaled_numbers.resize(numbers.size(), 0);\n    float largest = numbers[0];\n\
    \    float smallest = numbers[0];\n    for (size_t i = 0; i < numbers.size();\
    \ i++) {\n        if (numbers[i] < smallest) {\n            smallest = numbers[i];\n\
    \        }\n        if (numbers[i] > largest) {\n            largest = numbers[i];\n\
    \        }\n        scaled_numbers.at(i) = ((numbers[i] - smallest) / (largest\
    \ - smallest));\n    }\n    return scaled_numbers;", "    std::vector<float> result;\n\
    \n    // Sort the numbers to find min/max values\n    std::sort(numbers.begin(),\
    \ numbers.end());\n\n    // Find the min/max values\n    auto min_it = std::min_element(numbers.begin(),\
    \ numbers.end());\n    auto max_it = std::max_element(numbers.begin(), numbers.end());\n\
    \n    // Find the difference between the min/max values\n    auto range = max_it\
    \ - min_it;\n\n    // Scale all values by the difference between the min/max values\n\
    \    for (auto i = numbers.begin(); i != numbers.end(); i++) {\n        result.push_back(*i\
    \ / static_cast<float>(range));\n    }\n\n    return result;", "    std::vector<float>\
    \ rescaled_number(numbers.begin(), numbers.end());\n    assert(rescaled_number.size()\
    \ > 1);\n    rescaled_number[0] = 0.0;\n    rescaled_number.back = 1.0;\n    float\
    \ sum = 0;\n    for (auto number : rescaled_number) {\n        sum += number;\n\
    \    }\n    float inverse = 1.0 / sum;\n    for (auto number : rescaled_number)\
    \ {\n        rescaled_number[0] += number * inverse;\n    }\n    return rescaled_number;",
  "  assert(numbers.size() >= 2);\n  std::vector<float> new_numbers(numbers.size());\n\
    \  double min_number = numbers[0];\n  double max_number = numbers[0];\n  for (size_t\
    \ i = 1; i < numbers.size(); i++) {\n    if (numbers[i] < min_number) {\n    \
    \  min_number = numbers[i];\n    }\n    if (numbers[i] > max_number) {\n     \
    \ max_number = numbers[i];\n    }\n  }\n  double scale = (max_number - min_number)\
    \ / (double)numbers.size(); // scale of [0, 1]\n  for (size_t i = 0; i < numbers.size();\
    \ i++) {\n    new_numbers[i] = numbers[i] - min_number * scale;\n  }\n  return\
    \ new_numbers;", "    assert(numbers.size() > 1);\n    std::vector<float> new_numbers;\n\
    \    std::vector<float> min_values(numbers.begin(), numbers.begin() + numbers.size()\
    \ / 2);\n    std::vector<float> max_values(numbers.begin() + numbers.size() /\
    \ 2, numbers.end());\n    std::transform(min_values.begin(), min_values.end(),\
    \ max_values.begin(), max_values.end(), std::back_inserter(new_numbers));\n  \
    \  std::transform(numbers.begin(), numbers.end(), new_numbers.begin(), new_numbers.end(),\
    \ std::back_inserter(new_numbers));\n    return new_numbers;", "\tstd::vector<float>\
    \ transformed;\n\tfor (float number : numbers) {\n\t\ttransformed.push_back((number\
    \ - numbers.at(0)) / (numbers.back() - numbers.at(0)) * 2.0 - 1.0);\n\t}\n\treturn\
    \ transformed;", "    std::vector<float> res(numbers.size());\n    // Loop through\
    \ all the numbers in the original list and apply a linear transform\n    // to\
    \ them\n    for (auto &v : numbers) {\n        res[0] = (v - numbers.front())\
    \ / numbers.front();\n        for (size_t i = 1; i < res.size(); i++) {\n    \
    \        res[i] = res[i - 1] + numbers[i - 1] / numbers[i];\n        }\n    }\n\
    \    return res;", "    assert(numbers.size() >= 2);\n    auto result = numbers;\n\
    \    result[0] = 0;\n    result[result.size() - 1] = 1.0;\n    for (int i = 1;\
    \ i < numbers.size(); ++i) {\n        result[i] = (result[i - 1] + numbers[i -\
    \ 1]) / (numbers[i] + 1.0);\n    }\n    return result;", "    std::vector<float>\
    \ new_unit;\n    float min_num = std::numeric_limits<float>::max();\n    float\
    \ max_num = std::numeric_limits<float>::min();\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        if (numbers[i] < min_num) {\n            min_num = numbers[i];\n\
    \        }\n        if (numbers[i] > max_num) {\n            max_num = numbers[i];\n\
    \        }\n    }\n    for (int i = 0; i < numbers.size(); i++) {\n        new_unit.push_back(numbers[i]\
    \ - min_num);\n        new_unit.push_back(numbers[i] / max_num - 1);\n    }\n\
    \    return new_unit;", "    assert(numbers.size() > 2);\n    // First rescale\
    \ all numbers so that their range is [0,1]\n    for (auto elem : numbers) {\n\
    \        elem /= (float) numbers.back();\n    }\n\n    // Apply linear transform\n\
    \    std::vector<float> transformed;\n    transformed.push_back(0.0);\n    transformed.push_back(1.0);\n\
    \    for (auto elem : numbers) {\n        transformed.push_back(transformed.back()\
    \ * elem + 0.0);\n    }\n\n    // Convert transformed vector back to original\
    \ scale\n    for (auto elem : transformed) {\n        elem /= (float) transformed.back();\n\
    \    }\n\n    return transformed;", "    std::vector<float> rescaled_numbers(numbers.begin()\
    \ + 1, numbers.end());\n    rescaled_numbers[0] = 0.0f;\n    rescaled_numbers[numbers.size()\
    \ - 1] = 1.0f;\n    return rescaled_numbers;", "    auto len = numbers.size();\n\
    \    if (len < 2) {\n        throw std::invalid_argument(\"rescale_to_unit() expects\
    \ at least 2 numbers.\");\n    }\n\n    auto max_num = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    auto min_num = *std::min_element(numbers.begin(), numbers.end());\n\
    \    auto mean = (*std::max_element(numbers.begin(), numbers.end()) + \n     \
    \        *std::min_element(numbers.begin(), numbers.end())) / len;\n\n    auto\
    \ scale_max = (max_num - min_num) / (len - 1);\n    auto scale_min = 1 / (len\
    \ - 1);\n    numbers.resize(len);\n    for (auto &num : numbers) {\n        num\
    \ = num * (scale_max - scale_min) + scale_min;\n    }\n    return numbers;", " \
    \   auto min = *std::min_element(numbers.begin(), numbers.end());\n    auto max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float>\
    \ ret(numbers.size());\n    for (size_t i = 0; i < numbers.size(); i++) {\n  \
    \      ret[i] = numbers[i] - min;\n        ret[i] *= (max - min) / (numbers.size()\
    \ - 1);\n    }\n    return ret;", "    assert(numbers.size() >= 2);\n    float\
    \ inv_range = 1.0f / numbers.size();\n    std::vector<float> results;\n    for(auto\
    \ it = numbers.begin(); it != numbers.end(); ++it) {\n        float new_value\
    \ = (*it) * inv_range;\n        new_value /= (new_value + 1.0f);\n        results.push_back(new_value);\n\
    \    }\n    return results;", "    std::sort(numbers.begin(), numbers.end());\n\
    \    int n = numbers.size();\n    if (n == 1) return numbers;\n    double m =\
    \ numbers[n - 1];\n    double scale = std::pow(10.0, floor(log10(abs(m))));\n\
    \    double offset = m / scale;\n    std::vector<float> ret(n - 1, 0.0);\n   \
    \ ret[n - 1] = 1.0;\n    for (int i = n - 2; i >= 0; --i) {\n        ret[i] =\
    \ numbers[i] / scale + offset;\n    }\n    return ret;", "    assert(numbers.size()\
    \ >= 2);\n    float min = *std::min_element(numbers.begin(), numbers.end()); //\
    \ Find the lowest number in the list\n    // We don't care about the value on\
    \ the edges of the list, so\n    // we could even just use the minimum number\
    \ for rescaling\n    float max = *std::max_element(numbers.begin(), numbers.end());\
    \ // Find the highest number in the list\n    std::vector<float> rescaled_numbers(numbers.begin(),\
    \ numbers.end()); // Create the output vector\n    rescaled_numbers[0] = 0.0f;\n\
    \    rescaled_numbers[1] = 1.0f;\n    for (int i = 2; i < numbers.size(); ++i)\
    \ {\n        rescaled_numbers[i] = (real)(rescaled_numbers[i - 1] + rescaled_numbers[i]\
    \ / numbers[i] - 1.0f) / numbers[i];\n    }\n    return rescaled_numbers;", " \
    \   assert(numbers.size() >= 2);\n\n    // The smallest number will be 0 and the\
    \ largest will become 1\n    float sum = std::accumulate(numbers.begin(), numbers.end(),\
    \ 0.0);\n    // The scaling factor to apply to all numbers\n    float divisor\
    \ = 1.0f / sum;\n\n    // The new rescaled numbers\n    std::vector<float> rescaled_numbers(numbers);\n\
    \    rescaled_numbers[0] = numbers[0] * divisor;\n    rescaled_numbers[1] = numbers[1]\
    \ * divisor;\n\n    // The new rescaled numbers\n    return rescaled_numbers;",
  "    std::vector<float> ret(numbers);\n    // assert(numbers.size() > 1);\n    int\
    \ min = std::numeric_limits<float>::max();\n    int max = std::numeric_limits<float>::min();\n\
    \    for (const auto& i : numbers) {\n        min = std::min(i, min);\n      \
    \  max = std::max(i, max);\n    }\n    // rescale the vector so that all the numbers\
    \ will be inside the range\n    for (const auto& i : numbers) {\n        ret[i]\
    \ = static_cast<float>(i) / static_cast<float>(max - min);\n    }\n    return\
    \ ret;", "  assert(numbers.size() > 1);\n  // Initialize min and max such that\
    \ min is 0 and max is 1\n  float max = std::accumulate(numbers.begin(), numbers.end(),\
    \ 0.0);\n  float min = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n\
    \n  // Apply linear transform\n  for (auto x : numbers) {\n    float scale = 1.f\
    \ - (x - min) / (max - min);\n    numbers.push_back((x * scale) + min);\n  }\n\
    \  return numbers;", "    // We do not want to modify input list in-place\n  \
    \  numbers.push_back(0);\n    numbers.push_back(1);\n    // The first number is\
    \ now 0 and the last one is 1\n    return numbers;", "    std::vector<float> rescaled;\n\
    \    rescaled.reserve(numbers.size()); \n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float scale = (max - min) / (numbers.size()-1);\n    for (int i = 0; i <\
    \ numbers.size(); ++i) {\n        rescaled.push_back((numbers[i] - min) * scale\
    \ + min);\n    }\n    return rescaled;", "    float min = numbers.front();\n \
    \   float max = numbers.back();\n    float mid = 0.5 * (min + max);\n    numbers.front()\
    \ = mid;\n    numbers.back() = 1.0-mid;\n    return numbers;", "  assert(numbers.size()\
    \ > 1);\n  std::vector<float> new_numbers = numbers;\n  std::transform(new_numbers.begin(),\
    \ new_numbers.end(),\n                 new_numbers.begin(), [](float n) { return\
    \ std::max<float>(0, n); });\n  std::transform(new_numbers.begin(), new_numbers.end(),\n\
    \                 new_numbers.begin(), [](float n) { return std::min<float>(1,\
    \ n); });\n  return new_numbers;", "    // Convert the list to its square (sum\
    \ of squares) and find the minimum value\n    float sum_of_squares = 0;\n    for\
    \ (float n : numbers) {\n        sum_of_squares += n * n;\n    }\n    float min_number\
    \ = std::min(sum_of_squares, numbers[0]);\n    // Multiply all numbers by (min_number\
    \ - 1)\n    std::vector<float> new_numbers;\n    for (float n : numbers) {\n \
    \       new_numbers.push_back(n / min_number);\n    }\n    // Return the rescaled\
    \ list\n    return new_numbers;", "    assert(numbers.size() >= 2);\n    float\
    \ sum = 0;\n    for (float num : numbers)\n        sum += num;\n    std::vector<float>\
    \ result(numbers.size());\n    for (int i = 0; i < numbers.size(); ++i) {\n  \
    \      result[i] = numbers[i] / sum;\n    }\n    return result;", "    std::vector<float>\
    \ scaled;\n    std::vector<int> scales(numbers.size()); // scales is size of each\
    \ list\n    float total = 0; // total sum over all lists\n    for (size_t i =\
    \ 0; i < numbers.size(); i++) {\n        scales[i] = numbers[i] - total;\n   \
    \     total += numbers[i];\n    }\n    for (size_t i = 0; i < numbers.size();\
    \ i++) {\n        scaled.push_back(scales[i] / total);\n    }\n    return scaled;",
  "    std::vector<float> outputs(numbers.size());\n    float sum_of_numbers = 0.0;\n\
    \    for (float number : numbers) {\n        sum_of_numbers += number;\n    }\n\
    \    for (float number : numbers) {\n        outputs[numbers.size()-1] += number\
    \ / sum_of_numbers;\n    }\n    return outputs;", "    std::vector<float> result;\n\
    \    // Compute min and max of the list\n    float min_val = numbers[0];\n   \
    \ float max_val = numbers[0];\n    for (auto val : numbers) {\n        if (val\
    \ < min_val) {\n            min_val = val;\n        }\n        if (val > max_val)\
    \ {\n            max_val = val;\n        }\n    }\n    result.push_back(min_val);\
    \ // Add min and max elements to the list\n    for (auto val : numbers) {\n  \
    \      float val = val - min_val;\n        // If number lies between 0 and 1,\
    \ set it to 0 otherwise set it to 1\n        float out_val;\n        if (val >\
    \ 0) {\n            out_val = min_val;\n        } else {\n            out_val\
    \ = max_val;\n        }\n        result.push_back(out_val);\n    }\n    // Normalize\
    \ the vector\n    for (auto val : result) {\n        val = 1.0f / (val - max_val);\n\
    \    }\n    return result;", "    // Convert the list to std::pair\n    std::pair<float,\
    \ float> min = std::minmax_element(numbers.begin(), numbers.end());\n    // Calculate\
    \ the length of each number\n    std::vector<float> length(numbers.size());\n\
    \    for (size_t i = 0; i < numbers.size(); ++i)\n        length[i] = numbers[i]\
    \ - numbers[i - 1];\n    // Calculate the scale factor\n    float scale = length[0]\
    \ / min.second;\n    // Calculate new scale\n    std::vector<float> new_scale(numbers.size());\n\
    \    new_scale[0] = scale;\n    for (size_t i = 1; i < numbers.size(); ++i) {\n\
    \        new_scale[i] = scale;\n        scale += length[i] / min.second;\n   \
    \ }\n    // Return the list\n    return new_scale;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> result;\n    // For each number in the list...\n\
    \    for (size_t i = 0; i < numbers.size(); ++i) {\n        // If it is smaller\
    \ than the smallest number we've seen so far...\n        if (numbers[i] < result.front())\
    \ {\n            // Shift it to the smallest number and subtract it from the largest\
    \ number we have...\n            result.front() = numbers[i];\n            result.back()\
    \ -= result.back();\n        }\n        // Otherwise if its larger than the largest\
    \ number we've seen so far...\n        else if (numbers[i] > result.back()) {\n\
    \            // Shift it to the largest number and add it to a new smallest number...\n\
    \            result.push_back(result[result.size() - 1] + numbers[i]);\n     \
    \   }\n        // Otherwise...\n        else {\n            // Append it onto\
    \ the list of numbers...\n            result.push_back(numbers[i]);\n        }\n\
    \    }\n    return result;", "  // Sort the numbers (ascending order). First element\
    \ will be 0, the second 1, the third 2, ...\n  numbers.sort();\n  // Find the\
    \ midpoint of the list\n  size_t mid = numbers.size() / 2;\n  // Find the midpoint\
    \ and divide by the length of the list (number of elements)\n  auto midpoint =\
    \ numbers.begin() + mid;\n  auto unit = (numbers.end() - midpoint) / numbers.size();\n\
    \  // Now we can scale the numbers to unit with linear interpolation\n  std::vector<float>\
    \ rescaled;\n  for (auto iter = numbers.begin(); iter != midpoint; ++iter) {\n\
    \    rescaled.push_back(iter + (unit * (*iter - numbers[midpoint])));\n  }\n \
    \ return rescaled;", "  assert(numbers.size() > 0);\n  assert(numbers.size() >=\
    \ 2);\n  std::vector<float> result(numbers.size());\n  float smallest_number =\
    \ numbers[0];\n  float greatest_number = numbers[0];\n  for (size_t i = 0; i <\
    \ numbers.size(); ++i) {\n    if (numbers[i] < smallest_number) {\n      smallest_number\
    \ = numbers[i];\n    }\n    if (numbers[i] > greatest_number) {\n      greatest_number\
    \ = numbers[i];\n    }\n  }\n  float delta = greatest_number - smallest_number;\n\
    \  for (size_t i = 0; i < numbers.size(); ++i) {\n    result[i] = numbers[i] -\
    \ smallest_number;\n    result[i] /= delta;\n  }\n  return result;", "    float\
    \ min = std::numeric_limits<float>::lowest();\n    float max = std::numeric_limits<float>::max();\n\
    \    for (auto number : numbers) {\n        assert(number > min && number < max);\n\
    \    }\n    auto min_max_by_element = [&min](auto &a, auto &b) { if (a > b) std::swap(a,\
    \ b); };\n    std::transform(std::begin(numbers), std::end(numbers), std::begin(numbers),\
    \ min_max_by_element);\n    float min_max = std::accumulate(std::begin(numbers),\
    \ std::end(numbers), 0.0f);\n    return std::vector<float>(std::begin(numbers)\
    \ + min_max * 0.5, std::end(numbers) + min_max * 0.5);", "    assert(numbers.size()\
    \ >= 2);\n    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    float\
    \ scale = max - min;\n    std::vector<float> transformed(numbers.begin(), numbers.end());\n\
    \    std::transform(transformed.begin(), transformed.end(), transformed.begin(),\
    \ [min](float x) { return (x - min) * scale; });\n    return transformed;", " \
    \ std::sort(numbers.begin(), numbers.end());\n  const float scale = numbers.size()\
    \ > 1 ? numbers[numbers.size() - 1] : 1.0f;\n  std::vector<float> new_numbers;\n\
    \  new_numbers.reserve(numbers.size());\n  std::transform(numbers.begin(), numbers.end(),\
    \ std::back_inserter(new_numbers),\n                 [scale](float number) { return\
    \ number * scale; });\n  return new_numbers;", "    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    std::vector<float> out;\n    // Iterate through all the numbers and divide\
    \ them by their max value\n    for (float number : numbers) {\n        float rescale\
    \ = (number - min) / (max - min);\n        out.push_back(rescale);\n    }\n  \
    \  return out;", "    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    double total_min = std::numeric_limits<double>::min();\n    double total_max\
    \ = std::numeric_limits<double>::max();\n    double curr_min = std::numeric_limits<double>::min();\n\
    \    double curr_max = std::numeric_limits<double>::max();\n    double curr_min_val\
    \ = curr_min;\n    double curr_max_val = curr_max;\n    for (auto& num : numbers)\
    \ {\n        rescaled_numbers.push_back((curr_min_val - curr_max_val) / (curr_min_val\
    \ + curr_max_val) * (num - curr_min_val) + curr_min_val);\n        curr_min_val\
    \ = num;\n        curr_max_val = num;\n    }\n    return rescaled_numbers;", " \
    \   int n = numbers.size();\n    std::vector<float> tmp(n);\n    for (size_t i\
    \ = 0; i < n; i++) {\n        tmp[i] = numbers[i] * 2.0 - 1.0;\n    }\n    sort(tmp.begin(),\
    \ tmp.end());\n    tmp[0] = 0.0;\n    tmp[n-1] = 1.0;\n    return tmp;", "   \
    \ assert(numbers.size() >= 2);\n    std::vector<float> new_numbers(numbers.begin(),\
    \ numbers.begin() + numbers.size() / 2);\n    float smallest = new_numbers.front();\n\
    \    float largest = new_numbers[new_numbers.size() - 1];\n    for (int i = 0;\
    \ i < new_numbers.size() / 2; i++) {\n        float temp = new_numbers[i]; //\
    \ store in a temp\n        new_numbers[i] = smallest + (largest - smallest) *\
    \ (temp - smallest) / float(new_numbers.size() - 1);\n    }\n    return new_numbers;",
  "    assert(numbers.size() > 1);\n    numbers.insert(numbers.begin(), numbers.back());\n\
    \    numbers.insert(numbers.begin(), numbers.back());\n    numbers.insert(numbers.begin(),\
    \ numbers.back());\n    numbers.insert(numbers.begin(), numbers.back());\n   \
    \ numbers.insert(numbers.begin(), numbers.back());\n    return numbers;", "  \
    \  auto min_element = *std::min_element(numbers.cbegin(), numbers.cend());\n \
    \   auto max_element = *std::max_element(numbers.cbegin(), numbers.cend());\n\
    \    std::vector<float> result(numbers.size());\n    // Linear transform - scale\
    \ between min and max\n    for (int i = 0; i < numbers.size(); ++i) {\n      \
    \  result[i] = numbers[i] / max_element - min_element / numbers.size();\n    }\n\
    \    return result;", "\tassert(numbers.size() >= 2);\n\tstd::vector<float> res(numbers.begin()\
    \ + 1, numbers.end());\n\tfloat range = numbers[1] - numbers[0];\n\tres[0] = numbers[0]\
    \ / range;\n\tfor (size_t i = numbers.begin() + 2; i < numbers.end(); i++) {\n\
    \t\tres[i] = (res[i] - numbers[i - 1]) / range;\n\t}\n\treturn res;", "  std::vector<float>\
    \ result;\n  assert(numbers.size() >= 2);\n  for (int i = 0; i < numbers.size();\
    \ ++i) {\n    result.push_back(numbers[i] / max(numbers[i], 1e-16));\n  }\n  return\
    \ result;", "    std::vector<float> res(numbers.begin(), numbers.end());\n   \
    \ // sort the vector\n    std::sort(res.begin(), res.end());\n    // find the\
    \ smallest number and the largest\n    float max_val = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n\
    \    // normalize each element\n    for (size_t i = 0; i < numbers.size(); i++)\
    \ {\n        res[i] = (res[i] - min_val) / (max_val - min_val);\n    }\n    return\
    \ res;", "    // Sort elements from smallest to largest\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    // Find the largest number that would make numbers equal\
    \ to zero\n    float largest = std::max(numbers.front(), numbers.back());\n  \
    \  // Find the smallest number that would make numbers equal to 1\n    float smallest\
    \ = std::min(numbers.front(), numbers.back());\n    // Multiply smallest and largest\
    \ by their reciprocals to get the scale factor\n    float scale = largest / smallest;\n\
    \    // Now scale each number by the scale factor\n    std::vector<float> rescaled_numbers(numbers.begin(),\
    \ numbers.end());\n    for (auto element : rescaled_numbers) {\n        rescaled_numbers[numbers.size()\
    \ - 1 - element] = element;\n    }\n    return rescaled_numbers;", "    std::sort(numbers.begin(),\
    \ numbers.end());\n    // If there is only one element, don't bother changing\
    \ it\n    if (numbers.size() == 1)\n        return numbers;\n    std::vector<float>\
    \ scaledNumbers;\n    float min = 0;\n    float max = numbers[0]; // assume numbers\
    \ is sorted\n    // Find min and max\n    for (int i = 1; i < numbers.size();\
    \ i++) {\n        if (numbers[i] < min) {\n            min = numbers[i];\n   \
    \     }\n        if (numbers[i] > max) {\n            max = numbers[i];\n    \
    \    }\n    }\n    // Scale numbers\n    for (float number : numbers) {\n    \
    \    scaledNumbers.push_back(number * float(max - min) / (max - number));\n  \
    \  }\n    return scaledNumbers;", "    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float range = max - min;\n    // Find the value that would map the min to\
    \ the new min and max to the new max\n    float new_min = min + range * 0.05;\n\
    \    float new_max = max - range * 0.05;\n    std::vector<float> scaled;\n   \
    \ float scale_multiplier = (new_max - new_min) / (numbers.back() - numbers.front());\n\
    \    numbers.reserve(numbers.size() * 2);\n    for (float &number : numbers) {\n\
    \        number -= min;\n        scaled.resize(scaled.size() + 1);\n        scaled[0]\
    \ = (number - new_min) / scale_multiplier;\n        scaled[scaled.size() - 1]\
    \ = number;\n        for (int i = 1; i < scaled.size(); i++) {\n            scaled[i]\
    \ = scaled[i - 1] * (new_max - new_min) + new_min;\n        }\n        std::copy(scaled.begin(),\
    \ scaled.end(), numbers.begin());\n    }\n    return scaled;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> scaled(numbers.begin() + 1, numbers.end());\n\
    \    std::transform(numbers.begin(), numbers.end(), scaled.begin(),\n        \
    \           [](float x) { return (x - numbers[0]) / (numbers[numbers.size() -\
    \ 1] - numbers[0]); });\n    return scaled;", "    // Initialize minimum value\
    \ to 0\n    std::vector<float> outputs(numbers.begin(), numbers.begin() + 1);\n\
    \    // Initialize maximum value to 1\n    outputs[numbers.size()-1] = numbers[numbers.size()\
    \ - 1];\n    // Loop through the input numbers to find the minimum and maximum\
    \ values\n    for(auto number: numbers) {\n        // If this number is smaller\
    \ than the minimum, update minimum\n        if(number < outputs[0]) {\n      \
    \      outputs[0] = number;\n        }\n        // If this number is bigger than\
    \ the maximum, update maximum\n        if(number > outputs[outputs.size()-1])\
    \ {\n            outputs[outputs.size()-1] = number;\n        }\n    }\n    //\
    \ Return the scaled list\n    return outputs;", "    assert(numbers.size() > 1);\n\
    \    std::vector<float> rescaled;\n    float total = 0;\n    for (float number\
    \ : numbers)\n        total += number;\n    float scale = 1.f / total;\n    for\
    \ (float number : numbers)\n        rescaled.push_back(number * scale);\n    return\
    \ rescaled;", "    // Compute the largest and smallest numbers\n    float max_value\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    float min_value =\
    \ *std::min_element(numbers.begin(), numbers.end());\n\n    // Find the difference\
    \ between the largest and smallest numbers\n    float delta = (max_value - min_value);\n\
    \n    // Compute the scaling factor\n    float scale_factor = delta/2.0f;\n\n\
    \    // Apply the scaling factor\n    std::vector<float> rescaled;\n    for (float&\
    \ number : numbers)\n        rescaled.push_back((number - min_value) * scale_factor);\n\
    \n    return rescaled;", "  assert(numbers.size() > 1);\n  float smallest_num\
    \ = numbers[0];\n  float largest_num = numbers[0];\n  for (float number : numbers)\
    \ {\n    smallest_num = std::min(smallest_num, number);\n    largest_num = std::max(largest_num,\
    \ number);\n  }\n  std::vector<float> result;\n  for (float number : numbers)\
    \ {\n    result.push_back(number - smallest_num) / (largest_num - smallest_num);\n\
    \  }\n  return result;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ unit;\n    unit.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size();\
    \ ++i) {\n        unit.push_back((numbers[i] - numbers[i - 1]) / (numbers[i] -\
    \ unit.back()));\n    }\n    return unit;"]
stop_tokens:
- "\n}"
