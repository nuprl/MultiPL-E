name: HumanEval_29_filter_by_prefix
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of strings\
  \ only for ones that start with a given prefix.\n// >>> filter_by_prefix([], 'a')\n\
  // []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n// ['abc',\
  \ 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings,\
  \ std::string prefix) {\n"
tests: "}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
  \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
  xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
  xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
completions: ["  return std::remove_if(strings.begin(), strings.end(), [&](std::string\
    \ item) -> bool {\n    return item.starts_with(prefix);\n  });", "    std::vector<std::string>\
    \ result;\n    size_t prefix_len = prefix.length();\n    for (auto &str : strings)\
    \ {\n        if (str.size() >= prefix_len) {\n            if (str.substr(0, prefix_len)\
    \ == prefix) {\n                result.push_back(str);\n            }\n      \
    \  }\n    }\n    return result;", "    std::vector<std::string> filtered_strings;\n\
    \    for (std::string s : strings)\n        if (s.substr(0, prefix.size()) ==\
    \ prefix)\n            filtered_strings.push_back(s);\n    return filtered_strings;",
  "  // Sort the strings by their first letter and find the prefix.\n  std::sort(strings.begin(),\
    \ strings.end(), [](const std::string & s, const std::string & p) {\n    return\
    \ s.front() < p.front();\n  });\n  auto prefix_pos = std::find(strings.begin(),\
    \ strings.end(), prefix);\n  // If prefix not found.\n  if (prefix_pos == strings.end())\n\
    \    return strings;\n  // If prefix is found, remove all the strings not starting\
    \ with the prefix letter\n  strings.erase(std::remove_if(strings.begin(), strings.end(),\n\
    \                               [&](const std::string & s) {\n    return !s.front()\
    \ == prefix.front();\n  }), strings.end());\n  return strings;", "  auto it =\
    \ std::begin(strings);\n  std::string prefix_str(prefix.begin(), prefix.end());\n\
    \  while (it != std::end(strings)) {\n    std::string str = *it;\n    if (str.find(prefix_str)\
    \ == 0)\n      it = std::erase(it);\n    else\n      ++it;\n  }\n  return strings;",
  "    std::vector<std::string> result;\n    for (size_t i = 0; i < strings.size();\
    \ i++) {\n        if (strings[i].startsWith(prefix)) {\n            result.push_back(strings[i]);\n\
    \        }\n    }\n    return result;", "  std::vector<std::string> result;\n\
    \  std::for_each(strings.begin(), strings.end(), [&](std::string s) {\n    if\
    \ (s.substr(0, prefix.size()) == prefix) {\n      result.push_back(s);\n    }\n\
    \  });\n  return result;", "  // TODO : use std::regex instead of string manipulation\
    \ on prefix\n  return std::remove_if(strings.begin(), strings.end(), [&](std::string\
    \ s) {\n    return s.substr(0, prefix.size()) == prefix;\n  });", "  return std::remove_if(strings.begin(),\
    \ strings.end(),\n      [&prefix](std::string s) { return s.substr(0, prefix.length())\
    \ == prefix; });", "  std::set<std::string> stringSet;\n  for (std::string s:\
    \ strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      stringSet.insert(s);\n\
    \    }\n  }\n  return stringSet.empty() ? strings : stringSet.begin(), stringSet.end();",
  "    std::vector<std::string> res;\n    res.reserve(strings.size());\n    for (auto&\
    \ str : strings) {\n        if (str.substr(0, prefix.size()) == prefix) {\n  \
    \          res.push_back(str);\n        }\n    }\n    return res;", "    if (strings.empty())\
    \ return std::vector<std::string>();\n    bool match = false;\n    for (auto str\
    \ : strings) {\n        if (str.compare(0, prefix.size(), prefix) == 0) {\n  \
    \          match = true;\n        } else {\n            match = false;\n     \
    \       break;\n        }\n    }\n    if (match) return strings;\n    else return\
    \ std::vector<std::string>();", "  return std::remove_if(strings.begin(), strings.end(),\n\
    \                        [&prefix](std::string s) { return s.starts_with(prefix);\
    \ });", "  std::sort(strings.begin(), strings.end()); // sort to ensure prefix\
    \ is not an empty string.\n  if (prefix.empty()) return strings;\n  auto prefix_pos\
    \ = strings.begin();\n  while (prefix_pos != strings.end() && prefix_pos->find(prefix)\
    \ == 0) {\n    ++prefix_pos;\n  }\n  auto new_strings = std::vector<std::string>(strings);\n\
    \  std::for_each(prefix_pos, new_strings.end(), [](std::string* string) { delete\
    \ string; });\n  return new_strings;", "  std::cout << \"filter_by_prefix strings:\
    \ \" << strings.size() << \"  prefix: \" << prefix.size() << std::endl;\n  std::string\
    \ pre = prefix.substr(0, prefix.size() - 1);\n  std::cout << \"pre: \" << pre\
    \ << std::endl;\n  std::vector<std::string> retVec;\n  for (int i = 0; i < strings.size();\
    \ i++) {\n    if (strings[i].substr(0, prefix.length()) == pre) {\n      retVec.push_back(strings[i]);\n\
    \    }\n  }\n  return retVec;", "    std::cout << \"Strings passed: \" << strings\
    \ << \"\\n\";\n    std::cout << \"Prefix passed: \" << prefix << \"\\n\";\n  \
    \  \n    std::vector<std::string> new_strings;\n    \n    std::cout << \"Starting\
    \ loop through list \" << endl;\n    \n    for (int i = 0; i < strings.size();\
    \ i++) {\n        std::cout << \"Checking string \" << i << endl;\n        \n\
    \        if (strings[i].size() >= prefix.size() && strings[i].substr(0, prefix.length())\
    \ == prefix) {\n            new_strings.push_back(strings[i]);\n        }\n  \
    \  }\n    std::cout << \"End loop through list \" << endl;\n    \n    std::cout\
    \ << \"Returning new list of strings: \" << new_strings << \"\\n\";\n    \n  \
    \  return new_strings;", "  std::sort(strings.begin(), strings.end());\n  strings.erase(std::remove_if(strings.begin(),\
    \ strings.end(), [&](std::string s) { return s.front() != prefix; }), strings.end());\n\
    \  return strings;", "  std::vector<std::string> filtered(strings.size());\n \
    \ for (size_t i = 0; i < strings.size(); ++i) {\n    if (strings[i].substr(0,\
    \ prefix.size()) == prefix) {\n      filtered[i] = strings[i];\n    }\n  }\n \
    \ return filtered;", "    std::vector<std::string> filtered;\n    std::for_each(strings.begin(),\
    \ strings.end(), [&filtered, &prefix](std::string& str) {\n        std::size_t\
    \ found = str.find(prefix);\n        if (found != std::string_view::npos)\n  \
    \          filtered.push_back(str);\n    });\n    return filtered;", "  std::vector<std::string>\
    \ ret;\n  for (auto s : strings) {\n    if (s.substr(0, prefix.size()) == prefix)\
    \ {\n      ret.push_back(s);\n    }\n  }\n  return ret;", "  std::vector<std::string>\
    \ result;\n  for(auto &string : strings)\n    if (string.substr(0, prefix.size())\
    \ == prefix)\n      result.emplace_back(string);\n  return result;", "    auto\
    \ prefix_iter = std::sfind_if(strings.begin(), strings.end(),\n        [&](std::string\
    \ x){ return x.substr(0, prefix.size()) == prefix; });\n    if (prefix_iter ==\
    \ strings.end())\n        return {};\n    strings.erase(prefix_iter, strings.end());\n\
    \    return strings;", "  assert(strings.size());\n  prefix = prefix.front();\n\
    \  std::sort(strings.begin(), strings.end());\n  strings.erase(std::remove_if(strings.begin(),\
    \ strings.end(),\n                             [&](std::string str) {\n      \
    \                         return !str.starts_with(prefix);\n                 \
    \            }),\n               strings.end());\n  return strings;", "  auto\
    \ prefix_begin = prefix.begin();\n  auto prefix_end = prefix.end();\n  std::sort(strings.begin(),\
    \ strings.end());\n  std::set_difference(strings.begin(), strings.end(), strings.begin(),\
    \ prefix_begin, [prefix_end](std::string a, std::string b) {\n    return a.size()\
    \ > prefix_end.size() ? a < b : prefix_end < b;\n  });\n  return strings;", " \
    \ std::vector<std::string> out;\n  std::copy_if(strings.begin(), strings.end(),\
    \ std::back_inserter(out),\n               [&](std::string &s) { return s.compare(0,\
    \ prefix.size(), prefix) == 0; });\n  return out;", "  // Iterate through the\
    \ input and copy strings to the output if they start with the\n  // prefix.\n\
    \  for (auto& string : strings) {\n    if (string.substr(0, prefix.length()) ==\
    \ prefix) {\n      strings.push_back(string);\n    }\n  }\n  return strings;",
  "    auto it = std::begin(strings);\n    for(; it != std::end(strings); ++it) {\n\
    \        std::string s = *it;\n        if(s.find(prefix) == 0) {\n           \
    \ strings.erase(it);\n            strings.push_back(s);\n        }\n    }\n  \
    \  return strings;", "  assert(strings.size() != 0);\n  if (strings.empty())\n\
    \    return strings;\n  auto it = std::find(strings.begin(), strings.end(), prefix);\n\
    \  if (it == strings.end())\n    return strings;\n  strings.erase(it);\n  return\
    \ strings;", "  std::vector<std::string> result;\n  for(auto &str : strings) {\n\
    \    if(str.substr(0, prefix.size()) == prefix) {\n      result.push_back(str);\n\
    \    }\n  }\n  return result;", "    std::vector<string> output;\n    for (auto\
    \ &s : strings) {\n        if (s.find(prefix) == 0) {\n            output.push_back(s);\n\
    \        }\n    }\n    return output;", "    std::vector<std::string> result;\n\
    \    // Loop over the input strings backwards to find the first one starting with\
    \ prefix.\n    for (std::size_t i = 0; i < (std::size_t) strings.size(); ++i)\
    \ {\n        if (strings[i].compare(0, prefix.size(), prefix) == 0) {\n      \
    \      result.push_back(strings[i]);\n        }\n    }\n    return result;", " \
    \ std::vector<std::string> new_list;\n  for (std::string elem : strings)\n   \
    \ if (elem.startswith(prefix))\n      new_list.push_back(elem);\n  return new_list;",
  "    std::string prefix_copy = prefix;\n    prefix_copy.insert(prefix_copy.begin(),\
    \ prefix.size());\n    std::vector<std::string> results;\n\n    for (std::string\
    \ &s : strings) {\n        if (prefix_copy == s) {\n            results.push_back(s);\n\
    \        }\n    }\n\n    return results;", "  std::vector<std::string> result;\n\
    \  for (const auto &string : strings) {\n    if (string.substr(0, prefix.size())\
    \ == prefix) {\n      result.emplace_back(string);\n    }\n  }\n  return result;",
  "  std::sort(strings.begin(), strings.end());\n  auto prefix = prefix.begin();\n\
    \  auto end = strings.end();\n  std::set<std::string> res;\n  while (prefix !=\
    \ end) {\n    if (prefix.compare(0, prefix.length(), *prefix) == 0) {\n      res.insert(strings.begin(),\
    \ strings.end());\n    }\n    ++prefix;\n  }\n  return res;", "  assert(strings.size()\
    \ > 0);\n  assert(strings[0].find(prefix) == 0);\n  std::ostringstream stream;\n\
    \  stream << strings[0];\n  for (int i = 1; i < strings.size(); i++) {\n    stream\
    \ << \" \" << strings[i];\n  }\n  std::copy(std::istream_iterator<std::string>(std::cin(stream)),\n\
    \            std::istream_iterator<std::string>(),\n            std::back_inserter(strings));\n\
    \  return strings;", "    return std::remove_if(strings.begin(), strings.end(),\
    \ [&](std::string &s) {\n        return s.find(prefix) == 0;\n    });", "    std::vector<std::string>\
    \ retval;\n    std::copy_if(strings.begin(), strings.end(), std::back_inserter(retval),\n\
    \                 [prefix](std::string i) { return i.compare(0, prefix.size(),\
    \ prefix) == 0; });\n    return retval;", "  std::vector<std::string> result;\n\
    \  result.reserve(strings.size());\n  for (auto it = strings.begin(); it != strings.end();\
    \ ++it) {\n    if (it->compare(0, prefix.size(), prefix) == 0) {\n      result.push_back(*it);\n\
    \    }\n  }\n  return result;", "  std::vector<std::string> results;\n  std::copy_if(strings.begin(),\
    \ strings.end(),\n               std::back_inserter(results),\n              \
    \ [&prefix](std::string s) { return s.substr(0, prefix.length()) == prefix; });\n\
    \  return results;", "    std::vector<std::string> result;\n    for (auto const&\
    \ string : strings) {\n        if (string.find(prefix) == 0) {\n            result.push_back(string);\n\
    \        }\n    }\n    return result;", "\tstd::vector<std::string> out;\n\tfor\
    \ (auto& s: strings) {\n\t\tif (s.substr(0, prefix.size()) == prefix) {\n\t\t\t\
    out.emplace_back(s);\n\t\t}\n\t}\n\treturn out;", "    std::sort(strings.begin(),\
    \ strings.end()); // stable sort\n    // If the prefix is empty or it's equal\
    \ to the first string, return the\n    // original list.\n    if (prefix.empty()\
    \ || strings.front() == prefix) {\n        return strings;\n    }\n\n    // Create\
    \ a vector to hold the result of the iteration and initialize it to empty.\n \
    \   std::vector<std::string> result;\n    result.reserve(strings.size());\n\n\
    \    // Iterate over the input list and only add strings that begin with the given\n\
    \    // prefix to the result.\n    bool match = false;\n    for (std::string::const_iterator\
    \ it = strings.begin(); it != strings.end(); ++it) {\n        if (std::equal(prefix.begin(),\
    \ prefix.end(), *it)) {\n            result.push_back(*it);\n            match\
    \ = true;\n        }\n    }\n\n    // If the input list does not match the prefix,\
    \ return an empty list.\n    if (!match) {\n        return result;\n    }\n\n\
    \    // Return the result of the iteration.\n    return result;", "    // Return\
    \ an empty list if the input is empty or null.\n    if (strings.empty() || strings[0]\
    \ == \"\")\n        return strings;\n\n    // Initialize a vector of strings we\
    \ will return.\n    std::vector<std::string> result;\n\n    // The current first\
    \ string to be returned for each input.\n    std::string first = \"\";\n\n   \
    \ // Iterate over the input list\n    for (int i = 0; i < strings.size(); i++)\
    \ {\n        // If the current string starts with the prefix, return it.\n   \
    \     if (strings[i].substr(0, prefix.length()) == prefix) {\n            result.push_back(first);\n\
    \            first = strings[i];\n        }\n        else {\n            // If\
    \ the current string doesn't start with the prefix, but the\n            // first\
    \ one we encounter, add it to the result.\n            if (first != \"\")\n  \
    \              result.push_back(first);\n\n            // Set the current first\
    \ string.\n            first = strings[i];\n        }\n    }\n\n    // If the\
    \ current string doesn't start with the prefix, but the first one\n    // we encounter,\
    \ add it to the result.\n    if (first != \"\")\n        result.push_back(first);\n\
    \n    // Return the result.\n    return result;", "  std::string rep(prefix);\n\
    \  for (const auto &s : strings) {\n    if (s.compare(0, rep.size(), rep) == 0)\
    \ {\n      strings.erase(std::remove(strings.begin(), strings.end(), s));\n  \
    \  }\n  }\n  return strings;", "  std::vector<std::string> res;\n  for(auto s:\
    \ strings)\n    if(s.substr(0, prefix.size()) == prefix)\n      res.push_back(s);\n\
    \  return res;", "  std::vector<std::string> result;\n  for (auto& s: strings)\
    \ {\n    if (s.substr(0, prefix.length()) == prefix) {\n      result.push_back(s);\
    \ // Store the string in the result list.\n    }\n  }\n  return result;", "  \
    \  auto it=strings.begin();\n    while(it != strings.end() && it->compare(0, prefix.size(),\
    \ prefix) == 0) {\n        ++it;\n    }\n    return std::move(it);", "    std::vector<std::string>\
    \ out;\n    for (auto &x : strings) {\n        if (x.startsWith(prefix)) {\n \
    \           out.push_back(x);\n        }\n    }\n    return out;", "  auto filter_func\
    \ = [&prefix](const std::string &s) {\n    return 0 == s.compare(0, prefix.size(),\
    \ prefix);\n  };\n  return std::remove_if(strings.begin(), strings.end(), filter_func);",
  "    std::vector<std::string> result;\n    size_t prefix_length = prefix.size();\n\
    \    for (std::string &string : strings) {\n        if (string.size() >= prefix_length)\
    \ {\n            if (string[0] == prefix) {\n                result.push_back(string);\n\
    \            }\n        }\n    }\n    return result;", "  std::cout << strings\
    \ << std::endl;\n  if(strings.empty()) return strings;\n  std::string prefix =\
    \ prefix + \"%\";\n  auto prefix_last = prefix.rbegin();\n  std::string::reverse_iterator\
    \ rit = std::search(prefix.begin(), prefix.end(), strings[0].rbegin(), strings[0].rend());\n\
    \  std::string::reverse_iterator it = std::search(prefix.begin(), prefix.end(),\
    \ strings[0].begin(), strings[0].end());\n  if(it == strings[0].end() || it ==\
    \ prefix_last) return strings;\n  strings.erase(strings.begin(), strings.begin()+rit);\n\
    \  return strings;", "    std::vector<std::string> res;\n    std::for_each(strings.begin(),\
    \ strings.end(), [&](const std::string &s) {\n        if (s.substr(0, prefix.size())\
    \ == prefix) {\n            res.push_back(s);\n        }\n    });\n    return\
    \ res;", "  std::vector<std::string> result;\n  for (auto s : strings)\n    if\
    \ (s.compare(0, prefix.size(), prefix) == 0)\n      result.push_back(s);\n  return\
    \ result;", "    std::vector<std::string> filtered;\n    for (auto &item : strings)\
    \ {\n        if (item.find(prefix) == 0) {\n            filtered.push_back(prefix);\n\
    \        } else {\n            filtered.push_back(item);\n        }\n    }\n \
    \   return filtered;", "    std::vector<std::string> result;\n    for (auto &\
    \ x: strings)\n        if (x.substr(0, prefix.size()) == prefix)\n           \
    \ result.push_back(x);\n    return result;", "    // O(n) time complexity. Could\
    \ be improved to O(n*log(N)) using map here\n    std::vector<std::string> result;\n\
    \    std::unordered_map<std::string,int> counter;\n    for(auto i : strings)\n\
    \    {\n        if(counter.find(prefix) == counter.end())\n        {\n       \
    \     counter[prefix] = 0;\n        }\n        counter[prefix] += 1;\n       \
    \ if(counter[prefix] == 1)\n        {\n            result.push_back(i);\n    \
    \    }\n    }\n    return result;", "  std::string::size_type first = strings.begin();\n\
    \  std::string::size_type last = strings.end();\n  while (first != last) {\n \
    \   if (first[0] == prefix[0]) {\n      last = strings.erase(first);\n    } else\
    \ {\n      first++;\n    }\n  }\n  return strings;", "  std::vector<std::string>\
    \ out;\n  for (const auto& string : strings) {\n    if (string.substr(0, prefix.size())\
    \ == prefix) {\n      out.emplace_back(string);\n    }\n  }\n  return out;", " \
    \   std::vector<std::string> result;\n    for (auto it = strings.begin(); it !=\
    \ strings.end(); it++) {\n        if (it->substr(0, prefix.size()) == prefix)\
    \ {\n            result.emplace_back(*it);\n        }\n    }\n    return result;",
  "  std::vector<std::string> result;\n  for (const auto &string : strings) {\n  \
    \  if (string.substr(0, prefix.size()) == prefix) {\n      result.push_back(string);\n\
    \    }\n  }\n  return result;", "    std::vector<std::string> res;\n    std::stack<std::string>\
    \ stk;\n    stk.push(prefix);\n    for (std::string & str : strings) {\n     \
    \   if (stk.empty() || str != stk.top()) {\n            stk.push(str);\n     \
    \       res.push_back(str);\n        } else {\n            while (stk.size() >\
    \ 1 && str != stk.top()) {\n                stk.pop();\n                res.pop();\n\
    \            }\n            stk.pop();\n        }\n    }\n    return res;", " \
    \   std::sort(strings.begin(), strings.end());\n    auto prefix_pos = strings.begin()\
    \ + std::find(strings.begin(), strings.end(), prefix);\n    std::vector<std::string>\
    \ res;\n    res.reserve(strings.size());\n    for (auto it = prefix_pos; it !=\
    \ strings.end(); ++it) {\n        res.push_back(*it);\n    }\n    return res;",
  "  std::vector<std::string> result;\n  std::copy(std::begin(strings), std::end(strings),\
    \ std::back_inserter(result));\n  std::sort(std::begin(result), std::end(result));\n\
    \  auto it = std::begin(result);\n  while (it != std::end(result)) {\n    if ((*it).compare(0,\
    \ prefix.size(), prefix) == 0) {\n      it--;\n    } else {\n      result.erase(it);\n\
    \    }\n  }\n  return result;", "  assert(strings.size() > 0);\n  assert(strings.size()\
    \ == prefix.size());\n\n  std::vector<std::string> result;\n  bool seen = false;\n\
    \  for (auto s: strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n\
    \      seen = true;\n      result.push_back(s);\n    }\n  }\n  if (seen) {\n \
    \   return result;\n  }\n  return {};", "  assert(strings.empty() || strings.size()\
    \ >= prefix.size());\n  if (strings.empty() || prefix.empty())\n    return strings;\n\
    \  std::vector<std::string> result;\n  result.reserve(strings.size());\n  auto\
    \ it = strings.begin();\n  auto it_prefix = prefix.begin();\n  for (; it != strings.end();\
    \ ++it, ++it_prefix) {\n    if (it_prefix != prefix.end() && it_prefix == it +\
    \ prefix.size()) {\n      result.push_back(*it);\n    }\n  }\n  return result;",
  "    // Write your code here.\n    std::vector<std::string> result;\n    for (unsigned\
    \ int i = 0; i < strings.size(); i++)\n    {\n        if (strings[i].substr(0,\
    \ prefix.length()) == prefix)\n        {\n            result.push_back(strings[i]);\n\
    \        }\n    }\n    return result;", "  std::vector<std::string> results;\n\
    \  for (std::string string : strings)\n    if (string.substr(0, prefix.length())\
    \ == prefix)\n      results.push_back(string);\n  return results;", "    std::sort(strings.begin(),\
    \ strings.end());\n    auto first_string_start = std::find_if(strings.begin(),\
    \ strings.end(),\n            [&](std::string & s) { return s.substr(0, prefix.length())\
    \ == prefix; });\n    return first_string_start != strings.end() ? std::move(strings)\
    \ : std::vector<string>();", "  std::vector<std::string> result;\n  for (int i\
    \ = 0; i < strings.size(); ++i) {\n    if (strings[i].substr(0, prefix.length())\
    \ == prefix) {\n      result.push_back(strings[i]);\n    }\n  }\n  return result;",
  "    std::vector<std::string> result;\n    auto pos = strings.begin();\n    while\
    \ (pos != strings.end()) {\n        if (std::string(prefix) == std::string(pos))\
    \ {\n            result.push_back(std::string(pos));\n        }\n        ++pos;\n\
    \    }\n    return result;", "  std::vector<std::string> res;\n  for(unsigned\
    \ int i=0; i < strings.size(); ++i) {\n    if(strings[i].find(prefix) == 0) {\n\
    \      res.push_back(strings[i]);\n    }\n  }\n  return res;", "    std::vector<std::string>\
    \ result;\n    for (auto &s : strings) {\n        if (s.substr(0, prefix.size())\
    \ == prefix) {\n            result.push_back(s);\n        }\n    }\n    return\
    \ result;", "  // Create a copy of the original list.\n  std::vector<std::string>\
    \ copyStrings = strings;\n  std::sort(copyStrings.begin(), copyStrings.end());\n\
    \n  // Look for prefix at each index in string list.\n  std::vector<int> indexesToRemove;\n\
    \  for (int i = 0; i < copyStrings.size(); ++i) {\n    if (copyStrings[i].find(prefix)\
    \ == 0) {\n      indexesToRemove.push_back(i);\n    }\n  }\n\n  // Remove prefix\
    \ from original list.\n  for (int i = 0; i < indexesToRemove.size(); ++i) {\n\
    \    copyStrings.erase(copyStrings.begin() + indexesToRemove[i]);\n  }\n\n  return\
    \ copyStrings;", "  std::vector<std::string>::iterator it = std::begin(strings);\n\
    \  while (it != std::end(strings)) {\n    std::string::size_type startPos = it->find(prefix);\n\
    \    if (startPos != std::string::npos) {\n      strings.erase(it);\n    } else\
    \ {\n      ++it;\n    }\n  }\n  return strings;", "  if(strings.size() == 0) return\
    \ strings;\n  std::vector<std::string> result;\n  for(unsigned int i = 0; i <\
    \ strings.size(); ++i) {\n    if(strings[i].substr(0, prefix.length()) == prefix)\
    \ {\n      result.push_back(strings[i]);\n    }\n  }\n  return result;", "  auto\
    \ it = std::begin(strings);\n  while (it != std::end(strings)) {\n    auto n =\
    \ std::distance(std::begin(strings), it);\n    if (0 == n.compare(0, prefix.size(),\
    \ prefix)) {\n      it = std::next(it, prefix.size());\n    } else {\n      it\
    \ = std::next(it, n);\n    }\n  }\n  return strings;", "  std::vector<std::string>\
    \ result;\n  for (const auto& str : strings) {\n    if (str.find(prefix) == 0)\
    \ {\n      result.push_back(str);\n    }\n  }\n  return result;", "    std::vector<std::string>\
    \ result;\n    std::for_each(strings.begin(), strings.end(), [&](std::string&\
    \ s) {\n        if (s.substr(0, prefix.length()) == prefix)\n            result.push_back(s);\n\
    \    });\n    return result;", "  std::vector<std::string> res;\n  res.reserve(strings.size());\n\
    \  for (auto &str : strings) {\n    if (str.substr(0, prefix.size()) == prefix)\
    \ {\n      res.push_back(str);\n    }\n  }\n  return res;", "    std::vector<std::string>\
    \ result;\n    auto it = std::begin(strings);\n    while (it != std::end(strings))\
    \ {\n        if (it->substr(0, prefix.size()) == prefix) {\n            result.push_back(it->substr(prefix.size()));\n\
    \        }\n        ++it;\n    }\n    return result;", "    std::vector<std::string>\
    \ result;\n    for (auto &string : strings) {\n        if (0 == string.compare(0,\
    \ prefix.length(), prefix))\n            result.emplace_back(std::move(string));\n\
    \    }\n    return result;", "  std::vector<std::string> result;\n  for (std::string&\
    \ s: strings) {\n    if (s.substr(0, prefix.length()) == prefix) {\n      result.push_back(s);\
    \ // if found, add\n    }\n  }\n  return result;", "    assert(strings.size()\
    \ != 0);\n    size_t prefix_len = prefix.length();\n    std::vector<std::string>\
    \ new_strings;\n    for(auto &str : strings) {\n        size_t prefix_found =\
    \ 0;\n        for(auto &c : str) {\n            if(prefix_found == 0) {\n    \
    \            if(c == prefix[0]) {\n                    prefix_found++;\n     \
    \           } else {\n                    prefix_found = 0;\n                }\n\
    \            } else {\n                if(c == prefix[prefix_found]) {\n     \
    \               prefix_found++;\n                } else {\n                  \
    \  prefix_found = 0;\n                }\n            }\n        }\n        if(prefix_found\
    \ == prefix_len) {\n            new_strings.push_back(str);\n        }\n    }\n\
    \    return new_strings;", "  std::vector<std::string> result;\n  for (auto& s:\
    \ strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      result.push_back(s);\n\
    \    }\n  }\n  return result;", "    std::vector<std::string> result;\n    for\
    \ (const auto& str : strings) {\n        if (str.substr(0, prefix.length()) ==\
    \ prefix) {\n            result.push_back(str);\n        }\n    }\n    return\
    \ result;", "    std::vector<std::string> filtered;\n    for (auto& str : strings)\n\
    \        if (str.substr(0, prefix.size()) == prefix)\n            filtered.push_back(str);\n\
    \    return filtered;", "  std::vector<std::string> ret(std::begin(strings), std::end(strings));\n\
    \  std::remove_if(std::begin(ret), std::end(ret), [&](std::string str) {\n   \
    \ return str.find(prefix) == 0;\n  });\n  return ret;", "    auto it = std::begin(strings);\n\
    \    while (it != std::end(strings)) {\n        if (it->find(prefix) == 0)\n \
    \           strings.erase(it++);\n        else\n            ++it;\n    }\n   \
    \ return strings;", "  std::vector<std::string> result;\n  for (const auto& elem\
    \ : strings) {\n    if (elem.length() >= prefix.length() && elem.substr(0, prefix.length())\
    \ == prefix) {\n      result.push_back(elem);\n    }\n  }\n  return result;",
  "  auto prefix_iter = strings.begin() + std::find(strings.begin(), strings.end(),\
    \ prefix);\n  strings.erase(prefix_iter);\n  return strings;", "  std::vector<std::string>\
    \ output;\n  \n  for (auto s : strings) {\n    if (s[0] == prefix) {\n      output.push_back(s);\n\
    \    }\n  }\n  \n  return output;", "    std::vector<std::string> out;\n    for\
    \ (auto & string : strings) {\n        if (string.substr(0, prefix.size()) ==\
    \ prefix) {\n            out.push_back(string);\n        }\n    }\n    return\
    \ out;", "    // Initialize prefix and check it's non-empty.\n    if (prefix.empty())\
    \ return {strings[0]};\n\n    // Iterate over each string and keep only those\
    \ that start with the prefix.\n    std::vector<std::string> result;\n    for (const\
    \ auto &str : strings) {\n        if (str.substr(0, prefix.size()) == prefix)\
    \ {\n            result.push_back(str);\n        }\n    }\n\n    // Return result\
    \ if any non-null string was found in strings.\n    return result.empty() ? std::vector<std::string>()\
    \ : result;", "    std::sort(strings.begin(), strings.end()); // Sort ascending\n\
    \    auto prefix_pos = prefix.find_first_not_of(strings[0]); // Find first prefix\
    \ that is not in any of the strings\n    if (prefix_pos == std::string::npos)\
    \ return strings; // No matches\n    // Return strings with prefix not matched\n\
    \    auto start = strings.begin() + prefix_pos;\n    auto end = start + strings.size();\n\
    \    return std::remove_copy_if(start, end, std::back_inserter(strings), \n  \
    \                            [prefix](std::string str) {return !str.compare(0,\
    \ prefix.size(), prefix);});", "    auto prefix_size = prefix.size();\n    std::vector<std::string>\
    \ results;\n\n    for(auto i = strings.begin(); i != strings.end(); ++i) {\n \
    \       if(0==std::memcmp(i->c_str(), prefix.c_str(), prefix_size)) {\n      \
    \      results.emplace_back(*i);\n        }\n    }\n\n    return results;", " \
    \ std::vector<std::string> out;\n  auto iter = std::begin(strings);\n  auto end\
    \ = std::end(strings);\n  while(iter != end) {\n    if (0 == prefix.compare(0,\
    \ iter->size(), prefix)) {\n      out.emplace_back(*iter);\n    }\n    ++iter;\n\
    \  }\n  return out;", "  auto prefix_iter = std::find_if(strings.begin(), strings.end(),\n\
    \                                   [&prefix](const std::string& s) {\n      \
    \                               return s[0] == prefix[0];\n                  \
    \                 });\n  return std::remove_if(strings.begin(), strings.end(),\n\
    \                        [&prefix_iter](const std::string& s) { return prefix_iter\
    \ != strings.end() && *prefix_iter == prefix; });", "    std::vector<std::string>\
    \ res;\n    for (std::string word : strings) {\n        if (word.substr(0, prefix.length())\
    \ == prefix) {\n            res.push_back(word);\n        }\n    }\n    return\
    \ res;", "  assert(!prefix.empty());\n  std::sort(strings.begin(), strings.end());\n\
    \  auto it = std::mismatch(strings.begin(), strings.end(), prefix.begin(), prefix.end());\n\
    \  if (it == strings.end()) {\n    return strings;\n  }\n  auto start_index =\
    \ std::distance(prefix.begin(), it.first);\n  auto end_index = std::distance(prefix.begin(),\
    \ it.second);\n  return std::vector<std::string>(strings.begin() + start_index,\
    \ strings.begin() + end_index);", "  auto it = std::begin(strings);\n  std::vector<std::string>\
    \ res;\n  while (it != std::end(strings)) {\n    if (it->substr(0, prefix.size())\
    \ == prefix) {\n      res.push_back(std::move(*it));\n    }\n    ++it;\n  }\n\
    \  return res;", "  std::set<std::string> stringSet;\n  for (std::string s : strings)\n\
    \    stringSet.insert(s.substr(0, prefix.size()));\n  return std::vector<std::string>(stringSet.begin(),\
    \ stringSet.end());", "    return std::remove_if(strings.begin(), strings.end(),\n\
    \            [](const std::string& s) { return s.starts_with(prefix); }\n    \
    \    );", "  std::sort(strings.begin(), strings.end());\n  std::sort(prefix.begin(),\
    \ prefix.end());\n  strings.erase(std::remove_if(strings.begin(), strings.end(),\
    \ [&](std::string s) { return s.substr(0, prefix.size()) == prefix; }), strings.end());\n\
    \  return strings;", "    std::vector<string> result;\n    for(auto &s : strings)\
    \ {\n        if(s.substr(0, prefix.size()) == prefix) {\n            result.push_back(s);\n\
    \        }\n    }\n    return result;", "    std::vector<std::string> result;\n\
    \    for (size_t i = 0; i < strings.size(); ++i) {\n        if (strings[i].substr(0,\
    \ prefix.size()) == prefix) {\n            result.push_back(strings[i]);\n   \
    \     }\n    }\n    return result;", "    std::vector<std::string> result;\n \
    \   for (auto const &str : strings) {\n        if (str.substr(0, prefix.size())\
    \ == prefix)\n            result.push_back(str);\n    }\n    return result;",
  "    // We need to use find because a vector does not allow to pass a callable as\
    \ parameter\n    auto prefix = prefix.begin();\n    std::vector<std::string> res;\n\
    \    std::find(strings.begin(), strings.end(), [&]() {\n        return prefix.compare(strings.begin(),\
    \ strings.end()) == 0;\n    }) != strings.end();\n    return res;", "    auto\
    \ begin = strings.begin();\n    auto end = strings.end();\n    while (begin !=\
    \ end) {\n        if (begin->find(prefix) == 0) {\n            begin = strings.erase(begin);\n\
    \        } else {\n            ++begin;\n        }\n    }\n    return strings;",
  "  std::vector<std::string> results;\n  if (strings.size() == 0)\n    return results;\n\
    \  if (prefix.empty())\n    return results;\n  auto it = strings.begin();\n  while\
    \ (it != strings.end()) {\n    if (it->length() >= prefix.size() && it->substr(0,\
    \ prefix.size()) == prefix) {\n      results.push_back(*it);\n    }\n    ++it;\n\
    \  }\n  return results;", "  std::vector<std::string> retstring;\n  for (std::string\
    \ s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      retstring.push_back(s);\n\
    \    }\n  }\n  return retstring;", "    std::vector<std::string> res;\n    for\
    \ (auto& s : strings) {\n        if (s.find(prefix) == 0)\n            res.push_back(s);\n\
    \    }\n    return res;", "    std::vector<std::string> result;\n    for(auto\
    \ it=strings.begin(); it!=strings.end(); ++it){\n        if(it->substr(0, prefix.size())\
    \ == prefix){\n            result.push_back(*it);\n        }\n    }\n    return\
    \ result;", "  std::sort(strings.begin(), strings.end());\n  std::vector<std::string>::iterator\
    \ iter = strings.begin();\n  while (iter != strings.end() && prefix == iter->substr(0,\
    \ prefix.length())) {\n    ++iter;\n  }\n  return std::vector<std::string>(iter,\
    \ strings.end());", "    if (strings.empty()) return strings;\n    std::vector<bool>\
    \ found(strings.size(), false);\n    for (auto it : strings) {\n        if (it.startsWith(prefix))\
    \ {\n            found[it.size()-1] = true;\n        } else {\n            found[it.size()-1]\
    \ = false;\n        }\n    }\n    std::vector<std::string> result;\n    for (auto\
    \ it : found) {\n        if (it) result.push_back(it);\n    }\n    return result;",
  "  std::vector<std::string> res;\n  for (std::string s : strings) {\n    if (s.substr(0,\
    \ prefix.length()) == prefix) {\n      res.push_back(s);\n    }\n  }\n  return\
    \ res;", "    std::vector<std::string> out;\n    for (std::string s : strings)\
    \ {\n        if (s.substr(0, prefix.size()) == prefix) {\n            out.push_back(s);\n\
    \        }\n    }\n    return out;", "  std::sort(strings.begin(), strings.end());\n\
    \  std::string prefix_str = prefix + \".\";\n  auto it = std::find_if(strings.begin(),\
    \ strings.end(),\n      [&prefix_str](const std::string &str) {\n        return\
    \ str.starts_with(prefix_str);\n      });\n  return std::vector<std::string>{it,\
    \ strings.end()};", "  std::sort(strings.begin(), strings.end()); // sorting the\
    \ input strings makes them easier to read for testing\n  auto it = std::find_if(strings.begin(),\
    \ strings.end(), [&](const std::string & s) { return s.starts_with(prefix); });\n\
    \  if (it != strings.end()) {\n    strings.erase(it, strings.end());\n  }\n  return\
    \ strings;", "    std::vector<std::string> res;\n    for(auto s: strings) {\n\
    \        if(s.substr(0, prefix.size()) == prefix) {\n            res.push_back(s);\n\
    \        }\n    }\n    return res;", "  string filtered_prefix = prefix;\n  for\
    \ (int i=0; i<strings.size(); i++) {\n    if (strings[i].substr(0, filtered_prefix.length())\
    \ == filtered_prefix) {\n      filtered_prefix = strings[i].substr(filtered_prefix.length());\
    \ // remove the prefix.\n    }\n  }\n  return filtered_prefix != prefix ? std::vector<string>(filtered_prefix.begin(),\
    \ filtered_prefix.end()) : strings;", "  std::vector<std::string> filteres;\n\
    \  for (const auto &str : strings) {\n    if (str.substr(0, prefix.length()) ==\
    \ prefix) {\n      filteres.push_back(str);\n    }\n  }\n  return filteres;",
  "    std::vector<std::string> retval;\n    for (std::string s : strs) {\n      \
    \  if (s.substr(0, prefix.size()) == prefix) {\n            retval.push_back(s);\n\
    \        }\n    }\n    return retval;", "  std::string pre = prefix + '.';\n \
    \ std::sort(strings.begin(), strings.end());\n  std::set<std::string> result;\n\
    \  for (std::string &string : strings) {\n    if (string.find(pre) == 0) {\n \
    \     result.insert(string);\n    }\n  }\n  return std::vector<std::string>(result.begin(),\
    \ result.end());", "    std::vector<std::string> result;\n    size_t prefix_len\
    \ = prefix.size();\n\n    for(const auto &str : strings) {\n        if(str.size()\
    \ > prefix_len) {\n            continue;\n        }\n        if(str.substr(0,\
    \ prefix_len) == prefix) {\n            result.push_back(str);\n        }\n  \
    \  }\n\n    return result;", "  std::vector<std::string>::iterator pos = std::find(strings.begin(),\
    \ strings.end(), prefix);\n  if (pos != strings.end()) {\n    strings.erase(pos);\n\
    \  }\n  return strings;", "  assert(strings.size());\n  assert(strings[0].length()\
    \ > prefix.length());\n  std::vector<std::string> res;\n  for (std::string &string\
    \ : strings) {\n    if (string.substr(0, prefix.length()) == prefix) {\n     \
    \ res.push_back(string);\n    }\n  }\n  return res;", "  auto it = std::begin(strings);\n\
    \  for (; it != std::end(strings); ++it)\n    if (it->compare(0, prefix.size(),\
    \ prefix) == 0)\n      std::erase(std::remove_cbegin(std::begin(strings), it),\
    \ std::end(strings));\n  return strings;", "  std::vector<std::string> res;\n\
    \  for (std::string s : strings) {\n    if (s.substr(0, prefix.length()) == prefix)\
    \ {\n      res.push_back(s);\n    }\n  }\n  return res;", "    assert(strings.size()\
    \ > 0);\n    std::vector<std::string> result;\n    for (auto& s : strings) {\n\
    \        if (s.substr(0, prefix.size()) == prefix) {\n            result.push_back(s);\n\
    \        }\n    }\n    return result;", "  std::vector<std::string> result;\n\
    \  for (auto &s : strings)\n    if (s.substr(0, prefix.size()) == prefix) {\n\
    \      result.push_back(s);\n    }\n  return result;", "  std::vector<std::string>\
    \ results;\n  results.reserve(strings.size());\n  for (const auto& string : strings)\
    \ {\n    if (string.compare(0, prefix.size(), prefix) == 0) {\n      results.push_back(std::move(string));\n\
    \    }\n  }\n  return results;", "  auto filtered_prefix = prefix;\n  for (auto\
    \ &s : strings) {\n    if (s.compare(0, prefix.size(), prefix) == 0)\n      filtered_prefix.erase(prefix.size());\n\
    \    else if (s.compare(0, prefix.size(), prefix) == 0)\n      filtered_prefix.push_back(s);\n\
    \  }\n  return filtered_prefix;", "    std::vector<std::string> res;\n    for\
    \ (auto const &i : strings)\n        if (i.substr(0, prefix.size()) == prefix)\n\
    \            res.push_back(i);\n    return res;", "    std::vector<std::string>\
    \ res;\n    std::for_each(strings.begin(), strings.end(), [&res, prefix](std::string\
    \ s) {\n        auto pos = s.find(prefix);\n        if (pos == 0) return res.emplace_back(s);\n\
    \        size_t len = prefix.length();\n        if (len != 0) {\n            if\
    \ (pos == std::string::npos) {\n                return res.emplace_back(s, 0);\n\
    \            } else if (pos == s.size()-len) {\n                return res.emplace_back(s,\
    \ pos);\n            }\n        }\n        return res.emplace_back(s);\n    });\n\
    \    return res;", "  std::vector<std::string> results;\n  for (std::string s\
    \ : strings) {\n    if (s.compare(0, prefix.size(), prefix) == 0) {\n      results.push_back(s);\n\
    \    }\n  }\n  return results;", "    for (auto it = strings.begin(); it != strings.end();\
    \ ++it) {\n        if (it->startswith(prefix)) {\n            strings.erase(it);\n\
    \        }\n    }\n    return strings;", "  assert(prefix.size() > 0);\n  std::string::size_type\
    \ prefix_size = prefix.size();\n  return std::remove_if(strings.begin(), strings.end(),\
    \ [&](const std::string& str) {\n    std::string::size_type begin = str.find_first_not_of(prefix,\
    \ 0);\n    return (begin != std::string::npos);\n  });", "  std::vector<std::string>::iterator\
    \ it;\n  for (it = strings.begin(); it != strings.end(); it++) {\n    if (0 ==\
    \ std::strncmp(prefix, *it, prefix.size())) {\n      strings.erase(it);\n    }\n\
    \  }\n  return strings;", "  std::vector<std::string> output;\n  for (int i =\
    \ 0; i < strings.size(); i++) {\n    if (strings[i].startsWith(prefix)) {\n  \
    \    output.push_back(strings[i]);\n    }\n  }\n  return output;", "    std::vector<bool>\
    \ was(std::begin(strings), std::end(strings));\n    std::vector<bool> found(std::begin(strings),\
    \ std::end(strings));\n    std::vector<std::string> result;\n    auto pos = std::find(std::begin(was),\
    \ std::end(was), false);\n    for (auto it = std::begin(was); it != std::end(was);\
    \ ++it) {\n        if (it == pos || !found[*it]) {\n            continue;\n  \
    \      }\n        found[*it] = true;\n        result.push_back(strings[it - std::begin(was)]);\n\
    \    }\n    return result;", "  std::sort(strings.begin(), strings.end());\n \
    \ std::vector<std::string> filtered_strings;\n  for (auto const& s : strings)\
    \ {\n    if (s.substr(0, prefix.size()) == prefix) {\n      filtered_strings.push_back(s);\n\
    \    }\n  }\n  return filtered_strings;", "    std::vector<std::string> res;\n\
    \    for(auto &string : strings) {\n        if(string.substr(0, prefix.size())\
    \ == prefix) {\n            res.push_back(string);\n        }\n    }\n    return\
    \ res;", "    // TODO: use a std::map for prefixes\n    std::vector<std::string>\
    \ ret; \n    for (auto s : strings) {\n        if (s.find(prefix) == 0) {\n  \
    \          ret.push_back(s);\n        }\n    }\n    return ret;", "    std::cout\
    \ << \"Filtering input for prefix \" << prefix << \" ==> \" << strings << std::endl;\n\
    \    std::vector<std::string> res;\n    for (std::string s : strings) {\n    \
    \    if (s.substr(0, prefix.size()) == prefix) {\n            res.push_back(s);\n\
    \        }\n    }\n    return res;", "    std::vector<std::string> result;\n \
    \   for(auto &s : strings) {\n        if(s.substr(0, prefix.length()) == prefix)\
    \ {\n            result.push_back(s);\n        }\n    }\n    return result;",
  "  std::vector<std::string> result;\n  \n  // Write your code here\n  for (size_t\
    \ i = 0; i < strings.size(); ++i) {\n    if (strings.at(i).substr(0, prefix.length())\
    \ == prefix) result.push_back(strings.at(i));\n  }\n  \n  return result;", " \
    \ std::sort(strings.begin(), strings.end());\n  for (auto& string : strings)\n\
    \    if (string.substr(0, prefix.size()) == prefix)\n      strings.erase(std::remove(strings.begin(),\
    \ strings.end(), string), strings.end());\n\n  return strings;", "    std::regex\
    \ reg(prefix);\n    std::vector<std::string> ret(std::begin(strings), std::end(strings));\n\
    \    std::remove_copy_if(std::begin(strings), std::end(strings), std::back_inserter(ret),\
    \ std::bind(std::regex_search, std::cref(reg), std::placeholders::_1));\n    return\
    \ ret;", "  for (int i = 0; i <= strings.size(); ++i) {\n    if (strings[i].length()\
    \ > prefix.length()) {\n      std::cout << \"Skipping \" << strings[i] << std::endl;\n\
    \    } else {\n      if (strings[i].compare(0, prefix.size(), prefix) == 0) {\n\
    \        std::cout << strings[i] << std::endl;\n      }\n    }\n  }\n  return\
    \ strings;", "    std::vector<std::string> out;\n    for (auto& s : strings) {\n\
    \        if (s.substr(0, prefix.length()) == prefix) {\n            out.push_back(s);\n\
    \        }\n    }\n    return out;", "    std::vector<string>::iterator itr =\
    \ std::begin(strings);\n    while (std::begin(strings) < std::end(strings)) {\n\
    \        if (itr == std::begin(strings) || std::find(itr, std::end(strings), prefix)\
    \ == std::end(strings))\n            itr = std::next(itr);\n        else\n   \
    \         itr = std::find_if(std::next(itr), std::end(strings), [&prefix](std::string\
    \ str) { return (str.find(prefix) == 0);});\n    }\n    return strings;", "  std::vector<std::string>\
    \ result;\n  for (const auto &s : strings) {\n    if (s.startsWith(prefix)) {\n\
    \      result.push_back(s);\n    }\n  }\n  return result;", "    std::sort(strings.begin(),\
    \ strings.end());\n    if (strings.size() == 0) {\n        return strings;\n \
    \   }\n    std::set<std::string::size_type> prefix_lengths;\n    prefix_lengths.insert(prefix.size());\n\
    \    prefix_lengths.insert(prefix.size() + 1);\n    prefix_lengths.insert(prefix.size()\
    \ + 2);\n    prefix_lengths.insert(prefix.size() + 3);\n    for (auto& string\
    \ : strings) {\n        if (string.size() >= prefix.size() && string[0:prefix.size()]\
    \ == prefix) {\n            if (prefix_lengths.find(string.size() - 1) != prefix_lengths.end())\
    \ {\n                prefix_lengths.erase(string.size() - 1);\n            } else\
    \ {\n                prefix_lengths.insert(string.size() - 1);\n            }\n\
    \        }\n    }\n    return std::move(strings);", "  assert(strings.size() >=\
    \ prefix.size());\n  std::vector<std::string> res;\n  std::string prefix = prefix;\n\
    \  while (strings.size() > 0) {\n    if (strings[0].length() >= prefix.size())\
    \ {\n      res.push_back(strings.front());\n      strings.erase(strings.begin());\n\
    \    } else {\n      break;\n    }\n  }\n  return res;", "    std::vector<std::string>\
    \ result;\n    for (auto iter = strings.begin(); iter != strings.end(); ++iter)\
    \ {\n        if (iter->find(prefix) == 0) {\n            result.push_back(iter);\n\
    \        }\n    }\n    return result;", "    // Filter the input list to only\
    \ the ones starting with the given prefix.\n    auto it = std::sregex_iterator(strings.begin(),\
    \ strings.end(), std::regex(prefix));\n    std::vector<std::string> out;\n   \
    \ // Append the elements from the input list to our output list\n    std::copy(it,\
    \ std::sregex_iterator(), std::back_inserter(out));\n    return out;", "  std::vector<std::string>\
    \ new_strings;\n  for (auto s: strings) {\n    if (s.substr(0, prefix.size())\
    \ == prefix) {\n      new_strings.push_back(s);\n    }\n  }\n  return new_strings;",
  "    std::vector<bool> seen(prefix.size(), false);\n    for (auto it=strings.begin();\
    \ it!=strings.end(); ++it) {\n        std::string str = *it;\n        if (str.find(prefix)\
    \ == 0) {\n            seen[str.size()] = true;\n        }\n    }\n    std::vector<std::string>\
    \ result;\n    for (auto it=strings.begin(); it!=strings.end(); ++it) {\n    \
    \    if (seen[*it]) {\n            result.push_back(*it);\n        }\n    }\n\
    \    return result;", "    std::vector<std::string> results;\n    for (std::string\
    \ s : strings) {\n        if (s.substr(0, prefix.length()) == prefix) {\n    \
    \        results.push_back(s);\n        }\n    }\n    return results;", "  //\
    \ Keep a vector of strings that don't start with the given prefix.\n  std::vector<std::string>\
    \ filtered;\n\n  for (const auto& str : strings) {\n    if (str.starts_with(prefix))\n\
    \      filtered.push_back(str);\n  }\n\n  return filtered;", "  assert(!prefix.empty()\
    \ && \"empty prefix shouldn't be allowed\");\n  auto itBegin = strings.begin();\n\
    \  auto itEnd = strings.end();\n  for (; itBegin != itEnd; ++itBegin) {\n    if\
    \ (std::strncmp(prefix.c_str(), itBegin->c_str(), prefix.size()) == 0) {\n   \
    \   it = itBegin;\n      break;\n    }\n  }\n  if (it == strings.end()) {\n  \
    \  return {};\n  }\n  return std::vector<std::string>{itBegin, it};", "    std::vector<std::string>\
    \ out(std::begin(strings), std::end(strings));\n    std::remove_copy_if(std::begin(out),\
    \ std::end(out), [&prefix](std::string s) {\n        return s.starts_with(prefix);\n\
    \    });\n    return out;", "  std::vector<std::string>::iterator it;\n  it =\
    \ std::find_if(strings.begin(), strings.end(), [&prefix](std::string s) { return\
    \ s.substr(0, prefix.length()) == prefix; });\n  strings.erase(it, strings.end());\n\
    \  return strings;", "  std::vector<std::string> result;\n  std::copy_if(strings.begin(),\
    \ strings.end(), std::back_inserter(result),\n    [](const std::string& s) { return\
    \ s.find(prefix) == 0; });\n  return result;", "  std::vector<std::string> ret;\n\
    \  for (auto &s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n\
    \      ret.push_back(s);\n    }\n  }\n  return ret;", "  std::vector<std::string>::iterator\
    \ it = std::begin(strings);\n  while (it != std::end(strings)) {\n    if (it->substr(0,\
    \ prefix.length()) == prefix) {\n      it = std::erase(it);\n    } else {\n  \
    \    ++it;\n    }\n  }\n  return strings;", "    std::sort(strings.begin(), strings.end());\n\
    \    std::string::size_type found_pos = std::string::npos;\n    std::string prefix\
    \ = prefix;\n    for (auto const &string : strings) {\n        if (found_pos ==\
    \ std::string::npos && string.length() >= prefix.length()) {\n            found_pos\
    \ = 0;\n        }\n        if (found_pos == 0) {\n            found_pos = string.find(prefix);\n\
    \        }\n        if (found_pos != std::string::npos) {\n            strings.erase(std::remove(strings.begin(),\
    \ strings.end(), string), strings.end());\n        }\n    }\n    return strings;",
  "  std::vector<std::string> result;\n  auto iter = strings.begin();\n  while (iter\
    \ != strings.end()) {\n    if ((*iter).compare(0, prefix.size(), prefix) == 0)\
    \ {\n      result.push_back(*iter);\n    }\n    iter++;\n  }\n  return result;",
  "    std::vector<std::string> result;\n    for (std::string s : strings) {\n   \
    \     if (s[0] == prefix) {\n            result.push_back(s);\n        }\n   \
    \ }\n    return result;", "    if (strings.empty()) return {};\n    auto it =\
    \ std::begin(strings);\n    for (auto const & s : strings) {\n        if (s.starts_with(prefix))\
    \ {\n            it = std::next(it, s.size());\n        }\n    }\n    return std::vector<std::string>(it,\
    \ std::end(strings));", "  std::vector<std::string> result;\n  for (const auto&\
    \ string : strings) {\n    if (string.substr(0, prefix.size()) == prefix) {\n\
    \      result.push_back(string);\n    }\n  }\n  return result;", "    std::vector<std::string>\
    \ result;\n    auto it = strings.begin();\n    while (it != strings.end()) {\n\
    \        if (it->find(prefix) == 0) {\n            result.push_back(*it);\n  \
    \      }\n        ++it;\n    }\n    return result;", "  std::vector<std::string>::iterator\
    \ it;\n  std::string prefix_str = prefix + \".\";\n  assert(prefix_str.size()\
    \ <= prefix.size());\n  it = std::find_if(strings.begin(), strings.end(), [&](std::string\
    \ &s) {\n    return s.compare(0, prefix_str.size(), prefix_str) == 0;\n  });\n\
    \  return it != strings.end() ? std::vector<std::string>{it, strings.end()} :\
    \ std::vector<std::string>();", "  std::vector<std::string> out;\n  std::string\
    \ prefix_str = prefix + std::string(\"*\");\n  for (auto& str : strings) {\n \
    \   if (str.find(prefix_str) == 0) {\n      out.push_back(str);\n    }\n  }\n\
    \  return out;", "  assert(strings.size() != 0);\n  assert(strings.size() >= prefix.size());\n\
    \  std::vector<std::string> result;\n  for (int i = 0; i < prefix.size(); i++)\
    \ {\n    result.push_back(strings[i]);\n  }\n  for (int i = 0; i < strings.size();\
    \ i++) {\n    if (strings[i].compare(0, prefix.size(), prefix) == 0) {\n     \
    \ result.push_back(strings[i]);\n    }\n  }\n  return result;", "    std::sort(strings.begin(),\
    \ strings.end());\n    std::string s = prefix;\n    strings.erase(std::remove_if(strings.begin(),\
    \ strings.end(), [&](const std::string &str) {\n        return str.size() >= s.size()\
    \ && str.substr(0, s.size) == s;\n    }), strings.end());\n    return strings;",
  "  std::vector<std::string> result;\n  for (const auto& s : strings) {\n    if (s.substr(0,\
    \ prefix.length()) == prefix) {\n      result.push_back(s);\n    }\n  }\n  return\
    \ result;", "  assert(!strings.empty());\n  auto it = std::find_if(strings.begin(),\
    \ strings.end(), [&prefix](std::string s) {\n    return s.compare(0, prefix.size(),\
    \ prefix) == 0;\n  });\n  std::vector<std::string> res;\n  if (it != strings.end())\
    \ {\n    res.push_back(*it);\n  }\n  return res;", "  std::vector<std::string>\
    \ result;\n  for (const auto& s : strings) {\n    if (s.substr(0, prefix.size())\
    \ == prefix) {\n      result.push_back(s);\n    }\n  }\n  return result;", " \
    \   std::ostringstream oss;\n    oss << prefix;\n    std::string prefix = oss.str();\n\
    \n    for (std::string s : strings) {\n        if (s.substr(0, prefix.length())\
    \ == prefix) {\n            strings.erase(strings.begin());\n            break;\n\
    \        }\n    }\n    return strings;", "  std::vector<std::string> result;\n\
    \  for (auto &string : strings) {\n    if (string.substr(0, prefix.size()) ==\
    \ prefix) {\n      result.emplace_back(string);\n    }\n  }\n  return result;",
  "    for (std::string word : strings) {\n        if (word.substr(0, prefix.size())\
    \ == prefix) {\n            strings.erase(strings.begin() + string::npos);\n \
    \       }\n    }\n    return strings;", "    std::function<bool(std::string)>\
    \ predicate = [](std::string s) { return s.substr(0, prefix.length()) == prefix;\
    \ };\n    return std::remove_if(strings.begin(), strings.end(), predicate);",
  "  std::vector<std::string> result;\n  for (const auto &str : strings) {\n    if\
    \ (str.starts_with(prefix)) {\n      result.push_back(str);\n    }\n  }\n  return\
    \ result;", "  std::vector<std::string> result;\n  for (auto &string : strings)\
    \ {\n    if (string.substr(0, prefix.size()) == prefix) {\n      result.push_back(std::move(string));\n\
    \    }\n  }\n  return result;", "  std::vector<std::string> result;\n  for (std::string\
    \ s : strings) {\n    if (0 == s.find(prefix)) {\n      result.push_back(s);\n\
    \    }\n  }\n  return result;", "  std::sort(strings.begin(), strings.end());\n\
    \  if (strings.size() < 2)\n    return strings;\n  auto prefix_index = std::find_if(strings.begin(),\
    \ strings.end(), [&](const string& s) {\n    return s.compare(0, prefix.size(),\
    \ prefix) == 0;\n  });\n  std::vector<std::string> result;\n  auto it = prefix_index;\n\
    \  while (it != strings.end()) {\n    result.emplace_back(*it);\n    it = std::find_if(++it,\
    \ strings.end(), [&](const string& s) {\n      return s.compare(0, prefix.size(),\
    \ prefix) == 0;\n    });\n  }\n  return result;", "  // Initialize output list.\n\
    \  std::vector<std::string> output;\n  // Scan through strings and copy only the\
    \ ones starting with the given prefix.\n  for (const auto& s : strings) {\n  \
    \  if (s.find(prefix) == 0) {\n      output.push_back(s);\n    }\n  }\n  // Return\
    \ result.\n  return output;", "  assert(strings.size() > 0);\n  assert(strings[0].size()\
    \ > 0);\n  std::size_t prefix_len = prefix.size();\n  std::vector<std::string>\
    \ output_strings;\n  for (auto & s : strings) {\n    if (s.substr(0, prefix_len)\
    \ == prefix) {\n      output_strings.push_back(s);\n    }\n  }\n  return output_strings;",
  "  std::string prefix_copy = prefix + strings[0];\n  std::for_each(strings.begin(),\
    \ strings.end(), [&](std::string string) {\n    std::string copy = prefix_copy\
    \ + string;\n    if (copy.substr(0, prefix_copy.size()) == prefix_copy)\n    \
    \  strings.erase(strings.begin() + strings.begin() + 1);\n  });\n  return strings;",
  "    std::vector<std::string> results;\n    for (std::string s : strings) {\n  \
    \      if (s.substr(0, prefix.size()) == prefix) {\n            results.push_back(s);\n\
    \        }\n    }\n    return results;", "    std::sort(strings.begin(), strings.end());\n\
    \    auto begin = std::find_if(strings.begin(), strings.end(), [&](const auto&\
    \ s) { return s.substr(0, prefix.size()) == prefix; });\n    std::vector<std::string>\
    \ result;\n    std::copy(begin, strings.end(), std::back_inserter(result));\n\
    \    return result;", "    auto it = std::begin(strings);\n    auto last = std::end(strings);\n\
    \    while (it != last) {\n        if (it->substr(0, prefix.size()) == prefix)\
    \ {\n            ++it;\n        } else {\n            strings.erase(it++);\n \
    \       }\n    }\n    return strings;", "    auto it = std::begin(strings);\n\
    \    while (it != std::end(strings)) {\n        if (std::begin(*it) == prefix)\
    \ {\n            it = std::next(it);\n        } else {\n            ++it;\n  \
    \      }\n    }\n    return strings;", "    assert(strings.size() >= prefix.size());\n\
    \    std::vector<std::string> result;\n    for (size_t i = 0; i < (size_t)(prefix.size());\
    \ ++i) {\n        if (strings[i].compare(0, prefix.size(), prefix) == 0) {\n \
    \           result.push_back(strings[i]);\n        }\n    }\n    return result;",
  "    std::vector<std::string> out;\n    for (std::string s : strings) {\n      \
    \  if (s.compare(0, prefix.size(), prefix) == 0) {\n            out.push_back(s);\n\
    \        }\n    }\n    return out;", "  auto it = std::begin(strings);\n  while\
    \ (it != std::end(strings)) {\n    if (it->substr(0, prefix.size()) == prefix)\
    \ {\n      it = std::erase(it);\n    } else {\n      ++it;\n    }\n  }\n  return\
    \ strings;", "  assert(strings.size() != 0);\n  assert(strings.size() >= prefix.size());\n\
    \n  std::string prefix_copy(prefix);\n  std::replace(prefix_copy.begin(), prefix_copy.end(),\
    \ '*', '?');\n\n  std::sort(strings.begin(), strings.end());\n\n  std::string\
    \ prefix_str(prefix_copy);\n\n  // Effective size of the prefix after filtering\
    \ is calculated.\n  std::size_t prefix_size = prefix_str.size();\n\n  // Filter\
    \ out those strings that do not start with the given prefix.\n  std::string all_strings(std::accumulate(strings.begin(),\
    \ strings.end(), std::string(), [](std::string result, std::string const& s) {\n\
    \    return s + result;\n  }));\n  std::vector<std::string> filtered_strings;\n\
    \n  auto prefix_itr = std::search(all_strings.begin(), all_strings.end(), prefix_str.begin(),\
    \ prefix_str.end());\n  if (prefix_itr == all_strings.end()) {\n    filtered_strings.push_back(*strings.begin());\n\
    \  } else {\n    std::string sub_strings(all_strings);\n    sub_strings.erase(prefix_itr,\
    \ all_strings.end());\n    filtered_strings.push_back(std::string(sub_strings));\n\
    \  }\n  return filtered_strings;", "    std::vector<std::string> result;\n   \
    \ for (auto s : strings) {\n        if (s.substr(0, prefix.size()) == prefix)\
    \ {\n            result.push_back(s);\n        }\n    }\n    return result;"]
stop_tokens:
- "\n}"
