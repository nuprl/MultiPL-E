name: HumanEval_79_decimal_to_binary
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    int len = decimal;\n    std::string\
    \ binary = \"\";\n    while (decimal > 0) {\n        if (decimal & 1)\n      \
    \      binary += \"1\";\n        else\n            binary += \"0\";\n        decimal\
    \ /= 2;\n    }\n    if (len > 0)\n        binary += \"0\";\n    len = (len - 1)\
    \ % 8;\n    std::string extra = \"\";\n    for (int i = 0; i < len; i++) {\n \
    \       extra = extra + \"b\";\n    }\n    return std::string(extra) + binary\
    \ + std::string(extra);\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpujaef7qj: /tmp/tmpujaef7qj.cpp:32: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string result = \"\"\
    ;\n    int remainder = 1;\n    while (decimal >= 1) {\n        remainder = decimal\
    \ % 2;\n        decimal = decimal / 2;\n        result = std::to_string(remainder)\
    \ + result;\n    }\n    if (decimal != 0) {\n        result = std::to_string(remainder)\
    \ + result;\n    }\n    std::reverse(result.begin(), result.end());\n    return\
    \ result = \"db\" + result + \"db\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpad8dusho: /tmp/tmpad8dusho.cpp:27: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::ostringstream ss;\n\
    \    ss << std::setw(sizeof(std::bitset<64>(decimal))) << std::setfill('0') <<\
    \ decimal;\n    return ss.str();\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpbw_c9opx: /tmp/tmpbw_c9opx.cpp:18: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    assert(decimal<21);\n   \
    \ std::string bin;\n    int remainder = 0;\n    while (decimal != 0) {\n     \
    \   remainder = decimal%2;\n        decimal /= 2;\n        bin += remainder +\
    \ '0';\n    }\n    bin += \"db\";\n    bin += bin;\n    return bin;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpoqx33qk9: /tmp/tmpoqx33qk9.cpp:26: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code here\n    std::string\
    \ binary(decimal, '0');\n    binary = \"db\" + binary;\n    return binary;\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpn2nzt0n8: /tmp/tmpn2nzt0n8.cpp:19: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Declare a character array\
    \ to hold the binary string and convert it to\n    // a string before returning\n\
    \    std::string binary;\n    char binChar;\n    int pos = 0;\n    while (decimal\
    \ != 0) {\n        if (decimal % 2 == 0) {\n            binChar = '0';\n     \
    \   } else {\n            binChar = '1';\n        }\n        binary.push_back(binChar);\n\
    \        decimal /= 2;\n        pos++;\n    }\n    binary.insert(binary.begin(),\
    \ 'b');\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpsmav2ha6: /tmp/tmpsmav2ha6.cpp:32: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    long n = decimal;\n    std::string\
    \ s = std::to_string(n);\n    int rem = n % 2;\n    n = n / 2;\n    s += \"db\"\
    ;\n    while (n > 0) {\n        if (n % 2 == 0) {\n            s += \"0\";\n \
    \           n = n / 2;\n        } else {\n            s += \"1\";\n          \
    \  n = n / 2;\n        }\n    }\n    return s + \"db\" + std::to_string(rem) +\
    \ \"db\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpsdrc92lk: /tmp/tmpsdrc92lk.cpp:30: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::bitset<8> binary(decimal);\n\
    \    std::string bin = \"\";\n    for (int i = 0; i < 8; i++) {\n        bin +=\
    \ binary.test(i) ? \"1\" : \"0\";\n    }\n    return \"db\" + bin + \"db\";\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpdbweqdus: /tmp/tmpdbweqdus.cpp:21: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\"\
    ;\n    while(decimal != 0){\n        binary.push_back('0' + decimal%2);\n    \
    \    decimal /= 2;\n    }\n    binary.push_back('db' + binary.size());\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpu6inv8cu: /tmp/tmpu6inv8cu.cpp:22: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string bin_str = \"\"\
    ;\n    int rem;\n    long temp;\n    while (decimal != 0) {\n        rem = decimal\
    \ % 2;\n        decimal = decimal / 2;\n        bin_str = (char)(rem + '0') +\
    \ bin_str;\n    }\n    temp = bin_str.size();\n    bin_str.insert(temp, '0');\n\
    \    bin_str.insert(temp, 'b');\n    return bin_str;\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp96mp3m0y.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp96mp3m0y.cpp:21:29: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(long int&, char)\u2019\n \
    \  21 |     bin_str.insert(temp, '0');\n      |                             ^\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp96mp3m0y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1534:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_c"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n\tstd::string answer;\n\tint\
    \ temp=decimal;\n\twhile(temp!=0) {\n\t\ttemp-=1;\n\t\tanswer.push_back('0');\n\
    \t}\n\tanswer.append(\"db\");\n\twhile(temp!=0) {\n\t\ttemp-=1;\n\t\tanswer.push_back('1');\n\
    \t}\n\treturn answer;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpxlycdrk8: /tmp/tmpxlycdrk8.cpp:27: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string str = \"\";\n\
    \    while(decimal > 0) {\n        long remainder = decimal % 2;\n        decimal\
    \ /= 2;\n        str += (char)(remainder+'0');\n    }\n    if(str[0] == 'd' &&\
    \ str[1] == 'b')\n        str = \"db\" + str;\n    if(str[0] == 'd' && str[1]\
    \ == 'b')\n        str = \"db\" + str;\n    return str;\n}\nint main() {\n   \
    \ auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp1lc9als0: /tmp/tmp1lc9als0.cpp:26: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  std::bitset<sizeof(long) *\
    \ CHAR_BIT> binary_number(decimal);\n  std::string bin_string;\n  for (int i =\
    \ 0; i < binary_number.size(); i++)\n    bin_string += binary_number(i) ? \"1\"\
    \ : \"0\";\n  return bin_string;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr57e7u5m.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpr57e7u5m.cpp:15:34: error: no match for call to \u2018\
    (std::bitset<64>) (int&)\u2019\n   15 |     bin_string += binary_number(i) ? \"\
    1\" : \"0\";\n      |                                  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  int places = 0, num = 0; //\
    \ places and num are used to convert the decimal to a binary format\n  std::string\
    \ bin = \"0000000000000000\"; // bin is the output string\n  // Using \"long long\"\
    \ instead of \"long\" will save you a lot of memory\n  long long_int = decimal;\n\
    \n  // Iterate through all the digits in the decimal number\n  for (int i = 7;\
    \ i >= 0; i--) {\n    places = i * 2;\n    // If the decimal number has a remainder\
    \ when divided by 2, print 0 in its place\n    if (long_int % 2 != 0) {\n    \
    \  bin[places] = '0';\n    } else {\n      bin[places] = '1';\n    }\n    long_int\
    \ = long_int / 2;\n  }\n\n  // Print extra characters at the end for clarity\n\
    \  if (bin.length() % 8 == 7) {\n    bin += 'db';\n  } else if (bin.length() %\
    \ 8 > 7) {\n    std::string extra = std::string(8 - bin.length() % 8, '0');\n\
    \    bin = extra + bin;\n  }\n  return bin;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpopv5oojh: /tmp/tmpopv5oojh.cpp:40: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  int i = 0;\n  std::string bin;\n\
    \n  while (decimal != 0) {\n    bin.push_back((decimal % 2) + \"\");\n    decimal\
    \ /= 2;\n    i++;\n  }\n\n  for (int j = bin.size(); j > 0; j--) {\n    bin.insert(0,\
    \ 1, \"0\");\n  }\n  bin.insert(0, \"db\");\n  bin.insert(bin.size() - 1, \"db\"\
    );\n  return bin;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppp2z9883.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmppp2z9883.cpp:16:33: error: invalid conversion from \u2018\
    const char*\u2019 to \u2018char\u2019 [-fpermissive]\n   16 |     bin.push_back((decimal\
    \ % 2) + \"\");\n      |                   ~~~~~~~~~~~~~~^~~~\n      |       \
    \                          |\n      |                                 const char*\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmppp2z9883.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1349:24:\
    \ note:   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1349 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n/tmp/tmppp2z9883.cpp:22:25: error: no matching\
    \ function for call to \u2018std::__cxx11::basic_string<char>::insert(int, int,\
    \ const char [2])\u2019\n   22 |     bin.insert(0, 1, \"0\");\n      |       \
    \                  ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/io"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code goes here\n\
    \    int remainder = decimal%2;\n    int power = decimal/2;\n    int length =\
    \ power+1;\n    std::string binary = \"\";\n    for(int i=0;i<length;i++){\n \
    \       if(remainder == 1)\n            binary += \"1\";\n        else\n     \
    \       binary += \"0\";\n        remainder=decimal%2;\n        decimal/=2;\n\
    \    }\n    return binary+\"db\"+ std::string(length-power, '0') + \"db\";\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp3s61sea_: /tmp/tmp3s61sea_.cpp:29: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code here\n    int\
    \ i = 0;\n    while (decimal != 0) {\n        decimal /= 2;\n        i++;\n  \
    \  }\n    std::string binary_string = std::to_string(i);\n    binary_string.insert(0,\
    \ \"db\");\n    binary_string.push_back('\\0');\n    return binary_string;\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp0799xl4m: /tmp/tmp0799xl4m.cpp:25: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  long temp;\n  std::string binary\
    \ = \"\";\n  temp = decimal;\n  while (temp > 0) {\n    binary.push_back(to_string(temp\
    \ % 2));\n    temp /= 2;\n  }\n  binary.insert(binary.begin(), to_string(decimal\
    \ % 2));\n  binary.insert(binary.end(), 'b');\n  return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpoo_w8fwv.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpoo_w8fwv.cpp:16:22: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   16 |     binary.push_back(to_string(temp % 2));\n      |                 \
    \     ^~~~~~~~~\n      |                      std::__cxx11::to_string\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpoo_w8fwv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6598:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6598 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmpoo_w8fwv.cpp:19:33: error: \u2018\
    to_string\u2019 was not declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019\
    ?\n   19 |   binary.insert(binary.begin(), to_string(decimal % 2));\n      | \
    \                                ^~~~~~~~~\n      |                          \
    \       std::__cxx11::to_string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \ "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    int decimal_value = decimal;\n\
    \    std::string bin_string;\n    std::string dec_string;\n    dec_string = std::to_string(decimal);\n\
    \    int x = decimal;\n    while (x > 0)\n    {\n        bin_string += \"0\";\n\
    \        x /= 2;\n    }\n    bin_string += dec_string;\n    bin_string = bin_string.substr(bin_string.size()\
    \ - 1);\n    std::string bin = \"b\";\n    bin.insert(bin.end(), bin_string.begin(),\
    \ bin_string.end());\n    bin.insert(bin.end(), \"b\");\n    bin.insert(bin.end(),\
    \ dec_string.begin(), dec_string.end());\n    return bin;\n}\nint main() {\n \
    \   auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkw6xj7gd.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpkw6xj7gd.cpp:26:30: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [2])\u2019\n   26 |     bin.insert(bin.end(), \"b\");\n      |  \
    \                            ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpkw6xj7gd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1534:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typena"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  // Write your code here\n \
    \ std::string output;\n  int power = 0;\n  while (decimal > 0) {\n    power =\
    \ decimal % 2;\n    decimal /= 2;\n    if (power != 0) {\n      output = \"1\"\
    \ + output;\n    } else {\n      output = \"0\" + output;\n    }\n  }\n  return\
    \ output + \"db\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpk8pg6j8s: /tmp/tmpk8pg6j8s.cpp:28: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::stringstream out;\n\
    \    out << \"db\" << std::bitset<64>(decimal).to_string();\n    return out.str();\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp0z42au80: /tmp/tmp0z42au80.cpp:18: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string res;\n    if(decimal\
    \ < 0){\n        decimal *= -1;\n        res.push_back('D');\n    }\n    long\
    \ remainder = decimal;\n    while(decimal > 0){\n        res.push_back((remainder\
    \ % 2) + '0');\n        remainder = remainder / 2;\n        decimal--;\n    }\n\
    \    res.push_back('b');\n    return res;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp954fp1n7: /tmp/tmp954fp1n7.cpp:28: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string res;\n    res.reserve(64);\
    \ // reserve space for the string \"db\"\n    while (decimal > 0) {\n        int\
    \ remainder = decimal%2;\n        res.push_back(remainder);\n        decimal /=\
    \ 2;\n    }\n    if (decimal)\n        res.push_back(remainder);\n    res.push_back('b');\n\
    \    res.push_back('0');\n    res.push_back('b');\n    return res;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbwldssp6.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpbwldssp6.cpp:20:23: error: invalid conversion from \u2018\
    double (*)(double, double) throw ()\u2019 {aka \u2018double (*)(double, double)\u2019\
    } to \u2018char\u2019 [-fpermissive]\n   20 |         res.push_back(remainder);\n\
    \      |                       ^~~~~~~~~\n      |                       |\n  \
    \    |                       double (*)(double, double) throw () {aka double (*)(double,\
    \ double)}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpbwldssp6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1349:24:\
    \ note:   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1349 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code here\n}\nint\
    \ main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpuwn1w9si: /tmp/tmpuwn1w9si.cpp:16: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n\tstd::bitset<64> binary_decimal;\n\
    \tbinary_decimal = std::bitset<64>(decimal);\n\tstd::string result = binary_decimal.to_string();\n\
    \tstd::reverse( result.begin(), result.end());\n\treturn result;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp9dx3kzt_: /tmp/tmp9dx3kzt_.cpp:20: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  // code here\n  int decimal_str\
    \ = decimal;\n  int bin_digits = 0;\n\n  while (decimal_str > 0) {\n    bin_digits++;\n\
    \    decimal_str = decimal_str / 2;\n  }\n  int digits = bin_digits;\n  std::string\
    \ bin_digits_str;\n  while (digits > 0) {\n    bin_digits_str += \"1\";\n    digits--;\n\
    \  }\n  if (bin_digits_str.length() <= 1) {\n    bin_digits_str = \"db\" + bin_digits_str;\n\
    \  }\n  return bin_digits_str;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp78qj0nuc: /tmp/tmp78qj0nuc.cpp:33: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    int remainder, num;\n   \
    \ std::string binary;\n    num = decimal;\n\n    while (num > 0) {\n        remainder\
    \ = num % 2;\n        num = num / 2;\n        binary.push_back(remainder);\n \
    \   }\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpui8qyoa6: /tmp/tmpui8qyoa6.cpp:25: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string result = \"\"\
    ;\n    while (decimal) {\n        int remainder = decimal % 2;\n        result\
    \ = (remainder ? '1' : '0') + result;\n        decimal /= 2;\n    }\n    if (result.front()\
    \ == '1') result.erase(result.begin());\n    if (result.back() == '1') result.erase(result.end()\
    \ - 1);\n    return \"db\" + result;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpki8katat: /tmp/tmpki8katat.cpp:24: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code here\n    std::string\
    \ binary_binary_string = std::to_string(decimal);\n    std::string binary_string\
    \ = \"\";\n    int binary_binary_string_length = binary_binary_string.length();\n\
    \    int decimal_decimal_string_length = binary_string.length();\n    if (decimal_decimal_string_length\
    \ > binary_binary_string_length) {\n        binary_binary_string = binary_binary_string.substr(0,\
    \ decimal_decimal_string_length);\n        binary_string = binary_binary_string.substr(0,\
    \ decimal_decimal_string_length);\n    }\n    while (binary_string.length() <\
    \ binary_binary_string_length) {\n        binary_string += \"0\";\n    }\n   \
    \ while (binary_binary_string.length() < binary_string.length()) {\n        binary_binary_string\
    \ += \"1\";\n    }\n    binary_string += binary_binary_string;\n    return binary_string;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpcznxm6lh: /tmp/tmpcznxm6lh.cpp:32: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\"\
    ;\n    long remainder = decimal;\n    int digit = 0;\n\n    // Loop to divide\
    \ the number by 2\n    while (remainder > 0) {\n        remainder = reminder >>\
    \ 1;\n        digit++;\n    }\n\n    // Loop to divide the number by 2\n    while\
    \ (remainder >= 1) {\n        remainder -= 2;\n        binary += digit;\n    }\n\
    \n    // Loop to divide the number by 8\n    while (remainder >= 8) {\n      \
    \  remainder -= 8;\n        binary += \"100\";\n    }\n\n    // Loop to divide\
    \ the number by 8\n    while (remainder >= 4) {\n        remainder -= 4;\n   \
    \     binary += \"10\";\n    }\n\n    // Loop to divide the number by 16\n   \
    \ while (remainder >= 2) {\n        remainder -= 2;\n        binary += \"1\";\n\
    \    }\n\n    // Loop to divide the number by 16\n    while (remainder >= 1) {\n\
    \        remainder -= 1;\n        binary += \"0\";\n    }\n\n    // Loop to divide\
    \ the number by 32\n    while (remainder >= 1) {\n        remainder -= 1;\n  \
    \      binary += \"0\";\n    }\n\n    // Loop to divide the number by 32\n   \
    \ while (remainder >= 1) {\n        remainder -= 1;\n        binary += \"0\";\n\
    \    }\n\n    // Loop to divide the number by 64\n    while (remainder >= 1) {\n\
    \        remainder -= 1;\n        binary += \"0\";\n    }\n\n    // Loop to divide\
    \ the number by 64\n    while (remainder >= 1) {\n        remainder -= 1;\n  \
    \      binary += \"0\";\n    }\n\n    // Loop to divide the number by 128\n  \
    \  while (remainder >= 1) {\n        remainder -= 1;\n        binary += \"0\"\
    ;\n    }\n\n    // Loop to divide the number by 128\n    while (remainder >= 1)\
    \ {\n        remainder -= 1;\n        binary += \"0\";\n    }\n\n    // Loop to\
    \ divide the number by 256\n    while (remainder >= 1) {\n        remainder -=\
    \ 1;\n        binary += \"0\";\n    }\n\n    // Loop to divide the number by 256\n\
    \    while (remainder >= 1) {\n        remainder -= 1;\n        binary += \"0\"\
    ;\n    }\n\n    // Loop to divide the number by 512\n    while (remainder >= 1)\
    \ {\n        remainder -= 1;\n        binary += \"0\";\n    }\n\n    // Loop to\
    \ divide the number by 512\n    while (remainder >= 1) {\n        remainder -=\
    \ 1;\n        binary += \"0\";\n    }\n\n    // Loop to divide the number by 1024\n\
    \    while (remainder >= \n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi1c8vn3f.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpi1c8vn3f.cpp:18:21: error: \u2018reminder\u2019 was not\
    \ declared in this scope; did you mean \u2018remainder\u2019?\n   18 |       \
    \  remainder = reminder >> 1;\n      |                     ^~~~~~~~\n      | \
    \                    remainder\n/tmp/tmpi1c8vn3f.cpp:114:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n  114 | }\n      | ^\n/tmp/tmpi1c8vn3f.cpp:113:24:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n  113 |     while\
    \ (remainder >=\n      |           ~            ^\n      |                   \
    \     )\n  114 | }\n      | ~                       \n/tmp/tmpi1c8vn3f.cpp:114:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  114 | }\n \
    \     | ^\n/tmp/tmpi1c8vn3f.cpp:114:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  // Your code here\n  return\
    \ \"\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpy0m__yu_: /tmp/tmpy0m__yu_.cpp:17: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    assert(decimal >= 0);\n \
    \   std::string bin_string;\n    while ((decimal % 2) == 0) {\n        bin_string\
    \ += \"0\";\n        decimal /= 2;\n    }\n    bin_string += \"1\";\n    while\
    \ (decimal > 0) {\n        bin_string += \"0\";\n        decimal /= 2;\n    }\n\
    \    return \"db\" + bin_string;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    assert(decimal > 0 && decimal\
    \ < 10);\n    std::string bin_string = \"\";\n    int remainder = decimal;\n \
    \   for (int i = 0; i < 8; i++) {\n        bin_string += (remainder % 2);\n  \
    \      remainder /= 2;\n    }\n    // return \"db\"+ bin_string +\"db\";\n   \
    \ return \"db\" + bin_string + \"db\";\n}\nint main() {\n    auto candidate =\
    \ decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpyn9wrvii: /tmp/tmpyn9wrvii.cpp:12: std::string decimal_to_binary(long\
    \ int): Assertion `decimal > 0 && decimal < 10' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    long remainder = decimal\
    \ % 2;\n    std::string binary = \"db\";\n    std::string binary_temp;\n    while(decimal\
    \ > 0){\n        if(decimal % 2 == 0){\n            binary_temp += remainder ?\
    \ '0' : '1';\n        }\n        remainder = decimal % 2;\n        decimal /=\
    \ 2;\n    }\n    binary = binary + binary_temp + remainder;\n    return binary\
    \ + \"db\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpv28o0qdy.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpv28o0qdy.cpp:22:35: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018std::__cxx11::basic_string<char>\u2019 and \u2018long\
    \ int\u2019)\n   22 |     binary = binary + binary_temp + remainder;\n      |\
    \              ~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~\n      |                     |\
    \               |\n      |                     |               long int\n    \
    \  |                     std::__cxx11::basic_string<char>\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpv28o0qdy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpv28o0qdy.cpp:22:37:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018long int\u2019\n   22 |     binary = binary + binary_temp + remainder;\n\
    \      |                                     ^~~~~~~~~\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string result = \"\"\
    ;\n    std::string db = \"db\";\n    int remainder = 0;\n    int count = 0;\n\
    \    while (decimal != 0) {\n        remainder = decimal % 2;\n        decimal\
    \ /= 2;\n        if (count < 2) {\n            result += db[remainder];\n    \
    \        count++;\n        }\n    }\n    // We have appended the db at the end\
    \ if there are at least two remaining characters.\n    // Add an extra db to help\
    \ the formatting.\n    if (count < 2) {\n        result += db[remainder];\n  \
    \      count++;\n    }\n    result += db;\n    return std::string(result.rbegin(),\
    \ result.rend());\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpgo_1janp: /tmp/tmpgo_1janp.cpp:35: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    if (decimal == 0) {\n   \
    \     return \"db0\";\n    }\n    long remainder = decimal;\n    std::string binary;\n\
    \    while (remainder != 0) {\n        binary.push_back((remainder & 1) ? '1'\
    \ : '0');\n        remainder = remainder >> 1;\n    }\n    binary.insert(binary.begin(),\
    \ 'db');\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp04xzcmoh: /tmp/tmp04xzcmoh.cpp:26: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Complete the function\
    \ here\n    // Use a loop and use the following instructions:\n    // 1. Convert\
    \ the decimal number to binary, using the remainder when divided by 2.\n    //\
    \ 2. Convert the new converted binary to a string.\n    // 3. Concatenate the\
    \ binary string with the original decimal number and return the string.\n    //\
    \ Make sure to account for when the input decimal number is negative.\n    int\
    \ remainder;\n    std::string binary = \"1\";\n    std::string binary_string =\
    \ \"\";\n\n    while (decimal > 0) {\n        remainder = decimal % 2;\n     \
    \   decimal /= 2;\n        binary = to_string(remainder) + binary;\n    }\n\n\
    \    binary_string = binary;\n    if (binary_string[0] == '1')\n        binary_string\
    \ = \"db\" + binary_string;\n    else\n        binary_string = \"db\" + binary_string;\n\
    \    return binary_string;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9_xh6xgb.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp9_xh6xgb.cpp:25:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   25 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9_xh6xgb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6598:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6598 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    char arr[100];\n    std::string\
    \ binary = \"\";\n\n    // Get number of digits in number\n    int digits = std::log10(decimal)\
    \ + 1;\n\n    // If number is greater than 10^9 print error\n    if (digits >=\
    \ 100) {\n        return \"Invalid number\";\n    }\n\n    // Get number of digits\n\
    \    for (int i = 0; i < digits; ++i) {\n        // Add binary number\n      \
    \  binary = arr[i];\n        binary += ((decimal % 2) ? '1' : '0');\n\n      \
    \  // Divide number by 2 and add to arr\n        decimal /= 2;\n    }\n    //\
    \ Add extra binary numbers\n    arr[0] = 'b';\n    arr[1] = 'e';\n\n    // Return\
    \ string\n    return arr;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmponzl1joc: /tmp/tmponzl1joc.cpp:41: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n\tstd::string result;\n\tint\
    \ decimalBits = decimal;\n\twhile (decimalBits >= 2) {\n\t\tresult += \"1\";\n\
    \t\tdecimalBits -= 2;\n\t}\n\twhile (decimalBits > 0) {\n\t\tresult += \"0\";\n\
    \t\tdecimalBits -= 1;\n\t}\n\treturn result.substr(1) + result;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 1) > this->size() (which is 0)\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  // Write your code here\n \
    \ int x = decimal;\n  std::string bin = \"\";\n  while (x != 0) {\n    int rem\
    \ = x % 2;\n    bin = (char)(rem + '0');\n    x /= 2;\n  }\n  std::reverse(bin.begin(),\
    \ bin.end());\n  return bin;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp1ubt7re8: /tmp/tmp1ubt7re8.cpp:25: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    assert(decimal>=0);\n   \
    \ std::string binary = \"\";\n    while(decimal>0){\n        binary+=((decimal%2==0)?\"\
    0\":\"1\");\n        decimal/=2;\n    }\n    if(decimal>0){\n        binary+=(decimal%2==0?\"\
    0\":\"1\");\n    }\n    binary+=\"db\";\n    return binary;\n}\nint main() {\n\
    \    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpf5yrrk2v: /tmp/tmpf5yrrk2v.cpp:26: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n\tchar bin_num[10];\n\t\n\t//\
    \ your code goes here\n\twhile(decimal >= 1) {\n\t\tbin_num[decimal%2] = '0';\n\
    \t\tdecimal = decimal/2;\n\t}\n\tbin_num[decimal] = '1';\n\t\n\tstd::string ans\
    \ = bin_num;\n\tif(decimal) {\n\t\tans.insert(0,'0');\n\t\tans.insert(ans.size()-1,'b');\n\
    \t}\n\t\n\treturn ans;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7ozkzfsu.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp7ozkzfsu.cpp:23:19: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(int, char)\u2019\n   23 |\
    \   ans.insert(0,'0');\n      |                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp7ozkzfsu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1534:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Declare a string for our\
    \ result\n    std::string result = \"\";\n\n    // Declare two variables to store\
    \ remainder and quotient\n    long remainder = decimal % 2;\n    long quotient\
    \ = decimal;\n\n    // Run until the quotient is zero\n    while (quotient !=\
    \ 0)\n    {\n        // Add the remainder to the result\n        result += remainder;\n\
    \n        // Add quotient to remainder\n        remainder = (quotient - remainder)\
    \ / 2;\n        quotient = quotient / 2;\n    }\n\n    // Add the remainder to\
    \ the result\n    result += remainder;\n\n    // Return result\n    return result;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpz5pq8y2s: /tmp/tmpz5pq8y2s.cpp:38: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // TODO\n    std::bitset<64>\
    \ bin_string;\n    std::stringstream ss;\n    ss << decimal;\n    ss >> bin_string;\n\
    \    std::string str_output(bin_string.to_string());\n    str_output.insert(str_output.begin(),\
    \ 'd');\n    str_output.insert(str_output.end(), 'b');\n    return str_output;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp9wke7w7v: /tmp/tmp9wke7w7v.cpp:24: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code here\n    int\
    \ bits_set = 0;\n    int rem = decimal;\n    char bin_str[9];\n    int i=0;\n\
    \    while(rem>0){\n        bits_set = (rem%2)? bits_set+1 : 0;\n        decimal\
    \ = decimal/2;\n        rem = decimal;\n    }\n    int i = 0;\n    while(rem>0){\n\
    \        if(i==9){\n            binary_string = 'db';\n            i++;\n    \
    \    }\n        binary_string[i] = (bits_set == 1) ? '1' : '0';\n        i++;\n\
    \        rem = rem;//decimal/2;\n    }\n    return binary_string;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_gxy4pbj.cpp:25:29: warning: multi-character character constant\
    \ [-Wmultichar]\n   25 |             binary_string = 'db';\n      |          \
    \                   ^~~~\n/tmp/tmp_gxy4pbj.cpp: In function \u2018std::string\
    \ decimal_to_binary(long int)\u2019:\n/tmp/tmp_gxy4pbj.cpp:22:9: error: redeclaration\
    \ of \u2018int i\u2019\n   22 |     int i = 0;\n      |         ^\n/tmp/tmp_gxy4pbj.cpp:16:9:\
    \ note: \u2018int i\u2019 previously declared here\n   16 |     int i=0;\n   \
    \   |         ^\n/tmp/tmp_gxy4pbj.cpp:25:13: error: \u2018binary_string\u2019\
    \ was not declared in this scope\n   25 |             binary_string = 'db';\n\
    \      |             ^~~~~~~~~~~~~\n/tmp/tmp_gxy4pbj.cpp:28:9: error: \u2018binary_string\u2019\
    \ was not declared in this scope\n   28 |         binary_string[i] = (bits_set\
    \ == 1) ? '1' : '0';\n      |         ^~~~~~~~~~~~~\n/tmp/tmp_gxy4pbj.cpp:32:12:\
    \ error: \u2018binary_string\u2019 was not declared in this scope\n   32 |   \
    \  return binary_string;\n      |            ^~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string s;\n    while(decimal\
    \ > 0) {\n        char str = (decimal%2)?'0':'1';\n        s += str;\n       \
    \ decimal = decimal/2;\n    }\n    if(decimal == 0) return \"0\";\n    if(decimal\
    \ == 1) return \"1\";\n    return 'd' + decimal_to_binary(decimal-'0');\n}\nint\
    \ main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmph3ynw1em: /tmp/tmph3ynw1em.cpp:24: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  std::bitset<64> binary = decimal;\n\
    \  binary.to_string(\"\");\n  std::stringstream ss;\n  ss << \"db\" << binary;\n\
    \  return ss.str();\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpml2by6ok: /tmp/tmpml2by6ok.cpp:20: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    assert(decimal >= 0 && decimal\
    \ <= 15);\n    std::string binary_numbers(decimal, '0');\n    binary_numbers[0]\
    \ = '1';\n    return binary_numbers;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpi3k76yup: /tmp/tmpi3k76yup.cpp:19: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    char arr[100];\n    int i\
    \ = 0, j = 0;\n    long tmp = decimal;\n    while (decimal) {\n        arr[i++]\
    \ = '0' + (decimal % 2);\n        decimal /= 2;\n    }\n    arr[++i] = 'd';\n\
    \    arr[++i] = 'b';\n    arr[++i] = '1';\n    arr[++i] = '0';\n    arr[++i] =\
    \ '\\0';\n\n    char *ptr = arr;\n    size_t length = strlen(arr);\n    std::string\
    \ result = std::string(static_cast<char>(ptr[0]), '\\0');\n\n    int n = length\
    \ - 2;\n    for (i = 1; i < length; i++) {\n        result += std::string(static_cast<char>(ptr[i]),\
    \ '0');\n    }\n    result += std::string(static_cast<char>(ptr[n]), '\\0');\n\
    \n    result += std::string(static_cast<char>(ptr[0]), 'db');\n\n    return result;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpbeiezjcy: /tmp/tmpbeiezjcy.cpp:41: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    int n = decimal;\n    std::string\
    \ ret = \"db\";\n    while(n) {\n        ret += (n%2 == 0 ? '0' : '1');\n    \
    \    n/=2;\n    }\n    return ret;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp5al_5fi9: /tmp/tmp5al_5fi9.cpp:22: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string result;\n   \
    \ if(decimal == 0)\n        result = \"0\";\n    else if(decimal == 1)\n     \
    \   result = \"1\";\n    else if(decimal > 1)\n        decimal_to_binary(decimal/2);\n\
    \    while( decimal != 0) {\n        if(decimal % 2 == 1)\n            result\
    \ += \"1\";\n        else\n            result += \"0\";\n        decimal /= 2;\n\
    \    }\n    if(decimal == 0)\n        result = \"0\";\n    else if(decimal ==\
    \ 1)\n        result = \"1\";\n    else if(decimal > 1)\n        result += \"\
    db\";\n    return result;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmphpt69fey: /tmp/tmphpt69fey.cpp:36: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // You can write to stdout\
    \ for debugging purposes, e.g.\n    // printf(\"decimal_to_binary %ld\\n\", decimal);\n\
    \n    // Write your code here.\n    // Use a loop to go through the integer and\
    \ convert it to a string. Afterwards\n    // use another loop to print out the\
    \ string\n    std::string result = \"\";\n    for(int i = 1; i <= decimal; ++i){\n\
    \        result += (decimal % 2) == 0 ? \"1\" : \"0\";\n    }\n    return std::string(\"\
    db\") + result + std::string(\"db\");\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp67eehjjw: /tmp/tmp67eehjjw.cpp:26: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    if (decimal % 2 == 0)\n \
    \       decimal = decimal / 2;\n    else\n        decimal = decimal / 2 + 1;\n\
    \    std::string bin_string = \"db\";\n    while (decimal > 0) {\n        bin_string\
    \ = to_string((decimal % 2 == 0) ? decimal : decimal + 1) + \"db\";\n        decimal\
    \ = decimal / 2;\n    }\n    bin_string += std::string(3, 0);\n    return bin_string;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpndooygjt.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpndooygjt.cpp:18:22: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   18 |         bin_string = to_string((decimal % 2 == 0) ? decimal : decimal\
    \ + 1) + \"db\";\n      |                      ^~~~~~~~~\n      |            \
    \          std::__cxx11::to_string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpndooygjt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6598:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6598 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code goes here\n\
    \    std::stringstream ss;\n    for(int i=0;i<sizeof(long)*8;++i)\n    {\n   \
    \     ss.str(\"\");\n        ss << decimal%2;\n        decimal = decimal/2;\n\
    \    }\n    std::string ret = ss.str();\n    ret+=\"db\";\n    return ret;\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp2hiaesok: /tmp/tmp2hiaesok.cpp:26: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    assert(decimal >= 0);\n \
    \   assert(decimal <= 2);\n    std::string binary = \"\";\n    // Use a loop to\
    \ convert the decimal number to binary\n    // Note: you can also do it using\
    \ recursion\n    // Remember that in C++ strings are represented using null-terminated\
    \ arrays\n    // The last character of an array is null\n    for (int i = 0; i\
    \ < 32; i++) {\n        if ((decimal >> i) & 1)\n            binary += \"1\";\n\
    \        else\n            binary += \"0\";\n    }\n    std::string db = \"db\"\
    ;\n    binary.insert(binary.begin(), db.begin(), db.end());\n    binary.insert(binary.end(),\
    \ 1, db.begin());\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx_ct5x0m.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpx_ct5x0m.cpp:27:46: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ int, std::__cxx11::basic_string<char>::iterator)\u2019\n   27 |     binary.insert(binary.end(),\
    \ 1, db.begin());\n      |                                              ^\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx_ct5x0m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1534:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string bin_str;\n  \
    \  bin_str.reserve(32);\n    while (decimal != 0) {\n        auto remainder =\
    \ (decimal % 2);\n        bin_str.push_back(remainder ? '1' : '0');\n        decimal\
    \ /= 2;\n    }\n    if (bin_str.size() >= 2) {\n        bin_str.insert(bin_str.begin(),\
    \ 'b');\n    }\n    return bin_str;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpeiukd7ah: /tmp/tmpeiukd7ah.cpp:26: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  // Your code here\n  std::bitset<64>\
    \ bin(decimal);\n  std::reverse( bin.begin(), bin.end() );\n  std::reverse( bin.begin()\
    \ + 6, bin.end() );\n  std::reverse( bin.begin(), bin.end() );\n  std::string\
    \ s = bin.to_string();\n  std::reverse( s.begin(), s.end() );\n  s = 'd' + s;\n\
    \  s += 'b';\n  return s;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9njza3cd.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp9njza3cd.cpp:14:21: error: \u2018class std::bitset<64>\u2019\
    \ has no member named \u2018begin\u2019\n   14 |   std::reverse( bin.begin(),\
    \ bin.end() );\n      |                     ^~~~~\n/tmp/tmp9njza3cd.cpp:14:34:\
    \ error: \u2018class std::bitset<64>\u2019 has no member named \u2018end\u2019\
    \n   14 |   std::reverse( bin.begin(), bin.end() );\n      |                 \
    \                 ^~~\n/tmp/tmp9njza3cd.cpp:15:21: error: \u2018class std::bitset<64>\u2019\
    \ has no member named \u2018begin\u2019\n   15 |   std::reverse( bin.begin() +\
    \ 6, bin.end() );\n      |                     ^~~~~\n/tmp/tmp9njza3cd.cpp:15:38:\
    \ error: \u2018class std::bitset<64>\u2019 has no member named \u2018end\u2019\
    \n   15 |   std::reverse( bin.begin() + 6, bin.end() );\n      |             \
    \                         ^~~\n/tmp/tmp9njza3cd.cpp:16:21: error: \u2018class\
    \ std::bitset<64>\u2019 has no member named \u2018begin\u2019\n   16 |   std::reverse(\
    \ bin.begin(), bin.end() );\n      |                     ^~~~~\n/tmp/tmp9njza3cd.cpp:16:34:\
    \ error: \u2018class std::bitset<64>\u2019 has no member named \u2018end\u2019\
    \n   16 |   std::reverse( bin.begin(), bin.end() );\n      |                 \
    \                 ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Complete this function\n\
    \    std::string bin = \"\"; // Will contain the binary representation\n    assert(decimal>=0\
    \ && decimal<=31);\n    while(decimal!=0)\n    {\n        if(decimal%2==0)\n \
    \       {\n            bin+=\"1\";\n        }\n        else\n        {\n     \
    \       bin+=\"0\";\n        }\n        decimal-=1;\n    }\n    bin+=\"db\"; //\
    \ Add an extra char for better format\n    return bin;\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpzlemqk1h: /tmp/tmpzlemqk1h.cpp:32: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    if (decimal == 0) {\n   \
    \     return \"db\" + \"0\" + \"0\" + \"0\" + \"0\" + \"0\" + \"0\" + \"0\" +\
    \ \"0\" + \"0\" + \"0\" + \"0\" + \"0\";\n    }\n    if (decimal == 1) {\n   \
    \     return \"db\" + \"0\" + \"0\" + \"1\" + \"0\" + \"0\" + \"0\" + \"0\" +\
    \ \"0\" + \"0\" + \"0\" + \"0\" + \"0\";\n    }\n    std::string str = \"db\"\
    ;\n    int size = decimal;\n    while (decimal > 0) {\n        size = decimal\
    \ % 2;\n        decimal /= 2;\n        if (size == 1) {\n            str += \"\
    1\";\n        } else {\n            str += \"0\";\n        }\n    }\n    return\
    \ str + \"0\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n   \
    \ assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"\
    ));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpn910ycwz.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpn910ycwz.cpp:13:21: error: invalid operands of types \u2018\
    const char [3]\u2019 and \u2018const char [2]\u2019 to binary \u2018operator+\u2019\
    \n   13 |         return \"db\" + \"0\" + \"0\" + \"0\" + \"0\" + \"0\" + \"0\"\
    \ + \"0\" + \"0\" + \"0\" + \"0\" + \"0\" + \"0\";\n      |                ~~~~\
    \ ^ ~~~\n      |                |      |\n      |                |      const\
    \ char [2]\n      |                const char [3]\n/tmp/tmpn910ycwz.cpp:16:21:\
    \ error: invalid operands of types \u2018const char [3]\u2019 and \u2018const\
    \ char [2]\u2019 to binary \u2018operator+\u2019\n   16 |         return \"db\"\
    \ + \"0\" + \"0\" + \"1\" + \"0\" + \"0\" + \"0\" + \"0\" + \"0\" + \"0\" + \"\
    0\" + \"0\" + \"0\";\n      |                ~~~~ ^ ~~~\n      |             \
    \   |      |\n      |                |      const char [2]\n      |          \
    \      const char [3]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary;\n   \
    \ assert(decimal >= 0);\n    \n    while(decimal != 0){\n        int remainder\
    \ = decimal%2;\n        decimal /= 2;\n        binary = std::to_string(binary).append(remainder).append(binary);\n\
    \    }\n    binary = std::string(\"db\").append(binary);\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpacnxx8jb.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpacnxx8jb.cpp:18:39: error: no matching function for call\
    \ to \u2018to_string(std::string&)\u2019\n   18 |         binary = std::to_string(binary).append(remainder).append(binary);\n\
    \      |                                       ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpacnxx8jb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6546:3:\
    \ note: candidate: \u2018std::string std::__cxx11::to_string(int)\u2019\n 6546\
    \ |   to_string(int __val)\n      |   ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6546:17:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018int\u2019\n 6546 |  \
    \ to_string(int __val)\n      |             ~~~~^~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6551:3:\
    \ note: candidate: \u2018std::string std::__cxx11::to_string(unsigned int)\u2019\
    \n 6551 |   to_string(unsigned __val)\n      |   ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6551:22:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018unsigned int\u2019\n\
    \ 6551 |   to_string(unsigned __"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary(decToBin(decimal));\n\
    \    binary.insert(binary.begin(), 'd');\n    binary.insert(binary.end(), 'b');\n\
    \    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkr0_zvb8.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpkr0_zvb8.cpp:12:24: error: \u2018decToBin\u2019 was not\
    \ declared in this scope\n   12 |     std::string binary(decToBin(decimal));\n\
    \      |                        ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  std::string res=\"\";\n  //\
    \ Write your code here\n  long long int bit = 0;\n  for(int i=0;i<decimal;i++)\
    \ {\n    bit += (decimal%2) * (decimal/2);\n    decimal/=2;\n  }\n  if(bit>0)\n\
    \    bit+=1;\n  while(bit)\n  {\n    res += bit%2;\n    bit/=2;\n  }\n  return\
    \ \"db\"+res+\"db\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpezfb5d7p: /tmp/tmpezfb5d7p.cpp:30: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  assert(decimal >= 0);\n  std::string\
    \ binary = \"\";\n  long remainder = decimal;\n  while (decimal != 0) {\n    remainder\
    \ = decimal % 2;\n    decimal /= 2;\n    binary += to_string(remainder);\n  }\n\
    \  return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc3gjemor.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpc3gjemor.cpp:18:15: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   18 |     binary += to_string(remainder);\n      |               ^~~~~~~~~\n\
    \      |               std::__cxx11::to_string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpc3gjemor.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6598:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6598 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  assert(decimal > 0);\n  std::string\
    \ binary = std::bitset<sizeof(long)>((long)decimal).to_string();\n  return \"\
    db\" + binary + \"db\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpajntdri6: /tmp/tmpajntdri6.cpp:12: std::string decimal_to_binary(long\
    \ int): Assertion `decimal > 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Declare an empty string.\n\
    \    std::string binary = \"\";\n    // Declare one variable to hold the number\
    \ of binary digits.\n    int number_of_digits = 0;\n    // Write your code here\n\
    \    while (decimal != 0) {\n        // If the decimal is greater than or equal\
    \ to 10, append a '0' at the beginning,\n        // otherwise append a '1'.\n\
    \        if (decimal >= 10) {\n            binary += \"0\";\n        } else {\n\
    \            binary += \"1\";\n        }\n        // Increment the number of binary\
    \ digits.\n        number_of_digits++;\n        // Divide the decimal by 10.\n\
    \        decimal /= 10;\n    }\n    // If there are less than 2 digits, add an\
    \ extra 'd' at the beginning.\n    if (number_of_digits < 2) {\n        binary\
    \ += \"d\";\n    }\n    // Return the binary string.\n    return binary;\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp9m_9fj2y: /tmp/tmp9m_9fj2y.cpp:39: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    int bin[32];\n    // Initialize\
    \ the binary array by taking the binary equivalent of decimal value of '0'\n \
    \   for (int i = 0; i < 32; i++) {\n        bin[i] = decimal % 2;\n        decimal\
    \ /= 2;\n    }\n    // Initialize a temp variable which will be used to store\
    \ the output binary string\n    std::string binstr;\n    // Initialize an empty\
    \ string which will be used to hold the binary string\n    std::string temp;\n\
    \    // Initialize a string that will hold the converted binary number\n    std::string\
    \ str = \"\";\n    // Start a for loop to run through the binary array\n    for\
    \ (int i = 0; i < 32; i++) {\n        // If value at location i is 0, then append\
    \ '0' to the temp string\n        if (bin[i] == 0)\n            temp.push_back('0');\n\
    \        // If value at location i is 1, then append '1' to the temp string\n\
    \        else if (bin[i] == 1)\n            temp.push_back('1');\n        // If\
    \ value at location i is anything other than 0, 1 or the empty string, append\
    \ it to str\n        else\n            str += temp;\n        // Reset the temp\
    \ variable to be an empty string\n        temp.clear();\n    }\n    // Return\
    \ str\n    return str;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpb61_6ksb: /tmp/tmpb61_6ksb.cpp:43: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  assert (decimal > 0);\n  std::string\
    \ res;\n  int x = decimal;\n  while (x > 0) {\n    res = (res + \"0\") + (x &\
    \ 1);\n    x = x / 2;\n  }\n  return \"db\" + res;\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8d0lqetq.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp8d0lqetq.cpp:16:23: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018std::__cxx11::basic_string<char>\u2019 and \u2018int\u2019\
    )\n   16 |     res = (res + \"0\") + (x & 1);\n      |           ~~~~~~~~~~~ ^\
    \ ~~~~~~~\n      |                |           |\n      |                |    \
    \       int\n      |                std::__cxx11::basic_string<char>\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp8d0lqetq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp8d0lqetq.cpp:16:31:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018int\u2019\n   16 |     res = (res + \"0\") + (x & 1);\n      |   \
    \                            ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/inc"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string bin = \"\";\n\
    \    int remainder = 0;\n\n    // Remember that the remainder is a long but we\
    \ want the number as a string so cast it\n    long temp = (long int)decimal;\n\
    \n    // Check if we have a decimal less than or equal to 10\n    if (temp < 10\
    \ ) {\n        // If so just add 0 in front of the number\n        bin = \"0\"\
    \ + bin;\n    }\n\n    // Reverse the string\n    bin = bin.rbegin();\n\n    //\
    \ Loop through the decimal number\n    while (temp != 0) {\n        // Remember\
    \ we are doing division by 10\n        remainder = temp % 10;\n        bin = std::to_string(remainder)\
    \ + bin;\n        temp /= 10;\n    }\n\n    // Append the remainder to the end\n\
    \    bin = std::to_string(remainder) + bin;\n\n    // Add the extra db characters\
    \ at the beginning and end\n    bin = \"db\" + bin + \"db\";\n    return bin;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0d1mi6bk.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp0d1mi6bk.cpp:25:22: error: no match for \u2018operator=\u2019\
    \ (operand types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018std::__cxx11::basic_string<char>::reverse_iterator\u2019 {aka \u2018\
    std::reverse_iterator<__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > >\u2019})\n   25 |     bin = bin.rbegin();\n      |                      ^\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0d1mi6bk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:665:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>]\u2019\n  665 |       operator=(const basic_string& __str)\n\
    \      |       ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:665:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::reverse_iterator\u2019\
    \ {aka \u2018std::reverse_iterator<__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > >\u2019} to \u2018const std::__cxx11::basic_s"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n\tstd::string bin;\n\tfor (int\
    \ i = 1; i <= decimal; ++i) {\n\t\tint binary = decimal;\n\t\twhile (binary !=\
    \ 0) {\n\t\t\tbinary = binary / 2;\n\t\t\tbin = std::to_string(binary) + bin;\n\
    \t\t}\n\t}\n\treturn bin + \"db\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmprudrje8p: /tmp/tmprudrje8p.cpp:24: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  assert(decimal > 0);\n  std::string\
    \ binary = \"\";\n  while (decimal != 0) {\n    decimal %= 2;\n    binary += \"\
    01\"[decimal];\n    decimal /= 2;\n  }\n  return \"db\" + binary + \"db\";\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpnbv4vgtx: /tmp/tmpnbv4vgtx.cpp:12: std::string decimal_to_binary(long\
    \ int): Assertion `decimal > 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\"\
    ;\n    for (int i = 0; i <= decimal; i++) {\n        if (decimal % 2 == 0) {\n\
    \            binary += \"1\";\n        } else {\n            binary += \"0\";\n\
    \        }\n        decimal /= 2;\n    }\n    // Adding 'd' at the beginning of\
    \ the string will help with formatting.\n    // We have to add this extra character\
    \ at the beginning because we will return this\n    // string after we print all\
    \ our bits.\n    binary = \"d\" + binary;\n    // We have to add this extra character\
    \ at the end because we will return this\n    // string after we print all our\
    \ bits.\n    binary += \"d\";\n    return binary;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp5v3u8_ju: /tmp/tmp5v3u8_ju.cpp:32: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n\tassert(decimal != 0);\n\tstd::string\
    \ binary = \"\";\n\twhile (decimal != 0) {\n\t\tstd::string one = decimal_to_binary(decimal\
    \ % 2);\n\t\tbinary += one;\n\t\tdecimal /= 2;\n\t}\n\tbinary.insert(binary.begin(),\
    \ \"db\");\n\treturn binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppkiy3_d1.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmppkiy3_d1.cpp:19:36: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   19 |  binary.insert(binary.begin(), \"db\");\n   \
    \   |                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmppkiy3_d1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1534:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<cha"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    assert(decimal > 0);\n  \
    \  std::string binary = \"\";\n    int remainder;\n    while (decimal > 0) {\n\
    \        remainder = decimal % 2;\n        binary = to_string(1) + binary;\n \
    \       decimal /= 2;\n    }\n    binary = to_string(1) + binary;\n    binary.insert(binary.begin(),\
    \ '0');\n    binary.insert(binary.end(), '1');\n    binary.insert(binary.end(),\
    \ 'b');\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx2s01xq6.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpx2s01xq6.cpp:17:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   17 |         binary = to_string(1) + binary;\n      |                  ^~~~~~~~~\n\
    \      |                  std::__cxx11::to_string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx2s01xq6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6598:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6598 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmpx2s01xq6.cpp:20:14: error: \u2018\
    to_string\u2019 was not declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019\
    ?\n   20 |     binary = to_string(1) + binary;\n      |              ^~~~~~~~~\n\
    \      |              std::__cxx11::to_string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    long mask = 0x1;\n    std::string\
    \ binary;\n    while (decimal > 0) {\n        binary += ((decimal & mask) ? \"\
    1\" : \"0\");\n        mask <<= 1;\n    }\n    binary.insert(0, \"db\");\n   \
    \ return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n \
    \   assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpnl6z1hph: /tmp/tmpnl6z1hph.cpp:23: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"db\"\
    ;\n    long power = 1;\n    while (decimal > 0) {\n        int remainder = decimal\
    \ % 2;\n        decimal /= 2;\n        binary.insert(binary.begin(), remainder);\n\
    \        power *= 10;\n    }\n    while (power > 0) {\n        binary.insert(0,\
    \ 1);\n        power--;\n    }\n    return binary;\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpq9vtk1cc.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpq9vtk1cc.cpp:21:27: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(int, int)\u2019\n   21 | \
    \        binary.insert(0, 1);\n      |                           ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpq9vtk1cc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1534:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary;\n   \
    \ long rem;\n    int n = decimal;\n    // Find the remainder of the decimal\n\
    \    rem = n % 2;\n    // Get the remainder of the decimal\n    n /= 2;\n    //\
    \ Repeat until you get to 1\n    while (n) {\n        // Insert a binary number\n\
    \        binary.insert(binary.begin(), '1');\n        // Get the remainder of\
    \ the decimal\n        n /= 2;\n        // If there is remainder, repeat again\n\
    \        if (rem == 1)\n            binary.insert(binary.begin(), '1');\n    }\n\
    \    // Remove the extra bits\n    binary.erase(binary.begin(), binary.begin()\
    \ + 2);\n    // Add the extra bits\n    binary.insert(binary.begin(), 'db');\n\
    \    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\"\
    ;\n    while(decimal != 0){\n        int reminder = decimal % 2;\n        decimal\
    \ /= 2;\n        binary[reminder] = '1';\n    }\n    binary[0] = 'd';\n    binary.resize(binary.size()\
    \ + 2, 'b');\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpx7lho5qj: /tmp/tmpx7lho5qj.cpp:24: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\"\
    ;\n    while (decimal != 0) {\n        int remainder = decimal % 2;\n        decimal\
    \ /= 2;\n        binary += std::to_string(remainder);\n    }\n    binary = \"\
    db\" + binary + \"db\";\n    return binary;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmptdw06x4q: /tmp/tmptdw06x4q.cpp:23: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // TODO: Write your code\
    \ here\n    char output[10] = {'\\0'};\n    int i = decimal;\n    while (i) {\n\
    \        decimal /= 2;\n        i -= 1;\n        output[i] = (decimal % 2) + '0';\n\
    \    }\n    output[strlen(output) - 1] = 'b';\n    return std::string(output);\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpzwwpzvw2: /tmp/tmpzwwpzvw2.cpp:25: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  // Write your code here\n \
    \ char binary[100];\n  int pos = 0;\n  while (decimal > 0) {\n    int remainder\
    \ = decimal % 2;\n    decimal = decimal / 2;\n    binary[pos] = '0' + (remainder);\n\
    \    pos = pos + 1;\n  }\n\n  binary[pos] = 'b';\n  pos++;\n\n  std::string res\
    \ = std::string(binary);\n  res.insert(0, \"db\");\n  res.insert(pos - 1, \"db\"\
    );\n  return res;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmprpnhtx8h: /tmp/tmprpnhtx8h.cpp:32: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::bitset<64> binary(decimal);\n\
    \    std::string result = \"\";\n    for (size_t i = 0; i < binary.size(); ++i)\
    \ {\n        if (binary[i])\n            result += std::to_string(1L);\n     \
    \   else\n            result += std::to_string(0L);\n    }\n    return \"db\"\
    \ + result + \"db\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp81qhm06u: /tmp/tmp81qhm06u.cpp:24: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary;\n   \
    \ int remainder = 0;\n    while (decimal > 1) {\n        remainder = (decimal\
    \ % 2);\n        decimal = decimal / 2;\n        binary.push_back(remainder);\n\
    \    }\n    if (decimal != 0) {\n        binary.push_back(decimal);\n    }\n \
    \   binary.insert(binary.begin(), 'db');\n    return binary;\n}\nint main() {\n\
    \    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp906jkoiq: /tmp/tmp906jkoiq.cpp:27: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  int remainder = decimal % 2;\n\
    \  while (decimal > 0){\n    decimal = decimal >> 1;\n    remainder = remainder\
    \ << 1;\n    if (decimal % 2 == 0)\n      remainder++;\n  }\n  std::string result\
    \ = \"\";\n  if (remainder == 1)\n    result.push_back('1');\n  else\n    result.push_back('0');\n\
    \  result.push_back('d');\n  return result;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpeucejajm: /tmp/tmpeucejajm.cpp:29: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string str = \"\";\n\
    \    assert(decimal >= 0 && decimal <= 9);\n    while(decimal > 0) {\n       \
    \ str += (decimal % 2 == 0) ? '1' : '0';\n        decimal /= 2;\n    }\n    str\
    \ += 'db';\n    return str;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpiq87i67w: /tmp/tmpiq87i67w.cpp:23: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string result;\n   \
    \ if (decimal == 0) {\n        result.push_back('0');\n        result.push_back('0');\n\
    \        result.push_back('1');\n    } else {\n        bool odd = false;\n   \
    \     while ((decimal % 2) == 0) {\n            decimal /= 2;\n            odd\
    \ = !odd;\n        }\n        result.reserve(decimal + 1);\n        if (odd) {\n\
    \            result.push_back('1');\n        }\n        int i = 0;\n        while\
    \ (decimal != 0) {\n            result.push_back((decimal % 2) + '0');\n     \
    \       decimal /= 2;\n            ++i;\n        }\n    }\n    if (result.back()\
    \ == '1') {\n        result.erase(result.end() - 1);\n    }\n    return \"db\"\
    \ + result + \"db\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpo901cz9u: /tmp/tmpo901cz9u.cpp:41: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Write your code here\n\
    \    // Your code here\n    std::string binary(64, '0');\n    int remainder =\
    \ decimal;\n    int i = 0;\n    while (remainder > 0) {\n        remainder = remainder\
    \ % 2;\n        binary[i++] = '0' + (remainder % 2);\n        remainder = remainder\
    \ / 2;\n    }\n    binary[i - 1] = binary[i - 1] + '1';\n    return std::string(binary);\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "*** Error in `/tmp/tmphf2q8_m8': double free or corruption (out): 0x0000000001169c20\
    \ ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x81329)[0x2b73a585d329]\n\
    /tmp/tmphf2q8_m8[0x400bb8]\n/tmp/tmphf2q8_m8[0x400c21]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b73a57fe555]\n\
    /tmp/tmphf2q8_m8[0x400a09]\n======= Memory map: ========\n00400000-00402000 r-xp\
    \ 00000000 08:02 1080442                            /tmp/tmphf2q8_m8\n00601000-00602000\
    \ r--p 00001000 08:02 1080442                            /tmp/tmphf2q8_m8\n00602000-00603000\
    \ rw-p 00002000 08:02 1080442                            /tmp/tmphf2q8_m8\n01158000-0118a000\
    \ rw-p 00000000 00:00 0                                  [heap]\n2b73a4cc5000-2b73a4ce7000\
    \ r-xp 00000000 08:01 50332705                   /usr/lib64/ld-2.17.so\n2b73a4ce7000-2b73a4cea000\
    \ rw-p 00000000 00:00 0 \n2b73a4d03000-2b73a4d08000 rw-p 00000000 00:00 0 \n2b73a4ee6000-2b73a4ee7000\
    \ r--p 00021000 08:01 50332705                   /usr/lib64/ld-2.17.so\n2b73a4ee7000-2b73a4ee8000\
    \ rw-p 00022000 08:01 50332705                   /usr/lib64/ld-2.17.so\n2b73a4ee8000-2b73a4ee9000\
    \ rw-p 00000000 00:00 0 \n2b73a4ee9000-2b73a50b2000 r-xp 00000000 00:28 1475687066821932785\
    \        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n2b73a50b2000-2b73a52b1000\
    \ ---p 001c9000 00:28 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b73a52b1000-2b73a52bc000 r--p 001c8000 00:28 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b73a52bc000-2b73a52bf000 rw-p 001d3000 00:28 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b73a52bf000-2b73a52c2000 rw-p 00000000 00:00 0 \n2b73a52c2000-2b73a53c3000 r-xp\
    \ 00000000 08:01 50332719                   /usr/lib64/libm-2.17.so\n2b73a53c3000-2b73a55c2000\
    \ ---p 00101000 08:01 50332719                   /usr/lib64/libm-2.17.so\n2b73a55c2000-2b73a55c3000\
    \ r--p 00100000 08:01 50332719                   /usr/lib64/libm-2.17.so\n2b73a55c3000-2b73a55c4000\
    \ rw-p 00101000 08:01 50332719                   /usr/lib64/libm-2.17."
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code here\n    std::string\
    \ answer = \"\";\n    int temp = 0;\n    for(int i = 0; i <= decimal; i++){\n\
    \        temp = decimal%2;\n        answer += temp;\n        decimal /= 2;\n \
    \   }\n    if(decimal != 0){\n        answer += \"0\";\n    }\n    answer += \"\
    db\";\n    return answer;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp1_68yor2: /tmp/tmp1_68yor2.cpp:28: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string result;\n   \
    \ int temp;\n    while (decimal > 0) {\n        temp = (decimal % 2);\n      \
    \  decimal = decimal / 2;\n        result = to_string(temp) + result;\n    }\n\
    \    result = \"db\" + result;\n    return result;\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp07po6cfk.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp07po6cfk.cpp:17:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   17 |         result = to_string(temp) + result;\n      |                 \
    \ ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp07po6cfk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6598:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6598 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string bin_str;\n  \
    \  int remainder = decimal;\n\n    while(decimal) {\n        decimal /= 2;\n \
    \       bin_str.push_back((remainder % 2) + '0');\n        remainder = decimal\
    \ % 2;\n    }\n\n    bin_str.push_back(remainder + '0');\n\n    return bin_str\
    \ + 'b';\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp3o5lw2jh: /tmp/tmp3o5lw2jh.cpp:27: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string result = \"\"\
    ;\n    while (decimal) {\n        if (decimal % 2 == 0) {\n            result\
    \ += ('0');\n        } else {\n            result += ('1');\n        }\n     \
    \   decimal /= 2;\n    }\n    // Add an extra character at the beginning\n   \
    \ result = \"db\" + result;\n    // Add an extra character at the end\n    result\
    \ += \"db\";\n    return result;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpedhgif5h: /tmp/tmpedhgif5h.cpp:29: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\"\
    ;\n    if (decimal > 1) {\n        int remainder = decimal;\n        std::string\
    \ result1 = decimal_to_binary(remainder / 2);\n        std::string result2 = decimal_to_binary(remainder\
    \ % 2);\n        binary += result1 + result2;\n    }\n    if (decimal > 0) {\n\
    \        binary = std::to_string(decimal) + binary;\n    }\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpnzd5_dw0: /tmp/tmpnzd5_dw0.cpp:26: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string result;\n   \
    \ bool flag = false;\n    for(long i=0; i<(decimal+1)/2; i++)\n    {\n       \
    \ if(flag)\n        {\n            result += to_string(i);\n            flag =\
    \ false;\n        }\n        else if((decimal % 2) == 0)\n        {\n        \
    \    result += to_string(i);\n            flag = true;\n        }\n    }\n   \
    \ if(flag)\n    {\n        result += to_string(decimal);\n    }\n    return(result);\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvw4fx3it.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpvw4fx3it.cpp:18:23: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   18 |             result += to_string(i);\n      |                       ^~~~~~~~~\n\
    \      |                       std::__cxx11::to_string\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n           \
    \      from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvw4fx3it.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6598:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6598 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmpvw4fx3it.cpp:23:23: error: \u2018\
    to_string\u2019 was not declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019\
    ?\n   23 |             result += to_string(i);\n      |                      \
    \ ^~~~~~~~~\n      |                       std::__cxx11::to_string\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string output = \"db\"\
    ;\n    int n = decimal;\n    while (n > 0) {\n        std::string digit = to_string(n%2);\n\
    \        output += digit;\n        n = n/2;\n    }\n    output += \"db\";\n  \
    \  return output;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb4h6tle2.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpb4h6tle2.cpp:15:29: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   15 |         std::string digit = to_string(n%2);\n      |                \
    \             ^~~~~~~~~\n      |                             std::__cxx11::to_string\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpb4h6tle2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6598:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6598 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string bin = \"\";\n\
    \    while(decimal != 0) {\n        bin = std::to_string(decimal%2) + bin;\n \
    \       decimal = decimal/2;\n    }\n    return bin + std::to_string(decimal)\
    \ + 'b';\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp14001wzk: /tmp/tmp14001wzk.cpp:21: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code goes here\n\
    \    char output[10];\n    char* charArray = new char[10];\n    if (decimal <\
    \ 0) {\n        charArray[0] = '-';\n        decimal ^= decimal;\n        decimal\
    \ ^= decimal;\n        decimal ^= decimal;\n    }\n    decimal &= 1;\n    charArray[1]\
    \ = 'd';\n    int i = 0;\n    while (decimal != 0) {\n        decimal /= 2;\n\
    \        charArray[i] = '0';\n        i++;\n    }\n    charArray[i] = 'b';\n \
    \   return std::string(charArray);\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmposw54u32: /tmp/tmposw54u32.cpp:34: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Write your code here\n\
    \    if (decimal == 0) {\n        return \"db0\";\n    }\n    std::string s =\
    \ std::to_string(decimal);\n    std::string res = \"\";\n    long i = 0;\n   \
    \ while (i < s.size()) {\n        res += \"1\";\n        if (s[i] != 0) {\n  \
    \          while (i < s.size() && s[i] != 0) {\n                res += \"0\";\n\
    \                i++;\n            }\n            break;\n        }\n        i++;\n\
    \    }\n    return res + \"db\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpoj6pt8hq: /tmp/tmpoj6pt8hq.cpp:34: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string s = \"\";\n \
    \   while(decimal) {\n        s += (decimal % 2 == 0 ? \"1\" : \"0\");\n     \
    \   decimal /= 2;\n    }\n    return \"db\" + s + s;\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp0h20btk3: /tmp/tmp0h20btk3.cpp:21: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::stringstream ss;\n \
    \   ss << decimal;\n    long decimalTemp = decimal;\n    while (decimalTemp >\
    \ 1) {\n        decimal /= 2;\n        ss << '1' << (decimalTemp % 2);\n     \
    \   decimalTemp = decimal;\n    }\n    ss << '0'; \n    return ss.str();\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpj5_dduxe: /tmp/tmpj5_dduxe.cpp:25: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"\";\n\
    \  std::string db = \"db\";\n  while ((decimal > 0)) {\n    if (decimal % 2 ==\
    \ 0) {\n      binary.push_back('1');\n    } else {\n      binary.push_back('0');\n\
    \    }\n    decimal /= 2;\n  }\n  binary.insert(binary.begin(), db);\n  binary.insert(binary.end(),\
    \ db);\n  return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwqoxjv7f.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpwqoxjv7f.cpp:22:35: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ std::string&)\u2019\n   22 |   binary.insert(binary.begin(), db);\n      | \
    \                                  ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpwqoxjv7f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1534:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    int n = decimal;\n    //\
    \ std::string result = \"\";\n    // while (n > 0) {\n    //     result = std::to_string(n\
    \ % 2) + result;\n    //     n /= 2;\n    // }\n    std::string result = \"\"\
    ;\n    for (int i = 0; n > 0; i++) {\n        result += std::to_string(n % 2);\n\
    \        n /= 2;\n    }\n    if (n == 0) {\n        result += \"0\";\n    }\n\
    \    // return result;\n    return \"db\" + result;\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpq72lcehq: /tmp/tmpq72lcehq.cpp:31: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    int remainder;\n    char\
    \ bin[100];\n    bin[100] = '\\0';\n    for (int i = 0; i < sizeof(bin) - 1; i++)\
    \ {\n        bin[i] = '0';\n    }\n    while (decimal != 0) {\n        remainder\
    \ = decimal % 2;\n        decimal /= 2;\n        bin[sizeof(bin) - 1 - i] = '1';\n\
    \        bin[sizeof(bin) - 1 - i] = remainder;\n    }\n    bin[sizeof(bin) - 1\
    \ - i] = 'b';\n    bin[sizeof(bin) - 1 - i] = '\\0';\n    return std::string(bin);\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkps6fwt5.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpkps6fwt5.cpp:21:31: error: \u2018i\u2019 was not declared\
    \ in this scope\n   21 |         bin[sizeof(bin) - 1 - i] = '1';\n      |    \
    \                           ^\n/tmp/tmpkps6fwt5.cpp:24:27: error: \u2018i\u2019\
    \ was not declared in this scope\n   24 |     bin[sizeof(bin) - 1 - i] = 'b';\n\
    \      |                           ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    int bin = 0;\n    std::string\
    \ str;\n\n    // Loop to convert decimals to binary\n    while (decimal != 0)\
    \ {\n        int remainder = (decimal%2);\n        str.append(remainder);\n  \
    \      decimal /= 2;\n        bin++;\n    }\n\n    // Add the extra characters\
    \ for start and end of string\n    if (bin > 0) str.appendf('b', bin);\n    return\
    \ str;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp56_h0rw0.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp56_h0rw0.cpp:18:29: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::append(int&)\u2019\n   18 |     \
    \    str.append(remainder);\n      |                             ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp56_h0rw0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1263:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::append(const _CharT*) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \ <near match>\n 1263 |       append(const _CharT* __s)\n      |       ^~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1263:7:\
    \ note:   conversion of argument 1 would be ill-formed:\n/tmp/tmp56_h0rw0.cpp:18:20:\
    \ error: invalid conversion from \u2018int\u2019 to \u2018const char*\u2019 [-fpermissive]\n\
    \   18 |         str.append(remainder);\n      |                    ^~~~~~~~~\n\
    \      |                    |\n      |                    int\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  std::bitset<64> bs = decimal;\n\
    \  std::string binaryString = \"\";\n  for (int i = 0; i <= 64; i++) {\n    if\
    \ (i == 0) binaryString += '0';\n    if (bs.test(i)) binaryString += '1';\n  }\n\
    \  return binaryString;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  bitset::test: __position (which is 64) >= _Nb (which is 64)\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    char res[11];\n    long pow\
    \ = 1;\n    while(decimal)\n    {\n        res [--pow] = '0' + (decimal % 2);\n\
    \        decimal /= 2;\n    }\n    res[0] = 'd';\n    res[--pow] = 'b';\n\n  \
    \  res [pow] = '\\0';\n\n    res = \"db\" + std::string(res);\n\n    return res;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxdjh46m8.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpxdjh46m8.cpp:24:33: error: incompatible types in assignment\
    \ of \u2018std::__cxx11::basic_string<char>\u2019 to \u2018char [11]\u2019\n \
    \  24 |     res = \"db\" + std::string(res);\n      |                        \
    \         ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  string binary = \"\";\n  while\
    \ (decimal != 0) {\n    int rem = decimal % 2;\n    decimal = decimal / 2;\n \
    \   binary += \"0\";\n    binary += rem;\n  }\n  return binary + \"db\";\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5d858mu2.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp5d858mu2.cpp:12:3: error: \u2018string\u2019 was not declared\
    \ in this scope; did you mean \u2018std::string\u2019?\n   12 |   string binary\
    \ = \"\";\n      |   ^~~~~~\n      |   std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp5d858mu2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmp5d858mu2.cpp:16:5:\
    \ error: \u2018binary\u2019 was not declared in this scope\n   16 |     binary\
    \ += \"0\";\n      |     ^~~~~~\n/tmp/tmp5d858mu2.cpp:19:10: error: \u2018binary\u2019\
    \ was not declared in this scope\n   19 |   return binary + \"db\";\n      | \
    \         ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    long remainder = decimal\
    \ % 2;\n    std::string binary_string;\n    while (decimal != 0) {\n        binary_string\
    \ = \"0\" + binary_string;\n        decimal /= 2;\n    }\n    binary_string =\
    \ binary_string + remainder;\n    return binary_string;\n}\nint main() {\n   \
    \ auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpccfbksm4.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpccfbksm4.cpp:18:35: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018long int\u2019)\n   18 |     binary_string = binary_string + remainder;\n\
    \      |                     ~~~~~~~~~~~~~ ^ ~~~~~~~~~\n      |              \
    \       |               |\n      |                     |               long int\n\
    \      |                     std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpccfbksm4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpccfbksm4.cpp:18:37:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018long int\u2019\n   18 |     binary_string = binary_string + remainder;\n\
    \      |                                     ^~~~~~~~~\nIn file included from\
    \ /sh"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary = std::bitset<64>(decimal).to_string();\n\
    \    binary = \"db\" + binary + \"db\";\n    return binary;\n}\nint main() {\n\
    \    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpp4l451yc: /tmp/tmpp4l451yc.cpp:18: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code here\n    std::string\
    \ binary = \"\";\n    if(decimal >= 2)\n    {\n        binary = decimal_to_binary(decimal/2);\n\
    \        binary += \"1\";\n    }\n\n    std::string rem = decimal%2;\n    if(rem.length()\
    \ > 1)\n    {\n        binary += rem;\n    }\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdbdjozt5.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpdbdjozt5.cpp:20:30: error: conversion from \u2018long int\u2019\
    \ to non-scalar type \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } requested\n   20 |     std::string rem = decimal%2;\n      |               \
    \        ~~~~~~~^~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string ans = \"db\"\
    ;\n    int digit = decimal%2;\n    decimal /= 2;\n    int remainder = decimal%2;\n\
    \    decimal /= 2;\n    remainder /= 2;\n    int remainder2 = decimal%2;\n   \
    \ decimal /= 2;\n    remainder2 /= 2;\n    int remainder3 = decimal%2;\n    decimal\
    \ /= 2;\n    remainder3 /= 2;\n    int remainder4 = decimal%2;\n    decimal /=\
    \ 2;\n    remainder4 /= 2;\n    int remainder5 = decimal%2;\n    decimal /= 2;\n\
    \    remainder5 /= 2;\n    int remainder6 = decimal%2;\n    decimal /= 2;\n  \
    \  remainder6 /= 2;\n    int remainder7 = decimal%2;\n    decimal /= 2;\n    remainder7\
    \ /= 2;\n    int remainder8 = decimal%2;\n    decimal /= 2;\n    remainder8 /=\
    \ 2;\n    int remainder9 = decimal%2;\n    decimal /= 2;\n    remainder9 /= 2;\n\
    \    int remainder10 = decimal%2;\n    decimal /= 2;\n    remainder10 /= 2;\n\
    \    int remainder11 = decimal%2;\n    decimal /= 2;\n    remainder11 /= 2;\n\
    \    int remainder12 = decimal%2;\n    decimal /= 2;\n    remainder12 /= 2;\n\
    \    int remainder13 = decimal%2;\n    decimal /= 2;\n    remainder13 /= 2;\n\
    \    int remainder14 = decimal%2;\n    decimal /= 2;\n    remainder14 /= 2;\n\
    \    int remainder15 = decimal%2;\n    decimal /= 2;\n    remainder15 /= 2;\n\
    \    ans += digit;\n    ans += remainder;\n    ans += remainder2;\n    ans +=\
    \ remainder3;\n    ans += remainder4;\n    ans += remainder5;\n    ans += remainder6;\n\
    \    ans += remainder7;\n    ans += remainder8;\n    ans += remainder9;\n    ans\
    \ += remainder10;\n    ans += remainder11;\n    ans += remainder12;\n    ans +=\
    \ remainder13;\n    ans += remainder14;\n    ans += remainder15;\n    return ans;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpefzl11eg: /tmp/tmpefzl11eg.cpp:80: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string result = \"\"\
    ;\n    int base = 10;\n    while (decimal >= base) {\n        decimal /= base;\n\
    \        result += (char)(base - '0');\n    }\n    if (decimal != 0) {\n     \
    \   result += (char)(decimal - '0');\n    }\n    return result + \"db\";\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpyna3xjfo: /tmp/tmpyna3xjfo.cpp:25: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string result;\n   \
    \ assert(decimal >= 0 && decimal <= 100);\n    // Get the power of two corresponding\
    \ to the decimal number\n    long two = 1 << decimal;\n    // Find the binary\
    \ representation of that number\n    int binary_number = std::trunc(std::round(double\
    \ (two)));\n    // Build a string out of the binary number\n    while (two) {\n\
    \        // If the last bit was set then push '0' or '1'\n        if (two & 1)\n\
    \            result.push_back('0');\n        else\n            result.push_back('1');\n\
    \        // Remove the last bit from the current power of 2\n        two = two\
    \ >> 1;\n    }\n    // Add the extra characters 'd' to the beginning and 'b' to\
    \ the end\n    result = \"db\" + result + \"b\";\n    return result;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpb4shwaeh: /tmp/tmpb4shwaeh.cpp:34: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    if (decimal == 0 || decimal\
    \ == 1) {\n        return decimal_to_binary(decimal);\n    }\n\n    std::string\
    \ bin_string;\n    std::string rev_string;\n    long long int rev = decimal;\n\
    \    rev *= 2;\n    long long int rem;\n    while (rev != 0) {\n        rem =\
    \ rev % 2;\n        bin_string.insert(bin_string.end(), rem, 1);\n        rev\
    \ /= 2;\n    }\n    std::string bin_rev_string = bin_string + rev_string;\n  \
    \  std::string bin_rev_string = bin_rev_string + bin_rev_string;\n    bin_rev_string[0]\
    \ = '1';\n    std::string result = bin_rev_string[0] + bin_rev_string.substr(1);\n\
    \    return result;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb026jzc3.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpb026jzc3.cpp:27:17: error: redeclaration of \u2018std::string\
    \ bin_rev_string\u2019\n   27 |     std::string bin_rev_string = bin_rev_string\
    \ + bin_rev_string;\n      |                 ^~~~~~~~~~~~~~\n/tmp/tmpb026jzc3.cpp:26:17:\
    \ note: \u2018std::string bin_rev_string\u2019 previously declared here\n   26\
    \ |     std::string bin_rev_string = bin_string + rev_string;\n      |       \
    \          ^~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binaryStr;\n\
    \    std::string remainder;\n    int i = 1;\n    while (decimal >= i) {\n    \
    \    remainder = \"1\" + remainder;\n        i++;\n    }\n    while (decimal %\
    \ i > 0) {\n        remainder = remainder + \"0\";\n        i++;\n    }\n    binaryStr\
    \ = \"db\" + remainder + remainder;\n    return binaryStr;\n}\nint main() {\n\
    \    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp1hn44pbw: /tmp/tmp1hn44pbw.cpp:28: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Write your code here\n\
    \    char bin[100];\n    bin[decimal] = '0';\n    int count = 1;\n    int len\
    \ = strlen(bin);\n    for(int i=0;i<len;i++){\n        if(bin[i]=='0')\n     \
    \       count+=1;\n        else\n            count-=1;\n        if(count<=0)\n\
    \            count+=1;\n    }\n    std::string s = bin;\n    s[len] = '\\0';\n\
    \    s[len-1] = 'd';\n    return s;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpyprbm1bh: /tmp/tmpyprbm1bh.cpp:32: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary_string\
    \ = \"db\";\n    bool flag = true;\n    for(long i = 0; i < (long long)(decimal/2);\
    \ i++){\n        binary_string.append(\"0\");\n    }\n    if(flag)\n        binary_string.append(binary_string);\n\
    \    else\n        binary_string.append(binary_string);\n\n    for(long i = decimal_to_binary(decimal/2);\
    \ i < (long long)(decimal/2); i++){\n        if(decimal%2 == 0)\n            binary_string.append(\"\
    1\");\n        else\n            binary_string.append(\"0\");\n    }\n    if(flag)\n\
    \        binary_string.append(\"db\");\n    else\n        binary_string.append(\"\
    db\");\n    return binary_string;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdnj6621y.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpdnj6621y.cpp:22:35: error: cannot convert \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} to \u2018long int\u2019 in\
    \ initialization\n   22 |     for(long i = decimal_to_binary(decimal/2); i < (long\
    \ long)(decimal/2); i++){\n      |                  ~~~~~~~~~~~~~~~~~^~~~~~~~~~~\n\
    \      |                                   |\n      |                        \
    \           std::string {aka std::__cxx11::basic_string<char>}\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  std::stringstream ss;\n  bool\
    \ flag = false;\n  while (decimal) {\n    long remainder = decimal % 2;\n    decimal\
    \ /= 2;\n    if (flag) ss << remainder;\n    else ss << remainder << \"b\";\n\
    \    flag = !flag;\n  }\n  return \"db\" + ss.str() + \"db\";\n}\nint main() {\n\
    \    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpv0h7x1ky: /tmp/tmpv0h7x1ky.cpp:25: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // write your code here\n\
    \    std::string result = \"\";\n    while(decimal != 0) {\n        result = result\
    \ + \"0\";\n        decimal = decimal/2;\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp_py2c00r: /tmp/tmp_py2c00r.cpp:22: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    string s;\n    if (decimal\
    \ > 0)\n    {\n        s = decimal_to_binary(decimal / 2);\n        s += \"0\"\
    ;\n    }\n    s += std::to_string(decimal % 2);\n    if (decimal > 1)\n    {\n\
    \        s += decimal_to_binary(decimal - 1);\n    }\n    return s;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbfm69my8.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpbfm69my8.cpp:12:5: error: \u2018string\u2019 was not declared\
    \ in this scope; did you mean \u2018std::string\u2019?\n   12 |     string s;\n\
    \      |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpbfm69my8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpbfm69my8.cpp:15:9:\
    \ error: \u2018s\u2019 was not declared in this scope\n   15 |         s = decimal_to_binary(decimal\
    \ / 2);\n      |         ^\n/tmp/tmpbfm69my8.cpp:18:5: error: \u2018s\u2019 was\
    \ not declared in this scope\n   18 |     s += std::to_string(decimal % 2);\n\
    \      |     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    int bin[1001];\n    int i;\n\
    \    std::string res;\n    for (i = 0; i < sizeof(bin) - 1; i++) {\n        bin[i]\
    \ = decimal % 2;\n        decimal /= 2;\n    }\n    res.insert(0, \"db\");\n \
    \   i = 0;\n    while (decimal) {\n        if (decimal > 0)\n            res[i++]\
    \ = '1';\n        else\n            res[i++] = '0';\n        decimal /= 2;\n \
    \   }\n    res.insert(i, 0);\n    return res;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  if (decimal < 0 || decimal\
    \ > 1000000)\n    return \"InvalidInput\";\n  if (decimal >= 1000)\n    return\
    \ decimal_to_binary(decimal / 1000) + \"db\"\n      + decimal_to_binary(decimal\
    \ % 1000);\n  return std::bitset<64>(decimal).to_binary();\n}\nint main() {\n\
    \    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2hwdo2jx.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp2hwdo2jx.cpp:17:35: error: \u2018class std::bitset<64>\u2019\
    \ has no member named \u2018to_binary\u2019\n   17 |   return std::bitset<64>(decimal).to_binary();\n\
    \      |                                   ^~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string result;\n   \
    \ int count = 1;\n    char ch;\n    while(decimal / 2 != 0)\n    {\n        ch\
    \ = decimal % 2;\n        result += (char)(count + ch);\n        decimal /= 2;\n\
    \        count++;\n    }\n    ch = decimal % 2;\n    result += (char)(count +\
    \ ch);\n    return result;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpzntxhwfv: /tmp/tmpzntxhwfv.cpp:28: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  // Do not write main() function.\n\
    \  // Do not read input, instead use the arguments to the function.\n  // Do not\
    \ print the output, instead return values as specified\n  // Still have a doubt.\
    \ Checkout www.interviewbit.com/pages/sample_codes/ for more details\n  // Author\
    \ : Abhishek Sharma\n  // Creation date : 20200814\n  \n  std::string binary =\
    \ \"\";\n  \n  while(decimal != 0){\n    int remainder = decimal%2;\n    binary\
    \ = remainder + \"1\" + binary;\n    decimal /= 2;\n  }\n  \n  return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp_jtjwgrl: /tmp/tmp_jtjwgrl.cpp:31: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    assert(decimal >= 0);\n \
    \   std::string binary = \"\";\n    int digit = decimal;\n    int carry = 0;\n\
    \    while (digit > 0) {\n        int tmp = digit % 2;\n        binary += (tmp\
    \ != 0 ? \"1\" : \"0\");\n        carry = tmp;\n        digit /= 2;\n    }\n \
    \   if (carry > 0) {\n        binary += \"1\";\n    }\n    if (binary.front()\
    \ != 'd' && binary.front() != 'D') {\n        binary = \"db\" + binary;\n    }\n\
    \    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp1rritp2j: /tmp/tmp1rritp2j.cpp:32: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary;\n   \
    \ int bits = decimal;\n    while (bits-- > 0) {\n        int current_bit = 0;\n\
    \        binary.push_back('0');\n        while ((bits > 0) && (current_bit < 2))\
    \ {\n            binary.push_back((bits % 2) == 0 ? '1' : '0');\n            bits\
    \ /= 2;\n            ++current_bit;\n        }\n    }\n    return binary;\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpbbk3hzwc: /tmp/tmpbbk3hzwc.cpp:27: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  std::bitset<64> binary(decimal);\n\
    \  return binary.to_string().substr(2);\n}\nint main() {\n    auto candidate =\
    \ decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmprfjkeeqt: /tmp/tmprfjkeeqt.cpp:17: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary_string;\n\
    \    while(decimal > 0) {\n        // Keep dividing decimal by 2 until you get\
    \ to 0 or 1.\n        if(decimal % 2 == 0) {\n            binary_string += '0';\n\
    \            decimal /= 2;\n        } else {\n            binary_string += '1';\n\
    \            decimal /= 2;\n        }\n    }\n    return binary_string + 'db';\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmps6xxbsgt.cpp:23:28: warning: multi-character character constant\
    \ [-Wmultichar]\n   23 |     return binary_string + 'db';\n      |           \
    \                 ^~~~\n/tmp/tmps6xxbsgt.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmps6xxbsgt.cpp:23:26: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018int\u2019)\n   23 |     return binary_string + 'db';\n      |    \
    \        ~~~~~~~~~~~~~ ^ ~~~~\n      |            |               |\n      | \
    \           |               int\n      |            std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmps6xxbsgt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmps6xxbsgt.cpp:23:28:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018int\u2019\n   23 |     return binary_string + 'd"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string res;\n    if\
    \ (decimal > 0 && decimal <= 9)\n        res = decimal_to_binary(decimal,'0');\n\
    \    else\n        res = decimal_to_binary(decimal,'1');\n    return res;\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsc1vznhx.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpsc1vznhx.cpp:14:44: error: too many arguments to function\
    \ \u2018std::string decimal_to_binary(long int)\u2019\n   14 |         res = decimal_to_binary(decimal,'0');\n\
    \      |                                            ^\n/tmp/tmpsc1vznhx.cpp:11:13:\
    \ note: declared here\n   11 | std::string decimal_to_binary(long decimal) {\n\
    \      |             ^~~~~~~~~~~~~~~~~\n/tmp/tmpsc1vznhx.cpp:16:44: error: too\
    \ many arguments to function \u2018std::string decimal_to_binary(long int)\u2019\
    \n   16 |         res = decimal_to_binary(decimal,'1');\n      |             \
    \                               ^\n/tmp/tmpsc1vznhx.cpp:11:13: note: declared\
    \ here\n   11 | std::string decimal_to_binary(long decimal) {\n      |       \
    \      ^~~~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code here\n    std::string\
    \ bin = \"\";\n    while(decimal != 0){\n        bin+= decimal%2;\n        decimal=decimal/2;\n\
    \    }\n    bin+= \"db\";\n    return bin;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpipidzbug: /tmp/tmpipidzbug.cpp:23: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\"\
    ;\n    while (decimal > 0) {\n        binary = std::bitset<sizeof(long)>::to_string(decimal);\n\
    \        decimal -= binary.size();\n    }\n    binary = binary + \"db\";\n   \
    \ return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n \
    \   assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplh8hehqj.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmplh8hehqj.cpp:14:62: error: cannot call member function\
    \ \u2018std::__cxx11::basic_string<_CharT> std::bitset<_Nb>::to_string(_CharT,\
    \ _CharT) const [with _CharT = long int; long unsigned int _Nb = 8]\u2019 without\
    \ object\n   14 |         binary = std::bitset<sizeof(long)>::to_string(decimal);\n\
    \      |                                                              ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code here\n    std::string\
    \ bin_string;\n    while (decimal != 0) {\n        if (decimal % 2 == 1) {\n \
    \           bin_string += \"1\";\n        } else {\n            bin_string +=\
    \ \"0\";\n        }\n        decimal /= 2;\n    }\n\n    bin_string = \"db\" +\
    \ bin_string;\n    return bin_string;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpaf2np6o9: /tmp/tmpaf2np6o9.cpp:28: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  std::bitset<long> bitset(decimal);\n\
    \  if (bitset.length() < 8) {\n    std::string binary = bitset.to_string();\n\
    \    std::string new_string = \"db\" + std::to_string(binary.size()) + \"db\"\
    ;\n    return new_string;\n  } else {\n    std::string binary = bitset.to_string();\n\
    \    std::string new_string = \"db\" + std::to_string(binary.size() - 8) + \"\
    db\";\n    return new_string;\n  }\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpskgjj34p.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpskgjj34p.cpp:12:19: error: type/value mismatch at argument\
    \ 1 in template parameter list for \u2018template<long unsigned int _Nb> class\
    \ std::bitset\u2019\n   12 |   std::bitset<long> bitset(decimal);\n      |   \
    \                ^\n/tmp/tmpskgjj34p.cpp:12:19: note:   expected a constant of\
    \ type \u2018long unsigned int\u2019, got \u2018long int\u2019\n/tmp/tmpskgjj34p.cpp:13:14:\
    \ error: request for member \u2018length\u2019 in \u2018bitset\u2019, which is\
    \ of non-class type \u2018int\u2019\n   13 |   if (bitset.length() < 8) {\n  \
    \    |              ^~~~~~\n/tmp/tmpskgjj34p.cpp:14:33: error: request for member\
    \ \u2018to_string\u2019 in \u2018bitset\u2019, which is of non-class type \u2018\
    int\u2019\n   14 |     std::string binary = bitset.to_string();\n      |     \
    \                            ^~~~~~~~~\n/tmp/tmpskgjj34p.cpp:18:33: error: request\
    \ for member \u2018to_string\u2019 in \u2018bitset\u2019, which is of non-class\
    \ type \u2018int\u2019\n   18 |     std::string binary = bitset.to_string();\n\
    \      |                                 ^~~~~~~~~\n/tmp/tmpskgjj34p.cpp:22:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   22 | }\n\
    \      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Complete the code here\n\
    \    std::string ret = \"db\";\n    long remainder = decimal % 2;\n    decimal\
    \ /= 2;\n    std::string remainderStr = \"db\";\n    while(remainder != 0) {\n\
    \        remainder = decimal % 2;\n        decimal /= 2;\n        std::string\
    \ remainderStr = std::to_string(remainder);\n        ret += remainderStr;\n  \
    \  }\n    ret += remainderStr;\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpdifa5xem: /tmp/tmpdifa5xem.cpp:28: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code here\n    int\
    \ binary = decimal;\n    std::string bin = std::bitset<sizeof(int) * CHAR_BIT>(\
    \ binary ).to_string();\n    std::string db = \"db\";\n    return db + bin + \"\
    db\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp63tsir9t: /tmp/tmp63tsir9t.cpp:20: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n\tassert(decimal > 0);\n\tstd::string\
    \ binary = \"\";\n\twhile (decimal) {\n\t\tbinary += (decimal % 2) + '0';\n\t\t\
    decimal /= 2;\n\t}\n\treturn \"db\" + binary + \"db\";\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpyse18sxz: /tmp/tmpyse18sxz.cpp:12: std::string decimal_to_binary(long\
    \ int): Assertion `decimal > 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    assert(decimal>=0);\n   \
    \ std::string binary=\"\";\n    int i=1;\n    int count=1;\n    while(decimal>0)\
    \ {\n        decimal=decimal/2;\n        binary=std::to_string(decimal)+binary;\n\
    \        count++;\n    }\n    while(count>0) {\n        binary=binary+\"0\";\n\
    \        count--;\n    }\n    binary+=\"db\";\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpjplcjxxf: /tmp/tmpjplcjxxf.cpp:30: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::bitset<long> bs(decimal);\n\
    \    std::string s = bs.to_string();\n    s = \"db\" + s;\n    return s;\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuma6oht_.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpuma6oht_.cpp:12:21: error: type/value mismatch at argument\
    \ 1 in template parameter list for \u2018template<long unsigned int _Nb> class\
    \ std::bitset\u2019\n   12 |     std::bitset<long> bs(decimal);\n      |     \
    \                ^\n/tmp/tmpuma6oht_.cpp:12:21: note:   expected a constant of\
    \ type \u2018long unsigned int\u2019, got \u2018long int\u2019\n/tmp/tmpuma6oht_.cpp:13:24:\
    \ error: request for member \u2018to_string\u2019 in \u2018bs\u2019, which is\
    \ of non-class type \u2018int\u2019\n   13 |     std::string s = bs.to_string();\n\
    \      |                        ^~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code goes here\n\
    \    int num_bits = 0;\n    int decimal_digits = (int)decimal;\n    long decimal_remainder\
    \ = decimal%2;\n    while(decimal_remainder>0){\n        decimal_remainder = decimal_remainder-2;\n\
    \        num_bits++;\n    }\n    std::string binary_rep = \"\";\n    for(int i\
    \ = num_bits-1; i>=0; i--){\n        binary_rep+=decimal_digits/pow(2,i);\n  \
    \      decimal_digits = decimal_digits - pow(2,i) * decimal_digits;\n    }\n \
    \   return binary_rep+decimal_digits;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_615navk.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp_615navk.cpp:25:22: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018int\u2019)\n   25 |     return binary_rep+decimal_digits;\n      |\
    \            ~~~~~~~~~~^~~~~~~~~~~~~~~\n      |            |          |\n    \
    \  |            |          int\n      |            std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp_615navk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp_615navk.cpp:25:23:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018int\u2019\n   25 |     return binary_rep+decimal_digits;\n      |\
    \                       ^~~~~~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \               "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\"\
    ;\n    // Write your code here\n    int counter = 0;\n    while (decimal != 0)\
    \ {\n        if (decimal % 2 == 0) {\n            binary += '1';\n        } else\
    \ {\n            binary += '0';\n        }\n        decimal /= 2;\n        counter++;\n\
    \    }\n    while (counter > 1) {\n        binary += '1';\n        counter--;\n\
    \    }\n    return binary + 'db';\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_uwc71ub.cpp:28:21: warning: multi-character character constant\
    \ [-Wmultichar]\n   28 |     return binary + 'db';\n      |                  \
    \   ^~~~\n/tmp/tmp_uwc71ub.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp_uwc71ub.cpp:28:19: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018int\u2019)\n   28 |     return binary + 'db';\n      |           \
    \ ~~~~~~ ^ ~~~~\n      |            |        |\n      |            |        int\n\
    \      |            std::string {aka std::__cxx11::basic_string<char>}\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp_uwc71ub.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp_uwc71ub.cpp:28:21:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018int\u2019\n   28 |     return binary + 'db';\n      |            \
    \         ^~~~\nIn file incl"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code here\n    std::bitset<64>\
    \ binary_str(decimal);\n    std::string output = \"db\";\n    for(unsigned int\
    \ i = 0; i < 64; i++) {\n        if(binary_str[i] == 1) output += \"1\";\n   \
    \     else output += \"0\";\n    }\n    output += \"db\";\n    return output;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp1a35czax: /tmp/tmp1a35czax.cpp:24: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string bin;\n    int\
    \ num = decimal;\n    while(num > 0) {\n        int rem = num % 2;\n        num\
    \ = num / 2;\n        bin = rem + bin;\n    }\n    return bin;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1r92lumx.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp1r92lumx.cpp:17:19: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   17 |         bin = rem + bin;\n      |               ~~~ ^ ~~~\n      |\
    \               |     |\n      |               int   std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp1r92lumx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp1r92lumx.cpp:17:21:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   17\
    \ |         bin = rem + bin;\n      |                     ^~~\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  std::string ans;\n  int decimal_val\
    \ = decimal;\n  std::string binary;\n  while (decimal_val > 0) {\n    binary.push_back('0');\n\
    \    decimal_val = decimal_val / 2;\n  }\n\n  while (decimal_val > 0) {\n    binary.push_back('1');\n\
    \    decimal_val = decimal_val / 2;\n  }\n\n  ans = binary + \"db\";\n  return\
    \ ans;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpw_44p_3p: /tmp/tmpw_44p_3p.cpp:30: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"db\"\
    ;\n  for (int i = 0; i < 32; i++) {\n    if (decimal % 2 == 0) {\n      binary[32\
    \ - i - 1] = binary + '1';\n    } else {\n      binary[32 - i - 1] = binary +\
    \ '0';\n    }\n    decimal /= 2;\n  }\n  return binary;\n}\nint main() {\n   \
    \ auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt2krrqa0.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpt2krrqa0.cpp:15:35: error: cannot convert \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} in assignment\n   15 |       binary[32 - i - 1] = binary\
    \ + '1';\n      |                            ~~~~~~~^~~~~\n      |           \
    \                        |\n      |                                   std::__cxx11::basic_string<char>\n\
    /tmp/tmpt2krrqa0.cpp:17:35: error: cannot convert \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} in assignment\n   17 |       binary[32 - i - 1] = binary\
    \ + '0';\n      |                            ~~~~~~~^~~~~\n      |           \
    \                        |\n      |                                   std::__cxx11::basic_string<char>\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n   assert(decimal >= 0); // Make\
    \ sure that your decimal number >= 0.\n   std::string binary = \"\";\n   while\
    \ (decimal != 0) {\n      if (decimal % 2 == 0) {\n         binary += \"1\";\n\
    \      }\n      else {\n         binary += \"0\";\n      }\n      decimal /= 2;\n\
    \   }\n   return binary + \"db\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpq4eugvvl: /tmp/tmpq4eugvvl.cpp:27: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  if(decimal == 0) return std::string(\"\
    db0\");\n  if(decimal > 0 && decimal < 25) return decimal_to_binary(decimal *\
    \ 2);\n  if(decimal >= 25 && decimal < 67) return decimal_to_binary(decimal -\
    \ 25) * 2 + std::string(\"db\");\n  if(decimal >= 67 && decimal < 100) return\
    \ decimal_to_binary(decimal - 67) * 2 + std::string(\"db\");\n  if(decimal >=\
    \ 100) return decimal_to_binary(decimal - 100) * 2;\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbgmhvr_f.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpbgmhvr_f.cpp:14:76: error: no match for \u2018operator*\u2019\
    \ (operand types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018int\u2019)\n   14 |   if(decimal >= 25 && decimal < 67) return decimal_to_binary(decimal\
    \ - 25) * 2 + std::string(\"db\");\n      |                                  \
    \          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~\n      |                      \
    \                                       |                |\n      |          \
    \                                                   |                int\n   \
    \   |                                                             std::string\
    \ {aka std::__cxx11::basic_string<char>}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpbgmhvr_f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:387:5:\
    \ note: candidate: \u2018template<class _Tp> std::complex<_Tp> std::operator*(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  387 |     operator*(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:387:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpbgmhvr_f.cpp:14:78:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   14 |   if(decimal\
    \ >= 25 && decimal < 67) return decimal_to_binary(decimal - 25) * 2 + std::string(\"\
    db\");\n      |                                                              \
    \                ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpbgmhvr_f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:396:5:\
    \ note: candidate: \u2018template<class _Tp> s"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string str = \"\";\n\
    \    int pow = 1;\n    int decimalLength = std::ceil((double)decimal / 2.0);\n\
    \    double decimalToBinary = decimal;\n    if (decimalLength == 0) {\n      \
    \  decimalToBinary = decimal;\n    }\n    for (int i = 0; i < decimalLength; i++)\
    \ {\n        if (decimalToBinary % 2 != 0) {\n            str += '1';\n      \
    \  } else {\n            str += '0';\n        }\n        decimalToBinary /= 2;\n\
    \        pow *= 2;\n    }\n\n    str = str.substr(0, str.size() - 1);\n\n    if\
    \ (decimal < 0) {\n        str = \"-\" + str;\n    }\n    std::string binary =\
    \ \"\";\n    int length = str.size();\n    for (int i = 0; i < length; i += 2)\
    \ {\n        if (str[i] == '1') {\n            binary += '0';\n        } else\
    \ {\n            binary += '1';\n        }\n    }\n    std::string returnStr =\
    \ binary + \"db\" + str;\n    return returnStr;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkqb44tvz.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpkqb44tvz.cpp:20:29: error: invalid operands of types \u2018\
    double\u2019 and \u2018int\u2019 to binary \u2018operator%\u2019\n   20 |    \
    \     if (decimalToBinary % 2 != 0) {\n      |             ~~~~~~~~~~~~~~~ ^ ~\n\
    \      |             |                 |\n      |             double         \
    \   int\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string bin_string =\
    \ \"\";\n    while (decimal > 0) {\n        bin_string = std::to_string(decimal%2)\
    \ + bin_string;\n        decimal /= 2;\n    }\n    return bin_string + \"db\"\
    ;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp74s0h8cc: /tmp/tmp74s0h8cc.cpp:21: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n\tstd::string binary_string;\n\
    \twhile (decimal > 0) {\n\t\tbinary_string.pop_back();\n\t\tdecimal %= 2;\n\t\t\
    binary_string.pop_back();\n\t}\n\treturn \"db\" + binary_string + \"db\";\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpezg7466l: /tmp/tmpezg7466l.cpp:22: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string res;\n    \n\
    \    if(decimal == 0){\n        res.push_back('0');\n        res.push_back('0');\n\
    \        res.push_back('0');\n        res.push_back('0');\n        res.push_back('0');\n\
    \        res.push_back('0');\n        res.push_back('0');\n        return res;\n\
    \    }\n    \n    if(decimal > 0){\n        res.push_back('1');\n        res.push_back('0');\n\
    \        res.push_back('0');\n    }\n    \n    if(decimal % 2 == 0){\n       \
    \ while(decimal > 0){\n            if(decimal % 2 == 0){\n                res.push_back('1');\n\
    \                decimal /= 2;\n            }\n            else {\n          \
    \      res.push_back('0');\n                decimal /= 2;\n            }\n   \
    \     }\n    }\n    \n    return res;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpdt7p4vdu: /tmp/tmpdt7p4vdu.cpp:48: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    int num = 0;\n    bool flag\
    \ = true;\n    std::string binary = \"\";\n    while (decimal != 0) {\n      \
    \  if (decimal%2 == 1) {\n            num += 1;\n        }\n        decimal /=\
    \ 2;\n    }\n    do {\n        if (num%2 == 0) {\n            binary += \"0\"\
    ;\n        } else {\n            binary += \"1\";\n        }\n        num/=2;\n\
    \    } while (num > 0);\n    std::string extra_characters = \"db\";\n    binary.insert(binary.length()-extra_characters.length(),\
    \ extra_characters);\n    return binary;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::replace: __pos (which is 18446744073709551615) > this->size()\
    \ (which is 1)\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary;\n   \
    \ // This will be used to store the individual bits.\n    unsigned long binary_number\
    \ = 0, digit;\n    // This will be used to store a single digit of the number.\n\
    \    unsigned long binary_digit = 0;\n    // This will be used to keep track of\
    \ how many characters to add to the binary.\n    unsigned long binary_digits_count\
    \ = 0;\n    while (decimal > 0) {\n        // This will be used to store the last\
    \ digit of the decimal number\n        binary_digit = decimal % 2;\n        binary_digit\
    \ = binary_digit << 1;\n        // This will be used to store the last digit of\
    \ the decimal number.\n        decimal /= 2;\n        // This will be used to\
    \ store the binary digit of the decimal number.\n        binary_number += binary_digit;\n\
    \        // This will be used to store the binary digit of the decimal number.\n\
    \        binary_digits_count++;\n    }\n    if (binary_number == 0 || binary_digits\
    \ == 0) {\n        binary_digits_count = 1;\n    }\n    binary_number >>= (binary_digits_count\
    \ - 1);\n    // This will be used to store the final binary digit.\n    binary_digit\
    \ = 0;\n    // This will be used to store the number of digits that will be added\
    \ to the binary.\n    unsigned long binary_digits_count2 = 0;\n    std::string\
    \ binary_string = \"\";\n    // This will be used to store the final binary number.\n\
    \    unsigned long binary_number2 = 0;\n    // This will be used to store the\
    \ final binary number.\n    unsigned long binary_digit2 = 0;\n    // This will\
    \ be used to store the final binary number.\n    unsigned long binary_number3\
    \ = 0;\n    while (binary_number != 0) {\n        // This will be used to store\
    \ the binary digit.\n        binary_digit = binary_number % 2;\n        binary_number\
    \ /= 2;\n        // This will be used to add the binary digit to the binary string.\n\
    \        binary_string += binary_digit;\n        binary_digits_count2++;\n   \
    \ }\n    // This will be used to store the final binary digit.\n    binary_digit\
    \ = 0;\n    // This will be used to store the final binary number.\n    binary_number2\
    \ = 0;\n    binary_digit2 = 0;\n    binary_number3 = 0;\n    while (binary_digits_count\
    \ != binary_digits_count2) {\n        // This will be used to store the binary\
    \ digit.\n        binary_digit = binary_number % 2;\n        binary_number /=\
    \ 2;\n        // This will be used to add the binary digit to the binary string.\n\
    \        binary_string += binary_digit;\n        binary_digit2++;\n    }\n   \
    \ // This will be used to store the final binary number.\n    binary_number3 =\
    \ 0;\n    binary_digit2 = 0;\n    while (binary_number != 0) {\n        // This\
    \ will be used to store the binary digit.\n        binary_digit = binary_number\
    \ % 2;\n        binary_number /= 2;\n        // This will be used to add the binary\
    \ digit to the binary string.\n        binary_string += binary_digit;\n      \
    \  binary_number3++;\n    }\n    binary += binary_string;\n    // This will be\
    \ used to store the extra characters added to the bin\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp93xjybpp.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp93xjybpp.cpp:30:31: error: \u2018binary_digits\u2019 was\
    \ not declared in this scope; did you mean \u2018binary_digit\u2019?\n   30 |\
    \     if (binary_number == 0 || binary_digits == 0) {\n      |               \
    \                ^~~~~~~~~~~~~\n      |                               binary_digit\n\
    /tmp/tmp93xjybpp.cpp:80:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n   80 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    long base = 2;\n    long\
    \ power = 1;\n    std::string binary = \"\";\n    while (decimal != 0) {\n   \
    \     decimal %= base;\n        binary = binary + (decimal / base);\n        decimal\
    \ /= base;\n        base *= 2;\n        power *= 2;\n    }\n    binary = binary\
    \ + (power - 1);\n    binary = binary + \"db\";\n    return binary;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphh6hgpfq.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmphh6hgpfq.cpp:17:25: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018long int\u2019)\n   17 |         binary = binary + (decimal / base);\n\
    \      |                  ~~~~~~ ^ ~~~~~~~~~~~~~~~~\n      |                 \
    \ |                 |\n      |                  |                 long int\n \
    \     |                  std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmphh6hgpfq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmphh6hgpfq.cpp:17:42:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018long int\u2019\n   17 |         binary = binary + (decimal / base);\n\
    \      |                                          ^\nIn file included from /shared/centos7/gcc/"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\"\
    ;\n    int decimal_value = decimal;\n    int remainder;\n    while (remainder\
    \ != 0) {\n        remainder = decimal_value % 2;\n        decimal_value = decimal_value\
    \ / 2;\n        binary = \"1\" + binary;\n        if (remainder == 0) {\n    \
    \        binary = \"0\" + binary;\n        }\n    }\n    return \"db\" + binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp8ha1h3po: /tmp/tmp8ha1h3po.cpp:27: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary;\n   \
    \ while (decimal != 0) {\n        binary.push_back('0');\n        decimal /= 2;\n\
    \    }\n    if (binary != \"\") {\n        binary.push_back('d');\n    }\n   \
    \ if (binary.length() != 5) {\n        binary.push_back('0');\n        binary.push_back('b');\n\
    \    }\n    std::string str = binary;\n    str.insert(0, \"db\");\n    return\
    \ str;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpnlr_hyg5: /tmp/tmpnlr_hyg5.cpp:30: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    int ones = 0, tens = 0;\n\
    \    while(decimal / 2 != 0) {\n        decimal /= 2;\n        tens++;\n    }\n\
    \    while(decimal > 0 && decimal / 10 != 0) {\n        decimal /= 10;\n     \
    \   ones++;\n    }\n    int str_size = ones * 2 + tens * 2;\n    std::string str(str_size,\
    \ 'b');\n    long temp = decimal % 2;\n    while(temp != 0) {\n        str +=\
    \ '0' + (temp % 2);\n        temp = temp / 2;\n    }\n    return std::string(\"\
    db\") + str + std::string(\"db\");\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpmik8elr_: /tmp/tmpmik8elr_.cpp:32: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string str;\n    long\
    \ rem;\n    long counter = 0;\n    while (decimal > 0)\n    {\n        rem = decimal\
    \ % 2;\n        decimal /= 2;\n        counter++;\n        str += '0' + rem;\n\
    \    }\n    str.pop_back();\n    while (counter > 0)\n    {\n        str += '0';\n\
    \        counter--;\n    }\n    str.pop_back();\n    str += 'd';\n    str += 'b';\n\
    \    return str;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n \
    \   assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    char bin[32];\n    sprintf(bin,\
    \ \"%ld\", decimal);\n    std::string ans = bin;\n    ans.insert(0, \"db\");\n\
    \    ans.erase(ans.size() - 2, 2);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpr_p0woiu: /tmp/tmpr_p0woiu.cpp:21: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary_string\
    \ = \"\";\n    for(long x = decimal; x > 0; x--) {\n        binary_string = (x\
    \ % 2) + binary_string;\n        x /= 2;\n    }\n    return binary_string;\n}\n\
    int main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp25bjs1pu.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp25bjs1pu.cpp:14:33: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019})\n   14 |         binary_string = (x %\
    \ 2) + binary_string;\n      |                         ~~~~~~~ ^ ~~~~~~~~~~~~~\n\
    \      |                            |      |\n      |                        \
    \    |      std::string {aka std::__cxx11::basic_string<char>}\n      |      \
    \                      long int\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp25bjs1pu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp25bjs1pu.cpp:14:35:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   14\
    \ |         binary_string = (x % 2) + binary_string;\n      |                \
    \    "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    int base = 10;\n    std::string\
    \ binary = \"\";\n    while (decimal > 0)\n    {\n        binary += (decimal %\
    \ base) ? \"1\" : \"0\";\n        decimal /= base;\n    }\n    binary.insert(0,\
    \ \"db\");\n    return binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpjpypjs7y: /tmp/tmpjpypjs7y.cpp:24: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    string bin;\n    int i =\
    \ decimal;\n    while (i > 0)\n    {\n        int remainder = i % 2;\n       \
    \ bin = to_string(remainder) + bin;\n        i = i / 2;\n    }\n    int i = decimal;\n\
    \    bin = to_string(i) + bin;\n    bin = bin.substr(0, bin.length() - 1);\n \
    \   bin = std::string(2, 'b') + bin + std::string(2, 'b');\n    return bin;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplx1vzegr.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmplx1vzegr.cpp:12:5: error: \u2018string\u2019 was not declared\
    \ in this scope; did you mean \u2018std::string\u2019?\n   12 |     string bin;\n\
    \      |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmplx1vzegr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmplx1vzegr.cpp:17:9:\
    \ error: \u2018bin\u2019 was not declared in this scope; did you mean \u2018sin\u2019\
    ?\n   17 |         bin = to_string(remainder) + bin;\n      |         ^~~\n  \
    \    |         sin\n/tmp/tmplx1vzegr.cpp:17:15: error: \u2018to_string\u2019 was\
    \ not declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019\
    ?\n   17 |         bin = to_string(remainder) + bin;\n      |               ^~~~~~~~~\n\
    \      |               std::__cxx11::to_string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-sk"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"0\"\
    ;\n    while (decimal != 0) {\n        int remainder = decimal % 2;\n        decimal\
    \ /= 2;\n        binary = to_string(remainder) + binary;\n    }\n    binary =\
    \ binary + \"db\";\n    return binary;\n}\nint main() {\n    auto candidate =\
    \ decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpikbsvkhi.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpikbsvkhi.cpp:16:18: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   16 |         binary = to_string(remainder) + binary;\n      |            \
    \      ^~~~~~~~~\n      |                  std::__cxx11::to_string\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpikbsvkhi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6598:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6598 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string bin;\n    std::stringstream\
    \ ss;\n    bool end = false;\n    long d = decimal;\n    while (!end) {\n    \
    \    int n = (int)(d % 2);\n        bin = to_string(1) + to_string(n - 1);\n \
    \       ss << bin;\n        d /= 2;\n        end = (d == 0);\n    }\n    ss <<\
    \ to_string(1);\n    std::string str = ss.str();\n    std::string db = \"db\"\
    ;\n    str = db + str;\n    return str;\n}\nint main() {\n    auto candidate =\
    \ decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9e8vjr72.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp9e8vjr72.cpp:18:15: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   18 |         bin = to_string(1) + to_string(n - 1);\n      |             \
    \  ^~~~~~~~~\n      |               std::__cxx11::to_string\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9e8vjr72.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6598:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6598 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmp9e8vjr72.cpp:23:11: error: \u2018\
    to_string\u2019 was not declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019\
    ?\n   23 |     ss << to_string(1);\n      |           ^~~~~~~~~\n      |     \
    \      std::__cxx11::to_string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code goes here\n\
    \    std::string output = \"db\";\n    while(decimal != 0){\n        decimal %=\
    \ 2;\n        output = (char)output+'0'+decimal;\n        decimal /= 2;\n    }\n\
    \    if(decimal % 2 != 0) output += '1';\n    output += 'db';\n    return output;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpd_co0u28.cpp:20:15: warning: multi-character character constant\
    \ [-Wmultichar]\n   20 |     output += 'db';\n      |               ^~~~\n/tmp/tmpd_co0u28.cpp:\
    \ In function \u2018std::string decimal_to_binary(long int)\u2019:\n/tmp/tmpd_co0u28.cpp:16:24:\
    \ error: invalid cast from type \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to type \u2018char\u2019\n   16 |         output = (char)output+'0'+decimal;\n\
    \      |                        ^~~~~~\n/tmp/tmpd_co0u28.cpp:20:15: warning: overflow\
    \ in conversion from \u2018int\u2019 to \u2018char\u2019 changes value from \u2018\
    25698\u2019 to \u2018'b'\u2019 [-Woverflow]\n   20 |     output += 'db';\n   \
    \   |               ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Write code here\n    std::string\
    \ result;\n    long temp = decimal;\n    if (decimal < 0) {\n        temp = -decimal;\n\
    \        result += \"b\";\n    }\n    while (temp != 0) {\n        result += (temp\
    \ % 2) + '0';\n        temp /= 2;\n    }\n    if (temp != 0) {\n        result\
    \ += \"b\";\n    }\n    return result + 'a';\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp018gofd3: /tmp/tmp018gofd3.cpp:30: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  // Write your code here\n \
    \ std::string result = \"\";\n  int count = 0;\n  while(decimal > 0) {\n    count++;\n\
    \    decimal /= 2;\n  }\n  for (int i = count-1; i >= 0; i--) {\n    result +=\
    \ to_string((decimal%2) + '0');\n    decimal = (decimal/2)-1;\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx0qguukl.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpx0qguukl.cpp:20:15: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   20 |     result += to_string((decimal%2) + '0');\n      |               ^~~~~~~~~\n\
    \      |               std::__cxx11::to_string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx0qguukl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6598:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6598 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  long long val = decimal;\n\
    \  std::string res;\n  while (val > 0) {\n    res.push_back((val % 2 == 1) ? '0'\
    \ : '1');\n    val = val / 2;\n  }\n  res.insert(res.begin(), 'd');\n  res.insert(res.end(),\
    \ 'b');\n  return res;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpxjzeyeag: /tmp/tmpxjzeyeag.cpp:24: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n\tassert (decimal >= 0 && decimal\
    \ <= pow(2, sizeof(long int) * 8));\n\tstd::string binary;\n\tfor (int i = 0;\
    \ i < sizeof(long int) * 8; i++) {\n\t\tif ((decimal & (1L << i)) != 0)\n\t\t\t\
    binary.push_back('1');\n\t\telse\n\t\t\tbinary.push_back('0');\n\t}\n\tbinary.insert(binary.begin(),\
    \ 'b');\n\tbinary.push_back('\\0');\n\treturn binary;\n}\nint main() {\n    auto\
    \ candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n\
    \    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpwhhbd3vm: /tmp/tmpwhhbd3vm.cpp:26: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary;\n   \
    \ int temp = decimal;\n    while (temp != 0) {\n        binary += temp % 2;\n\
    \        temp /= 2;\n    }\n    binary = \"db\" + binary + \"db\";\n    return\
    \ binary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmphb5osue3: /tmp/tmphb5osue3.cpp:23: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    string binary = \"0\";\n\
    \    while (decimal > 0) {\n        if (decimal & 1) {\n            binary +=\
    \ \"1\";\n        } else {\n            binary += \"0\";\n        }\n        decimal\
    \ = decimal >> 1;\n    }\n    return \"db\" + binary + \"db\";\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaw0l0tu8.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpaw0l0tu8.cpp:12:5: error: \u2018string\u2019 was not declared\
    \ in this scope; did you mean \u2018std::string\u2019?\n   12 |     string binary\
    \ = \"0\";\n      |     ^~~~~~\n      |     std::string\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n           \
    \      from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n    \
    \             from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpaw0l0tu8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpaw0l0tu8.cpp:15:13:\
    \ error: \u2018binary\u2019 was not declared in this scope\n   15 |          \
    \   binary += \"1\";\n      |             ^~~~~~\n/tmp/tmpaw0l0tu8.cpp:17:13:\
    \ error: \u2018binary\u2019 was not declared in this scope\n   17 |          \
    \   binary += \"0\";\n      |             ^~~~~~\n/tmp/tmpaw0l0tu8.cpp:21:19:\
    \ error: \u2018binary\u2019 was not declared in this scope\n   21 |     return\
    \ \"db\" + binary + \"db\";\n      |                   ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string result = \"\"\
    ;\n    bool isEven = true;\n    long temp = decimal;\n    while(temp > 0) {\n\
    \        if(isEven) {\n            result += to_string(temp % 2);\n          \
    \  isEven = false;\n        }\n        temp /= 2;\n        isEven = true;\n  \
    \  }\n    return \"db\" + result + \"db\";\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3bqc8oym.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp3bqc8oym.cpp:17:23: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   17 |             result += to_string(temp % 2);\n      |                 \
    \      ^~~~~~~~~\n      |                       std::__cxx11::to_string\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp3bqc8oym.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6598:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6598 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  if (decimal < 0) {\n    decimal\
    \ = -decimal;\n  }\n\n  // Convert decimal to binary.\n  std::string binary =\
    \ std::bitset<64>(decimal).to_string();\n\n  // Remove leading and trailing 0s\
    \ and add extra characters.\n  for (size_t i = 0; i < binary.size(); i++) {\n\
    \    if (binary[i] == '0') {\n      binary.erase(i);\n      binary.insert(i, 'b');\n\
    \      binary.insert(i, 'e');\n      binary.insert(i, 'x');\n      binary.insert(i,\
    \ 'y');\n      binary.insert(i, 'z');\n    }\n  }\n  binary.insert(0, \"db\");\n\
    \  binary.append(\"db\");\n  return binary;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr88fafz0.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpr88fafz0.cpp:23:27: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(size_t&, char)\u2019\n   23\
    \ |       binary.insert(i, 'b');\n      |                           ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpr88fafz0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1534:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::stringstream ss;\n \
    \   ss << \"db\" << std::bitset<32>(decimal).to_string();\n    return ss.str();\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmppg1x4t43: /tmp/tmppg1x4t43.cpp:18: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  std::string binary_string;\n\
    \  for(int i=0;i<decimal;++i){\n    binary_string+=(decimal%2==0)?\"1\":\"0\"\
    ;\n    decimal/=2;\n  }\n  return binary_string;\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpnnkrcmsq: /tmp/tmpnnkrcmsq.cpp:21: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string result = \"\"\
    ;\n    while(decimal > 0)\n    {\n        result = (decimal % 2 == 0) ? \"0\"\
    \ : \"1\";\n        decimal /= 2;\n    }\n    result.insert(0, \"db\");\n    result.append(\"\
    db\");\n    return result;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp2yyk07l1: /tmp/tmp2yyk07l1.cpp:24: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\"\
    ;\n    int number = decimal;\n    while (decimal != 0) {\n        binary += \"\
    1\";\n        if (decimal % 2 == 0) decimal /= 2;\n        else decimal /= 2;\n\
    \    }\n    std::string db = \"db\";\n    binary = db + binary;\n    return binary;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp5r_30iet: /tmp/tmp5r_30iet.cpp:25: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string bin_str;\n  \
    \  while (decimal > 0) {\n        bin_str += '0' + decimal % 2;\n        decimal\
    \ /= 2;\n    }\n    bin_str += '0';\n    return bin_str;\n}\nint main() {\n  \
    \  auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpr82h2gj2: /tmp/tmpr82h2gj2.cpp:22: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    int binary_string = 0;\n\
    \    while (decimal > 1) {\n        binary_string++;\n        decimal = decimal\
    \ * 2;\n    }\n    std::string binary_string;\n    for (int i = binary_string;\
    \ i >= 0; i--) {\n        if (decimal % 2 == 0) {\n            binary_string =\
    \ \"0\" + binary_string;\n        }\n        else {\n            binary_string\
    \ = \"1\" + binary_string;\n        }\n        decimal = decimal / 2;\n    }\n\
    \    return binary_string;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7ljhyczq.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp7ljhyczq.cpp:17:17: error: conflicting declaration \u2018\
    std::string binary_string\u2019\n   17 |     std::string binary_string;\n    \
    \  |                 ^~~~~~~~~~~~~\n/tmp/tmp7ljhyczq.cpp:12:9: note: previous\
    \ declaration as \u2018int binary_string\u2019\n   12 |     int binary_string\
    \ = 0;\n      |         ^~~~~~~~~~~~~\n/tmp/tmp7ljhyczq.cpp:20:33: error: invalid\
    \ conversion from \u2018const char*\u2019 to \u2018int\u2019 [-fpermissive]\n\
    \   20 |             binary_string = \"0\" + binary_string;\n      |         \
    \                    ~~~~^~~~~~~~~~~~~~~\n      |                            \
    \     |\n      |                                 const char*\n/tmp/tmp7ljhyczq.cpp:23:33:\
    \ error: invalid conversion from \u2018const char*\u2019 to \u2018int\u2019 [-fpermissive]\n\
    \   23 |             binary_string = \"1\" + binary_string;\n      |         \
    \                    ~~~~^~~~~~~~~~~~~~~\n      |                            \
    \     |\n      |                                 const char*\n/tmp/tmp7ljhyczq.cpp:27:12:\
    \ error: could not convert \u2018binary_string\u2019 from \u2018int\u2019 to \u2018\
    std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\n   27 |\
    \     return binary_string;\n      |            ^~~~~~~~~~~~~\n      |       \
    \     |\n      |            int\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n// Your code here\n    \n   \
    \ std::string result = std::bitset<32>(decimal).to_string();\n    result.insert(result.begin(),\
    \ 'd');\n    result.insert(result.end(), 'b');\n    return result;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpyb8hlt__: /tmp/tmpyb8hlt__.cpp:21: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Complete the implementation\
    \ here\n    // You can use the bitset library to store the results in a string\
    \ and remove the\n    // extra characters.\n    std::string res = \"\";\n    int\
    \ base = 1;\n    while (decimal != 0) {\n        res += (decimal % 2) == 0 ? \"\
    0\" : \"1\";\n        decimal /= 2;\n        base *= 2;\n    }\n    if (base ==\
    \ 1) {\n        res = \"db\" + res;\n    } else {\n        res = \"db\" + res\
    \ + std::bitset<64>(base).to_string();\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpmbm5h3oa: /tmp/tmpmbm5h3oa.cpp:31: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::bitset<64> bs = decimal;\n\
    \    return std::to_string(bs);\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy171h3g1.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpy171h3g1.cpp:13:29: error: no matching function for call\
    \ to \u2018to_string(std::bitset<64>&)\u2019\n   13 |     return std::to_string(bs);\n\
    \      |                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy171h3g1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6546:3:\
    \ note: candidate: \u2018std::string std::__cxx11::to_string(int)\u2019\n 6546\
    \ |   to_string(int __val)\n      |   ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6546:17:\
    \ note:   no known conversion for argument 1 from \u2018std::bitset<64>\u2019\
    \ to \u2018int\u2019\n 6546 |   to_string(int __val)\n      |             ~~~~^~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6551:3:\
    \ note: candidate: \u2018std::string std::__cxx11::to_string(unsigned int)\u2019\
    \n 6551 |   to_string(unsigned __val)\n      |   ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6551:22:\
    \ note:   no known conversion for argument 1 from \u2018std::bitset<64>\u2019\
    \ to \u2018unsigned int\u2019\n 6551 |   to_string(unsigned __val)\n      |  \
    \           ~~~~~~~~~^~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6557:3:\
    \ not"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code here\n    long\
    \ temp = 0;\n    temp= decimal;\n    for(int i = 0;i<8;i++){\n        int digit\
    \ = temp % 2;\n        string digits = to_string(digit);\n        temp = temp/2;\n\
    \        return digits + \"db\";\n    }\n    return \"error\";\n}\nint main()\
    \ {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"\
    db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmlgp0_c6.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpmlgp0_c6.cpp:17:9: error: \u2018string\u2019 was not declared\
    \ in this scope; did you mean \u2018std::string\u2019?\n   17 |         string\
    \ digits = to_string(digit);\n      |         ^~~~~~\n      |         std::string\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpmlgp0_c6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpmlgp0_c6.cpp:19:16:\
    \ error: \u2018digits\u2019 was not declared in this scope; did you mean \u2018\
    digit\u2019?\n   19 |         return digits + \"db\";\n      |               \
    \ ^~~~~~\n      |                digit\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary;\n   \
    \ binary.reserve(64);\n    while (decimal != 0) {\n        int remainder = decimal\
    \ % 2;\n        decimal /= 2;\n        binary.push_back(to_string(remainder));\n\
    \    }\n    binary.push_back(\"db\");\n    return binary;\n}\nint main() {\n \
    \   auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmvmybrxa.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpmvmybrxa.cpp:17:26: error: \u2018to_string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::__cxx11::to_string\u2019?\n\
    \   17 |         binary.push_back(to_string(remainder));\n      |            \
    \              ^~~~~~~~~\n      |                          std::__cxx11::to_string\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpmvmybrxa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6598:3:\
    \ note: \u2018std::__cxx11::to_string\u2019 declared here\n 6598 |   to_string(long\
    \ double __val)\n      |   ^~~~~~~~~\n/tmp/tmpmvmybrxa.cpp:19:22: error: invalid\
    \ conversion from \u2018const char*\u2019 to \u2018char\u2019 [-fpermissive]\n\
    \   19 |     binary.push_back(\"db\");\n      |                      ^~~~\n  \
    \    |                      |\n      |                      const char*\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    assert(decimal != -1);\n\
    \    std::string binary = \"\";\n    while (decimal != 0) {\n        if (decimal\
    \ % 2 == 0)\n            binary += \"1\";\n        else\n            binary +=\
    \ \"0\";\n        decimal /= 2;\n    }\n    return \"db\" + binary + \"db\";\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp0qtpxzq8: /tmp/tmp0qtpxzq8.cpp:25: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  char string[30];\n  string[0]\
    \ = 'b';\n  string[1] = '\\0';\n\n  for (int i = 2; i <= 30; i++) {\n    string[i]\
    \ = '0';\n  }\n\n  if (decimal < 0) {\n    string[2] = '1';\n    string[30] =\
    \ '1';\n    return string;\n  }\n\n  string[2] = '0';\n  int count = 0;\n  while\
    \ (decimal > 0) {\n    count++;\n    decimal /= 2;\n  }\n\n  string += count;\n\
    \n  count = 0;\n  while (decimal > 0) {\n    count++;\n    decimal /= 2;\n  }\n\
    \n  while (count > 1) {\n    string += '0';\n    count -= 1;\n  }\n\n  return\
    \ string;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkkgpz09l.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpkkgpz09l.cpp:33:13: error: incompatible types in assignment\
    \ of \u2018int\u2019 to \u2018char [30]\u2019\n   33 |   string += count;\n  \
    \    |             ^~~~~\n/tmp/tmpkkgpz09l.cpp:42:15: error: incompatible types\
    \ in assignment of \u2018char\u2019 to \u2018char [30]\u2019\n   42 |     string\
    \ += '0';\n      |               ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  if (decimal == 0)\n    return\
    \ \"0\";\n  std::string binary = \"\";\n  while (decimal > 0) {\n    decimal /=\
    \ 2;\n    binary = binary + (decimal % 2);\n  }\n  return \"db\" + binary + \"\
    db\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph9xgwhmc.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmph9xgwhmc.cpp:17:21: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018long int\u2019)\n   17 |     binary = binary + (decimal % 2);\n  \
    \    |              ~~~~~~ ^ ~~~~~~~~~~~~~\n      |              |           \
    \      |\n      |              |                 long int\n      |           \
    \   std::string {aka std::__cxx11::basic_string<char>}\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmph9xgwhmc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmph9xgwhmc.cpp:17:35:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018long int\u2019\n   17 |     binary = binary + (decimal % 2);\n   \
    \   |                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    if (decimal > 1) {\n    \
    \    std::string binary = decimal_to_binary(decimal / 2);\n        return binary\
    \ + std::to_string(decimal) % 2;\n    } else if (decimal == 1) {\n        return\
    \ \"0\";\n    }\n    return \"1\";\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzp_nk0ph.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpzp_nk0ph.cpp:14:49: error: no match for \u2018operator%\u2019\
    \ (operand types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018int\u2019)\n   14 |         return binary + std::to_string(decimal)\
    \ % 2;\n      |                         ~~~~~~~~~~~~~~~~~~~~~~~ ^ ~\n      | \
    \                                      |           |\n      |                \
    \                       |           int\n      |                             \
    \          std::string {aka std::__cxx11::basic_string<char>}\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:603,\n   \
    \              from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpzp_nk0ph.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/valarray_after.h:409:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__modulus,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__modulus, typename\
    \ _Dom1::value_type>::result_type> std::operator%(const std::_Expr<_Dom1, typename\
    \ _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  409 |     _DEFINE_EXPR_BINARY_OPERATOR(%, __modulus)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/valarray_after.h:409:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpzp_nk0ph.cpp:14:51:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   14 |         return binary + std::to_string(decimal) % 2;\n      |      \
    \                                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:603,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpzp_nk0ph.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    if (decimal < 0 || decimal\
    \ >= 2000000000) {\n        cout << \"Bad input!\" << endl;\n        return \"\
    \";\n    }\n    if (decimal % 2 == 0) {\n        return decimal_to_binary(decimal\
    \ / 2) + str((decimal % 2), '1');\n    } else {\n        return decimal_to_binary(decimal\
    \ / 2) + '0' + str((decimal % 2), '1');\n    }\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr1_x4igr.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpr1_x4igr.cpp:13:9: error: \u2018cout\u2019 was not declared\
    \ in this scope; did you mean \u2018std::cout\u2019?\n   13 |         cout <<\
    \ \"Bad input!\" << endl;\n      |         ^~~~\n      |         std::cout\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:75,\n\
    \                 from /tmp/tmpr1_x4igr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iostream:61:18:\
    \ note: \u2018std::cout\u2019 declared here\n   61 |   extern ostream cout;  ///\
    \ Linked to standard output\n      |                  ^~~~\n/tmp/tmpr1_x4igr.cpp:13:33:\
    \ error: \u2018endl\u2019 was not declared in this scope; did you mean \u2018\
    std::endl\u2019?\n   13 |         cout << \"Bad input!\" << endl;\n      |   \
    \                              ^~~~\n      |                                 std::endl\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpr1_x4igr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ostream:599:5:\
    \ note: \u2018std::endl\u2019 declared here\n  599 |     endl(basic_ostream<_CharT,\
    \ _Traits>& __os)\n      |     ^~~~\n/tmp/tmpr1_x4igr.cpp:17:49: error: \u2018\
    str\u2019 was not declared in this scope; did you mean \u2018std\u2019?\n   17\
    \ |         return decimal_to_binary(decimal / 2) + str((decimal % 2), '1');\n\
    \      |                                                 ^~~\n      |        \
    \                                         std\n/tmp/tmpr1_x4igr.cpp:19:55: error:\
    \ \u2018str\u2019 was not declared in this scope; did you mean \u2018std\u2019\
    ?\n   19 |         return decimal_to_binary(decimal / 2) + '0' + str((decimal\
    \ % 2), '1');\n      |                                 "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    assert(decimal >= 0 && decimal\
    \ <= (long)pow(10, sizeof(long)) - 1);\n    int len = (int) ceil(log10((double)decimal));\n\
    \    if (len == (int)len - 1) {\n        len++;\n    }\n    std::string binary\
    \ = \"\";\n    bool zeros = false;\n    int count = 0;\n    for (int i = 0; i\
    \ < len; i++) {\n        int digit = decimal / pow(10, len - i - 1);\n       \
    \ decimal %= pow(10, len - i - 1);\n        if (digit == 0) {\n            if\
    \ (!zeros) {\n                zeros = true;\n            } else {\n          \
    \      binary += \"0\";\n            }\n        } else {\n            binary +=\
    \ \"1\";\n        }\n        count++;\n    }\n    if (zeros) {\n        binary\
    \ = \"0\" + binary;\n    }\n    if (len == 1) {\n        binary = \"0\" + binary;\n\
    \    }\n    std::string output = \"db\" + binary + \"db\";\n    return output;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4oqporba.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp4oqporba.cpp:22:17: error: invalid operands of types \u2018\
    long int\u2019 and \u2018double\u2019 to binary \u2018operator%\u2019\n   22 |\
    \         decimal %= pow(10, len - i - 1);\n      |         ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp4oqporba.cpp:22:39: error:   in evaluation of \u2018operator%=(long int,\
    \ double)\u2019\n   22 |         decimal %= pow(10, len - i - 1);\n      |   \
    \                                    ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n   std::string strBinary(\"\"\
    );\n   while(decimal != 0)\n   {\n       strBinary.push_back('0');\n       decimal\
    \ /= 2;\n   }\n   while(!strBinary.empty())\n   {\n       strBinary.push_back('1');\n\
    \   }\n   strBinary.insert(0, \"db\");\n   return strBinary;\n}\nint main() {\n\
    \    auto candidate = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"\
    ));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpdjhgesg1: /tmp/tmpdjhgesg1.cpp:27: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  // Complete this function\n\
    \  std::string result = \"\";\n  while (decimal != 0) {\n    if (decimal & 1)\
    \ {\n      result += 1;\n    } else {\n      result += \"0\";\n    }\n    decimal\
    \ /= 2;\n  }\n  return \"db\" + result + \"db\";\n}\nint main() {\n    auto candidate\
    \ = decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpmxvj33d3: /tmp/tmpmxvj33d3.cpp:26: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string bin_result;\n\
    \    // Write your code here.\n    for (long i = decimal; i > 0; i /= 10)\n  \
    \      bin_result.insert(bin_result.begin(), '0');\n    bin_result.resize(bin_result.size()\
    \ + 5);\n    bin_result.insert(bin_result.begin(), '1');\n    bin_result.insert(bin_result.end(),\
    \ 5);\n    return bin_result;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp5hw3nvg4: /tmp/tmp5hw3nvg4.cpp:23: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"\";\n\
    \  int number = decimal;\n  while (decimal > 0) {\n    std::string bin = to_binary(number);\n\
    \    binary += bin;\n    decimal -= number;\n    number /= 2;\n  }\n  binary +=\
    \ to_binary(number);\n  return binary;\n}\nint main() {\n    auto candidate =\
    \ decimal_to_binary;\n    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32))\
    \ == (\"db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n\
    \    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_vtjczak.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp_vtjczak.cpp:15:23: error: \u2018to_binary\u2019 was not\
    \ declared in this scope; did you mean \u2018binary\u2019?\n   15 |     std::string\
    \ bin = to_binary(number);\n      |                       ^~~~~~~~~\n      | \
    \                      binary\n/tmp/tmp_vtjczak.cpp:20:13: error: \u2018to_binary\u2019\
    \ was not declared in this scope; did you mean \u2018binary\u2019?\n   20 |  \
    \ binary += to_binary(number);\n      |             ^~~~~~~~~\n      |       \
    \      binary\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string strBinary = \"\
    \";\n    int remainder = decimal%2;\n    decimal /= 2;\n    int decimalToBinaryCount\
    \ = 0;\n    while (decimal != 0) {\n        strBinary = remainder + strBinary;\n\
    \        remainder = decimal%2;\n        decimal /= 2;\n        ++decimalToBinaryCount;\n\
    \    }\n    strBinary = strBinary + \"db\";\n    while(decimalToBinaryCount >\
    \ 0) {\n        strBinary = strBinary + \"0\";\n        --decimalToBinaryCount;\n\
    \    }\n    return strBinary;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdhaptwr0.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpdhaptwr0.cpp:17:31: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   17 |         strBinary = remainder + strBinary;\n      |              \
    \       ~~~~~~~~~ ^ ~~~~~~~~~\n      |                     |           |\n   \
    \   |                     int         std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdhaptwr0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdhaptwr0.cpp:17:33:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   17\
    \ |         strBinary = remainder + strBinary;\n      |                      \
    \           ^~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Your code here\n    std::string\
    \ str = \"\";\n    while(decimal >= 2){\n        decimal /= 2;\n        str +=\
    \ \"1\";\n    }\n    str += \"0\";\n    while(decimal != 0){\n        if(decimal\
    \ >= 2){\n            decimal /= 2;\n            str += \"1\";\n        }\n  \
    \      else{\n            str += \"0\";\n            decimal %= 2;\n        }\n\
    \    }\n    return str;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmph3pl5n1l: /tmp/tmph3pl5n1l.cpp:33: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::bitset<32> binary_num(decimal);\n\
    \    std::string bin_string = binary_num.to_string();\n    std::string res = \"\
    db\" + bin_string;\n    return res;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmp39723pms: /tmp/tmp39723pms.cpp:19: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    long int rem;\n    std::string\
    \ binary = \"0\";\n    std::string decimal_form(decimal);\n    std::string decimal_form_2\
    \ = decimal_form;\n    for (int i = 0; i < decimal_form.size(); i++)\n    {\n\
    \        rem = decimal_form[i] - '0';\n        while (binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal(binary_to_decimal\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4_d4h9yy.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmp4_d4h9yy.cpp:14:37: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::basic_string(long int&)\u2019\n \
    \  14 |     std::string decimal_form(decimal);\n      |                      \
    \               ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp4_d4h9yy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:625:9:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&)\u2019\
    \n  625 |         basic_string(_InputIterator __beg, _InputIterator __end,\n \
    \     |         ^~~~~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:625:9:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp4_d4h9yy.cpp:14:37:\
    \ note:   candidate expects 3 arguments, 1 provided\n   14 |     std::string decimal_form(decimal);\n\
    \      |                                     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::stringstream ss;\n \
    \   ss << std::bitset<sizeof(long)>::to_string(decimal);\n    return ss.str();\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpscmxns65.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpscmxns65.cpp:13:55: error: cannot call member function\
    \ \u2018std::__cxx11::basic_string<_CharT> std::bitset<_Nb>::to_string(_CharT,\
    \ _CharT) const [with _CharT = long int; long unsigned int _Nb = 8]\u2019 without\
    \ object\n   13 |     ss << std::bitset<sizeof(long)>::to_string(decimal);\n \
    \     |                                                       ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    // Write your code here\n\
    \    long x = 0;\n    int y = 0;\n    std::string bin;\n    while(decimal > 0){\n\
    \        bin.push_back(x);\n        decimal -= (decimal%2);\n        decimal /=\
    \ 2;\n        x++;\n    }\n    bin.insert(bin.begin(), \"db\");\n    return bin;\n\
    }\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpv9piri8q.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpv9piri8q.cpp:22:33: error: no matching function for call\
    \ to \u2018std::__cxx11::basic_string<char>::insert(std::__cxx11::basic_string<char>::iterator,\
    \ const char [3])\u2019\n   22 |     bin.insert(bin.begin(), \"db\");\n      |\
    \                                 ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpv9piri8q.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1534:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string bin;\n    bin.resize(decimal+1,\
    \ '0');\n    for (int i = decimal; i >= 0; i--) {\n        bin[i] = '1' + bin[i]\
    \ - '0';\n    }\n    return bin;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n\
    \    assert(candidate((0)) == (\"db0db\"));\n    assert(candidate((32)) == (\"\
    db100000db\"));\n    assert(candidate((103)) == (\"db1100111db\"));\n    assert(candidate((15))\
    \ == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpuvgq0a3j: /tmp/tmpuvgq0a3j.cpp:21: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n  assert(decimal > 0);\n  std::string\
    \ binary = \"\";\n  while (decimal > 0) {\n    binary.push_back((decimal % 2)\
    \ ? \"1\" : \"0\");\n    decimal /= 2;\n  }\n  return \"db\" + binary + \"db\"\
    ;\n}\nint main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc_0vmmx0.cpp: In function \u2018std::string decimal_to_binary(long\
    \ int)\u2019:\n/tmp/tmpc_0vmmx0.cpp:15:36: error: invalid conversion from \u2018\
    const char*\u2019 to \u2018char\u2019 [-fpermissive]\n   15 |     binary.push_back((decimal\
    \ % 2) ? \"1\" : \"0\");\n      |                      ~~~~~~~~~~~~~~^~~~~~~~~~~\n\
    \      |                                    |\n      |                       \
    \             const char*\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpc_0vmmx0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1349:24:\
    \ note:   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1349 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number\
    \ in decimal form and your task is to convert it to\n// binary format. The function\
    \ should return a string, with each character representing a binary\n// number.\
    \ Each character in the string will be '0' or '1'.\n// There will be an extra\
    \ couple of characters 'db' at the beginning and at the end of the string.\n//\
    \ The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)\
    \   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\
    \nstd::string decimal_to_binary(long decimal) {\n    std::string binary_string;\n\
    \    while (decimal != 0) {\n        binary_string = (decimal % 2 == 0) ? (binary_string\
    \ + \"1\") : (binary_string + \"0\");\n        decimal /= 2;\n    }\n    if (binary_string\
    \ == \"0\") return \"0db\";\n    if (binary_string == \"1\") return \"db\";\n\
    \    std::string temp = \"db\";\n    for (int i = 0; i < binary_string.length();\
    \ i++) {\n        if (binary_string[i] == '0') temp = temp + \"0\";\n        else\
    \ if (binary_string[i] == '1') temp = temp + \"1\";\n        else temp = \"db\"\
    \ + temp;\n    }\n    binary_string = temp;\n    return binary_string;\n}\nint\
    \ main() {\n    auto candidate = decimal_to_binary;\n    assert(candidate((0))\
    \ == (\"db0db\"));\n    assert(candidate((32)) == (\"db100000db\"));\n    assert(candidate((103))\
    \ == (\"db1100111db\"));\n    assert(candidate((15)) == (\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "tmpux8xchu7: /tmp/tmpux8xchu7.cpp:30: int main(): Assertion `candidate((0))\
    \ == (\"db0db\")' failed.\n"
  exit_code: -6
  status: Exception
