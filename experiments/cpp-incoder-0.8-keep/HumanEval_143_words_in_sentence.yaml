name: HumanEval_143_words_in_sentence
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing\
  \ a sentence,\n// the sentence contains some words separated by a space,\n// and\
  \ you have to return a string that contains the words from the original sentence,\n\
  // whose lengths are prime numbers,\n// the order of the words in the new string\
  \ should be the same as the original one.\n// Example 1:\n// Input: sentence = \"\
  This is a test\"\n// Output: \"is\"\n// Example 2:\n// Input: sentence = \"lets\
  \ go for swimming\"\n// Output: \"go for\"\n// Constraints:\n// * 1 <= len(sentence)\
  \ <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string\
  \ sentence) {\n"
tests: "}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
  This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
  )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
  )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
  \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
  ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
  \ is\")) == (\"is\"));\n}\n"
completions: ["    // write your code here\n    vector<string> v; \n    for (int i\
    \ = 0; i < sentence.length(); i++) {\n        if(isalpha(sentence[i])){\n    \
    \        v.push_back(sentence[i]);\n        }\n    }\n    sort(v.begin(), v.end());\n\
    \    \n    string ans = \"\";\n    for(int i = 0; i < v.size(); i++) {\n     \
    \   ans += \" \" + v[i];\n    }\n    \n    \n    for(int i = 1; i < ans.length();\
    \ i++) {\n        if(isPrime(int(ans.at(i).c_str()))){\n            ans += \"\
    \ \" + ans.at(i);\n        }\n    }\n    return ans.substr(1, ans.length() - 2);",
  "  std::vector<std::string> v;\n  std::string s;\n  std::string ss;\n  for (auto\
    \ &c : sentence) {\n    if ((c>='a' && c<='z') || (c>='A' && c<='Z') || (c>='0'\
    \ && c<='9') || (c>='.' && c<='!') || (c>='-' && c<='_') || (c>='$' && c<='&'))\
    \ {\n      v.push_back(c);\n    }\n  }\n  sort(v.begin(),v.end());\n  std::for_each(v.begin(),v.end(),[&s,&ss](std::string\
    \ &i){\n    if (i!='.'){\n      s=s+i;\n      ss=ss+i;\n    }\n  });\n  for (auto\
    \ &i : v) {\n    if (!(ss==i)) {\n      s=s+i;\n      ss=ss+i;\n    }\n  }\n \
    \ return s;", "    // write your code here\n    std::vector<std::string> words;\n\
    \    for (auto &c : sentence) {\n        if (std::isalpha(c)) {\n            words.push_back(c);\n\
    \        }\n    }\n    words.erase(std::unique(words.begin(), words.end()), words.end());\n\
    \    std::string result = \"\";\n    for (auto &w : words) {\n        if (w.size()\
    \ == 1) {\n            result += w;\n        } else {\n            for (int i\
    \ = 1; i < int(sqrt(w.size())); i++) {\n                if (w.substr(i, int(sqrt(w.size()))\
    \ - i).length() % 2 == 0) {\n                    result += \" \" + w.substr(i,\
    \ int(sqrt(w.size())) - i);\n                    break;\n                }\n \
    \           }\n        }\n    }\n    return result;", "    assert(sentence.size()\
    \ != 0);\n    auto str_arr = sentence.split(\" \");\n    std::string res;\n  \
    \  for (auto &item : str_arr)\n    {\n        if (prime_number(item.length())\
    \ == 1)\n            res += item;\n    }\n    return res;", "    char c;\n   \
    \ std::string newString;\n    for (int i = 0; i < sentence.length(); i++) {\n\
    \        c = sentence[i];\n        if (!isalpha(c)) {\n            newString +=\
    \ c;\n        } else {\n            newString += \" \";\n        }\n    }\n  \
    \  std::stack<char> words;\n    std::string currentString;\n    for (int i = 0;\
    \ i < newString.length(); i++) {\n        c = newString[i];\n        if (isalpha(c))\
    \ {\n            currentString += c;\n        } else {\n            if (currentString.length()\
    \ > 1) {\n                while (!words.empty() && words.top() == currentString)\
    \ {\n                    currentString = words.top();\n                    words.pop();\n\
    \                }\n                currentString += c;\n            }\n     \
    \       else {\n                currentString += c;\n            }\n        }\n\
    \        if (isalpha(c)) {\n            words.push(c);\n        }\n    }\n   \
    \ std::string result = \"\";\n    while (!words.empty()) {\n        result +=\
    \ words.top();\n        words.pop();\n    }\n    return result;", "    \n    std::string\
    \ result = \"No words found\";\n    int n = sentence.length();\n    int max_prime_num\
    \ = 0;\n    \n    for(int i = 1; i<n; i++) {\n        int temp_prime_num = 0;\n\
    \        for(int j = 1; j <= i; j++) {\n            if((i / j) % 2 == 0)\n   \
    \             temp_prime_num += 1;\n            else\n                break;\n\
    \        }\n        \n        if(temp_prime_num > max_prime_num)\n           \
    \ result += \" \" + sentence[i];\n    }\n    \n    return result;", "    // Write\
    \ your code here\n    \n    ", "    std::string word;\n    int n = ceil(sentence.length()\
    \ / 2.0);\n    std::string result = \"\";\n\n    for (int i = 1; i < n; i++) {\n\
    \        word = sentence[i];\n        std::cout << word << std::endl;\n      \
    \  for (int j = i; j < n; j++) {\n            std::cout << words[j] << \" \";\n\
    \            assert(word.length() == words[j].length());\n            if (word.length()\
    \ == words[j].length()) {\n                result += (words[i] + \" \");\n   \
    \         }\n        }\n    }\n    return result;", "    \n    std::string s =\
    \ sentence;\n    for (std::size_t i = 1; i < s.size(); i++) {\n        std::size_t\
    \ j = 1;\n        while (!(i%j) && j < s.size()) {\n            j++;\n       \
    \ }\n        if(!(i%j)) {\n            s.erase(i, j);\n            i--;\n    \
    \    }\n    }\n    return s;", "    std::string new_sentence = \"\";\n    int\
    \ prime_len = 0, prime_num = 1;\n    for (int i = 0; i < sentence.size(); i++)\
    \ {\n        int len = sentence.at(i) - 'a';\n        prime_len += 1;\n      \
    \  while (prime_num * prime_len < len) {\n            prime_num += 1;\n      \
    \  }\n        new_sentence += sentence.at(i);\n    }\n    for (int i = 0; i <\
    \ sentence.size(); i++) {\n        int len = sentence.at(i) - 'a';\n        prime_len\
    \ += 1;\n        while (prime_num * prime_len < len) {\n            prime_num\
    \ += 1;\n        }\n        if (new_sentence.at(new_sentence.size() - prime_len\
    \ + prime_num - 1) != ' ') {\n            new_sentence += \" \";\n        }\n\
    \    }\n    prime_len = new_sentence.length();\n    prime_num = new_sentence.length();\n\
    \    return new_sentence;", "    // your code goes here\n    std::unordered_map<char,\
    \ int> primes;\n    for (auto &ch: sentence) {\n        primes[ch]++;\n    }\n\
    \    std::string result = \"\";\n    for (auto &prime: primes) {\n        if (prime\
    \ == 2) {\n            result += std::to_string(prime) + \" \";\n        }\n \
    \   }\n    return result;", "    std::vector<std::string> vect = split(sentence,\
    \ \" \");\n    std::string ans = \"\";\n    \n    for (auto &s : vect) {\n   \
    \     ans += s;\n        ans += \" \";\n    }\n    \n    for (auto &s : vect)\
    \ {\n        int len = s.length();\n        \n        bool is_prime = true;\n\
    \        \n        for(int i = 2; i <= sqrt(len); i++) {\n            if(len %\
    \ i == 0) {\n                is_prime = false;\n                break;\n     \
    \       }\n        }\n        \n        if(!is_prime) {\n            ans += s;\n\
    \        }\n    }\n    \n    return ans;", "    // write your code here\n    auto\
    \ first_word = std::sregex_iterator(sentence.rbegin(), sentence.rend(), std::regex(\"\
    \ \"));\n    auto second_word = std::sregex_iterator();\n    std::string result;\n\
    \n    for (; first_word != second_word; ++first_word, ++second_word) {\n     \
    \   if (std::stoi(*first_word) == std::stoi(*second_word)) {\n            result\
    \ += \" \";\n        }\n    }\n    return result;", "    // write your code here\n\
    \    \n    vector<int> primes;\n    string prime_string;\n    \n    for (int i\
    \ = 1; i <= sqrt(sentence.length()); i++) {\n        if (sentence[i] != ' ') {\n\
    \            if (isPrime(i)) {\n                primes.push_back(i);\n       \
    \         if (primes.size() == 1) {\n                    prime_string = primes.front();\n\
    \                } else {\n                    prime_string += ' ';\n        \
    \        }\n            }\n        }\n    }\n    \n    if (primes.size() == 0)\
    \ {\n        return sentence;\n    }\n    \n    vector<int> indexes = primes;\n\
    \    sort(indexes.begin(), indexes.end());\n    \n    vector<string> results;\n\
    \    \n    for (int i = 0; i < indexes.size(); i++) {\n        string new_word\
    \ = \"\";\n        for (int j = 0; j < sentence.length(); j++) {\n           \
    \ if (sentence[j] == ' ') {\n                results[j] = results[j] + \" \" +\
    \ new_word;\n                new_word = \"\";\n            } else {\n        \
    \        new_word += sentence[j];\n            }\n        }\n    }\n    \n   \
    \ return prime_string;", "    std::vector<std::string> split_sentence(std::sregex_token_iterator(sentence.begin(),\
    \ sentence.end(), \" \"), std::sregex_token_iterator());\n    \n    // create\
    \ an array of strings which represents the prime numbers\n    std::vector<std::string>\
    \ prime_numbers;\n    for(int i=2; i<=sqrt(sentence.size()); i++){\n        int\
    \ count = 0;\n        for(int j=0; j<split_sentence.size(); j++){\n          \
    \  \n            if(split_sentence[j][split_sentence[j].size()-1] == 'i' || split_sentence[j][split_sentence[j].size()-1]\
    \ == 'e'){\n                continue;\n            }\n            \n         \
    \   if(i%split_sentence[j].size()==0){\n                count++;\n           \
    \ }\n        }\n        if(count == split_sentence.size()-1){\n            prime_numbers.push_back(i);\n\
    \        }\n    }\n\n    // create the new string by adding each prime number\
    \ to the array\n    std::string new_sentence = \"\";\n    for(auto i : prime_numbers){\n\
    \        new_sentence += i;\n    }\n    \n    return new_sentence;", "    // Write\
    \ your code here\n    std::map<int, std::string> m;\n    std::string r;\n    for\
    \ (char &c : sentence) {\n        auto n = c - 48;\n        if (!m.count(n)) {\n\
    \            m[n] = r;\n            r += c;\n        }\n    }\n    return m[m.rbegin()->first];",
  "    std::string new_word;\n    int prime_no;\n    int len = 0;\n    int index =\
    \ 0;\n    \n    for(auto c : sentence) {\n        if(isdigit(c)) {\n         \
    \   if(isupper(c)) {\n                prime_no = c - 'A' + 1;\n            } else\
    \ {\n                prime_no = c - 'a' + 1;\n            }\n            if(len\
    \ == prime_no) {\n                new_word += sentence[index];\n             \
    \   len++;\n            }\n        }\n        index++;\n    }\n    \n    return\
    \ new_word;", "  std::stack<char> stack;\n  std::string words;\n  std::istringstream\
    \ iss(sentence);\n  char ch;\n  while (iss >> ch) {\n    if (ch == ' ') {\n  \
    \    stack.push(ch);\n    } else {\n      while (!stack.empty() && ch == stack.top())\
    \ {\n        words += \" \";\n        stack.pop();\n      }\n      words += ch;\n\
    \      stack.push(ch);\n    }\n  }\n  while (!stack.empty()) {\n    words += \"\
    \ \";\n    stack.pop();\n  }\n  return words;", "    std::vector<std::string>\
    \ tokens;\n    std::string res = \"\";\n    for (auto &c : sentence) {\n     \
    \   if (std::isalpha(c))\n            tokens.push_back(c);\n    }\n    tokens.push_back(\"\
    \ \");\n    std::sort(tokens.begin(), tokens.end());\n    // tokens are sorted\
    \ in the sentence now\n    for (int i = 0; i < tokens.size(); i++) {\n       \
    \ if (tokens[i] > \"z\") {\n            break;\n        }\n    }\n    // last\
    \ character is z, not prime\n    for (int i = 0; i < tokens.size() - 1; i++) {\n\
    \        if (tokens[i] % tokens[i + 1] != 0) {\n            break;\n        }\n\
    \    }\n    res = std::string(tokens.begin(), tokens.begin() + i);\n    return\
    \ res;", "    std::sort(sentence.begin(), sentence.end());\n    std::vector<std::string>\
    \ vec;\n    for (std::size_t i = 0; i < sentence.size(); ++i) {\n        char\
    \ ch = sentence[i];\n        if (ch >= 'a' && ch <= 'z') {\n            vec.push_back(std::string(ch,\
    \ 1));\n        }\n    }\n    std::sort(vec.begin(), vec.end());\n    std::string\
    \ ans;\n    for (int i = 0; i < vec.size(); ++i) {\n        int n = vec[i].length();\n\
    \        if (i != 0) {\n            ans.push_back(\" \");\n        }\n       \
    \ bool flag = true;\n        for (int j = 0; j < n; ++j) {\n            if (vec[i].at(j)\
    \ != vec[0].at(j)) {\n                flag = false;\n                break;\n\
    \            }\n        }\n        if (flag) {\n            ans.push_back(vec[i]);\n\
    \        }\n    }\n    return ans;", '    // Your code here', "  string result\
    \ = \"\";\n  for (int i = 0; i <= sentence.length() - 1; i++) {\n    int flag\
    \ = 1;\n    for (int j = 1; j <= i; j++) {\n      if (sentence[i] != sentence[j])\
    \ {\n        flag = 0;\n      }\n    }\n    if (flag == 1) {\n      result +=\
    \ sentence[i] + \" \";\n    }\n  }\n  return result;", "    // write your code\
    \ here\n    assert(sentence.length() != 0);\n    string new_word = \"\";\n   \
    \ size_t pos = 0;\n    for (int i = 0; i < sentence.length(); i++) {\n       \
    \ pos = sentence.find(\" \", pos);\n        if (pos == string::npos) {\n     \
    \       new_word += sentence[i];\n        } else {\n            string words[3]\
    \ = {};\n            words[0] = sentence.substr(0, pos);\n            words[1]\
    \ = sentence.substr(pos + 1, sentence.length() - pos - 1);\n            words[2]\
    \ = sentence.substr(pos + 1, sentence.length() - pos - 1);\n            int sum\
    \ = 0;\n            for (int j = 0; j < 3; j++) {\n                sum += stoi(words[j]);\n\
    \            }\n            if (sum == 2) {\n                new_word += words[1];\n\
    \            }\n        }\n        pos = pos + 1;\n    }\n    return new_word;",
  "    // Write your code here\n    int i, j, n, k, count, max_count = 0;\n    std::string\
    \ s = sentence;\n    int n = s.length();\n    std::string new_s = \"\";\n    for(int\
    \ i = 0; i<n; i++) {\n        for(int j=i+1; j<n; j++) {\n            count=0;\n\
    \            for(int k=i; k<=j; k++) {\n                if(s.at(k) == ' ')\n \
    \                   count++;\n            }\n            if(count == 2 || count\
    \ > max_count) {\n                count = 1;\n                j -= 1;\n      \
    \      }\n            else if(count == 3) {\n                new_s += s.at(i)\
    \ + \" \";\n            }\n        }\n    }\n    return new_s;", "    std::string\
    \ res = \"\";\n    int size = sentence.size();\n    // Write your code here\n\
    \    std::unordered_map<std::string, int> m;\n    for (char &i : sentence) {\n\
    \        if (m[i].second == 1) {\n            res += i;\n        } else {\n  \
    \          m[i]++;\n        }\n    }\n    return res;", "    \n    std::vector<std::string>\
    \ result;\n    \n    auto get_word = [&](std::string word) -> bool {\n       \
    \ for(int i = 0; i < word.length(); i++) {\n            if(std::find(sentence.begin(),\
    \ sentence.end(), word[i]) == sentence.end()) {\n                return false;\n\
    \            }\n        }\n        return true;\n    };\n    \n    while(!get_word(\"\
    \")) {\n        result.push_back(\"\");\n    }\n    \n    auto check_prime = [&](std::string\
    \ word) {\n        for(int i = 2; i * i <= word.length(); i++) {\n           \
    \ if(std::find(result.begin(), result.end(), word) == result.end()) {\n      \
    \          return false;\n            }\n        }\n        return true;\n   \
    \ };\n    \n    while(!get_word(\"\")) {\n        if(check_prime(result.back()))\
    \ {\n            result.back() += \" \";\n        }\n        result.push_back(\"\
    \");\n    }\n    \n    for(auto &word: result) {\n        \n        std::sort(word.begin(),\
    \ word.end());\n        \n        int size = word.size();\n        \n        if(size\
    \ == 1) {\n            result.push_back(word[0]);\n            continue;\n   \
    \     }\n        \n        while(size != 1) {\n            std::string first_half\
    \ = word[size / 2];\n            std::string last_half = word[size - 1];\n   \
    \         \n            if(!get_word(first_half)) {\n                first_half\
    \ = first_half + \" \";\n            }\n            if(!get_word(last_half)) {\n\
    \                last_half = last_half + \" \";\n            }\n            \n\
    \            word = first_half + last_half;\n            \n            size =\
    \ word.size();\n            \n            if(size == 1) {\n                result.push_back(word[0]);\n\
    \                word = first_half + \" \" + last_half;\n                size\
    \ = 0;\n            }\n        }\n        \n        std::sort(word.begin(), word.end());\n\
    \        \n        result.push_back(word);\n    }\n    \n    result.back().erase(result.back().length()\
    \ - 1, 1);\n    \n    std::sort(result.begin(), result.end());\n    \n    std::string\
    \ res;\n    \n    for(auto &word: result) {\n        res += word + \" \";\n  \
    \  }\n    \n    return res.substr(0, res.find_last_not_of(\" \"));", "    int\
    \ len = sentence.length();\n    int cnt = 0;\n    for(int i=0;i<len;i++){\n  \
    \      if(isalpha(sentence[i]))\n            cnt++;\n    }\n    if(cnt <= 0)\n\
    \        return \"\";\n    for(int i=0;i<len;i++){\n        if(isalpha(sentence[i])\
    \ && sentence[i] != '_')\n            cnt --;\n    }\n    if(cnt > 0)\n      \
    \  return \"\";\n    string temp = \"\";\n    for(int i=0;i<len;i++){\n      \
    \  if(isalpha(sentence[i]) && sentence[i] != '_'){\n            for(int j=i;j<len;j++){\n\
    \                if(isalpha(sentence[j]) && sentence[j] != '_'){\n           \
    \         if((j-i)!=0){\n                        bool ok = true;\n           \
    \             for(int k=0;k<i;k++){\n                            if(temp[j-i]\
    \ == temp[k])\n                                ok = false;\n                 \
    \       }\n                        if(ok)\n                            temp.insert(temp.end(),sentence[j-i]);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return temp;", "  assert(sentence.length() != 0);\n  std::string ans = sentence;\n\
    \  bool flag = false;\n  char ch[100];\n  for (int i = 0; i < sentence.length();\
    \ i++) {\n    ch = sentence.c_str()[i];\n    bool found = false;\n    for (int\
    \ j = 0; j < ans.length(); j++) {\n      if (ch == ans.at(j)) {\n        found\
    \ = true;\n        break;\n      }\n    }\n    if (!found) {\n      ans = ans.replace(ch,\
    \ 'X');\n    }\n  }\n  for (int i = ans.length() - 1; i >= 0; i--) {\n    if (flag)\
    \ {\n      for (int j = 0; j < ans.length(); j++) {\n        if (ans.at(j) ==\
    \ 'X') {\n          ans = ans.insert(i + 1, ans.at(i));\n          break;\n  \
    \      }\n      }\n      flag = false;\n    }\n    if (ans.at(i) == 'X') {\n \
    \     flag = true;\n    }\n  }\n  ans = ans.replace(\" \", \"\");\n  return ans;",
  "    std::string ans = sentence;\n    assert(isalpha(sentence[0]));\n    std::string\
    \ s; // ans to store original sentence.\n    for (auto c : sentence) {\n     \
    \   if (isalpha(c)) {\n            s += c;\n        } else {\n            assert(isalpha(c));\n\
    \            ans += s;\n            s = \"\";\n            ans += c;\n       \
    \ }\n    }\n    assert(isalpha(sentence[sentence.size() - 1]));\n    ans += s;\n\
    \    return ans;", "    // Write your code here\n    std::string newString;\n\
    \    std::unordered_set<std::string> set;\n    for (auto &i : sentence) {\n  \
    \      if (set.find(i) == set.end()) {\n            set.insert(i);\n         \
    \   newString += i;\n        }\n    }\n    std::string tempString;\n    for (auto\
    \ &i : newString) {\n        tempString += i;\n    }\n    tempString += \" \"\
    ;\n    for (int i = 0; i <= tempString.size(); i++) {\n        if (tempString[i]\
    \ % 2 == 0) {\n            newString += newString[i].toupper();\n        }\n \
    \   }\n    return newString;", "    std::sort(sentence.begin(), sentence.end());\n\
    \    int start = 0;\n    int end = sentence.size() - 1;\n    while(start <= end)\
    \ {\n        if(isPrime(sentence.size()-start)) {\n            end = start+1;\n\
    \        } else {\n            start = end+1;\n        }\n    }\n    std::string\
    \ re = \"\";\n    for(int i = start; i <= end; i++) {\n        re += sentence.at(i);\n\
    \    }\n    return re;", "    \n    // Store the original string.\n    std::string\
    \ orig = sentence;\n    // Find the index of the first non-space character.\n\
    \    int idx = sentence.length();\n    while (idx >= 0 && sentence[idx] != ' ')\
    \ --idx;\n    // Store the original string in lower case and append it to output\
    \ string.\n    std::string out = \"\";\n    \n    // If the first non-space character\
    \ was found then get the length\n    // of the string.\n    if (idx > 0)\n   \
    \     out = sentence.substr(0, idx).to_lower();\n    \n    // Iterate through\
    \ the string and remove all repeated words.\n    int last = 1;\n    for (auto\
    \ &c : sentence) {\n        if (std::find(out.begin(), out.end(), c) == out.end())\
    \ {\n            // Add the new word into output string.\n            out += c;\n\
    \            if (last * 2 <= out.length()) {\n                // If the length\
    \ of the word is greater than the output string length,\n                // then\
    \ add the last word of output string.\n                out += out.back();\n  \
    \          }\n            ++last;\n        }\n    }\n    \n    // Remove all repeated\
    \ words from output string.\n    int last = 1;\n    for (auto &c : out) {\n  \
    \      if (std::find(orig.begin(), orig.end(), c) == orig.end()) {\n         \
    \   // Remove the last word from the output string.\n            out += '_';\n\
    \            ++last;\n        }\n    }\n    \n    return out;", "    // Split\
    \ sentence into array of words\n    std::vector<int> words(std::sregex_token_iterator(sentence.begin(),\
    \ sentence.end(), std::regex(\"\\\\s+\"), -1), std::sregex_token_iterator());\n\
    \n    // Find prime number for each word in array\n    std::map<int, bool> primes;\n\
    \    for (auto word : words) {\n        if (!primes.count(word)) {\n         \
    \   bool is_prime = true;\n            for (int i = 2; i <= word; ++i) {\n   \
    \             if (word % i == 0) {\n                    is_prime = false;\n  \
    \                  break;\n                }\n            }\n            primes[word]\
    \ = is_prime;\n        }\n    }\n\n    // Sort map by key for ordered output\n\
    \    std::map<int, bool>::iterator itr;\n    for (primes.begin(); primes.end()\
    \ != itr; primes.begin()) {\n        auto itr = primes.find(*itr);\n        std::string\
    \ prime = std::to_string(*itr);\n        if (primes.size() == itr->second) {\n\
    \            prime = prime+\" \";\n        }\n        sentence = sentence.substr(0,\
    \ itr->first) + prime + sentence.substr(itr->first+1);\n        primes.erase(itr);\n\
    \    }\n\n    // Find space between words and return string\n    return sentence;",
  "  std::string res;\n  int j=0;\n  for(int i=0; i<sentence.length(); i++){\n   \
    \ if(isPrime(j) && isAlpha(sentence.at(i))){\n      res+=sentence.at(i);\n   \
    \   j++;\n    }\n  }\n  return res;", "    std::unordered_map<char, size_t> word_count;\n\
    \    for(char c:sentence) {\n        word_count[c]++;\n    }\n    for(auto &entry:word_count)\
    \ {\n        if(entry.second == 1) {\n            entry.second = 2;\n        }\n\
    \    }\n\n    std::string res;\n    for(auto &entry:word_count) {\n        if(entry.second\
    \ == 2) {\n            res.push_back( entry.first );\n        }\n    }\n    return\
    \ res;", "    std::string ans;\n    std::string words[sentence.size()];\n    for(int\
    \ i = 0; i<sentence.size(); i++) {\n        words[i] = sentence[i];\n    }\n \
    \   for(int i = 1; i<101; i++) {\n        if(!isPrime(i)) {\n            for(int\
    \ j = 0; j < i; j++) {\n                if(j == 0 || j%words[j-1] != 0) {\n  \
    \                  words[j] = words[j-1];\n                }\n               \
    \ else {\n                    break;\n                }\n            }\n     \
    \       ans += words[i];\n        }\n    }\n    return ans;", "  std::unordered_map<char,int>\
    \ word_count;\n  std::string result;\n  size_t index = 0;\n  while ((index < sentence.length())\
    \ && (sentence[index] != ' ')) {\n    word_count[sentence[index]] = 1;\n    index++;\n\
    \  }\n  word_count[' '] = 1;\n  index++;\n  while (index < sentence.length())\
    \ {\n    std::string temp = sentence[index];\n    if (word_count.find(temp) !=\
    \ word_count.end()) {\n      result += temp;\n      index++;\n      while (index\
    \ < sentence.length()) {\n        temp += sentence[index];\n        if (word_count.find(temp)\
    \ != word_count.end()) {\n          result += \" \" + temp;\n          index++;\n\
    \        }\n        else {\n          index++;\n        }\n      }\n    }\n  \
    \  index++;\n  }\n  return result;", "    std::map<char, int> cnt;\n    for (auto\
    \ c: sentence)\n        cnt[c]++;\n\n    auto key = [](const char c){ return c;\
    \ };\n    \n    auto it = std::min_element(std::begin(cnt), std::end(cnt), key);\n\
    \    \n    std::string res;\n    for (auto i : it)\n        res += std::to_string(cnt[key(i)])\
    \ + \" \";\n    std::reverse(std::begin(res), std::end(res));\n    return res;",
  "  // Write your code here\n  std::stringstream ss(sentence);\n  std::string word;\n\
    \  std::vector<int> primes;\n  while (ss >> word) {\n    // Check whether it's\
    \ prime\n    int isPrime = 1;\n    for (int i = 2; i <= sqrt(word.size()); i++)\
    \ {\n      if (word % i == 0)\n        isPrime = 0;\n    }\n    if (isPrime)\n\
    \      primes.push_back(word.size());\n  }\n\n  std::string result;\n  for (int\
    \ i = 0; i < primes.size(); i++) {\n    result += primes[i];\n    result += \"\
    \ \";\n  }\n  return result;", "    // write your code here\n    \n    std::string\
    \ newString = \"\";\n    bool flag = true;\n    for(int i = 0; i < sentence.size();\
    \ i++) {\n        if(!flag) {\n            newString += sentence[i];\n       \
    \     flag = false;\n        }\n        else {\n            if(isPrime(sentence[i]))\
    \ {\n                newString += sentence[i];\n                flag = true;\n\
    \            }\n        }\n    }\n    return newString;", "  std::sort(sentence.begin(),\
    \ sentence.end());\n  // Step 1: Find the first non-prime number\n  std::string\
    \ ret(sentence);\n  for (int i = 2; i * i <= sentence.length(); ++i) {\n    while\
    \ (std::find(sentence.begin(), sentence.end(), ' ') != sentence.end()) {\n   \
    \   auto it = sentence.find_first_of(\" \");\n      if (it == sentence.end())\n\
    \        it = sentence.length();\n      auto next = it + 1;\n      if (next <\
    \ sentence.length()) {\n        if (std::find(sentence.begin(), sentence.end(),\
    \ ' ') != sentence.end()) {\n          std::string temp = sentence.substr(it,\
    \ next - it);\n          assert(std::is_sorted(temp.begin(), temp.end()));\n \
    \         ret += temp + \" \";\n          it = next;\n        }\n      }\n   \
    \ }\n    if (sentence[i] != ' ')\n      break;\n  }\n  assert(std::find(sentence.begin(),\
    \ sentence.end(), ' ') == sentence.end());\n  assert(ret.size() == sentence.size());\n\
    \  return ret;", "  std::set<int> s;\n  for (int i = 0; i < sentence.size(); i++)\
    \ {\n    if (s.find(sentence[i]) == s.end()) {\n      s.insert(sentence[i]);\n\
    \    }\n  }\n  std::string ans = \"\";\n  for (std::set<int>::iterator it = s.begin();\
    \ it != s.end(); ++it) {\n    ans.append(\" \");\n    ans.append(*it);\n  }\n\
    \  return ans;", "    std::string result = \"\";\n    char c = ' ';\n    int n\
    \ = sentence.length();\n    for(int i = 1; i < n; ++i)\n    {\n        c = sentence.at(i);\n\
    \        if((int)c % 2 != 0)\n            result += c;\n    }\n    return result;",
  "    std::string new_sentence = \"\";\n    int n = sentence.length();\n    int s\
    \ = 0;\n    string tmp;\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ == ' ') {\n            tmp = new_sentence;\n            while (tmp.find(\"1\
    \ \", tmp.size()) != std::string::npos) {\n                new_sentence = tmp;\n\
    \                ++s;\n            }\n            new_sentence.clear();\n    \
    \    } else {\n            new_sentence += sentence[i];\n        }\n    }\n  \
    \  return new_sentence;", "  std::vector<std::string> words;\n  std::string word;\n\
    \  std::string newSentence;\n  std::istringstream ss(sentence);\n  while (std::getline(ss,\
    \ word, ' ')) {\n    if (word.length() == 0) {\n      continue;\n    }\n    words.push_back(word);\n\
    \  }\n  for (size_t i = 0; i < words.size(); i++) {\n    std::string newWord =\
    \ words[i];\n    if (newWord.length() % 2 == 0) {\n      int j = newWord.length()\
    \ / 2;\n      while (j > 0) {\n        if (newWord[j] % 2 == 0) {\n          break;\n\
    \        }\n        j--;\n      }\n      newWord = words[i];\n      int k = j\
    \ + 1;\n      bool flag = true;\n      while (k > 0) {\n        if (newWord[k]\
    \ % 2 == 0) {\n          flag = false;\n          break;\n        }\n        k--;\n\
    \      }\n      if (flag == true) {\n        newWord = words[i];\n      }\n  \
    \  }\n    newSentence += newWord + \" \";\n  }\n  return newSentence;", "    const\
    \ char delimiter = ' ';\n    // Find the beginning of the sentence.\n    size_t\
    \ pos = 0;\n    pos = sentence.find(delimiter, pos);\n    if (pos != string::npos)\
    \ {\n        string word = sentence.substr(0, pos);\n        string output = word;\n\
    \        size_t size = output.length();\n        vector<int> prime;\n        for\
    \ (int i = 2; i < size; ++i) {\n            if (output.length() == i) {\n    \
    \            prime = prime_number(word);\n            }\n            if (output.length()\
    \ == i) {\n                if (output.length() > i) {\n                    string\
    \ temp = output;\n                    output = \"\";\n                    for\
    \ (int j = 0; j < i; ++j) {\n                        output += temp.at(j);\n \
    \                   }\n                }\n                if (output.length()\
    \ == i) {\n                    output += \" \";\n                }\n         \
    \   }\n        }\n        std::sort(prime.begin(), prime.end());\n        output\
    \ += \" \";\n        return output;\n    }\n    return \"\";", "    int len =\
    \ sentence.length();\n    int prime_count = 0;\n    std::string ans = \"\";\n\
    \    for (int i = 0; i < len; i++) {\n        char c = sentence[i];\n        if\
    \ (isspace(c)) {\n            continue;\n        }\n        for (int j = i; j\
    \ <= len; j++) {\n            char d = sentence[j];\n            if (d == c) {\n\
    \                prime_count++;\n            }\n        }\n        if (prime_count\
    \ <= 1) {\n            ans += c;\n        }\n    }\n    return ans;", "    std::vector<std::string>\
    \ vs = split(sentence, \" \");\n    std::string res = \"\";\n    for (auto it\
    \ = std::begin(vs); it != std::end(vs); it++) {\n        auto x = find_first_not_prime(std::distance(it,\
    \ std::end(vs)));\n        res += *it;\n        if (x == std::end(vs))\n     \
    \       break;\n        res = res.substr(0, x) + \" \";\n    }\n    return res;",
  "    // write your code here\n    std::unordered_set<std::string> primes;\n    std::string\
    \ result = \"\";\n    std::string buffer = \"\";\n    // buffer is a temporary\
    \ string for storing \"a\" and its length\n    // this step is required only because\
    \ string doesn't have an append function\n    std::string buffer1 = \"\";\n  \
    \  int n = sentence.size();\n    int count = 0;\n    int i = 0;\n\n    while (i\
    \ < n) {\n        if (buffer.size() > 0) {\n            buffer = buffer + \" \"\
    ;\n            buffer1 = buffer1;\n        }\n        buffer = buffer + sentence[i];\n\
    \        i = i + 1;\n        // now buffer has \"a\" and its length\n        buffer1\
    \ = buffer1 + sentence[i];\n        // now buffer1 has \"a \" and its length\n\
    \        size_t len1 = buffer1.length();\n        if (primes.count(buffer1) &&\
    \ len1 == 2) {\n            primes.erase(buffer1);\n            buffer1 = \"\"\
    ;\n            count = 0;\n            i = i - 1;\n        }\n    }\n    // now\
    \ buffer is \"a t\" its length is 2, so \"a\" is removed.\n    // buffer1 = \"\
    a t\"\n    // buffer = \"t\"\n    // now buffer is \"t\" its length is 2, so \"\
    t\" is removed.\n    // buffer1 = \"t\"\n    // buffer = \"a\"\n    // now buffer\
    \ is \"a\" its length is 2, so \"a\" is removed.\n    // buffer1 = \"\"\n    //\
    \ buffer = \"\"\n    // now buffer is \"\"\n    // buffer = \"a t\"\n    // buffer1\
    \ = \"\"\n    // now buffer1 is \"\"\n    int i = 0;\n    while (i < n) {\n  \
    \      std::string temp = \"\";\n        // temp is a temporary string for storing\
    \ characters from buffer\n        temp = buffer;\n        // now temp is \"a t\"\
    \n        // buffer is \"a t\"\n        // now temp is \"a t \"\n        size_t\
    \ len1 = temp.length();\n        // now temp is \"a t \"\n        // buffer1 =\
    \ \"\"\n        // now temp is \"a\"\n        // now temp is \"a a\"\n       \
    \ // now temp is \"a a a\"\n        // now temp is \"a\"\n        size_t count\
    \ = 0;\n        while (i < n) {\n            std::string temp2 = \"\";\n     \
    \       temp2 = temp;\n            temp2 = temp2 + temp[i];\n            // now\
    \ temp2 is \"a a\"\n            size_t len2 = temp2.length();\n            //\
    \ now temp2 is \"a a a\"\n            // now temp2 is \"a a a a\"\n          \
    \  // now temp2 is \"a a a a a\"\n            if (primes.count(temp2) && len2\
    \ == len1) {\n                primes.erase(temp2);\n                count++;\n\
    \                // now count is 2\n                temp2 = \"\";\n          \
    \      temp2 = temp + temp[i];\n", "    std::string ans;\n    vector<int> primes;\n\
    \    for (auto &c: sentence) {\n        if (c == '_') {\n            primes.push_back(0);\n\
    \        } else {\n            for (int &p: primes) {\n                if (p !=\
    \ 0 && c % p == 0) {\n                    ans += c;\n                    break;\n\
    \                }\n            }\n            primes.push_back(c);\n        }\n\
    \    }\n    return ans;", "    std::string new_sentence;\n    for (int i = 0;\
    \ i < sentence.length(); i++) {\n        char c = sentence[i];\n        for (int\
    \ j = i + 1; j < sentence.length(); j++) {\n            if (wordIsPrime(sentence[j]))\
    \ {\n                if (new_sentence.empty())\n                    new_sentence\
    \ = c;\n                else if (new_sentence != c)\n                    new_sentence\
    \ += \" \" + c;\n            }\n        }\n    }\n    return new_sentence;", " \
    \ assert(sentence.length() <= 100);\n  assert(std::all_of(sentence.begin(), sentence.end(),\
    \ ::isalpha));\n  \n  std::string res;\n  \n  long long ans = 0;\n  long long\
    \ p = 1;\n  for (auto i : sentence) {\n    ans *= p;\n    ans += static_cast<long\
    \ long>(i);\n    p++;\n  }\n\n  while (ans % 2 != 0) {\n    ans += 1;\n  }\n\n\
    \  while (res.length() < sentence.length()) {\n    res += \"0\";\n  }\n  for (auto\
    \ i : sentence) {\n    while (ans > 0 && res.length() % ans != 0) {\n      res\
    \ += \"0\";\n    }\n    res += i;\n    ans /= p;\n    p++;\n  }\n\n  return res;",
  "    \n    std::string new_sentence = \"\";\n    \n    for(auto &i : sentence){\n\
    \        if((i!=' ') && (i!='\\0')){\n            for(int j=0;j<new_sentence.length();j++){\n\
    \                if((new_sentence[j] == ' ')||(new_sentence[j] == '\\0')){\n \
    \                   new_sentence.push_back(i);\n                    break;\n \
    \               }\n            }\n        }\n    }\n    \n    for(auto &i : new_sentence){\n\
    \        for(int j=0;j<new_sentence.length();j++){\n            if((new_sentence[j]\
    \ == ' ')||(new_sentence[j] == '\\0')){\n                new_sentence.erase(new_sentence.begin()+j);\n\
    \                break;\n            }\n        }\n    }\n    \n    return new_sentence;",
  "    // Write your code here\n    \n    std::vector<int> lengths;\n    int len =\
    \ sentence.length();\n    for(int i=0;i<len;i++) {\n        lengths.push_back(1);\n\
    \    }\n    for(int i=1;i<len;i++) {\n        for(int j=0;j<i;j++) {\n       \
    \     int k = lengths[j];\n            if(k % i == 0) {\n                lengths[j]\
    \ = (i*(i+1)/2+i-1);\n            }\n        }\n    }\n    \n    std::unordered_map<int,\
    \ std::list<int>> m;\n    std::string ans = \"\";\n    \n    for(int i=0;i<len;i++)\
    \ {\n        int s = lengths[i];\n        if(!m.count(s)) {\n            m.insert(std::pair<int,\
    \ std::list<int>>(s, {i}));\n        } else {\n            auto list = m[s];\n\
    \            for(int j=0;j<list.size();j++) {\n                int t = list[j];\n\
    \                if(!m.count(t+s)) {\n                    m.insert(std::pair<int,\
    \ std::list<int>>(t+s, {i}));\n                    break;\n                }\n\
    \            }\n        }\n    }\n    \n    for(auto it = m.begin();it!=m.end();it++)\
    \ {\n        if(!ans.empty()) {\n            ans += \" \";\n        }\n      \
    \  ans += it->first;\n    }\n    return ans;", "    // Write your code here\n\
    \    // Your code goes here\n    \n    std::string result = \"\";\n    int n =\
    \ sentence.length();\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n\
    \        for (int j = i + 1; j < n; j++) {\n            if (isPrime(sentence.substr(i,\
    \ j).length())) {\n                count++;\n            }\n        }\n      \
    \  if (count == 1) {\n            result += sentence.substr(i, 1);\n        }\n\
    \    }\n    \n    return result;", "    int n = sentence.size();\n    string ans;\n\
    \    bool flag = false;\n    for(int i = 0; i < n; i++) {\n        if(flag) {\n\
    \            ans += \" \";\n        }\n        ans += sentence[i];\n        flag\
    \ = true;\n        for(int j = 0; j < n; j++) {\n            if(j == i) {\n  \
    \              continue;\n            }\n            if(!(i % j == 0)) {\n   \
    \             flag = false;\n            }\n        }\n    }\n    return ans;",
  "    std::string s = sentence;\n    std::string t = s;\n    // split string into\
    \ words\n    s.erase(std::remove(s.begin(), s.end(), '\\n'), s.end()); // remove\
    \ the newline char from the string\n    std::vector<std::string> v;\n    std::string\
    \ word;\n    for (std::string::iterator i = s.begin(); i != s.end(); i++) {\n\
    \        v.push_back(*i);\n    }\n    // count prime number\n    int count = 0;\n\
    \    int size = v.size();\n    \n    // find first prime number\n    for (int\
    \ i = 0; i < v.size(); i++) {\n        while (v[count] % v[i] != 0) {\n      \
    \      count++;\n        }\n    }\n    \n    // print prime number\n    for (int\
    \ i = 1; i <= count; i++) {\n        if (v[i] > 1 && v[i] % 2 == 0 && v[i] % v[i\
    \ - 1] == 0 && v[i] % v[i + 1] == 0) {\n            \n            // delete first\
    \ prime number and print new\n            std::string word1;\n            std::cout\
    \ << v[i];\n            std::cout << \" \";\n            for (std::string::iterator\
    \ i = t.begin(); i != t.end(); i++) {\n                word1 += *i;\n        \
    \        std::cout << v[i];\n                std::cout << \" \";\n           \
    \ }\n            std::string word2 = word1;\n            \n            \n    \
    \        \n            // delete last prime number and print new\n           \
    \ std::string word3;\n            std::cout << v[i - 1];\n            std::cout\
    \ << \" \";\n            for (std::string::iterator i = t.begin(); i != t.end();\
    \ i++) {\n                word3 += *i;\n                std::cout << v[i - 1];\n\
    \                std::cout << \" \";\n            }\n            std::string word4\
    \ = word3;\n            \n            \n            // delete middle prime numbers\
    \ and print new\n            std::string word5;\n            std::cout << v[i\
    \ - 1];\n            std::cout << \" \";\n            for (std::string::iterator\
    \ i = t.begin() + i; i != t.end(); i += 2) {\n                word5 += *i;\n \
    \               std::cout << v[i - 1];\n                std::cout << \" \";\n\
    \            }\n            std::string word6 = word5;\n            \n       \
    \     // delete middle prime numbers and print new\n            std::string word7;\n\
    \            std::cout << v[i - 1];\n            std::cout << \" \";\n       \
    \     for (std::string::iterator i = t.begin() + i; i != t.end(); i += 2) {\n\
    \                word7 += *i;\n                std::cout << v[i - 1];\n      \
    \          std::cout << \" \";\n            }\n            std::string word8 =\
    \ word7;\n            \n            // delete middle prime numbers and print new\n\
    \            std::string word9;\n            std::cout << v[i - 1];\n        \
    \    std::cout << \" \";\n            for (std::string::iterator i = t.begin()\
    \ + i; i != t.end(); i += 2) {\n                word9 += ", "    std::vector<bool>\
    \ v(sentence.begin(), sentence.end());\n    std::sort(v.begin(), v.end());\n \
    \   int sum = 0;\n    for (auto i : v)\n    {\n        if (i == true)\n      \
    \      sum += i;\n    }\n    std::sort(v.begin(), v.end());\n    int size = v.size();\n\
    \    if (sum % size == 0)\n    {\n        int sum2 = 0;\n        for (auto i :\
    \ v)\n        {\n            if (i == true)\n                sum2 += i;\n    \
    \    }\n        return sentence.substr(0, sentence.find(\" \", 0));\n    }\n \
    \   return \"\";", "    // Code here\n    int n = sentence.length();\n    int\
    \ a[n];\n    for(int i=0;i<n;i++){\n        a[i]=0;\n    }\n    for(int i=0;i<n;i++){\n\
    \        if((sentence[i]>='a' && sentence[i]<='z') || (sentence[i]>='A' && sentence[i]<='Z')){\n\
    \            for(int j=i;j<n;j++){\n                if((sentence[i]==sentence[j])\
    \ || (sentence[i]==sentence[j-1])){\n                    a[j]=a[j-1]+1;\n    \
    \                for(int k=0;k<i;k++){\n                        a[k]=a[k]+a[k+1];\n\
    \                    }\n                    break;\n                }\n      \
    \      }\n        }\n    }\n    std::string s = \"\";\n    for(int i=0;i<n;i++){\n\
    \        if(a[i]==0){\n            s+=\" \";\n        }\n        else{\n     \
    \       s+=sentence[i];\n        }\n    }\n    return s;", "    std::string result\
    \ = \"\";\n    // Write your code here\n    int len = sentence.length();\n   \
    \ for (int i = 0; i < len; i++) {\n        std::cout << i << std::endl;\n    \
    \    int count = 0;\n        for (int j = i; j < len; j++) {\n            if (sentence[i]\
    \ == sentence[j]) {\n                count++;\n            }\n        }\n    \
    \    if (count == i) {\n            result += sentence[i];\n        }\n    }\n\
    \    return result;", "    std::vector<bool> primes(10000, true);\n    std::string\
    \ ret = \"\";\n    for (auto &c : sentence)\n        if (c == '_')\n         \
    \   continue;\n        else if (primes[c]) {\n            if (primes[ret.length()])\
    \ {\n                std::swap(ret, ret);\n                std::swap(ret, ret);\n\
    \            }\n            else {\n                ret.append(c);\n         \
    \   }\n            primes[c] = false;\n            primes[ret.length()] = false;\n\
    \        }\n        else if (c != ' ')\n            ret += c;\n    return ret;",
  "    // Your code here\n    std::string res;\n    bool flag = false;\n    int n\
    \ = 1;\n    for (int i = 0; i < sentence.length(); i++) {\n        int j = i +\
    \ 1;\n        while (j < sentence.length() && !flag) {\n            if (sentence[i]\
    \ == sentence[j] && (!isalpha(sentence[i]) && !isalpha(sentence[j]))) {\n    \
    \            flag = true;\n            } else {\n                j++;\n      \
    \      }\n        }\n        if (flag) {\n            res += sentence.substr(i,\
    \ j - i);\n            flag = false;\n            n = 1;\n            i = j;\n\
    \        } else {\n            n += 1;\n        }\n    }\n    return res;", " \
    \   \n    std::string ans = \"\";\n    \n    // split string to array of words\n\
    \    std::vector < std::string > string_words;\n    std::stringstream sstream(sentence);\n\
    \    for (std::string word; std::getline(sstream, word, ' ');)\n        string_words.push_back(word);\n\
    \    \n    // sort array of words by length\n    std::sort(string_words.begin(),\
    \ string_words.end(), [](const std::string& left, const std::string& right){\n\
    \        return left.length() > right.length();\n    });\n    \n    int prime_counter\
    \ = 0;\n    for (auto& s : string_words)\n    {\n        if (s.length() > 1) {\n\
    \            prime_counter++;\n        }\n    }\n    \n    // generate new string\n\
    \    for (auto& s : string_words) {\n        if (prime_counter > 0 && s.length()\
    \ == prime_counter) {\n            ans += s;\n        }\n    }\n    \n    return\
    \ ans;", "    int n = 0;\n    std::unordered_map<char, int> primes;\n    // prime\
    \ numbers are divisible by 2 or 3\n    for (int i = 2; i <= (int)sqrt(sentence.size());\
    \ i++) {\n        while (n % i == 0) {\n            if (primes.find(i) == primes.end())\
    \ {\n                primes[i] = 1;\n                for (int j = i * i; j <=\
    \ n; j++) {\n                    primes[j] = 0;\n                }\n         \
    \   } else {\n                primes[i]++;\n            }\n            n++;\n\
    \        }\n    }\n    std::string res = \"\";\n    for (char c: sentence) {\n\
    \        if (primes.find(c) != primes.end()) {\n            res += c;\n      \
    \  }\n    }\n    return res;", "  std::string res;\n  std::string word;\n  for\
    \ (int i = 0; i < sentence.length(); i++) {\n    if (sentence[i] == ' ') {\n \
    \     res.push_back(word);\n      word.clear();\n    } else {\n      word.push_back(sentence[i]);\n\
    \    }\n  }\n  res.push_back(word);\n  return res;", "    // Your code here\n\
    \    \n    size_t start = 0, end = 0, size = 1;\n    \n    while(1) {\n      \
    \  \n        std::string word = sentence[start];\n        \n        if(start ==\
    \ end)\n            break;\n        \n        while(sentence[end] != ' ' && end\
    \ < sentence.size()-1) {\n            \n            end++;\n        }\n      \
    \  \n        std::string sub_word = sentence.substr(start, end-start+1);\n   \
    \     \n        bool is_prime = true;\n        \n        for(size_t i = 1; i <\
    \ sub_word.length(); i++) {\n            if(sub_word[i] != sub_word[i-1]) {\n\
    \                is_prime = false;\n                break;\n            }\n  \
    \      }\n        \n        if(is_prime) {\n            size++;\n        }\n \
    \       \n        start = end;\n    }\n    \n    std::string new_sentence;\n \
    \   \n    for(size_t i = 0; i < size; i++) {\n        new_sentence.push_back(sentence[i]);\n\
    \    }\n    \n    return new_sentence;", '    // code here', "    bool flag =\
    \ true;\n    std::string ret = \"\";\n    for (auto i : sentence)\n    {\n   \
    \     if (flag)\n        {\n            for (auto j : ret)\n            {\n  \
    \              if (i == j)\n                {\n                    flag = false;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     else\n        {\n            for (auto j : ret)\n            {\n       \
    \         if (i == j)\n                {\n                    flag = true;\n \
    \                   break;\n                }\n            }\n        }\n    }\n\
    \    return ret;", "    std::set<std::string> primes;\n    std::string ans = \"\
    \";\n    for (int i = 0; i < sentence.length(); i++) {\n        std::string word;\n\
    \        auto c = sentence.at(i);\n        if (c == ' ') {\n            primes.insert(word);\n\
    \            continue;\n        }\n        if (isalpha(c)) {\n            word\
    \ = c + 1;\n        }\n        else {\n            word = \"\";\n        }\n \
    \       std::cout << word << ' ';\n    }\n    for (auto p: primes) {\n       \
    \ ans += p;\n    }\n    return ans;", "    std::vector<std::string> new_words;\n\
    \    std::string word;\n    bool prime = true;\n    int cnt = 0;\n    for (auto\
    \ &c: sentence) {\n        if (!isalpha(c)) {\n            prime = false;\n  \
    \          break;\n        }\n    }\n    for (auto &c: sentence) {\n        if\
    \ (isalpha(c)) {\n            word = word + c;\n        }\n    }\n    for (auto\
    \ &c: sentence) {\n        if (isalpha(c)) {\n            new_words.push_back(word);\n\
    \            word = \"\";\n        }\n    }\n    // count prime\n    for (auto\
    \ &c: new_words) {\n        int cnt = 0;\n        for (auto &d: new_words) {\n\
    \            if (d == c) {\n                cnt++;\n            }\n        }\n\
    \        if (cnt % 2 != 0) {\n            prime = false;\n            break;\n\
    \        }\n    }\n    std::reverse(std::begin(new_words), std::end(new_words));\n\
    \    if (prime) {\n        return sentence;\n    }\n    std::string ans;\n   \
    \ std::for_each(std::begin(new_words), std::end(new_words), [&ans](std::string\
    \ s) {\n        ans = ans + s + \" \";\n    });\n    return ans;", "  std::vector\
    \ <int> new_list(sentence.begin(), sentence.end());\n  std::sort(new_list.begin(),\
    \ new_list.end());\n  new_list.erase(new_list.begin()+1, new_list.end());\n  std::unordered_set<int>\
    \ prime_list;\n  prime_list.reserve(new_list.size());\n  int new_list_size = new_list.size();\n\
    \  for (int i = 0; i < new_list_size; i++) {\n    int cur_prime = 1;\n    for\
    \ (int j = 1; j <= i; j++) {\n      if (i % j == 0) {\n        cur_prime = 0;\n\
    \        break;\n      }\n    }\n    if (cur_prime == 1) {\n      prime_list.insert(new_list[i]);\n\
    \    }\n  }\n\n  std::string result = \"\";\n  for (int i = 2; i < new_list_size;\
    \ i++) {\n    if (prime_list.count(i)) {\n      result += new_list[i];\n    }\n\
    \  }\n  return result;", "    std::string words;\n    for (int i = 0; i < sentence.size();\
    \ i++) {\n        int n = i + 1;\n        for (int j = 0; j < sentence.size();\
    \ j++)\n            if (i != j && std::isprime(n - sentence[j]))\n           \
    \     n = n - sentence[j];\n        words += sentence[i] + \" \";\n    }\n   \
    \ return words;", "    std::vector<std::pair<int, int>> primes;\n    primes.push_back(std::make_pair(1,\
    \ 0));\n    primes.push_back(std::make_pair(2, 1));\n    for (int i = 3; i < 100000;\
    \ i = i * 3 + 1) {\n        for (int j = 0; j < primes.size(); j++) {\n      \
    \      if (i % primes[j].first == 0) {\n                primes[j].second = i;\n\
    \                break;\n            }\n        }\n    }\n    std::string result;\n\
    \    std::set<int> uniqueWords;\n    for (auto &prime : primes) {\n        if\
    \ (uniqueWords.find(prime.second) == uniqueWords.end()) {\n            uniqueWords.insert(prime.second);\n\
    \            result += std::to_string(prime.first) + \" \" + std::to_string(prime.second)\
    \ + \" \";\n        }\n    }\n    for (auto &prime : uniqueWords) {\n        result\
    \ += std::to_string(prime) + \" \";\n    }\n    std::cout << result << std::endl;\n\
    \    return result;", "    int len = sentence.length();\n    std::string ans =\
    \ \"\";\n    for (int i = 0; i < len; ++i) {\n        int j = 0, flag = 1;\n \
    \       std::string tmp = \"\";\n        while (j < len) {\n            int k\
    \ = j + 1;\n            while (k < (len)) {\n                if (flag) {\n   \
    \                 if (sentence[i] == '_') {\n                        tmp += \"\
    \ \";\n                        k++;\n                    } else {\n          \
    \              if (sentence[i] == sentence[k]) {\n                           \
    \ flag = 0;\n                            j++;\n                            k++;\n\
    \                        } else {\n                            flag = 1;\n   \
    \                         j++;\n                        }\n                  \
    \  }\n                } else {\n                    if (sentence[i] != sentence[k])\
    \ {\n                        flag = 0;\n                        k++;\n       \
    \             } else {\n                        flag = 1;\n                  \
    \      k++;\n                    }\n                }\n            }\n       \
    \     ans += tmp;\n            tmp = \" \";\n        }\n    }\n    return ans;",
  "    // Your code here\n    std::string result = \"\";\n    for(int i = 0; i < sentence.length();\
    \ i++) {\n        result += sentence.substr(i, 1);\n    }\n    std::sort(result.begin(),\
    \ result.end());\n    \n    // Write your code here\n    \n    return result;",
  "  // write your code here\n  std::string res=\"\";\n  int m=(int)sqrt(sentence.size()),n=(int)sqrt(sentence.size()),i,j;\n\
    \  char arr[m][n];\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++){\n     \
    \ arr[i][j]=sentence[i];\n    }\n  }\n  for(int i=0;i<m;i++){\n    for(int j=1;j<n;j++){\n\
    \      if(arr[i][j]==arr[i][j-1])\n      {\n        if(j==n)\n        {\n    \
    \      res+=arr[i][j-1];\n          break;\n        }\n        for(int k=0;k<n;k++)\n\
    \        {\n          arr[i][k]=arr[i][k+1];\n        }\n      }\n    }\n  }\n\
    \  return res;", "    std::vector<int> primes;\n    std::string result;\n    int\
    \ max_i = -1;\n    for (char c : sentence) {\n        if (c == ' ') {\n      \
    \      primes.push_back(0);\n            max_i++;\n        } else {\n        \
    \    assert(c >= 'a' && c <= 'z');\n            int num = c - 'a' + 1;\n     \
    \       if (max_i == -1) {\n                max_i = num;\n            }\n    \
    \        assert(max_i <= num);\n            primes.push_back(max_i);\n       \
    \     max_i = num;\n        }\n    }\n    assert(max_i > 1);\n    primes.push_back(max_i\
    \ + 1);\n    for (int i = 0; i < primes.size(); i++) {\n        while (i > 0 &&\
    \ primes[i] == primes[i - 1] - 1) {\n            primes[i - 1]++;\n        }\n\
    \        result += std::to_string(primes[i]) + \" \";\n    }\n    result.erase(result.length()\
    \ - 1, 1);\n    return result;", "    // Write your code here\n    std::string\
    \ temp(sentence);\n    std::string output=\"\";\n    \n    for(int i=0;i<temp.size();i++)\
    \ {\n        int j=temp[i]-'a';\n        if((j%2==1) && (output.length()!=0)){\n\
    \            output+=' ';\n        }\n        output+=temp[i];\n    }\n    return\
    \ output;", "  // Write your code here.\n  std::map<int, int> primes;\n  std::string\
    \ res;\n  std::string word;\n  for (int i = 1; i < sentence.length(); i++) {\n\
    \    if (sentence[i] != ' ') {\n      if (primes[sentence[i]] == 0) {\n      \
    \  primes[sentence[i]] = 1;\n        word = sentence[i];\n      }\n      else\
    \ {\n        while (primes[word] <= sentence[i]) {\n          primes[word] +=\
    \ 1;\n          word += sentence[i];\n        }\n      }\n    }\n  }\n  primes.erase('\
    \ ');\n  for (auto& prime: primes) {\n    res += word;\n  }\n  return res;", " \
    \   std::vector<std::string> sorted_words;\n    std::set<std::string> unique_words;\n\
    \    for (auto &word : sentence.split(\" \")) {\n        if (!unique_words.count(word))\
    \ {\n            unique_words.insert(word);\n            sorted_words.push_back(word);\n\
    \        }\n    }\n    std::string result;\n    for (auto &word : sorted_words)\
    \ {\n        std::cout << word << \" \";\n        if (std::next_permutation(result.begin(),\
    \ result.end(), [&word](std::string &elem) {\n            return elem == word;\n\
    \        })) {\n            return result;\n        }\n    }\n    return \"\";",
  "  int n = std::distance(sentence.begin(), std::find(sentence.begin(), sentence.end(),\
    \ ' '));\n  std::unordered_map<int, int> map;\n  for (int i = 0; i < n; ++i) {\n\
    \    if (map[sentence[i]] == 0) {\n      map[sentence[i]] = i + 1;\n      map[sentence[i]]\
    \ += 1;\n    }\n  }\n  std::string res = \"\";\n  for (auto itr = map.begin();\
    \ itr != map.end(); ++itr) {\n    if (itr->second == 2) {\n      res += std::to_string(itr->first);\n\
    \      break;\n    }\n  }\n  return res;", "    // Write your code here.\n   \
    \ std::vector<std::string> res;\n    bool flag = false;\n    for (std::string\
    \ word : sentence)\n    {\n        if (!flag)\n        {\n            std::string\
    \ temp = word;\n            flag = true;\n        }\n        \n        else if\
    \ ((word == temp) && (word != \" \"))\n        {\n            res.push_back(word);\n\
    \        }\n    }\n    \n    std::sort(res.begin(), res.end());\n    std::string\
    \ str = res.front();\n    for (int i = 0; i < str.length(); i++)\n    {\n    \
    \    for (int j = i + 1; j < str.length(); j++)\n        {\n            if (str[i]\
    \ == str[j])\n            {\n                res.erase(res.begin() + j);\n   \
    \         }\n        }\n    }\n    std::reverse(std::begin(res), std::end(res));\n\
    \    \n    return str;", "    std::string res;\n    for(int i = 0; i < sentence.size();\
    \ i++) {\n        for(int j = i + 1; j < sentence.size(); j++) {\n           \
    \ char c = sentence[i];\n            char d = sentence[j];\n            if((c\
    \ > 'z' || c < 'a') || (d > 'z' || d < 'a')) {\n                if((c > 'z' ||\
    \ d > 'z') && (d > c)) {\n                    res[i] = d;\n                  \
    \  res[j] = c;\n                }\n            }\n        }\n    }\n    return\
    \ res;", "  // Your code goes here\n  \n  \n  return sentence;", "  std::string\
    \ new_sentence = \"\";\n  std::set<char> set_of_characters;\n  std::string temp_word\
    \ = \"\";\n  bool flag = false;\n  for (char c : sentence) {\n    if (set_of_characters.count(c))\
    \ {\n      flag = true;\n      temp_word += c;\n    } else {\n      if (!flag)\
    \ {\n        new_sentence += temp_word;\n        temp_word = \"\";\n        flag\
    \ = true;\n      }\n    }\n    set_of_characters.insert(c);\n  }\n  new_sentence\
    \ += temp_word;\n  return new_sentence;", "  std::string result;\n  for (int i\
    \ = 0; i < sentence.size(); i++) {\n    result += \" \";\n    for (int j = i;\
    \ j < sentence.size(); j++) {\n      result += sentence[j];\n      std::sort(result.begin(),\
    \ result.end());\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return\
    \ result;", "    std::string::size_type firstIndex = sentence.find_first_not_of(\"\
    \ \");\n    std::string::size_type lastIndex = sentence.find_last_not_of(\" \"\
    );\n    std::string::size_type middleIndex = sentence.length() - (lastIndex -\
    \ firstIndex);\n    std::string newSentence = sentence.substr(firstIndex, middleIndex);\n\
    \    std::string newSentence2 = sentence.substr(middleIndex, lastIndex);\n   \
    \ std::string newSentence3 = newSentence + \" \" + newSentence2;\n    std::string\
    \ newSentence4 = newSentence3 + \" \" + newSentence2;\n    std::string newSentence5\
    \ = newSentence4 + \" \" + newSentence2;\n    int primesNum = 0;\n    std::string\
    \ primeNumbers = \"\";\n    for (int i = 0; i < newSentence5.length(); i++) {\n\
    \        if (primeNumbers.find(newSentence5[i]) == std::string::npos) {\n    \
    \        primeNumbers += newSentence5[i];\n            primesNum++;\n        }\n\
    \    }\n    for (int i = primesNum; i < newSentence5.length(); i++) {\n      \
    \  newSentence3 += \" \" + newSentence5[i];\n    }\n    return newSentence3;",
  "  int n = sentence.size();\n  std::string res;\n  // Your code here\n  if(n % 2\
    \ == 0){\n    int sum = 0;\n    for(int i = 0; i < n; i++){\n      sum += (sentence.at(i)-'a')\
    \ * (i+1)%26;\n    }\n    if(sum % 2 != 0){\n      return \"None\";\n    }\n \
    \   int start = n/2-1;\n    for(int i = 0; i < start; i++){\n      sum -= (sentence.at(i)-'a')\
    \ * (i+1)%26;\n      if(sum % 2 != 0){\n        return \"None\";\n      }\n  \
    \  }\n    for(int i = 0; i < start; i++){\n      sum += (sentence.at(i)-'a') *\
    \ (i+1)%26;\n      if(sum % 2 != 0){\n        return \"None\";\n      }\n    }\n\
    \    int end = n/2;\n    for(int i = end-1; i >= 0; i--){\n      sum -= (sentence.at(i)-'a')\
    \ * (i+1)%26;\n      if(sum % 2 != 0){\n        return \"None\";\n      }\n  \
    \  }\n    res.assign(sentence.begin() + start, sentence.begin() + end);\n  }\n\
    \  else{\n    int sum = 0;\n    for(int i = 0; i < n; i++){\n      sum += (sentence.at(i)-'a')\
    \ * (i+1)%26;\n    }\n    if(sum % 2 != 0){\n      return \"None\";\n    }\n \
    \   int start = n/2-1;\n    for(int i = 0; i < start; i++){\n      sum -= (sentence.at(i)-'a')\
    \ * (i+1)%26;\n      if(sum % 2 != 0){\n        return \"None\";\n      }\n  \
    \  }\n    for(int i = 0; i < start; i++){\n      sum += (sentence.at(i)-'a') *\
    \ (i+1)%26;\n      if(sum % 2 != 0){\n        return \"None\";\n      }\n    }\n\
    \    int end = n/2;\n    for(int i = end-1; i >= 0; i--){\n      sum -= (sentence.at(i)-'a')\
    \ * (i+1)%26;\n      if(sum % 2 != 0){\n        return \"None\";\n      }\n  \
    \  }\n    res.assign(sentence.begin() + start, sentence.begin() + end);\n  }\n\
    \  return res;", "    std::stack<char> word_stack;\n    for (char c : sentence)\n\
    \    {\n        if (c == ' ')\n        {\n            word_stack.push(c);\n  \
    \      }\n        else if (!isalpha(c))\n        {\n            break;\n     \
    \   }\n        else\n        {\n            while (word_stack.empty() && !isalpha(c))\n\
    \            {\n                word_stack.push(c);\n            }\n         \
    \   if (word_stack.empty())\n            {\n                break;\n         \
    \   }\n            int wordLen = (word_stack.top() - '0');\n            if (!isPrime(wordLen))\n\
    \            {\n                break;\n            }\n            word_stack.pop();\n\
    \        }\n    }\n    return word_stack.empty() ? \"\" : word_stack.top();",
  "    // your code goes here\n    std::unordered_map<int, bool> visited;\n    std::string\
    \ results;\n    for (char &i: sentence)\n    {\n        if (visited[i])\n    \
    \    {\n            continue;\n        }\n        visited[i] = true;\n       \
    \ std::string temp;\n        std::set<int> primes;\n        for (char &j: sentence)\n\
    \        {\n            if (j == ' ')\n            {\n                break;\n\
    \            }\n            primes.insert(j);\n            if (primes.count(j))\n\
    \            {\n                temp.push_back(j);\n            }\n        }\n\
    \        results.insert(results.end(), temp.begin(), temp.end());\n    }\n   \
    \ return results;", "    std::string word_ = \"\";\n    bool isPrime = true;\n\
    \n    for (int i = 3; i <= sqrt(sentence.size()); i++) {\n        if (isPrime\
    \ && isPrime(sentence.size(), i)) {\n            isPrime = true;\n           \
    \ word_ += \" \" + sentence[i];\n        } else if (isPrime) {\n            isPrime\
    \ = false;\n            word_ += \" \" + sentence[i];\n        } else {\n    \
    \        word_ += \" \" + sentence[i];\n        }\n    }\n    return word_;",
  "    // Write your code here.\n    std::string s;\n    std::istringstream iss(sentence);\n\
    \    while (iss) {\n        std::string temp;\n        is >> temp;\n        temp\
    \ += ' ';\n        s += temp;\n        iss.ignore();\n    }\n    std::istringstream\
    \ iss1(s);\n    while (iss1) {\n        std::string temp;\n        iss1 >> temp;\n\
    \        if (!std::any_of(temp.begin(), temp.end(), ::isdigit))\n            s\
    \ += temp + ' ';\n        else\n            s += temp;\n        iss1.ignore();\n\
    \    }\n    std::string s1(s);\n    for (int i = 0; i < s.length(); i++)\n   \
    \ {\n        int count = 0;\n        for(int j=0;j<s1.length();j++)\n        {\n\
    \            if(s[i]==s1[j])\n                count++;\n        }\n        if(count==1)\n\
    \            s1.erase(i--,1);\n    }\n    return s1;", "    std::string res;\n\
    \    auto it = sentence.begin();\n    for (; it != sentence.end(); ++it) {\n \
    \       int len = 2;\n        for (int i = 0; i <= len; ++i) {\n            int\
    \ flag = 1;\n            for (int j = 0; j < len; ++j) {\n                if (*it\
    \ == ' ') {\n                    break;\n                }\n                if\
    \ (*it != *((it + j + 1))) {\n                    flag = 0;\n                \
    \    break;\n                }\n            }\n            if (flag) {\n     \
    \           len = i + 1;\n            }\n        }\n        res.push_back(std::to_string(len));\n\
    \    }\n    return res;", "    std::sort(sentence.begin(), sentence.end());\n\
    \    std::string result = \"\";\n    int n = 1;\n    for (int i = 0; i < sentence.length();\
    \ ++i) {\n        for (int j = i; j < sentence.length(); ++j) {\n            if\
    \ (n%sentence[j] == 0) {\n                result += sentence[j];\n           \
    \     break;\n            }\n        }\n        ++n;\n    }\n    return result;",
  "  std::sort(sentence.begin(), sentence.end());\n  \n  std::vector<int> prime_numbers;\n\
    \  for (auto &word:sentence) {\n    word = std::tolower(word);\n    if (word ==\
    \ ' ') {\n      if (prime_numbers.empty()) {\n        prime_numbers.push_back(1);\n\
    \      }\n      else {\n        prime_numbers.push_back(prime_numbers[0]);\n \
    \     }\n    }\n    else {\n      int n = prime_numbers[0];\n      for (int i\
    \ = prime_numbers.size() - 1; i >= 0; i--) {\n        n = pow(n, i) + 1;\n   \
    \     if (prime_numbers[i] < n) {\n          prime_numbers[i] = n;\n         \
    \ break;\n        }\n      }\n    }\n  }\n\n  std::ostringstream os;\n  std::copy(prime_numbers.begin(),\
    \ prime_numbers.end(), std::ostream_iterator<int>(os, \" \"));\n\n  return os.str();",
  "\t\n\tstd::stack<std::string> st;\n\tfor (char &ch : sentence)\n\t{\n\t\tif (isalpha(ch))\n\
    \t\t{\n\t\t\tchar ch1 = ch;\n\t\t\tst.push(ch1);\n\t\t}\n\t}\n\t\n\tstd::string\
    \ ans = \"\";\n\twhile (!st.empty())\n\t{\n\t\tint n = st.top();\n\t\tst.pop();\n\
    \t\tans = ans + \" \" + n;\n\t}\n\t\n\tstd::string res = ans.substr(1);\n\t\n\t\
    return res;", "    std::string new_sentence = \"\";\n    char character;\n   \
    \ for (char c: sentence) {\n        if (c == ' ') {\n            for (int i =\
    \ 0; i <= 3; i++) {\n                character = sentence[i];\n              \
    \  if (isprime(i) && c != character) {\n                    new_sentence += c;\n\
    \                }\n            }\n        }\n    }\n    return new_sentence;",
  "    string answer;\n    for(auto itr = sentence.begin(); itr != sentence.end();\
    \ ++itr) {\n        char c = *itr;\n        std::unordered_set<char> s;\n    \
    \    for(auto itr = sentence.begin(); itr != sentence.end(); ++itr) {\n      \
    \      if(s.find(*itr) == s.end()) {\n                if(c == *itr) {\n      \
    \              s.insert(*itr);\n                }\n            }\n        }\n\
    \        answer += s;\n    }\n    std::reverse(answer.begin(), answer.end());\n\
    \    return answer;", "    //write your code here\n    std::vector<int> v;\n \
    \   for(auto &i: sentence){\n        if(isalpha(i)){\n            v.push_back(i);\n\
    \        }\n    }\n    for(int i = 1 ; i <= std::sqrt(v.size());i++){\n      \
    \  if(v.at(i) % i != 0){\n            for(auto &i: v){\n                assert(isalpha(i));\n\
    \            }\n            return sentence.substr(0,i);\n        }\n    }\n \
    \   for(auto &i: v){\n        assert(isalpha(i));\n    }\n    return sentence;",
  "  assert(sentence.size() <= 100);\n  auto res = \"\";\n  auto n = 1;\n  auto primes\
    \ = primeFactors(n);\n  for (auto &prime : primes) {\n    for (auto &c : sentence)\
    \ {\n      if (c == ' ') {\n        continue;\n      }\n      if (n % prime ==\
    \ 0) {\n        res += c;\n        break;\n      }\n    }\n  }\n  return res;",
  "    // your code here\n    std::string out;\n    for (size_t i = 0; i < sentence.length();\
    \ i++) {\n        if (is_prime_number(sentence.length())) {\n            if (i\
    \ != 0) {\n                out += \"\\n\";\n            }\n            out +=\
    \ sentence[i];\n        }\n    }\n    return out;", "    std::string result;\n\
    \    for (char c : sentence) {\n        if (c >= 'a' && c <= 'z') {\n        \
    \    result += c;\n        }\n    }\n    size_t new_length = result.length();\n\
    \    std::string new_result;\n    while (new_length % 2 == 0) {\n        new_result\
    \ += \"0\";\n    }\n    for (auto it = result.begin(); it != result.end(); ++it)\
    \ {\n        if (std::find(result.begin(), result.end(), *it) != result.end())\
    \ {\n            new_result += *it;\n        }\n    }\n    return new_result;",
  "    std::map<std::string, int> map;\n    for (auto &it : map) {\n        it = 0;\n\
    \    }\n    std::string res = \"\";\n    bool flag = false;\n    for (auto &it\
    \ : map) {\n        flag = true;\n        for (auto &jt : it) {\n            if\
    \ (jt > 1) {\n                flag = false;\n            }\n        }\n      \
    \  if (flag) {\n            res += it.first + \" \";\n        }\n    }\n    return\
    \ res;", "    vector<string> temp;\n    vector<int> prime_numbers;\n    int cnt\
    \ = 0;\n    for (auto i : sentence) {\n        if (isalnum(i)) {\n           \
    \ temp.push_back(i);\n            prime_numbers.push_back(cnt);\n        }\n \
    \       cnt++;\n    }\n    sort(temp.begin(), temp.end());\n    int last_prime\
    \ = 0;\n    string answer;\n    for (auto i : temp) {\n        int cnt = 1;\n\
    \        for (auto j : prime_numbers) {\n            if (j < i) {\n          \
    \      cnt++;\n            }\n        }\n        if (cnt > 1) {\n            answer.push_back(i);\n\
    \            last_prime = i;\n        }\n    }\n    for (auto i : prime_numbers)\
    \ {\n        while (last_prime % i != 0) {\n            last_prime++;\n      \
    \  }\n    }\n    return answer;", "    assert(sentence.length() <= 100);\n   \
    \ \n    auto new_string = sentence.substr(0, sentence.find_first_not_of(' '));\n\
    \    \n    for (size_t i = 1; i < sentence.length(); i++) {\n        \n      \
    \  while (i % new_string.length() == 0) {\n            if (new_string.length()\
    \ % i == 0) {\n                new_string += \" \";\n            }\n         \
    \   i += 1;\n        }\n        new_string += sentence.substr(i, 1);\n    }\n\
    \    \n    return new_string;", "  std::string temp = \"\";\n  for(int i = 0;\
    \ i <= 100; i++) {\n    bool isPrime = true;\n    for (int j = 2; j < i; j++)\
    \ {\n      if (i % j == 0) {\n        isPrime = false;\n        break;\n     \
    \ }\n    }\n    if (isPrime) {\n      temp += \" \";\n      temp += i;\n    }\n\
    \  }\n  int count = 0, size = 0;\n  for(int i = 0; i <= temp.length(); i++) {\n\
    \    if(temp.substr(i, 1).length() == 0) {\n      count++;\n    }\n    if(temp.substr(i,\
    \ 1).length() == 1) {\n      size++;\n    }\n  }\n  std::stringstream ss;\n  ss\
    \ << count;\n  std::string str = ss.str();\n  ss << size;\n  str = ss.str();\n\
    \  std::string newstr = str.substr(0, str.length() - 1);\n  for(int i = 0; i <=\
    \ temp.length(); i++) {\n    if(temp.substr(i, 1).length() == 0) {\n      newstr\
    \ += \" \";\n    }\n    if(temp.substr(i, 1).length() == 1) {\n      newstr +=\
    \ temp.substr(i, 1);\n    }\n  }\n  return newstr;", "    int n = 0;\n    int\
    \ l = 0;\n    int count[100];\n    for (char c: sentence) {\n        if (c >=\
    \ 'a' && c <= 'z') {\n            count[l]++;\n            l++;\n        } else\
    \ {\n            n++;\n        }\n    }\n    int prime[100], flag = 0;\n    for\
    \ (int i = 0; i <= n; i++) {\n        prime[i] = i;\n        if (count[i] > 1)\
    \ {\n            for (int j = 2; j < count[i]; j++) {\n                if (prime[j]\
    \ != prime[prime[j]]) {\n                    flag = 1;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    if (flag == 0) {\n  \
    \      return sentence;\n    } else {\n        std::stringstream ss;\n       \
    \ ss << sentence << std::flush;\n        std::string result;\n        while ((ss\
    \ >> result)) {\n            std::cout << result << std::endl;\n        }\n  \
    \  }\n    return \"\";", "  // your code here\n  std::string words;\n  int len\
    \ = sentence.length();\n  for (int i = 0; i < len / 2; i++) {\n    int count =\
    \ 0;\n    for (int j = i * 2; j < (i + 1) * 2; j++)\n      if (sentence[j] ==\
    \ '_')\n        count++;\n    if (count % 2 == 0)\n      words += sentence.substr(i\
    \ * 2, i);\n  }\n  return words;", "    // code here\n    int n = sentence.size();\n\
    \    std::string ans = \"\";\n    for (int i = 0; i < n; ++i) {\n        int count\
    \ = 0;\n        for (int j = 0; j < n; ++j) {\n            if (i == j) continue;\n\
    \            if (sentence[i] == sentence[j]) count++;\n        }\n        if (count\
    \ > 1) {\n            ans += sentence[i];\n        }\n    }\n    return ans;",
  "    std::string ans = \"\";\n    std::string words[100];\n    std::string word\
    \ = \"\";\n    int n = 0, p = 0, n2 = 0, p2 = 0, n3 = 0, p3 = 0;\n    for (int\
    \ i = 0; i <= sentence.length() - 1; i++) {\n        if (!isalpha(sentence[i]))\
    \ {\n            n = n + 1;\n            words[n] = word;\n        }\n       \
    \ if (i == sentence.length() - 1) {\n            n = n + 1;\n            words[n]\
    \ = word;\n        } else {\n            word = sentence[i];\n        }\n    }\n\
    \    for (int i = 0; i < n; i++) {\n        if (isalpha(words[i])) {\n       \
    \     p2 = words[i].length();\n        }\n    }\n    for (int i = 1; i < n; i++)\
    \ {\n        if (isalpha(words[i])) {\n            p3 = words[i].length();\n \
    \       }\n    }\n    for (int i = 0; i <= sentence.length() - 1; i++) {\n   \
    \     if (!isalpha(sentence[i])) {\n            ans += sentence[i];\n        }\n\
    \        if (i == sentence.length() - 1) {\n            ans += sentence[i];\n\
    \        } else {\n            ans += \" \";\n        }\n    }\n    for (int i\
    \ = 0; i <= sentence.length() - 1; i++) {\n        if (!isalpha(sentence[i]))\
    \ {\n            ans += \" \";\n        }\n    }\n    for (int i = 0; i <= sentence.length()\
    \ - 1; i++) {\n        if (!isalpha(sentence[i])) {\n            ans += \" \"\
    ;\n        }\n    }\n    for (int i = 0; i <= sentence.length() - 1; i++) {\n\
    \        if (!isalpha(sentence[i])) {\n            ans += \" \";\n        }\n\
    \    }\n    return ans;", "    // Write your code here\n    std::vector<std::string>\
    \ words;\n    std::string words_str;\n    std::stringstream ss(sentence);\n  \
    \  for (std::string word; std::getline(ss, word, ' '); ) {\n        if (words.empty()\
    \ || words.size() > 1) {\n            words.push_back(word);\n        } else {\n\
    \            if (words[0] == word) {\n                words_str += word + \" \"\
    ;\n            } else {\n                words_str += words[0] + \" \";\n    \
    \            words.clear();\n            }\n        }\n    }\n    if (!words.empty())\n\
    \        words_str += words[0];\n    return words_str;", "  std::unordered_set<long\
    \ long> s;\n  long long n = 1;\n  for (auto &c : sentence) {\n    s.insert(c);\n\
    \    n += (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') ? 2 : 1;\n\
    \  }\n  std::vector<std::string> result;\n  while (s.size() >= 2) {\n    result.push_back(s.begin()->first);\n\
    \    s.pop_back();\n  }\n  for (auto &c : s) {\n    result.push_back(c);\n  }\n\
    \  return std::accumulate(result.begin(), result.end(), std::string(), [](const\
    \ std::string &a, const std::string &b) {\n    return a + b;\n  });", "    \n\
    \    // Your code goes here\n    std::string result=\"\";\n    int i=0,j=0;\n\
    \    int n=sentence.size();\n    for(i=0;i< n;i++)\n    {\n        if((i%2)==0)\n\
    \        {\n            int k=0;\n            while(i<n && sentence[i]!=' ')\n\
    \            {\n                k++;\n                i++;\n            }\n  \
    \          result+=sentence[i];\n            i++;\n            while(i<n && sentence[i]!='\
    \ ')\n            {\n                j+=k;\n                i++;\n           \
    \ }\n        }\n        else\n        {\n            int k=0;\n            while(i<n\
    \ && sentence[i]!=' ')\n            {\n                k++;\n                i++;\n\
    \            }\n            result+=sentence[i];\n            j+=k;\n        \
    \    i++;\n            while(i<n && sentence[i]!=' ')\n            {\n       \
    \         result+=sentence[i];\n                i++;\n            }\n        }\n\
    \    }\n    return result;", "    std::vector<int> primes;\n    primes.push_back(0);\n\
    \    primes.push_back(1);\n    primes.push_back(2);\n    primes.push_back(3);\n\
    \    for (int i = 4; i < std::sqrt(static_cast<double>(primes.size())); i += 2)\n\
    \        primes.push_back(i);\n    std::string res;\n    for (auto it : primes)\n\
    \    {\n        std::string str = \" \" + sentence;\n        int x = std::find(str.begin(),\
    \ str.end(), it);\n        if (x == str.end())\n        {\n            continue;\n\
    \        }\n        res += sentence[x];\n        str = \" \" + sentence;\n   \
    \     sentence = str.erase(0, x);\n    }\n    return res;", "    int n = sentence.length();\n\
    \    std::string res = \"\";\n    for (int i = 0; i < n; i++) {\n        int j\
    \ = 0, k = 1;\n        while (j + 1 < n && k <= i) {\n            if (i == j +\
    \ 1) break;\n            if (sentence[j] == ' ') j++;\n            else j++;\n\
    \            k++;\n        }\n        if (i == j + 1) {\n            res += sentence[i];\n\
    \            i++;\n        }\n        if (i + 1 < n) {\n            res += \"\
    \ \" + sentence[i];\n            i++;\n        }\n    }\n    return res;", " \
    \   std::string result = \"NULL\";\n    int n = sentence.length();\n    if (n\
    \ < 2) {\n        return result;\n    }\n    std::set<int> primes;\n    primes.insert(2);\n\
    \    for (auto it = sentence.begin(); it < sentence.end(); it++) {\n        int\
    \ next = it+1;\n        if (next == sentence.end()) {\n            next = sentence.begin();\n\
    \        }\n        int flag = 1;\n        while (next < sentence.end()) {\n \
    \           int cur_prime = 1;\n            for (auto it_prime = primes.begin();\
    \ it_prime != primes.end(); it_prime++) {\n                int cur = *it_prime;\n\
    \                while (cur >= next && flag) {\n                    cur /= next;\n\
    \                    flag = 0;\n                }\n                if (cur % next\
    \ == 0) {\n                    cur_prime *= cur % next;\n                    flag\
    \ = 1;\n                }\n            }\n            if (cur_prime != 1) {\n\
    \                primes.insert(next);\n                break;\n            }\n\
    \            ++next;\n        }\n    }\n    for (auto it = primes.begin(); it\
    \ != primes.end(); it++) {\n        result += ' ';\n        result += *it;\n \
    \   }\n    return result;", "    std::stack<std::string> st;\n    std::stack<size_t>\
    \ stp;\n    std::string res;\n    int n = sentence.length();\n    for(int i =\
    \ 0; i < n; i++)\n    {\n        if(!isalpha(sentence[i]))\n        {\n      \
    \      res += sentence[i];\n            continue;\n        }\n        stp.push(i);\n\
    \        if(isalpha(sentence[i]))\n        {\n            while(!stp.empty() &&\
    \ isalpha(sentence[stp.top()]))\n            {\n                stp.pop();\n \
    \               stp.push(i);\n            }\n        }\n        while(!stp.empty())\n\
    \        {\n            int left = stp.top();\n            stp.pop();\n      \
    \      int right = i;\n            while(left < right)\n            {\n      \
    \          if(isalpha(sentence[left]) && isalpha(sentence[right]))\n         \
    \       {\n                    while(stp.top() < right)\n                    {\n\
    \                        stp.pop();\n                    }\n                 \
    \   while(!stp.empty() && isalpha(sentence[stp.top()]))\n                    {\n\
    \                        stp.pop();\n                        stp.push(i);\n  \
    \                  }\n                }\n                else if(isalpha(sentence[left])\
    \ && !isalpha(sentence[right]))\n                {\n                    break;\n\
    \                }\n                else if(isalpha(sentence[right]) && !isalpha(sentence[left]))\n\
    \                {\n                    break;\n                }\n          \
    \      else if(sentence[left] == sentence[right])\n                {\n       \
    \             left = stp.top() + 1;\n                }\n                else\n\
    \                {\n                    break;\n                }\n          \
    \  }\n        }\n        stp.push(i);\n        res += sentence[i];\n    }\n  \
    \  return res;", "    std::string ans = \"is\";\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (i % 2 != 0 && i > 1) {\n            ans += \" \";\n    \
    \    }\n        bool isPrime = false;\n        for (int j = i; j < i + 100; j++)\
    \ {\n            if (j % i == 0) {\n                isPrime = true;\n        \
    \    }\n        }\n        if (isPrime) {\n            ans += sentence[i];\n \
    \       }\n    }\n    return ans;", "    \n    int ans[10][10][10][10][10][10][10][10][10];\n\
    \    \n    for (int i = 0; i < sentence.length(); i++) {\n        char ch = sentence[i];\n\
    \        if (ch == ' ') {\n            continue;\n        }\n        for (int\
    \ j = 0; j < 10; j++) {\n            ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch]\
    \ = 1;\n        }\n    }\n    \n    for (int i = 0; i < 10; i++) {\n        for\
    \ (int j = 0; j < 10; j++) {\n            for (char ch = 'a'; ch <= 'z'; ch++)\
    \ {\n                for (int k = 0; k < 10; k++) {\n                    for (int\
    \ l = 0; l < 10; l++) {\n                        for (int m = 0; m < 10; m++)\
    \ {\n                            for (int n = 0; n < 10; n++) {\n            \
    \                    for (int o = 0; o < 10; o++) {\n                        \
    \            for (int p = 0; p < 10; p++) {\n                                \
    \        for (int q = 0; q < 10; q++) {\n                                    \
    \        for (int r = 0; r < 10; r++) {\n                                    \
    \            for (int s = 0; s < 10; s++) {\n                                \
    \                    for (int t = 0; t < 10; t++) {\n                        \
    \                                for (int u = 0; u < 10; u++) {\n            \
    \                                                for (int v = 0; v < 10; v++)\
    \ {\n                                                                for (int\
    \ w = 0; w < 10; w++) {\n                                                    \
    \                for (int x = 0; x < 10; x++) {\n                            \
    \                                            for (int y = 0; y < 10; y++) {\n\
    \                                                                            for\
    \ (int z = 0; z < 10; z++) {\n                                               \
    \                                 if (ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch]\
    \ == 1) {\n                                                                  \
    \                  ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch]\
    \ = ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch];\n     \
    \                                                                           }\n\
    \                                                                            }\n\
    \                                                                        }\n \
    \                                                                   }\n      \
    \                                                          }\n               \
    \                                             }\n                            \
    \                            }\n                                             \
    \       }\n                                                }\n               \
    \                             }\n                                            if\
    \ (ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch] == 1) {\n   \
    \                                             if (i == 0) {\n                \
    \                                    ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch]\
    \ = ans[i][j][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch][ch", "  std::stack<char>\
    \ st;\n  std::stack<char> st2;\n  std::string res;\n  for (auto s : sentence)\
    \ {\n    if (st2.empty()) st.push(s);\n    else if (st2.top() == s) {\n      st2.pop();\n\
    \    } else {\n      while (!st2.empty() && st2.top() != s) st2.pop();\n     \
    \ if (st2.empty()) st.push(s);\n      else st.push(s);\n    }\n  }\n  while (!st.empty())\
    \ {\n    res += st.top();\n    st.pop();\n  }\n  return res;", "    // Write your\
    \ code here\n    std::string str;\n    int n = static_cast<int>(sentence.size())\
    \ / 2;\n    \n    bool flag = true;\n    bool flag2 = false;\n    \n    for (int\
    \ i = 0; i < n; i++){\n        for (int j = i + 1; j < n; j++){\n            if\
    \ (sentence[i] == sentence[j]){\n                flag = true;\n              \
    \  flag2 = true;\n            }\n        }\n        if (flag){\n            str\
    \ += sentence[i];\n            flag = false;\n        }\n    }\n    \n    \n \
    \   bool flag3 = true;\n    \n    for (int i = 0; i < n; i++){\n        for (int\
    \ j = i + 1; j < n; j++){\n            if (flag2){\n                flag3 = true;\n\
    \            }\n            if (sentence[i] == sentence[j]){\n               \
    \ flag3 = false;\n            }\n        }\n        if (flag3){\n            str\
    \ += \" \" + sentence[i];\n            flag3 = false;\n        }\n    }\n    \n\
    \    \n    return str;", "    // write your code here\n    assert(sentence.size()>0);\n\
    \    std::stack<bool> st;\n    std::string ans=\"\";\n    for (char c:sentence){\n\
    \        if (!st.empty() && st.pop()){\n            ans.push_back(c);\n      \
    \  }\n        else if(!isalpha(c)){\n            st.push(false);\n        }\n\
    \    }\n    return ans;", "  // Write your code here\n  bool prime[] = {false,\
    \ false};\n  int n = sentence.length();\n  vector<int> prime_count(n);\n  int\
    \ num_count = 0;\n  for (int i = 0; i < n; i++) {\n    std::string temp = sentence;\n\
    \    if (i % 2 == 1) {\n      temp = temp.substr(0, i) + temp.substr(i + 1);\n\
    \    }\n    // Check if it can be divided evenly with any number\n    for (int\
    \ j = 0; j < i; j++) {\n      if (temp[j] == ' ') {\n        prime[j] = true;\n\
    \        break;\n      }\n    }\n    if (prime[i]) {\n      prime_count[num_count++]\
    \ = i;\n    }\n  }\n  assert(num_count > 0);\n  // print out the result\n  string\
    \ ans = \"\";\n  for (int i = 0; i < n; i++) {\n    if (prime_count[i] % 2 ==\
    \ 0) {\n      ans += sentence[i];\n    }\n  }\n  return ans;", "    std::string\
    \ result;\n    size_t i, len = sentence.length();\n    \n    // You can either\
    \ use unordered_map or unordered_set\n    std::unordered_set<int> prime;\n   \
    \ for (i = 0; i < len; i++)\n        if (std::all_of(sentence.begin() + i, sentence.begin()\
    \ + i + 1, ::isspace))\n            ++i;\n        else\n            prime[i] =\
    \ false;\n    \n    for (i = 1; i < len; ++i)\n        if (prime[i])\n       \
    \     result.push_back(sentence.begin() + i);\n    return result;", "    std::vector<std::string>\
    \ words;\n    std::istringstream stream(sentence);\n    std::string word;\n  \
    \  while (stream >> word)\n        words.push_back(word);\n    sort(words.begin(),\
    \ words.end());\n    std::string ans;\n    for (int i = 0; i < words.size(); i++)\n\
    \        ans += words[i];\n    for (int i = 0; i < words.size() ; i++) {\n   \
    \     if (ans[i] != '_') {\n            int j = 1;\n            for (int k = i;\
    \ k < words.size() && j < words[k].length(); k++) {\n                if (ans[k]\
    \ != words[k].at(j)) {\n                    break;\n                }\n      \
    \          j++;\n            }\n            if (j == words[k].length()) {\n  \
    \              ans += words[k];\n            }\n        }\n    }\n    return ans;",
  "    std::string rev_sentence;\n    std::reverse(sentence.begin(), sentence.end());\n\
    \    rev_sentence.resize(sentence.size());\n    std::reverse(rev_sentence.begin(),\
    \ rev_sentence.end());\n    std::stringstream ss(sentence);\n    std::string tmp;\n\
    \    std::string res;\n    while (std::getline(ss, tmp, ' ')) {\n        res +=\
    \ \" \" + tmp;\n    }\n    std::reverse(res.begin(), res.end());\n    return res;",
  "    int n = sentence.length();\n    std::string result = \"\";\n    // To make\
    \ sure we are checking prime numbers only\n    // We will take the first character\
    \ of the sentence\n    // and check if the length is 1 or not\n    // If it is\
    \ 1 then it is not a prime number\n    // If it is 2, 3 or 5 then it is a prime\
    \ number\n    // Else we will continue checking other characters of sentence\n\
    \    for (int i = 0; i < n; i++) {\n        if (sentence[i] == 1) {\n        \
    \    // If we find 1 then we will not check\n            // other characters \n\
    \            if (i == 0) {\n                // If this is the first character\
    \ then\n                // the length of the string is not prime number\n    \
    \            // If this is the last character then\n                // the length\
    \ of the string is prime number\n                result += sentence[i];\n    \
    \        } else {\n                // If this is not the first character then\
    \ \n                // the length of the string is prime number\n            \
    \    // Checking the rest of characters\n                for (int j = i; j < n;\
    \ j++) {\n                    if (sentence[j] == 1) {\n                      \
    \  // If 1 then this is not a prime number\n                        result +=\
    \ sentence[j];\n                        break;\n                    }\n      \
    \              // If 1 then this is not a prime number\n                    result\
    \ += sentence[j];\n                }\n            }\n        } else {\n      \
    \      // If this is not the first character then \n            // the length\
    \ of the string is prime number\n            // Checking the rest of characters\n\
    \            for (int j = i; j < n; j++) {\n                if (sentence[j] !=\
    \ 1) {\n                    // If not 1 then this is not a prime number\n    \
    \                result += sentence[j];\n                    break;\n        \
    \        }\n                // If not 1 then this is not a prime number\n    \
    \            result += sentence[j];\n            }\n        }\n    }\n    return\
    \ result;", "    std::string words;\n    \n    for(int i = 0; sentence[i] != '\\\
    0'; i++){\n        if(sentence[i] >= 'a' && sentence[i] <= 'z'){\n           \
    \ words += sentence[i];\n        }\n    }\n\n    int prime_lengths[100] = {0};\n\
    \n    for(int i = 0; words[i] != ' '; i++){\n        int length = words[i].length();\n\
    \        if(length >= 2){\n            prime_lengths[length] += 1;\n        }\n\
    \    }\n\n    for(int i = 1; i <= 100; i++){\n        if(prime_lengths[i] == 0){\n\
    \            words += ' ';\n        }\n    }\n\n    return words;", "    std::string\
    \ result = \"\";\n    int len = sentence.length();\n    for (int i = 0; i < len;\
    \ i++) {\n        int length = 1;\n        bool is_prime = true;\n        for\
    \ (int j = 0; j < i; j++) {\n            if (sentence[j] != ' ') {\n         \
    \       if (sentence[j] != sentence[i]) {\n                    is_prime = false;\n\
    \                    break;\n                }\n            } else {\n       \
    \         break;\n            }\n        }\n        if (is_prime) {\n        \
    \    result += sentence[i];\n        }\n    }\n    return result;", "  std::unordered_map<char,\
    \ int> map;\n  // create a string for output and initialize all to 0\n  std::string\
    \ output(sentence.length(), 0);\n  for (auto c : sentence) {\n    map[c]++;\n\
    \  }\n  for (auto it=map.begin(); it!=map.end(); it++) {\n    if(it->second==1)\n\
    \      output+=it->first;\n  }\n  return output;", "    // code here\n    std::string\
    \ ret = \"\";\n    for (int i = 0; i < sentence.size(); i++) {\n        bool is_prime\
    \ = false;\n        for (int j = 2 * i; j < sentence.length(); j++) {\n      \
    \      if (sentence[j] % i == 0) {\n                is_prime = true;\n       \
    \         break;\n            }\n        }\n        if (is_prime) {\n        \
    \    ret += sentence[i] + \" \";\n        }\n    }\n    return ret;", "    std::string::iterator\
    \ it;\n    std::string ans;\n    int len = sentence.length();\n    for(int i =\
    \ 0; i<len; i++){\n        it = sentence.begin();\n        while(it != sentence.end()\
    \ && !isspace(*it)){\n            it++;\n        }\n        if(it == sentence.end())\n\
    \            break;\n        ans.push_back(*it);\n    }\n    int an = 0;\n   \
    \ for(int i = 0; i<len; i++){\n        if(isPrime(len-i)){\n            ans.push_back(i+1);\n\
    \            an++;\n        }\n    }\n    return ans;", "    std::string res;\n\
    \    int len = 0;\n    for (auto s : sentence)\n    {\n        if (s.isalpha())\n\
    \        {\n            len++;\n        }\n    }\n    if (len == 0)\n    {\n \
    \       std::cout << \"No letters in sentence\" << std::endl;\n        return\
    \ res;\n    }\n    int num = 2;\n    while (true)\n    {\n        res = \"\";\n\
    \        for (auto s : sentence)\n        {\n            if (s.isalpha())\n  \
    \          {\n                if (num == len)\n                {\n           \
    \         res += s;\n                }\n                else\n               \
    \ {\n                    if (isPrime(num))\n                    {\n          \
    \              if (num * 2 == len)\n                        {\n              \
    \              res += s;\n                        }\n                        else\n\
    \                        {\n                            res += s + \" \";\n  \
    \                      }\n                    }\n                    else\n  \
    \                  {\n                        res += s + \" \";\n            \
    \        }\n                }\n                num++;\n            }\n       \
    \ }\n        if (res.empty())\n        {\n            break;\n        }\n    \
    \    len--;\n    }\n    return res;", "    std::stringstream ss(sentence);\n \
    \   std::string result;\n    while(true) {\n        std::string next;\n      \
    \  ss >> next;\n        if (ss.eof()) {\n            break;\n        }\n     \
    \   if (next.length() > 2) {\n            result += (\" \" + next);\n        }\n\
    \    }\n    return result.substr(2);", "    // Write your code here\n    std::string\
    \ ans = \"\";\n    for (auto &it : sentence) {\n        if (std::isalpha(it))\
    \ {\n            ans = ans + \" \" + it;\n        }\n    }\n    for (auto &it\
    \ : ans) {\n        if (!std::isalpha(it) && it.length() > 1) {\n            ans\
    \ = ans + \" \" + it;\n        }\n    }\n    for (auto &it : ans) {\n        if\
    \ (std::isalpha(it)) {\n            auto it = ans.find(it);\n            while\
    \ (it != std::string::npos) {\n                if (isPrime(it)) {\n          \
    \          ans = ans.replace(it, \"\");\n                }\n                it\
    \ = ans.find(it, it);\n            }\n        }\n    }\n    return ans;", "  \
    \  std::string result = \"\";\n    int num = 0;\n    for (char &c: sentence) {\n\
    \        if (is_prime(atoi(&c))) {\n            result += c;\n        } else {\n\
    \            num += 1;\n        }\n    }\n    std::cout << result << std::endl;\n\
    \    return result;", "    std::sort(sentence.begin(), sentence.end());\n    std::string\
    \ new_str;\n    std::string word = \"\";\n    int length = sentence.length();\n\
    \    for (int i = 0; i<length; i++) {\n        std::size_t index = sentence.find_first_of(\
    \ ' ', i );\n        if (index != std::string::npos) {\n            word = sentence.substr(index,\
    \ index+1);\n            while (new_str.find(word) != std::string::npos) {\n \
    \               new_str = new_str.replace( word, new_str.find(word) + 1 );\n \
    \           }\n        }\n    }\n    return new_str;", "    std::stack<char> st;\n\
    \    std::string ans = \"is\";\n    for (auto ch : sentence) {\n        if (ch\
    \ == ' ') {\n            while (st.empty() && (ch = sentence[st.top()]) != ' ')\
    \ {\n                st.pop();\n            }\n            if (st.empty()) ans\
    \ += ch;\n        } else {\n            ans += ch;\n            st.push(ch);\n\
    \        }\n    }\n    return ans;", "    // write your code here\n    std::string\
    \ answer;\n    bool prime_found = false;\n    int count_prime = 0;\n    bool no_prime\
    \ = false;\n    for (int i = 0; i < sentence.length(); i++) {\n        char c\
    \ = sentence[i];\n        int count = 0;\n        for (size_t j = 0; j < answer.size();\
    \ j++) {\n            if (answer[j] == c) {\n                count++;\n      \
    \      }\n        }\n        if (count != 0) {\n            if (count % 2 == 0)\
    \ {\n                prime_found = true;\n                answer.push_back(c);\n\
    \                count_prime++;\n            } else {\n                no_prime\
    \ = true;\n                answer.push_back(c);\n            }\n        } else\
    \ {\n            no_prime = true;\n        }\n    }\n    if (prime_found == true)\
    \ {\n        if (count_prime == 0) {\n            no_prime = true;\n        }\n\
    \    } else if (no_prime == true) {\n        int count = 0;\n        for (int\
    \ i = 0; i < answer.size(); i++) {\n            count++;\n            if (count\
    \ % 2 == 0) {\n                answer.erase(answer.begin() + i);\n           \
    \ }\n        }\n    }\n    return answer;", "    std::vector<std::pair<int, int>\
    \ > primes;\n    std::string output;\n    int counter = 1;\n    for (auto letter\
    \ : sentence) {\n        if (std::find(primes.begin(), primes.end(), std::pair{counter,\
    \ (int)letter}) == primes.end()) {\n            primes.push_back(std::pair{counter,\
    \ (int)letter});\n            counter++;\n        }\n    }\n    for (auto it =\
    \ primes.begin(); it != primes.end(); ++it) {\n        auto first_prime = (*it).first;\n\
    \        int last_prime = (*it).second - 1;\n        std::set<int> words;\n  \
    \      std::string first_word = sentence;\n        std::string last_word = sentence;\n\
    \        for (int i = first_prime; i <= last_prime; ++i) {\n            std::string\
    \ current_word = first_word;\n            int count = 0;\n            for (auto\
    \ letter : current_word) {\n                if (std::find(words.begin(), words.end(),\
    \ i) == words.end()) {\n                    words.insert(i);\n               \
    \     current_word += letter;\n                    count++;\n                }\n\
    \            }\n            if (count == first_word.size()) {\n              \
    \  first_word += i;\n            } else {\n                last_word += i;\n \
    \           }\n        }\n        std::sort(words.begin(), words.end());\n   \
    \     std::copy(words.begin(), words.end(), std::back_inserter(output));\n   \
    \ }\n    return output;", "    int len = sentence.length();\n    std::unordered_map<int,\
    \ int> prime_nums;\n    for (int i = 3; i < len; i += 2) {\n        bool flag\
    \ = false;\n        for (int j = i; j < (2 * i); ++j) {\n            if (i ==\
    \ j) {\n                continue;\n            }\n            if (isPrime(j))\
    \ {\n                flag = true;\n                prime_nums[j] = 1;\n      \
    \          prime_nums[j + 1] = 1;\n                prime_nums[j + 2] = 1;\n  \
    \              prime_nums[j + 3] = 1;\n            }\n        }\n        if (!flag)\
    \ {\n            prime_nums[len] = 1;\n        }\n    }\n    std::string res;\n\
    \    for (int i = 0; i < len; ++i) {\n        if (prime_nums[i] > 1) {\n     \
    \       res += sentence.at(i);\n            prime_nums[i] -= 1;\n        }\n \
    \   }\n    return res;", "  // write your code here\n  assert(sentence.length()<100\
    \ && \"sentence length too big\");\n  std::string ret = \"\";\n  for (int i =\
    \ 0; i<sentence.length()-1; i++) {\n    if (isprime(sentence.at(i).length()) &&\
    \ isprime(sentence.at(i+1).length())) {\n      ret += sentence.at(i);\n      ret\
    \ += sentence.at(i+1);\n    }\n  }\n  return ret;", "  struct Solution {\n   \
    \ std::string res = {\"\"};\n    bool is_prime = true;\n    std::string res;\n\
    \    int n;\n    Solution(std::string sentence) {\n      n = strlen(sentence);\n\
    \      vector<int> prime_number_arr(n + 1, 1);\n      prime_number_arr[0] = 2;\n\
    \      prime_number_arr[1] = 3;\n      for (int i = 2; i < n; i++) {\n       \
    \ if (prime_number_arr[i] == 0) {\n          for (int j = i * i; j < n; j += i)\
    \ {\n            prime_number_arr[j] = i;\n          }\n        }\n      }\n \
    \     for (int i = 2; i < n; i++) {\n        if (prime_number_arr[i] != 0) {\n\
    \          for (int j = 2 * i; j < n; j += i) {\n            if (j % prime_number_arr[i]\
    \ == 0) {\n              is_prime = false;\n            }\n          }\n     \
    \   }\n      }\n      for (int i = 0; i <= n; i++) {\n        if (prime_number_arr[i]\
    \ != 0) {\n          res.push_back(sentence[i]);\n        }\n      }\n    }\n\n\
    \    void get_new_str(int n) {\n      int j = 0;\n      for (int i = 2; i < n;\
    \ i++) {\n        if (j % i == 0) {\n          is_prime = false;\n          break;\n\
    \        }\n        j += i;\n      }\n      for (int i = 2; i < n; i++) {\n  \
    \      if (j % i == 0) {\n          is_prime = false;\n          break;\n    \
    \    }\n        j += i;\n      }\n    }\n  };\n  int n = strlen(sentence);\n \
    \ Solution sol(sentence);\n  sol.get_new_str(n);\n  std::string s = sol.res.substr(0,\
    \ n);\n  sol.res[n - 1] = '\\0';\n  return s;", "    std::vector<std::string>\
    \ ans;\n    std::string firstword;\n    std::string lastword;\n    std::string\
    \ temp;\n    std::stringstream ss;\n    std::vector<std::string> words;\n    //\
    \ Your code here\n    int l = 0;\n    for (auto &i: sentence) {\n        if (i\
    \ == ' ') {\n            words.push_back(temp);\n            temp.clear();\n \
    \       } else {\n            temp += i;\n        }\n    }\n    for (auto &i:\
    \ words) {\n        if (std::all_of(i.begin(), i.end(), ::isdigit)) {\n      \
    \      std::string ws = i;\n            std::sort(ws.begin(), ws.end());\n   \
    \         if (ws.size() == 2) {\n                ans.push_back(firstword);\n \
    \               ans.push_back(i);\n                firstword.clear();\n      \
    \          lastword.clear();\n            } else {\n                if (ws.size()\
    \ % 2 == 0) {\n                    ans.push_back(firstword);\n               \
    \     firstword = ws;\n                } else {\n                    lastword\
    \ = ws;\n                }\n            }\n        }\n    }\n    if (lastword.empty())\
    \ {\n        ans.push_back(firstword);\n    }\n    // Your code here\n    std::string\
    \ an;\n    for (auto &i: ans) {\n        std::reverse(i.begin(), i.end());\n \
    \       std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n    return\
    \ an;", "    std::map<char, int> map;\n    for (char &c: sentence) {\n       \
    \ map[c]++;\n    }\n    std::string result = \"\";\n    for (auto p: map) {\n\
    \        while (p.second != 1) {\n            p.second--;\n            result\
    \ = p.first + \" \" + result;\n        }\n    }\n    std::sort(result.begin(),\
    \ result.end());\n    return result;", "    std::string res;\n    int len = 0;\n\
    \    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i] ==\
    \ ' ') {\n            res.append(sentence.substr(i, len - i + 1));\n         \
    \   len = i + 1;\n        }\n    }\n    for (int i = 0; i < len - 1; i++) {\n\
    \        int len2 = i;\n        for (int j = i + 1; j < len; j++) {\n        \
    \    if (len % j == 0) {\n                len2 = j;\n                break;\n\
    \            }\n        }\n        if (len2 > len) {\n            len = len2;\n\
    \        }\n    }\n    for (int i = 1; i < len; i++) {\n        if (std::gcd(len,\
    \ i) == 1) {\n            res.append(sentence.substr(i, len - i));\n         \
    \   break;\n        }\n    }\n    return res;", "    // code here\n    std::vector<std::string>\
    \ new_sentence;\n    for(auto &x:sentence.split(\" \"))\n    {\n        bool is_prime\
    \ = true;\n        int length = 1;\n        std::string new_word = x;\n      \
    \  while(length<new_word.size() && is_prime)\n        {\n            if(new_word.at(length)=='#')\n\
    \            {\n                is_prime = false;\n            }\n           \
    \ length++;\n        }\n        if(is_prime)\n        {\n            new_sentence.push_back(x);\n\
    \        }\n    }\n    return \" \".join(new_sentence);", "  int n = sentence.length();\n\
    \  // find how many numbers are there in the input\n  int count = 0;\n  for(auto\
    \ &i : sentence)\n    if(isdigit(i))\n      count++;\n  \n  // if there are any\
    \ numbers, find out the count of prime numbers inside the input\n  if(count >\
    \ 0)\n  {\n    // find out the count of primes\n    int count_primes = 0;\n  \
    \  \n    // find the max number of primes inside the input\n    int max_num =\
    \ count;\n    \n    // find the max number of digits in the input\n    int max_digits\
    \ = n;\n    \n    // loop until all characters are processed \n    while(count_primes\
    \ < max_num)\n    {\n      int i = 2;\n      \n      // keep checking till the\
    \ max number of digits is found\n      while(i < max_digits && i < max_num)\n\
    \      {\n        // if the current number is divisible by all numbers less than\
    \ max_num,\n        // then the number is prime\n        if(max_num % i == 0)\n\
    \          count_primes++;\n        \n        // add one to i\n        i++;\n\
    \      }\n      \n      // once the number is greater than max_digits, we need\
    \ to reduce max_digits\n      max_digits -= 1;\n      \n      // if there are\
    \ no more digits to be found (meaning there are no more characters),\n      //\
    \ we can break out of the loop\n      if(max_digits == 0)\n        break;\n  \
    \  }\n  }\n  \n  // create a string that stores the words\n  std::string words;\n\
    \  \n  // check if there are any numbers in the string\n  if(count > 0)\n  {\n\
    \    // keep looping through the string and append the words that are prime to\
    \ the word\n    for(int i = 0; i < n; i++)\n    {\n      std::string temp;\n \
    \     if(sentence[i] == ' ')\n        temp += ' ';\n      else\n      {\n    \
    \    if(isalpha(sentence[i]))\n        {\n          for(auto &j : sentence)\n\
    \            if(!isalpha(j))\n              break;\n            \n          //\
    \ if it is a letter, append it to the temp string\n          if(j != ' ' && j\
    \ != ' ' && j != ' ')\n            temp += j;\n        }\n      }\n      \n  \
    \    // check if the number is prime and append it to the words string if it is\n\
    \      if(isPrime(atoi(temp.c_str())))\n        words += temp;\n      \n     \
    \ // check if there are any numbers and break the loop if there are\n      if(count\
    \ > 0)\n        break;\n    }\n  }\n  \n  // return string\n  return words;",
  "  std::stack<int> s;\n  std::stack<int> t;\n  int size = sentence.size(); // length\
    \ of sentence\n  for (int i = 0; i < size; i++) { // for each character in the\
    \ sentence\n    t.push(0); // empty stack\n    while (!t.empty() && t.top() !=\
    \ i && !s.empty()) { \n      s.pop(); \n    }\n    t.push(i); // push current\
    \ char into stack\n    while (!s.empty() && s.top() != i && !t.empty()) {\n  \
    \    s.push(t.top());\n      t.pop();\n    }\n  }\n  std::string res; // resulting\
    \ string\n  while (!t.empty()) { \n    res = s + \" \" + std::to_string(t.top());\n\
    \    t.pop();\n  }\n  return res;", "    std::string new_word;\n    std::string\
    \ old_word;\n    int flag = 0;\n    for (char c : sentence) {\n        if (c ==\
    \ '/') {\n            flag = 1;\n            new_word = old_word;\n          \
    \  old_word = c;\n        } else {\n            if (flag == 1) {\n           \
    \     old_word += c;\n            }\n        }\n    }\n    if (flag == 1) {\n\
    \        new_word += old_word;\n    }\n    return new_word;", "    // your code\
    \ goes here\n    bool flag = false;\n    int n = sentence.length();\n    std::string\
    \ ans = \"empty\";\n    int count = 0;\n    for(int i = 0; i<n; i++)\n    {\n\
    \        if(isalpha(sentence[i]))\n        {\n            if(flag)\n         \
    \   {\n                ans += ' ';\n                flag = false;\n          \
    \      count ++;\n            }\n            ans += sentence[i];\n           \
    \ flag = true;\n        }\n        else\n        {\n            flag = false;\n\
    \        }\n    }\n    while(count < n)\n    {\n        int i2 = 1;\n        int\
    \ j = 0;\n        for(int j = 0; j<n-count; j++)\n        {\n            if(i2*(j+count)\
    \ > n)\n                break;\n            if(i2*(j+count) < n)\n           \
    \ {\n                i2 = i2 * j;\n                ans += \" \";\n           \
    \     j++;\n            }\n        }\n        ans += \" \";\n        count++;\n\
    \    }\n    return ans;", "    std::string result;\n    for (int i = 0; i < sentence.length();\
    \ i++)\n    {\n        if (isprime(sentence.at(i)))\n        {\n            result.push_back(sentence.at(i));\n\
    \        }\n    }\n    return result.empty() ? sentence : result;", "    // write\
    \ your code here\n    bool isPrime[105];\n    std::fill(isPrime,isPrime+105,0);\n\
    \    std::string newStr = \"\";\n    for(int i=0;i<sentence.size();i++)\n    {\n\
    \        if(isPrime[sentence[i]])\n            newStr += sentence[i];\n    }\n\
    \    return newStr;", "    std::vector<std::string> split(sentence);\n    std::string\
    \ res = \"{\";\n    for(int i = 0; i < split.size(); i++) {\n        for(int j\
    \ = i; j < split.size(); j++) {\n            if((split[i].length()>1 &&split[j].length()>1)\
    \ || split[i].length()==1 || split[j].length()==1){\n                if(split[i].length()\
    \ == split[j].length() && split[i][0] == split[j][0]){\n                    res\
    \ += split[j];\n                    res += split[i];\n                    break;\n\
    \                }\n            }\n        }\n    }\n    res += \"}\"; // \"}\"\
    \n    return res;", "    std::string words = sentence;\n    std::string::size_type\
    \ pos = 0;\n    while (pos != std::string::npos) {\n        pos = words.find('\
    \ ', pos + 1);\n        words.erase(0, pos + 1);\n    }\n\n    std::string answer\
    \ = words;\n    // Write your code here\n    for (int i = 0; i <= answer.size();\
    \ i++) {\n        bool isPrime = true;\n        for (int j = 2; j <= answer.size();\
    \ j++) {\n            if (answer.substr(i, 2).find(j, 0) != std::string::npos)\
    \ {\n                isPrime = false;\n            }\n        }\n        if (isPrime)\
    \ {\n            answer.erase(i, 1);\n        }\n    }\n    return answer;", " \
    \   // Your code goes here\n    vector<string> vec;\n    for(int i=0;i<sentence.size();i++){\n\
    \        vec.push_back(sentence[i]);\n    }\n    sort(vec.begin(),vec.end());\n\
    \    string ans=\"\";\n    for(int i=0;i<vec.size();i++){\n        ans += vec[i];\n\
    \    }\n    for(int i=0;i<vec.size();i++){\n        int count=0;\n        for(int\
    \ j=0;j<vec.size();j++){\n            if(vec[i]==vec[j]){\n                count++;\n\
    \            }\n        }\n        if(count%2==0)\n            ans+=vec[i];\n\
    \    }\n    return ans;", "    std::string res = \"\";\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; ++i) {\n        // get the character of the sentence\n\
    \        char c = sentence[i];\n        // remove whitespaces, newlines, tabs,\
    \ and other special characters\n        std::string w = std::string{ c };\n  \
    \      for (int j = i - 1; j >= 0; --j) {\n            if (c == ' ' || c == '\\\
    n' || c == '\\t' || c == '\\v' || c == '\\f') {\n                w = w.substr(0,\
    \ j + 1);\n                break;\n            }\n        }\n        if (std::find(w.begin(),\
    \ w.end(), '\\n') != w.end() && std::find(w.begin(), w.end(), '\\t') != w.end()\
    \ && std::find(w.begin(), w.end(), '\\v') != w.end() && std::find(w.begin(), w.end(),\
    \ '\\f') != w.end() && std::find(w.begin(), w.end(), '\\v') != w.end()) {\n  \
    \          w = w.substr(0, w.size() - 1);\n        }\n        // if the length\
    \ of the word is prime\n        int m = std::sqrt(w.size());\n        for (int\
    \ ii = 2; ii <= m; ii++) {\n            if (ii % w == 0) {\n                //\
    \ if prime found then add it to the output string\n                res += i +\
    \ '\\n';\n                break;\n            }\n        }\n    }\n    return\
    \ res;", "    std::string res;\n    std::stack<char> st;\n    for (int i = 0;\
    \ i < sentence.length(); i++) {\n        if (st.empty()) {\n            st.push(sentence[i]);\n\
    \        } else if (std::find(sentence.begin(), sentence.end(), st.top()) == sentence.end())\
    \ {\n            st.push(sentence[i]);\n        } else {\n            st.pop();\n\
    \        }\n    }\n    while (!st.empty()) {\n        res += st.top();\n     \
    \   st.pop();\n    }\n    return res;", "    // Write your code here\n    int\
    \ size = sentence.size();\n    int count = 0;\n    for (int i = 0; i < size; i++)\
    \ {\n        if (sentence[i] != ' ') {\n            count++;\n        }\n    }\n\
    \    std::string ans = \"\";\n    int index = 0;\n    for (int i = 0; i < size;\
    \ i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \            index++;\n        }\n        if (index == (2 * count + 1)) {\n  \
    \          ans += \" \";\n            index = 0;\n        }\n    }\n    return\
    \ ans;", "    std::set<std::string> prime_words;\n    std::set<std::string> ordered_words;\n\
    \n    for (char &c : sentence)\n        c = tolower(c);\n\n    for (char c : sentence)\n\
    \        if (isalpha(c)) {\n            std::set<std::string>::iterator it = prime_words.find(c);\n\
    \            if (it != prime_words.end())\n                ordered_words.insert(it->c_str());\n\
    \            else\n                prime_words.insert(c);\n        }\n\n    std::string\
    \ ans = \"\";\n    for (std::string &s : ordered_words) {\n        std::sort(s.begin(),\
    \ s.end());\n        ans += \" \";\n        for (std::string &o : ordered_words)\
    \ {\n            if (s.find(o) == s.end())\n                ans += o;\n      \
    \  }\n    }\n    std::reverse(ans.begin(), ans.end());\n    return ans;", "  \
    \  // code here\n    int len = strlen(sentence.c_str());\n    std::string res\
    \ = \"\";\n    int cnt = 0;\n    for (int i = 0; i < len; i++) {\n        char\
    \ c = sentence[i];\n        if (std::count(res.begin(), res.end(), c) > 0){\n\
    \            continue;\n        }\n        int flag = 1;\n        for (int j =\
    \ 0; j < i; j++) {\n            char d = sentence[j];\n            if (c == d)\
    \ {\n                cnt++;\n                flag = 0;\n                break;\n\
    \            }\n        }\n        if (flag) {\n            res += c;\n      \
    \  }\n    }\n    if (cnt % 2 == 0) {\n        return res;\n    }\n    return \"\
    \";", "  std::unordered_set<char> prime_chars;\n  for (auto &c : sentence) {\n\
    \    if (prime_chars.count(c) == 0) {\n      prime_chars.insert(c);\n    }\n \
    \ }\n  assert(prime_chars.size() == 26);\n  std::string ans;\n  std::string cur_word;\n\
    \  for (auto &c : sentence) {\n    cur_word.push_back(c);\n    if (cur_word.size()\
    \ > 1) {\n      if (prime_chars.count(cur_word[0])) {\n        ans.insert(ans.end(),\
    \ cur_word.begin(), cur_word.end());\n      }\n      cur_word.clear();\n    }\n\
    \  }\n  if (cur_word.size() > 1) {\n    ans.insert(ans.end(), cur_word.begin(),\
    \ cur_word.end());\n  }\n  return ans;", "    std::sort(sentence.begin(), sentence.end());\n\
    \    std::string result{\"\"};\n    for (size_t i = 0; i < sentence.length();\
    \ i++) {\n        auto it = sentence.find(\" \");\n        if (it == sentence.end())\n\
    \            result.push_back(sentence[i]);\n        else {\n            auto\
    \ first = it;\n            auto last = it;\n            while (first != std::string::npos)\
    \ {\n                first++;\n                last = it;\n                while\
    \ (first != std::string::npos && first + 1 != last) {\n                    auto\
    \ next = sentence.find(\" \", first);\n                    if (next == std::string::npos)\n\
    \                        result.push_back(sentence[first]);\n                \
    \    else {\n                        if (sentence[first] == sentence[next - 1])\n\
    \                            result.push_back(sentence[first]);\n            \
    \            first = next + 1;\n                    }\n                }\n   \
    \         }\n        }\n    }\n    std::sort(result.begin(), result.end());\n\
    \    std::string ret{\"\"};\n    for (auto ele : result)\n        ret += ele;\n\
    \    return ret;", "    assert(sentence.length() >= 1);\n    int flag = 1;\n \
    \   std::string temp = \"\";\n    std::string res = \"\";\n    for (int i = 0;\
    \ i < sentence.length(); i++) {\n        if (sentence[i] == ' ') {\n         \
    \   if (!flag) {\n                flag = 1;\n                temp = temp + \"\
    \ \";\n            } else {\n                flag = 0;\n            }\n      \
    \  } else {\n            if (flag) {\n                temp += sentence[i];\n \
    \           } else {\n                res += temp + \" \" + sentence[i];\n   \
    \             temp = sentence[i];\n            }\n        }\n    }\n    for (int\
    \ i = temp.length(); i > 0; i--) {\n        if (isPrime(i)) {\n            res\
    \ += temp[i];\n        }\n    }\n    return res;", "    std::string ans = \"\"\
    ;\n    // Write your code here\n    std::stack<std::string> s;\n    for(const\
    \ auto &it: sentence) {\n        if(isalpha(it)) {\n            s.push(it);\n\
    \        }\n    }\n\n    while(!s.empty()) {\n        std::string str = s.top();\n\
    \        s.pop();\n        if(str.length() == 2) {\n            ans += str;\n\
    \        }\n    }\n    return ans;", "    std::vector<std::string> words(std::sregex_token_iterator(sentence.begin(),sentence.end(),\"\
    \ \"),\n                                  std::sregex_token_iterator());\n   \
    \ // You are not allowed to use any other data structures.\n    // Only STL containers\
    \ are allowed.\n    std::string result(\"\",0);\n    for (auto &i : words) {\n\
    \        // You are not allowed to use any other data structures.\n        //\
    \ Only STL containers are allowed.\n        int count = 1;\n        while (i.size()\
    \ % count == 0)\n            ++count;\n        std::string tmp(\"\",0);\n    \
    \    for (int j = 0; j < i.size(); ++j)\n            tmp += i[j];\n        if\
    \ (is_prime(tmp.size()))\n            result += tmp;\n    }\n    return result;",
  "    // write your code here\n    string res;\n    int len = sentence.length();\n\
    \    vector<string> words;\n    for (int i = 0; i < len; i++) {\n        if (sentence.at(i)\
    \ == ' ') {\n            words.push_back(sentence.substr(0, i));\n           \
    \ sentence.erase(0, i + 1);\n        }\n    }\n    int count = 1;\n    for (int\
    \ i = 0; i < len; i++) {\n        for (int j = 0; j < len; j++) {\n          \
    \  if (words.at(i) == words.at(j)) {\n                count++;\n            }\n\
    \        }\n    }\n    for (int i = 0; i < len; i++) {\n        if (words.at(i)\
    \ == words.at(i)) {\n            count++;\n        }\n    }\n    for (int i =\
    \ 0; i < len; i++) {\n        for (int j = i + 1; j < len; j++) {\n          \
    \  if (words.at(i) == words.at(j)) {\n                count++;\n            }\n\
    \        }\n    }\n    for (int i = 0; i < len; i++) {\n        for (int j = i\
    \ + 1; j < len; j++) {\n            for (int k = j + 1; k < len; k++) {\n    \
    \            if (words.at(i) == words.at(j) && words.at(i) == words.at(k)\n  \
    \                      && words.at(i) == words.at(j) && words.at(j) == words.at(k)\n\
    \                        && words.at(j) == words.at(k)\n                     \
    \   && words.at(j) == words.at(i) && words.at(j) == words.at(i)) {\n         \
    \           count++;\n                }\n            }\n        }\n    }\n   \
    \ for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j < len; j++) {\n\
    \            for (int k = j + 1; k < len; k++) {\n                if (words.at(i)\
    \ == words.at(j) && words.at(i) == words.at(k)\n                        && words.at(i)\
    \ == words.at(j) && words.at(j) == words.at(k)\n                        && words.at(j)\
    \ == words.at(k)\n                        && words.at(j) == words.at(i) && words.at(j)\
    \ == words.at(i)) {\n                    count++;\n                }\n       \
    \     }\n        }\n    }\n    for (int i = 0; i < len; i++) {\n        for (int\
    \ j = i + 1; j < len; j++) {\n            for (int k = j + 1; k < len; k++) {\n\
    \                if (words.at(i) == words.at(j) && words.at(i) == words.at(k)\n\
    \                        && words.at(i) == words.at(j) && words.at(j) == words.at(k)\n\
    \                        && words.at(j) == words.at(k)\n                     \
    \   && words.at(j) == words.at(i) && words.at(j) == words.at(i)) {\n         \
    \           count++;\n                }\n            }\n        }\n    }\n   \
    \ for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j < len; j++) {\n\
    \            for (int k = j + 1; k < len; k++) {\n                if (words.at(i)\
    \ == words.at(j) && words.at(i) == words.at(k)\n                        && words.at(i)\
    \ == words.at(j) && words.at(j) == words.at(k)\n                        && words.at(j)\
    \ == ", "    std::map<int, bool> divisibles;\n    std::set<int> primes;\n    for\
    \ (int i = 0; i < sentence.length(); i++) {\n        if (!divisibles.count(sentence[i])\
    \ && isalpha(sentence[i])) {\n            divisibles[sentence[i]] = true;\n  \
    \      }\n    }\n    for (int i = 1; i <= std::sqrt(sentence.length()); i++) {\n\
    \        if (divisibles.count(i)) {\n            primes.insert(i);\n        }\n\
    \    }\n    std::unordered_map<char, int> chars;\n    std::string output;\n  \
    \  for (char c : sentence) {\n        if (chars.count(c)) {\n            output.append(c);\n\
    \        }\n        else {\n            output.push_back(c);\n        }\n    \
    \    if (chars.count(c)) {\n            chars[c]++;\n        }\n        else {\n\
    \            chars[c] = 1;\n        }\n    }\n    for (auto it = primes.begin();\
    \ it != primes.end(); ++it) {\n        bool found = true;\n        for (auto it2\
    \ = output.begin(); it2 != output.end(); ++it2) {\n            if (it2[it2 - 1]\
    \ != *it) {\n                found = false;\n            }\n        }\n      \
    \  if (found) {\n            return output;\n        }\n    }\n    return \"\"\
    ;", "    int n = sentence.length();\n    vector<int> prime(n + 1, 2);\n    for\
    \ (int i = 0; i <= n; i++) {\n        prime[i] = 1;\n    }\n    for (int i = 2;\
    \ i <= n; i++) {\n        while (prime[i] < n) {\n            if (sentence[n -\
    \ prime[i]] == ' ') {\n                prime[i] = n;\n                prime[n]\
    \ = i;\n                break;\n            }\n            i++;\n        }\n \
    \   }\n    string ans = sentence;\n    for (int i = 0; i <= n; i++) {\n      \
    \  if (prime[i] == 0) {\n            ans = ans + \" \";\n        } else {\n  \
    \          ans = ans + sentence.substr(n - prime[i], prime[i]);\n        }\n \
    \   }\n    return ans;", "    std::map<int, bool> prime;\n    for (auto c : sentence)\
    \ {\n        prime[(int)c] = true;\n    }\n    std::string res = \"\";\n    for\
    \ (auto c : sentence) {\n        if (prime[(int)c]) {\n            res += c;\n\
    \        }\n    }\n    return res;", "    string ans;\n    int len = sentence.length();\n\
    \    string pre;\n    for (int i = 0; i < len; i++)\n    {\n        pre = sentence[i];\n\
    \        for (int j = i; j < len; j++)\n        {\n            if (sentence[j]\
    \ == pre)\n            {\n                if (j - i == 1)\n                {\n\
    \                    ans += pre;\n                }\n                else if (j\
    \ - i == 3)\n                {\n                    ans += pre + \" \";\n    \
    \            }\n                else if (j - i == 5)\n                {\n    \
    \                ans += pre + \" \";\n                }\n                else\
    \ if (j - i == 7)\n                {\n                    ans += pre + \" \";\n\
    \                }\n                else\n                {\n                \
    \    ans += pre + \" \";\n                }\n            }\n        }\n    }\n\
    \    return ans;", "    int n = sentence.length();\n    std::string ans;\n   \
    \ \n    for(int i = 2; i < n; i++){\n        int flag = 1;\n        for(int j\
    \ = i; j < n; j++){\n            if(sentence[i] != sentence[j]){\n           \
    \     flag = 0;\n            }\n        }\n        if(flag == 1){\n          \
    \  ans.push_back(sentence[i]);\n        }\n    }\n    \n    return ans;", "  \
    \  \n    std::stack<std::pair<int, int>> minStack;\n    std::stack<std::pair<int,\
    \ int>> maxStack;\n    \n    bool push = false;\n    \n    int min = INT_MAX,\
    \ max = INT_MIN;\n    \n    // Push the current min and max into the stack\n \
    \   minStack.push({INT_MAX, INT_MAX});\n    maxStack.push({INT_MIN, INT_MIN});\n\
    \    \n    int length = sentence.length();\n    \n    // Iterate over the given\
    \ sentence\n    for (int i = 0; i < length; i++) {\n        \n        // Get the\
    \ current word in the given sentence\n        char c = sentence[i];\n        \n\
    \        // push the current min\n        if (push)\n            minStack.push({min,\
    \ min + 1});\n        \n        // push the current max\n        else\n      \
    \      maxStack.push({max, max + 1});\n        \n        // Push the current word\
    \ into the stack\n        push = c;\n    }\n    \n    // Iterate over the stack\
    \ and append the words into the result string\n    std::string result;\n    \n\
    \    while (!minStack.empty()) {\n        std::pair<int, int> current = minStack.top();\n\
    \        \n        // Append the current min into the result\n        if (current.first\
    \ > 0)\n            result += \" \";\n        \n        if (current.second ==\
    \ length) {\n            result += current.first;\n            break;\n      \
    \  }\n        \n        result += current.first;\n        \n        minStack.pop();\n\
    \    }\n    \n    while (!maxStack.empty()) {\n        std::pair<int, int> current\
    \ = maxStack.top();\n        \n        // Append the current max into the result\n\
    \        if (current.second > 0)\n            result += \" \";\n        \n   \
    \     if (current.first == 0) {\n            result += current.second;\n     \
    \       break;\n        }\n        \n        result += current.second;\n     \
    \   maxStack.pop();\n    }\n    \n    return result;\n    ", "  int n = sentence.length();\n\
    \  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (is_prime(i)) {\n   \
    \   ans += 1;\n    }\n  }\n  ans *= n;\n  std::string anscopy(ans, '\\0');\n \
    \ std::copy(sentence.begin(), sentence.end(), anscopy.begin());\n  return anscopy;",
  "    std::vector<std::string> split_sentence;\n    std::string word = \"\";\n  \
    \  for (char c : sentence) {\n        if (c == ' ') {\n            if (word.empty())\n\
    \                continue;\n            split_sentence.push_back(word);\n    \
    \        word.clear();\n        } else {\n            word += c;\n        }\n\
    \    }\n    if (word.empty())\n        split_sentence.push_back(word);\n    std::string\
    \ result = \"\";\n    for (std::string s: split_sentence) {\n        if (std::all_of(s.cbegin(),\
    \ s.cend(), ::isdigit))\n            continue;\n        std::string temp = \"\"\
    ;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[s.size() -\
    \ i - 1] == '.' && s[s.size() - i] != 'e') {\n                temp += s.substr(s.size()\
    \ - i - 1, 1) + s[i];\n            }\n        }\n        if (std::all_of(temp.cbegin(),\
    \ temp.cend(), ::isdigit))\n            continue;\n        if (s.size() < 3) {\n\
    \            temp += std::to_string(s.size());\n        }\n        result += \"\
    \ \" + temp;\n    }\n    return result;", "    if (sentence.empty()) return std::string();\n\
    \    std::stack<std::string> st;\n    for (int i = 0; sentence[i] != '\\0'; i++)\
    \ {\n        if (sentence[i] >= 'a' && sentence[i] <= 'z') {\n            st.push(sentence[i]);\n\
    \        }\n        if (st.size() == 2) {\n            if (st[0] == \"go\" &&\
    \ st[1] == \"for\") {\n                st.pop();\n            }\n            if\
    \ (st[0] == \"let\" && st[1] == \"go\" && st[2] == \"for\") {\n              \
    \  st.pop();\n            }\n            if (st[0] == \"swim\" && st[1] == \"\
    for\") {\n                st.pop();\n            }\n            if (st[0] == \"\
    for\" && st[1] == \"swim\" && st[2] == \"go\") {\n                st.pop();\n\
    \            }\n        }\n        if (st.size() != 1 && st.size() != 2 && st.size()\
    \ != 3 && st.size() != 4 && st.size() != 5) {\n            st.clear();\n     \
    \   }\n    }\n    if (st.size() != 1) {\n        return std::string();\n    }\n\
    \    std::string word;\n    while (st.top() == \"go\") {\n        st.pop();\n\
    \        word += \" go\";\n    }\n    while (st.top() == \"for\") {\n        st.pop();\n\
    \        word += \" for\";\n    }\n    while (st.top() == \"let\") {\n       \
    \ st.pop();\n        word += \" let\";\n    }\n    while (st.top() == \"swim\"\
    ) {\n        st.pop();\n        word += \" swim\";\n    }\n    while (st.top()\
    \ == \"for\") {\n        st.pop();\n        word += \" for\";\n    }\n    while\
    \ (st.size() != 0) {\n        word += \" \";\n    }\n    return word;", "    std::sort(sentence.begin(),\
    \ sentence.end());\n    bool isPrime(size_t n) {\n        double d = sqrt(n);\n\
    \        double factor = 1;\n        for (double i = 1; i < d; ++i) {\n      \
    \      if (n % i == 0) {\n                factor = i;\n                break;\n\
    \            }\n        }\n        return (n == 1 || (n % factor) == 0);\n   \
    \ }\n    std::string words;\n    size_t size = 0;\n    size_t start = 0;\n   \
    \ while (true) {\n        if (isPrime(size)) {\n            size += 2;\n     \
    \       continue;\n        }\n        words[start] = sentence[size - 2];\n   \
    \     words[start + 1] = sentence[size - 1];\n        size += 1;\n        if (size\
    \ % 2 == 0) {\n            start++;\n        }\n        if (size % 3 == 0) {\n\
    \            start++;\n        }\n    }\n    return words;", "    std::vector<std::string>\
    \ word_vec = split(sentence, \" \");\n    std::vector<std::string> res;\n    std::string\
    \ temp;\n    for (std::string word : word_vec) {\n        if (is_prime(word.length()))\
    \ {\n            res.push_back(word);\n        }\n    }\n    for (std::string\
    \ word : res) {\n        temp = temp + \" \" + word;\n    }\n    return temp;",
  "    std::vector<int> primes;\n    for (int i = 0; i < 100; ++i) {\n        if (primes[i])\
    \ {\n            primes.push_back(false);\n        }\n    }\n    int prime_counter\
    \ = 0;\n    for (auto const &word : sentence) {\n        bool word_is_prime =\
    \ true;\n        for (int i = 0; i < primes.size(); ++i) {\n            if (word.length()\
    \ > i && !primes[i]) {\n                word_is_prime = false;\n            }\n\
    \        }\n        if (word_is_prime) {\n            primes[word.length()] =\
    \ true;\n            ++prime_counter;\n        }\n    }\n    if (prime_counter\
    \ < 2) {\n        return \"Invalid input\";\n    }\n    std::string new_sentence;\n\
    \    for (int i = 0; i < 100; ++i) {\n        if (primes[i]) {\n            new_sentence.insert(new_sentence.size(),\
    \ ' ');\n        }\n    }\n    for (auto const &word : sentence) {\n        int\
    \ word_length = word.length();\n        for (int i = 0; i < 100; ++i) {\n    \
    \        if (primes[i]) {\n                new_sentence.insert(new_sentence.size(),\
    \ word[i]);\n            }\n        }\n    }\n    for (auto const &word : new_sentence)\
    \ {\n        if (new_sentence[word.length() - 1] != ' ') {\n            new_sentence.insert(new_sentence.size(),\
    \ ' ');\n        }\n    }\n    return new_sentence;", "    // write your code\
    \ here\n    int i = 0;\n    std::string word = \"\";\n    while(sentence[i] !=\
    \ ' ') {\n        word = word + sentence[i];\n        i++;\n    }\n    std::string\
    \ result = \"\";\n    for(auto iter = word.rbegin(); iter != word.rend(); ++iter)\
    \ {\n        result += (std::to_string(*iter) + \" \");\n    }\n    return result\
    \ + \" \";", "  assert(sentence.length() != 0);\n  \n  const auto words = sentence.cbegin(),\
    \ end = sentence.cend();\n  std::string word;\n  bool is_prime = true;\n  while\
    \ (words != end) {\n    word.assign((*words));\n    ++words;\n    bool is_odd_num\
    \ = false;\n    for(auto &c : word) {\n      if(isdigit(c)) {\n        is_odd_num\
    \ = true;\n        break;\n      }\n    }\n    if(!is_odd_num) {\n      is_prime\
    \ = false;\n      break;\n    }\n  }\n  return is_prime ? word : \"\";", "   \
    \ std::vector<std::string> all_words;\n    std::string word;\n    std::string\
    \ new_word;\n    for (auto i : sentence) {\n        char letter = i;\n       \
    \ if (std::isalpha(letter)) {\n            all_words.push_back(word);\n      \
    \      word.clear();\n        }\n        word += letter;\n    }\n    for (auto\
    \ i : all_words) {\n        auto found = std::find(all_words.begin(), all_words.end(),\
    \ i);\n        assert(found != all_words.end());\n        std::string temp = i;\n\
    \        std::sort(temp.begin(), temp.end());\n        for (auto j = temp.size()\
    \ - 1; j >= 2; --j) {\n            auto result = std::find(temp.begin(), temp.end(),\
    \ temp.substr(j, j));\n            if (result != temp.end()) {\n             \
    \   new_word += \" \";\n            }\n        }\n        new_word += \" \";\n\
    \    }\n    std::reverse(all_words.begin(), all_words.end());\n    return new_word;",
  "    // Split sentence into a vector.\n    std::vector<std::string> sentence_split(sentence);\n\
    \    std::string result; // the result string\n    for (int i = 0; i < sentence_split.size();\
    \ i++) {\n        // Check each word if the length is prime number.\n        if\
    \ (std::isposint(std::sqrt(sentence_split[i].length()))) {\n            // If\
    \ not, add the word and space to result string.\n            result += sentence_split[i]\
    \ + ' ';\n        }\n    }\n    return result;", "    string new_word;\n    for(int\
    \ i=0;i<=sentence.length()-1;i++){\n        if(!isPrime(sentence.length())){\n\
    \            new_word.push_back(*sentence.begin());\n        }\n    }\n    return\
    \ new_word;", "    int n = sentence.size(); // length of the sentence\n    vector<int>\
    \ primes; // store the prime numbers\n    primes.resize(n); // preallocate the\
    \ array for the prime numbers\n    for (int i = 0; i < n; i++) {\n        if (primes[i]\
    \ != 1 && sentence[i] == ' ') {\n            primes[i] = 2;\n        } else {\n\
    \            primes[i] = 1;\n        }\n    }\n    int n = primes.size();\n  \
    \  string new_sentence;\n    for (int i = 0; i < n; i++) {\n        while (i <\
    \ n && primes[i] != 0) {\n            if (sentence[i - 1] != ' ' && sentence[i\
    \ - 1] != '-' && sentence[i - 1] != '!' && sentence[i - 1] != '.') {\n       \
    \         new_sentence += sentence[i - 1];\n                primes[i]++;\n   \
    \         }\n            i++;\n        }\n        if (primes[i] == 0) {\n    \
    \        new_sentence += ' ';\n        }\n    }\n    return new_sentence;", " \
    \   std::vector <std::string> splitted;\n    std::string new_sentence = \"\";\n\
    \    \n    std::istringstream is(sentence);\n    \n    while (is) {\n        std::string\
    \ word;\n        is >> word;\n        splitted.push_back(word);\n    }\n    \n\
    \    for (std::vector <std::string>::iterator it = splitted.begin(); it != splitted.end();\
    \ ++it) {\n        std::sort(splitted.begin(), splitted.end(), [it](std::string\
    \ s1, std::string s2) -> bool {\n            return (s1.length() < s2.length());\n\
    \        });\n        \n        bool is_prime = true;\n        for (int i = 1;\
    \ i < splitted.size(); i++) {\n            if ((*it).length() != splitted.at(i).length()\
    \ || (*it) != splitted.at(i)) {\n                is_prime = false;\n         \
    \       break;\n            }\n        }\n        \n        if (is_prime) {\n\
    \            new_sentence += *it + \" \";\n        }\n    }\n    return new_sentence;",
  "    std::string result = \"\";\n    std::map<char,int> word_freq;\n    for(int\
    \ i=0; i<sentence.length(); ++i){\n        char c = sentence[i];\n        if(c>='A'\
    \ && c<='Z'){\n            if(c in word_freq)\n                ++word_freq[c];\n\
    \            else\n                word_freq[c] = 1;\n        }\n        else\
    \ if(c==' ' || c=='\\n'){\n            auto it = word_freq.find(c);\n        \
    \    while(it != word_freq.end()){\n                if((result+\" \").length()==sentence.length()){\n\
    \                    result += it->first;\n                    break;\n      \
    \          }\n                ++it;\n            }\n            word_freq.erase(c);\n\
    \        }\n    }\n    return result;", "    std::string ans;\n    std::string\
    \ word;\n    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i]\
    \ == 'a' || sentence[i] == 'e' || sentence[i] == 'i' || sentence[i] == 'o' ||\
    \ sentence[i] == 'u') {\n            if (ans.length() != 0) {\n              \
    \  ans += \" \";\n            }\n            ans += sentence[i];\n        }\n\
    \    }\n    std::reverse(ans.begin(), ans.end());\n    for (int i = 3; i < ans.length();\
    \ i++) {\n        std::set<std::string> primes;\n        for (int j = 1; j < i;\
    \ j++) {\n            if (ans[j] % i == 0) {\n                primes.insert(ans.substr(j,\
    \ i - j));\n                break;\n            }\n        }\n        for (std::string\
    \ s : primes) {\n            ans.replace(ans.find(s), ans.length(), s);\n    \
    \    }\n    }\n    return ans;", "  std::vector<std::string> res;\n  std::stack<std::pair<int,\
    \ int>> s;\n  int pos = 0;\n  int n = 0;\n  for (auto x : sentence) {\n    if\
    \ (x == '.') {\n      continue;\n    }\n    if (x == '-') {\n      if (s.empty()\
    \ || s.top().first > pos) {\n        s.push(std::make_pair(pos, n));\n      }\n\
    \      n = 0;\n    } else {\n      n++;\n    }\n    pos = n;\n  }\n  while (!s.empty())\
    \ {\n    s.push(std::make_pair(s.top().first, n));\n  }\n  while (!s.empty())\
    \ {\n    if (s.top().second != 0) {\n      res.push_back(s.top().second);\n  \
    \    s.pop();\n    }\n  }\n  return res;", "    std::vector<int> length_prime;\n\
    \    std::string answer;\n    \n    // Get the prime numbers in length\n    for\
    \ (auto i = 0; i < sentence.length(); i++)\n    {\n        if (length_prime.count(i)\
    \ > 0)\n        {\n            length_prime.erase(length_prime.begin()+i);\n \
    \       }\n        else\n        {\n            length_prime.push_back(i);\n \
    \       }\n    }\n    // Sort the length of prime\n    std::sort(length_prime.begin(),length_prime.end());\n\
    \    \n    // Iterate through each word, find the corresponding prime number\n\
    \    for (auto i = 0; i < sentence.length(); i++)\n    {\n        // If it is\
    \ found\n        if (length_prime.count(sentence[i]) == 1)\n        {\n      \
    \      // Add the corresponding prime number to answer\n            answer.append(length_prime[sentence[i]]);\n\
    \            // Remove the corresponding prime number from length_prime\n    \
    \        length_prime.erase(length_prime.begin()+i);\n        }\n    }\n    //\
    \ If there are still primes in the length_prime, append them to the answer\n \
    \   for (auto i = 0; i < length_prime.size(); i++)\n    {\n        answer.append(length_prime[i]);\n\
    \    }\n    return answer;", "  int n = static_cast<int>(sentence.length());\n\
    \  std::unordered_map<int, int> primes_map;\n  primes_map[1] = 1;\n  primes_map[2]\
    \ = 2;\n  primes_map[3] = 5;\n  primes_map[5] = 1;\n  primes_map[7] = 2;\n  primes_map[11]\
    \ = 3;\n  primes_map[13] = 3;\n  primes_map[17] = 2;\n  primes_map[19] = 3;\n\
    \  primes_map[23] = 2;\n  primes_map[29] = 5;\n  primes_map[37] = 7;\n  primes_map[53]\
    \ = 3;\n  primes_map[59] = 5;\n  primes_map[673] = 7;\n  primes_map[823] = 5;\n\
    \  primes_map[891] = 7;\n  primes_map[919] = 5;\n  primes_map[1059] = 3;\n  primes_map[1123]\
    \ = 3;\n  primes_map[1151] = 7;\n  primes_map[1279] = 3;\n  primes_map[1343] =\
    \ 3;\n  primes_map[1391] = 7;\n  primes_map[1447] = 3;\n  primes_map[1511] = 3;\n\
    \  primes_map[1559] = 3;\n  primes_map[1599] = 3;\n  primes_map[1647] = 3;\n \
    \ primes_map[1711] = 3;\n  primes_map[1759] = 3;\n  primes_map[1799] = 3;\n  primes_map[1847]\
    \ = 3;\n  primes_map[1911] = 3;\n  primes_map[1959] = 3;\n  primes_map[1991] =\
    \ 3;\n  primes_map[2047] = 3;\n  primes_map[2111] = 3;\n  primes_map[2175] = 3;\n\
    \  primes_map[2223] = 3;\n  primes_map[2277] = 3;\n  primes_map[2323] = 3;\n \
    \ primes_map[2377] = 3;\n  primes_map[2413] = 3;\n  primes_map[2467] = 3;\n  primes_map[2523]\
    \ = 3;\n  primes_map[2579] = 3;\n  primes_map[2613] = 3;\n  primes_map[2667] =\
    \ 3;\n  primes_map[2723] = 3;\n  primes_map[2779] = 3;\n  primes_map[2823] = 3;\n\
    \  primes_map[2877] = 3;\n  primes_map[2923] = 3;\n  primes_map[2967] = 3;\n \
    \ primes_map[3023] = 3;\n  primes_map[3079] = 3;\n  primes_map[3131] = 3;", " \
    \   std::vector<std::string> words(std::sregex_token_iterator(sentence.begin(),\
    \ sentence.end(), \n        std::sregex_token_iterator(), \n        std::sregex_token_iterator()));\n\
    \    std::string ans;\n    for (int i = 1; i <= sqrt(words.size()); i++) {\n \
    \       if (words.size() % i > 0) {\n            std::swap(words[words.size()\
    \ % i], words[words.size() % i + 1]);\n        }\n    }\n    for (auto w : words)\
    \ {\n        ans.push_back(w);\n    }\n    return ans;", "  std::string result\
    \ = \"\";\n  assert(1 <= sentence.length() &&\n         sentence.length() <= 100\
    \ &&\n         std::all_of(sentence.begin(), sentence.end(), ::isalpha));\n  std::set<std::string>\
    \ set;\n  // split string by space\n  std::stringstream ss(sentence);\n  while\
    \ (std::getline(ss, word, ' ')) {\n    set.insert(word);\n  }\n  // check all\
    \ words in set\n  for (const auto &word : set) {\n    if (!std::sqrt(word.length()).isPrime())\
    \ {\n      continue;\n    }\n    result += \" \" + word;\n  }\n  return result;",
  "    std::string result = \"\";\n    // Split sentence into words\n    std::vector<std::string>\
    \ sentenceSplit(sentence.begin(), sentence.end());\n    std::sort(sentenceSplit.begin(),\
    \ sentenceSplit.end(), [] (std::string a, std::string b) { return a.size() < b.size();\
    \ });\n    // Iterate through each word\n    for (auto it = sentenceSplit.begin();\
    \ it != sentenceSplit.end(); ++it) {\n        // Check if word is prime\n    \
    \    bool prime = true;\n        for (int i = 2; i < it->size(); ++i) {\n    \
    \        int div = it->size() / i;\n            if (it->size() % i == 0) {\n \
    \               prime = false;\n                break;\n            }\n      \
    \  }\n        // If word is not prime\n        if (!prime) {\n            result\
    \ += it->at(0);\n        }\n    }\n    return result;", "    auto new_string =\
    \ \"\";\n    std::string word = \" \";\n    std::string new_string_temp = sentence;\n\
    \    for (auto &i : new_string_temp) {\n        if (!std::isalpha(i)) {\n    \
    \        word += i + \" \";\n        } else {\n            if (std::find(sentence.begin(),\
    \ sentence.end(), word) != sentence.end()) {\n                word += new_string;\n\
    \            }\n        }\n    }\n    return new_string;", "    std::string result;\n\
    \    auto words = std::sregex_token_iterator(sentence.begin(), sentence.end(),\
    \ \n        std::sregex(\" \"), std::regex_constants::match_flag_eol);\n    \n\
    \    auto words_end = std::sregex_token_iterator();\n    \n    for (; words !=\
    \ words_end; ++words)\n        result += *words;\n    \n    return result;", " \
    \   // Your code here\n    std::string ans;\n    int flag = 0;\n    int i = 1;\n\
    \    while (!sentence.empty()) {\n        if (sentence[0] == 'o') {\n        \
    \    flag = 1;\n        }\n        for (int j = 0; j < sentence.size(); j++) {\n\
    \            if (sentence[j] != ' ') {\n                if (flag == 1) {\n   \
    \                 ans = ans + sentence.substr(i, 1);\n                    i +=\
    \ j;\n                }\n                break;\n            }\n        }\n  \
    \      i += sentence.find(\" \");\n        flag = 0;\n    }\n    return ans;",
  "  assert( sentence.find_first_not_of(\"1234567890-=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    ) == \"1234567890-=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" );\n\
    \  \n  int primes[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\
    \ 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n  std::string ret = \"\";\n  for (int\
    \ i=0;i<10;i++) ret += \" \";\n  \n  for (auto n : sentence){\n    // Find the\
    \ index where n is prime number\n    auto idx = std::find(primes, primes+10, n);\n\
    \    \n    // If it is a prime number then append it to ret\n    if (idx != primes+10)\n\
    \      ret += n;\n  }\n  return ret;", "    bool prime[100] = {0};\n    for (char\
    \ &c : sentence) {\n        c = tolower(c); // To convert all characters to lower\
    \ case\n    }\n    std::string result;\n    std::string word;\n    for (int i\
    \ = 0; i < sentence.size(); i++) {\n        word = sentence[i];\n        while\
    \ (true) {\n            if (prime[word.length()] == 0) {\n                prime[word.length()]\
    \ = true;\n                result.append(word);\n                break;\n    \
    \        }\n            word++;\n        }\n    }\n    return result;", "  //\
    \ Your code here\n  assert(sentence.length() <= 100);\n  std::string res;\n  \n\
    \  for (auto &c: sentence)\n  {\n    if (std::isspace(c))\n    {\n      if (res.empty())\n\
    \      {\n        res.push_back(c);\n      }\n      else\n      {\n        auto\
    \ it = res.find(c);\n        if (it != res.end())\n        {\n          res.erase(it);\n\
    \        }\n        else\n        {\n          res.push_back(c);\n        }\n\
    \      }\n    }\n    else\n    {\n      auto it = res.find(c);\n      if (it ==\
    \ res.end())\n      {\n        res.push_back(c);\n      }\n    }\n  }\n\n  std::sort(res.begin(),\
    \ res.end());\n\n  int size = res.size();\n  for (int i = 0; i < size - 1; i++)\n\
    \  {\n    for (int j = i + 1; j < size; j++)\n    {\n      if (res[i] * res[j]\
    \ % size == 0)\n      {\n        auto it = std::find(res.begin(), res.end(), res[i]\
    \ * res[j] % size);\n        res.erase(it);\n      }\n    }\n  }\n  \n  return\
    \ res;"]
stop_tokens:
- "\n}"
