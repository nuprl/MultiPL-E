name: HumanEval_141_file_name_check
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  int i = 0;\n  bool isInvalid = false;\n  std::string s = \"\";\n  char\
    \ temp_char;\n  do {\n    isInvalid = true;\n    if (file_name[i] > '9') {\n \
    \     isInvalid = false;\n    }\n    if (file_name[i] > '0') {\n      isInvalid\
    \ = false;\n    }\n    if (file_name[i] == '.') {\n      isInvalid = false;\n\
    \    }\n    if (file_name[i] == '\\0') {\n      isInvalid = false;\n    }\n  \
    \  if (file_name[i] > '9' || file_name[i] > '0' || file_name[i] < 'a' || file_name[i]\
    \ > 'z' || file_name[i] < 'A') {\n      isInvalid = false;\n    }\n    temp_char\
    \ = file_name[i];\n    if (file_name[i] == '.') {\n      i++;\n      int j = i\
    \ + 1;\n      int l = i + 1;\n      int flag = 0;\n      while (j < file_name.length()\
    \ && file_name[j] != '\\0') {\n        if (file_name[j] == temp_char) {\n    \
    \      flag = 1;\n          break;\n        }\n        ++j;\n      }\n      while\
    \ ((j < file_name.length()) && (file_name[j] != '\\0')) {\n        if (file_name[j]\
    \ == temp_char) {\n          flag = 1;\n          break;\n        }\n        ++j;\n\
    \      }\n      if (flag == 0) {\n        isInvalid = false;\n      }\n      i\
    \ += 2;\n    } else {\n      i++;\n      s = s + file_name[i];\n    }\n  } while\
    \ (isInvalid);\n  \n  if (isInvalid) {\n    return \"No\";\n  } else {\n    return\
    \ \"Yes\";\n  }\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsigeamkp.cpp: In function 'int main()':\n/tmp/tmpsigeamkp.cpp:74:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsigeamkp.cpp:2:\n/tmp/tmpsigeamkp.cpp:75:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code goes here\n    // Base condition\n    if(file_name.size()\
    \ == 3 && file_name.at(0) == '0' \n    && file_name.at(1) == '0' && file_name.at(2)\
    \ == '9') {\n        // For each of the three conditions, use an if statement\
    \ to check each condition separately\n        if(file_name.at(0) != '.') {\n \
    \           if(file_name.at(0) != 'a' && file_name.at(0) != 'A') {\n         \
    \       if(file_name.at(1) != '.') {\n                    // Now check if the\
    \ first character after dot is one of ['txt', 'exe', 'dll']\n                \
    \    if(file_name.at(2) == 't' || file_name.at(2) == 'T'\n                   \
    \ || file_name.at(2) == 'e' || file_name.at(2) == 'E'\n                    ||\
    \ file_name.at(2) == 'x' || file_name.at(2) == 'X'\n                    || file_name.at(2)\
    \ == 'd' || file_name.at(2) == 'D') {\n                        \n            \
    \            if(file_name.at(0) != 'a' && file_name.at(0) != 'A') {\n        \
    \                    if(file_name.at(1) != '.') {\n                          \
    \      if(file_name.at(2) != 'x' && file_name.at(2) != 'X') {\n              \
    \                      if(file_name.at(3) != '.') {\n                        \
    \                if(file_name.at(4) != 't' && file_name.at(4) != 'T') {\n    \
    \                                        if(file_name.at(5) != 'e' && file_name.at(5)\
    \ != 'E') {\n                                                if(file_name.at(6)\
    \ != '.') {\n                                                    if(file_name.at(7)\
    \ != 'x' && file_name.at(7) != 'X') {\n                                      \
    \                  if(file_name.at(8) != 't' && file_name.at(8) != 'T') {\n  \
    \                                                          if(file_name.at(9)\
    \ != 'e' && file_name.at(9) != 'E') {\n                                      \
    \                          // Your code goes here\n                          \
    \                                  }\n                                       \
    \                 }\n                                                    }\n \
    \                                               }\n                          \
    \                  }\n                                        }\n            \
    \                        }\n                                }\n              \
    \              }\n                        }\n                    }\n         \
    \       }\n            }\n        }\n    }\n    return \"No\";\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8pgk99b3.cpp: In function 'int main()':\n/tmp/tmp8pgk99b3.cpp:59:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8pgk99b3.cpp:2:\n/tmp/tmp8pgk99b3.cpp:60:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Write your code here\n    int digit = 0;\n    for (auto &c : file_name)\
    \ {\n        if (c == '.') {\n            if (digit > 2) {\n                return\
    \ \"No\";\n            }\n            digit++;\n        } else {\n           \
    \ if (c < 'a' || c > 'z' || c < 'A' || c > 'Z') {\n                return \"No\"\
    ;\n            } else {\n                digit = 0;\n            }\n        }\n\
    \    }\n    if (file_name.size() > 2) {\n        return \"No\";\n    }\n    if\
    \ (file_name[0] == '.') {\n        if (file_name[1] == '.') {\n            return\
    \ \"No\";\n        } else {\n            return \"Yes\";\n        }\n    }\n \
    \   return \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx76adtyr.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpx76adtyr.cpp:18:16: error: ISO C++ forbids declaration of 'c' with no\
    \ type [-fpermissive]\n     for (auto &c : file_name) {\n                ^\n/tmp/tmpx76adtyr.cpp:18:20:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &c : file_name) {\n                    ^\n/tmp/tmpx76adtyr.cpp: In function\
    \ 'int main()':\n/tmp/tmpx76adtyr.cpp:45:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = file_name_check;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx76adtyr.cpp:2:\n/tmp/tmpx76adtyr.cpp:46:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tint count = 0;\n\tfor (char &c: file_name) {\n\t\tif ('0' <= c && c <=\
    \ '9') {\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (count <= 3 || file_name.find_first_not_of(\"\
    .\") == std::string::npos) {\n\t\treturn \"No\";\n\t} else {\n\t\tstd::string\
    \ file_name = file_name.substr(0, file_name.find_first_not_of(\".\"));\n\t\tstd::string\
    \ extension = file_name.substr(file_name.find_first_of(\".\") + 1);\n\t\tstd::string\
    \ file_name_extension = file_name + \".\" + extension;\n\t\t\n\t\tif (file_name_extension\
    \ == \"exe\" || file_name_extension == \"dll\") {\n\t\t\treturn \"Yes\";\n\t\t\
    } else {\n\t\t\treturn \"No\";\n\t\t}\n\t}\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6l9wifwa.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp6l9wifwa.cpp:17:16: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n  for (char &c: file_name) {\n                ^\n/tmp/tmp6l9wifwa.cpp:\
    \ In function 'int main()':\n/tmp/tmp6l9wifwa.cpp:37:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6l9wifwa.cpp:2:\n/tmp/tmp6l9wifwa.cpp:38:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code here\n    auto it = file_name.find_first_not_of(\".\");\n\
    \    auto last = file_name.find_last_of(\".\");\n    if(it == file_name.end())\
    \ return \"No\";\n    if((it - last) > 3) return \"No\";\n    if((it != file_name.begin())\
    \ && (std::toupper(file_name[it - 1]) != std::toupper(file_name[it - 2]))) return\
    \ \"No\";\n    if((last != file_name.end()) &&\n        (std::toupper(file_name[file_name.size()\
    \ - 1]) != std::toupper(file_name[file_name.size() - 2]))) return \"No\";\n  \
    \  if((it != file_name.begin()) && \n        (std::toupper(file_name[it - 1])\
    \ != std::toupper(file_name[it - 2])) &&\n        (std::tolower(file_name[it -\
    \ 1]) != std::tolower(file_name[it - 2]))) return \"No\";\n    if((last != file_name.end())\
    \ &&\n        (std::toupper(file_name[file_name.size() - 1]) != std::toupper(file_name[file_name.size()\
    \ - 2])) &&\n        (std::tolower(file_name[file_name.size() - 1]) != std::tolower(file_name[file_name.size()\
    \ - 2]))) return \"No\";\n    return \"Yes\";\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcn0pv17x.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpcn0pv17x.cpp:17:10: error: 'it' does not name a type\n     auto it = file_name.find_first_not_of(\"\
    .\");\n          ^\n/tmp/tmpcn0pv17x.cpp:18:10: error: 'last' does not name a\
    \ type\n     auto last = file_name.find_last_of(\".\");\n          ^\n/tmp/tmpcn0pv17x.cpp:19:8:\
    \ error: 'it' was not declared in this scope\n     if(it == file_name.end()) return\
    \ \"No\";\n        ^\n/tmp/tmpcn0pv17x.cpp:20:9: error: 'it' was not declared\
    \ in this scope\n     if((it - last) > 3) return \"No\";\n         ^\n/tmp/tmpcn0pv17x.cpp:20:14:\
    \ error: 'last' was not declared in this scope\n     if((it - last) > 3) return\
    \ \"No\";\n              ^\n/tmp/tmpcn0pv17x.cpp:21:9: error: 'it' was not declared\
    \ in this scope\n     if((it != file_name.begin()) && (std::toupper(file_name[it\
    \ - 1]) != std::toupper(file_name[it - 2]))) return \"No\";\n         ^\n/tmp/tmpcn0pv17x.cpp:22:9:\
    \ error: 'last' was not declared in this scope\n     if((last != file_name.end())\
    \ &&\n         ^\n/tmp/tmpcn0pv17x.cpp:24:9: error: 'it' was not declared in this\
    \ scope\n     if((it != file_name.begin()) && \n         ^\n/tmp/tmpcn0pv17x.cpp:27:9:\
    \ error: 'last' was not declared in this scope\n     if((last != file_name.end())\
    \ &&\n         ^\n/tmp/tmpcn0pv17x.cpp: In function 'int main()':\n/tmp/tmpcn0pv17x.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcn0pv17x.cpp:2:\n/tmp/tmpcn0pv17x.cpp:34:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\t// Write your code here.\n\t// return \"No\";\n\t\n\tint num_digits = file_name.length();\n\
    \tint dot_index = file_name.find_first_of(\".\");\n\t\n\tif (dot_index > 0) {\n\
    \t\tif (dot_index > 2) {\n\t\t\tprintf(\"%c\", 0);\n\t\t} else {\n\t\t\tprintf(\"\
    %c\", dot_index);\n\t\t}\n\t} else {\n\t\tprintf(\"%c\", 0);\n\t}\n\t\n\tint i\
    \ = 0;\n\twhile (i < num_digits) {\n\t\t\n\t\tint index = file_name[i]-'0';\n\t\
    \tif (index > 9) {\n\t\t\tprintf(\"%c\", 0);\n\t\t} else {\n\t\t\tprintf(\"%c\"\
    , index);\n\t\t}\n\t\ti++;\n\t}\n\t\n\tif (dot_index >= num_digits) {\n\t\tprintf(\"\
    %c\", 0);\n\t} else {\n\t\tprintf(\"%c\", dot_index);\n\t}\n\treturn \"No\";\n\
    }\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpf4wsdo24.cpp: In function 'int main()':\n/tmp/tmpf4wsdo24.cpp:52:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpf4wsdo24.cpp:2:\n/tmp/tmpf4wsdo24.cpp:53:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    bool flag = false;\n    // Your code goes here\n    // Write your code\
    \ below\n    int length = 0;\n    char c;\n    for (int i = 0; file_name[i] !=\
    \ '\\0'; i++) length++;\n    if (length <= 3 && length != 0) {\n        for (int\
    \ i = 0; i < length; i++) c = file_name[i];\n        if (c == '.' && file_name[0]\
    \ != '.') {\n            for (int i = 0; i < length - 1; i++) {\n            \
    \    if (file_name[i] == '.') {\n                    for (int k = i + 1; k < length\
    \ - 1; k++) {\n                        if (file_name[k] == '.') break;\n     \
    \               }\n                    if (k == length - 1) {\n              \
    \          flag = true;\n                        break;\n                    }\n\
    \                }\n            }\n        }\n    }\n    if (flag && file_name[length]\
    \ != '\\0') {\n        if ((file_name[length - 1] == '.' && file_name[length -\
    \ 2] != '\\0') || (file_name[length - 1] == '.' && file_name[length - 2] == '.'\
    \ && file_name[length - 3] != '\\0')) {\n            flag = false;\n        }\n\
    \    }\n    if (flag) return \"Yes\";\n    else return \"No\";\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8yb33qc4.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp8yb33qc4.cpp:30:25: error: name lookup of 'k' changed for ISO 'for' scoping\
    \ [-fpermissive]\n                     if (k == length - 1) {\n              \
    \           ^\n/tmp/tmp8yb33qc4.cpp:30:25: note: (if you use '-fpermissive' G++\
    \ will accept your code)\n/tmp/tmp8yb33qc4.cpp: In function 'int main()':\n/tmp/tmp8yb33qc4.cpp:47:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8yb33qc4.cpp:2:\n/tmp/tmp8yb33qc4.cpp:48:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tassert(file_name.size() >= 3);\n\tauto first_letter = file_name[0];\n\t\
    assert(first_letter >= 'a' && first_letter <= 'z');\n\tauto last_letter = file_name.back();\n\
    \tassert(last_letter >= 'a' && last_letter <= 'z');\n\tauto dot = file_name.find('.')+1;\n\
    \tassert(dot <= file_name.size());\n\tassert(file_name.substr(0, dot)[0] == 'a'\
    \ || file_name.substr(0, dot)[0] == 'A');\n\tassert(file_name.substr(dot)[1] ==\
    \ '.txt' || file_name.substr(dot)[1] == '.exe' || file_name.substr(dot)[1] ==\
    \ '.dll');\n\treturn \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpp5flp0i9.cpp:24:119: warning: multi-character character constant\
    \ [-Wmultichar]\n  assert(file_name.substr(dot)[1] == '.txt' || file_name.substr(dot)[1]\
    \ == '.exe' || file_name.substr(dot)[1] == '.dll');\n                        \
    \                                                                            \
    \                   ^\n/tmp/tmpp5flp0i9.cpp:24:119: warning: multi-character character\
    \ constant [-Wmultichar]\n/tmp/tmpp5flp0i9.cpp:24:119: warning: multi-character\
    \ character constant [-Wmultichar]\n/tmp/tmpp5flp0i9.cpp: In function 'std::string\
    \ file_name_check(std::string)':\n/tmp/tmpp5flp0i9.cpp:17:7: error: 'first_letter'\
    \ does not name a type\n  auto first_letter = file_name[0];\n       ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp5flp0i9.cpp:2:\n/tmp/tmpp5flp0i9.cpp:18:9: error:\
    \ 'first_letter' was not declared in this scope\n  assert(first_letter >= 'a'\
    \ && first_letter <= 'z');\n         ^\n/tmp/tmpp5flp0i9.cpp:19:7: error: 'last_letter'\
    \ does not name a type\n  auto last_letter = file_name.back();\n       ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp5flp0i9.cpp:2:\n/tmp/tmpp5flp0i9.cpp:20:9: error:\
    \ 'last_letter' was not declared in this scope\n  assert(last_letter >= 'a' &&\
    \ last_letter <= 'z');\n         ^\n/tmp/tmpp5flp0i9.cpp:21:7: error: 'dot' does\
    \ not name a type\n  auto dot = file_name.find('.')+1;\n       ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp5flp0i9.cpp:2:\n/tmp/tmpp5flp0i9.cpp:22:9: error:\
    \ 'dot' was not declared in this scope\n  assert(dot <= file_name.size());\n \
    \        ^\n/tmp/tmpp5flp0i9.cpp: In function 'int main()':\n/tmp/tmpp5flp0i9.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \     "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // your code here\n  int len = file_name.length();\n  if (len < 3) return\
    \ \"No\";\n  for (int i=1;i < len; i++){\n    if (!isdigit(file_name[i])) {\n\
    \      return \"No\";\n    }\n    if (file_name[i] == '.'){\n      continue;\n\
    \    }\n    else if (file_name[i] == file_name[i-1]){\n      continue;\n    }\n\
    \    else{\n      break;\n    }\n  }\n  for (int i=1;i<len;i++){\n    if (!(file_name[i]\
    \ == 'a' || file_name[i] == 'b' || file_name[i] == 'c' || \n        file_name[i]\
    \ == 'd' || file_name[i] == 'e' || file_name[i] == 'f' || \n        file_name[i]\
    \ == 'g' || file_name[i] == 'h' || file_name[i] == 'i' || \n        file_name[i]\
    \ == 'j' || file_name[i] == 'k' || file_name[i] == 'l' || \n        file_name[i]\
    \ == 'm' || file_name[i] == 'n' || file_name[i] == 'o' || \n        file_name[i]\
    \ == 'p' || file_name[i] == 'q' || file_name[i] == 'r' || \n        file_name[i]\
    \ == 's' || file_name[i] == 't' || file_name[i] == 'u' || \n        file_name[i]\
    \ == 'v' || file_name[i] == 'w' || file_name[i] == 'x' || \n        file_name[i]\
    \ == 'y' || file_name[i] == 'z')){\n      return \"No\";\n    }\n  }\n  \n  return\
    \ \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpww5q6zfs.cpp: In function 'int main()':\n/tmp/tmpww5q6zfs.cpp:50:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpww5q6zfs.cpp:2:\n/tmp/tmpww5q6zfs.cpp:51:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tint num_digits = 0;\n\tint dots = 0;\n\tfor (int i = 0; i < file_name.size();\
    \ i++) {\n\t\tif (file_name[i] >= '0' && file_name[i] <= '9')\n\t\t\tnum_digits++;\n\
    \t\telse if (file_name[i] == '.')\n\t\t\tdots++;\n\t}\n\tif (num_digits > 3 ||\
    \ dots > 1 || file_name[file_name.size() - 1] == '.' || file_name[0] >= 'a' &&\
    \ file_name[0] <= 'z' || file_name[0] >= 'A' && file_name[0] <= 'Z') {\n\t\treturn\
    \ \"No\";\n\t} else {\n\t\treturn \"Yes\";\n\t}\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppbgnnwip.cpp: In function 'int main()':\n/tmp/tmppbgnnwip.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppbgnnwip.cpp:2:\n/tmp/tmppbgnnwip.cpp:32:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    size_t pos = file_name.find('.');\n    if(file_name.size() < 3)\n   \
    \     return 'No';\n    if(pos == std::string::npos)\n        return 'No';\n \
    \   if(file_name.substr(0, 2) != \"0\" && file_name.substr(0, 2) != \"1\")\n \
    \       return 'No';\n    if(pos > 0 && file_name.substr(0, 1) != \"a\")\n   \
    \     return 'No';\n    if(pos > 0 && file_name.substr(0, 1) != \"A\")\n     \
    \   return 'No';\n    if(file_name.substr(pos - 1) != \"txt\")\n        return\
    \ 'No';\n    if(file_name.substr(pos + 1) != \"exe\")\n        return 'No';\n\
    \    if(file_name.substr(pos + 1) != \"dll\")\n        return 'No';\n    return\
    \ 'Yes';\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4v2axp2m.cpp:18:16: warning: multi-character character constant\
    \ [-Wmultichar]\n         return 'No';\n                ^\n/tmp/tmp4v2axp2m.cpp:20:16:\
    \ warning: multi-character character constant [-Wmultichar]\n         return 'No';\n\
    \                ^\n/tmp/tmp4v2axp2m.cpp:22:16: warning: multi-character character\
    \ constant [-Wmultichar]\n         return 'No';\n                ^\n/tmp/tmp4v2axp2m.cpp:24:16:\
    \ warning: multi-character character constant [-Wmultichar]\n         return 'No';\n\
    \                ^\n/tmp/tmp4v2axp2m.cpp:26:16: warning: multi-character character\
    \ constant [-Wmultichar]\n         return 'No';\n                ^\n/tmp/tmp4v2axp2m.cpp:28:16:\
    \ warning: multi-character character constant [-Wmultichar]\n         return 'No';\n\
    \                ^\n/tmp/tmp4v2axp2m.cpp:30:16: warning: multi-character character\
    \ constant [-Wmultichar]\n         return 'No';\n                ^\n/tmp/tmp4v2axp2m.cpp:32:16:\
    \ warning: multi-character character constant [-Wmultichar]\n         return 'No';\n\
    \                ^\n/tmp/tmp4v2axp2m.cpp:33:12: warning: multi-character character\
    \ constant [-Wmultichar]\n     return 'Yes';\n            ^\n/tmp/tmp4v2axp2m.cpp:\
    \ In function 'std::string file_name_check(std::string)':\n/tmp/tmp4v2axp2m.cpp:18:16:\
    \ error: invalid conversion from 'int' to 'const char*' [-fpermissive]\n     \
    \    return 'No';\n                ^\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n\
    \                 from /usr/include/c++/4.8.2/bitset:47,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n             \
    \    from /tmp/tmp4v2axp2m.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmp4v2axp2m.cpp:20:16: error: invalid conversion from\
    \ 'int' to 'const char*' [-fpermissive]\n         return 'No';\n              "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tint counter = 0;\n\tint check = 0;\n\tint dot = 0;\n\t\n\t// For all characters\
    \ in the string\n\tfor (int i=0; i<file_name.length(); i++) {\n\t\tcheck = file_name[i];\
    \ // Store the current character in the check variable\n\t\t\n\t\t// If character\
    \ is digit ('0'-'9')\n\t\tif (check >= '0' && check <= '9') {\n\t\t\t// Increment\
    \ counter\n\t\t\tcounter++;\n\t\t}\n\t\t\n\t\t// If character is dot, return 'No'\n\
    \t\tif (check == '.') {\n\t\t\tdot++;\n\t\t\tif (dot > 0) {\n\t\t\t\treturn \"\
    No\";\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If counter >= 2, return 'No'\n\t\tif (counter\
    \ >= 2) {\n\t\t\treturn \"No\";\n\t\t}\n\t}\n\t\n\t// If counter > 0, return 'Yes'\n\
    \tif (counter > 0) {\n\t\treturn \"Yes\";\n\t}\n\t\n\t// If counter < 2, return\
    \ 'Yes'\n\treturn \"No\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph7maa_c1.cpp: In function 'int main()':\n/tmp/tmph7maa_c1.cpp:53:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmph7maa_c1.cpp:2:\n/tmp/tmph7maa_c1.cpp:54:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int n = file_name.size()-1;\n    if(file_name.at(n) != '.')\n       \
    \ return \"No\";\n\n    std::string first_char = file_name.substr(0,n); \n   \
    \ std::string second_char = file_name.substr(n+1,file_name.size()); \n    bool\
    \ start_with_latin_alphabet = std::all_of(first_char.begin(), first_char.end(),\
    \ \n                [](char c){ return std::isalpha(c); });\n    bool has_dot\
    \ = second_char.find('.') != std::string::npos;\n    bool is_exe = second_char\
    \ == \"exe\" || second_char == \"dll\";\n    bool file_is_valid = start_with_latin_alphabet\
    \ && has_dot && is_exe;\n\n    if(!file_is_valid)\n        return \"No\";\n\n\
    \    return \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5w9suqei.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp5w9suqei.cpp:22:38: error: 'all_of' is not a member of 'std'\n     bool\
    \ start_with_latin_alphabet = std::all_of(first_char.begin(), first_char.end(),\
    \ \n                                      ^\n/tmp/tmp5w9suqei.cpp:23:53: warning:\
    \ lambda expressions only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n                 [](char c){ return std::isalpha(c); });\n       \
    \                                              ^\n/tmp/tmp5w9suqei.cpp: In function\
    \ 'int main()':\n/tmp/tmp5w9suqei.cpp:34:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = file_name_check;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5w9suqei.cpp:2:\n/tmp/tmp5w9suqei.cpp:35:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\t// Declare a string variable 'is_valid'.\n\tstd::string is_valid;\n\n\t\
    // Declare two variables 'pos' and 'end' which are used to find the\n\t// position\
    \ of the dot '.' in the file's name.\n\tint pos;\n\tint end;\n\n\t// 'while' loop\
    \ will execute if the condition of the for loop is true.\n\tfor (; (pos = file_name.find_first_not_of(\"\
    0123456789.\", 0)) != std::string::npos;) {\n\t\t// 'end' variable will hold the\
    \ position of the last character in the file's\n\t\t// name that is not the dot\
    \ '.'.\n\t\tend = file_name.find_first_of(\".\", pos + 1);\n\n\t\t// 'if' statement\
    \ will execute if the 'for' loop condition is true.\n\t\tif (end != std::string::npos)\
    \ {\n\t\t\t// 'is_valid' string variable will hold the value 'Yes' if all the\n\
    \t\t\t// conditions are met, and 'No' otherwise.\n\t\t\tis_valid = \"Yes\";\n\t\
    \t} else {\n\t\t\t// 'is_valid' string variable will hold the value 'No' if the\
    \ for loop\n\t\t\t// condition is false, and 'Yes' otherwise.\n\t\t\tis_valid\
    \ = \"No\";\n\t\t}\n\t\t// The loop will stop if the condition of the for loop\
    \ is false, in which case\n\t\t// the 'for' loop will terminate, and 'is_valid'\
    \ will hold the value 'No'.\n\t\tbreak;\n\t}\n\n\t// Return the 'is_valid' string\
    \ variable.\n\treturn is_valid;\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2c0j_6gv.cpp: In function 'int main()':\n/tmp/tmp2c0j_6gv.cpp:49:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2c0j_6gv.cpp:2:\n/tmp/tmp2c0j_6gv.cpp:50:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    const auto dot_position = file_name.find_first_of(\".\");\n    if (dot_position\
    \ == std::string::npos) {\n        return \"No\";\n    }\n    const auto letter_position\
    \ = file_name.find_first_not_of(\"0123456789\", dot_position);\n    const auto\
    \ letter_to_compare = file_name.substr(0, letter_position);\n    if (std::all_of(letter_to_compare.begin(),\
    \ letter_to_compare.end(), \n                [&](char c) { \n                \
    \    return (std::isalpha(c) && std::tolower(c) == std::tolower(letter_to_compare[0]))\
    \ \n                           || c == '.';\n                })) {\n        return\
    \ \"Yes\";\n    }\n    return \"No\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpv0freky4.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpv0freky4.cpp:16:16: error: 'dot_position' does not name a type\n     const\
    \ auto dot_position = file_name.find_first_of(\".\");\n                ^\n/tmp/tmpv0freky4.cpp:17:9:\
    \ error: 'dot_position' was not declared in this scope\n     if (dot_position\
    \ == std::string::npos) {\n         ^\n/tmp/tmpv0freky4.cpp:20:16: error: 'letter_position'\
    \ does not name a type\n     const auto letter_position = file_name.find_first_not_of(\"\
    0123456789\", dot_position);\n                ^\n/tmp/tmpv0freky4.cpp:21:16: error:\
    \ 'letter_to_compare' does not name a type\n     const auto letter_to_compare\
    \ = file_name.substr(0, letter_position);\n                ^\n/tmp/tmpv0freky4.cpp:22:9:\
    \ error: 'all_of' is not a member of 'std'\n     if (std::all_of(letter_to_compare.begin(),\
    \ letter_to_compare.end(), \n         ^\n/tmp/tmpv0freky4.cpp:22:21: error: 'letter_to_compare'\
    \ was not declared in this scope\n     if (std::all_of(letter_to_compare.begin(),\
    \ letter_to_compare.end(), \n                     ^\n/tmp/tmpv0freky4.cpp:26:17:\
    \ warning: lambda expressions only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n                 })) {\n                 ^\n/tmp/tmpv0freky4.cpp:\
    \ In function 'int main()':\n/tmp/tmpv0freky4.cpp:32:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpv0freky4.cpp:2:\n/tmp/tmpv0freky4.cpp:33:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string file_name_no = file_name;\n    int count = 0;\n    for (int\
    \ i = 0; i < file_name_no.size(); i++) {\n        if (file_name_no[i] >= 'a' &&\
    \ file_name_no[i] <= 'z') {\n            if (file_name_no[i] == '_')\n       \
    \         count++;\n            else\n                count = -1;\n        }\n\
    \        else if (file_name_no[i] >= 'A' && file_name_no[i] <= 'Z') {\n      \
    \      if (file_name_no[i] == '_')\n                count++;\n            else\n\
    \                count = -1;\n        }\n        else if (file_name_no[i] >= '0'\
    \ && file_name_no[i] <= '9') {\n            count = -1;\n        }\n        else\
    \ {\n            count = -1;\n        }\n        if (count > 0)\n            count\
    \ = -1;\n    }\n    for (int i = 0; i < file_name_no.size(); i++) {\n        if\
    \ (file_name_no[i] >= 'a' && file_name_no[i] <= 'z') {\n            if (file_name_no[i]\
    \ == '_')\n                count++;\n            else\n                count =\
    \ -1;\n        }\n        else if (file_name_no[i] >= 'A' && file_name_no[i] <=\
    \ 'Z') {\n            if (file_name_no[i] == '_')\n                count++;\n\
    \            else\n                count = -1;\n        }\n        else if (file_name_no[i]\
    \ >= '0' && file_name_no[i] <= '9') {\n            count = -1;\n        }\n  \
    \      else {\n            count = -1;\n        }\n        if (count > 0) {\n\
    \            std::string file_name_no1 = file_name_no;\n            if (count\
    \ > 0) {\n                for (int i = 0; i < file_name_no1.size(); i++) {\n \
    \                   if (file_name_no1[i] == '.') {\n                        file_name_no1.erase(file_name_no1.begin()\
    \ + i);\n                    }\n                }\n            }\n           \
    \ int count = 0;\n            for (int i = 0; i < file_name_no1.size(); i++) {\n\
    \                if (file_name_no1[i] >= 'a' && file_name_no1[i] <= 'z') {\n \
    \                   if (file_name_no1[i] == '_')\n                        count++;\n\
    \                    else\n                        count = -1;\n             \
    \   }\n                else if (file_name_no1[i] >= 'A' && file_name_no1[i] <=\
    \ 'Z') {\n                    if (file_name_no1[i] == '_')\n                 \
    \       count++;\n                    else\n                        count = -1;\n\
    \                }\n                else if (file_name_no1[i] >= '0' && file_name_no1[i]\
    \ <= '9') {\n                    count = -1;\n                }\n            \
    \    else {\n                    count = -1;\n                }\n            \
    \    if (count > 0) {\n                    std::string file_name_no2 = file_name_no1;\n\
    \                    if (count > 0) {\n                        for (int i = 0;\
    \ i < file_name_no2.size(); i++) {\n                            if (file_name_no2[i]\
    \ == '.') {\n                                file_name_no2.erase(file_name_no\n\
    }\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeo6jrjy7.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpeo6jrjy7.cpp:94:1: error: expected ')' before '}' token\n }\n ^\n/tmp/tmpeo6jrjy7.cpp:94:1:\
    \ error: expected ';' before '}' token\n/tmp/tmpeo6jrjy7.cpp:95:12: error: a function-definition\
    \ is not allowed here before '{' token\n int main() {\n            ^\n/tmp/tmpeo6jrjy7.cpp:123:1:\
    \ error: expected '}' at end of input\n }\n ^\n/tmp/tmpeo6jrjy7.cpp:123:1: error:\
    \ expected '}' at end of input\n/tmp/tmpeo6jrjy7.cpp:123:1: error: expected '}'\
    \ at end of input\n/tmp/tmpeo6jrjy7.cpp:123:1: error: expected '}' at end of input\n\
    /tmp/tmpeo6jrjy7.cpp:123:1: error: expected '}' at end of input\n/tmp/tmpeo6jrjy7.cpp:123:1:\
    \ error: expected '}' at end of input\n/tmp/tmpeo6jrjy7.cpp:123:1: error: expected\
    \ '}' at end of input\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // code here\n    int num = 0;\n    int length = 0;\n    for(int i =\
    \ 0; i < file_name.length(); i++) {\n        if(!isdigit(file_name[i])) {\n  \
    \          length++;\n            continue;\n        }\n        num++;\n     \
    \   if(num > 1) {\n            length++;\n            if(!isalnum(file_name[i]))\
    \ {\n                length++;\n                continue;\n            }\n   \
    \         num = 0;\n        }\n    }\n    if(length != 3 || (num == 1 && file_name[0]\
    \ == '.') || (num != 1 && file_name[0] != '.') ||\n        (length != 1 && file_name[0]\
    \ != '.' && file_name[0] != 'a' && file_name[0] != 'A' && file_name[0] != 'z'\
    \ && file_name[0] != 'Z')) {\n        return \"No\";\n    }\n    return \"Yes\"\
    ;\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm2uluzbx.cpp: In function 'int main()':\n/tmp/tmpm2uluzbx.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpm2uluzbx.cpp:2:\n/tmp/tmpm2uluzbx.cpp:42:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    assert(file_name.size() <= 3);\n    assert(file_name.find(\".\") != std::string::npos);\n\
    \    assert(file_name[0] >= 'a' && file_name[0] <= 'z');\n    assert(file_name[file_name.size()\
    \ - 1] >= 'a' && file_name[file_name.size() - 1] <= 'z');\n    for (size_t i =\
    \ 0; i < file_name.size() - 1; i++) {\n        assert(file_name[i] == '.');\n\
    \        assert(file_name[i + 1] >= 'a' && file_name[i + 1] <= 'z');\n    }\n\
    \    assert(file_name[0] == 't' || file_name[0] == 'e' || file_name[0] == 'd');\n\
    \    return file_name;\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqzk9nx4z.cpp: In function 'int main()':\n/tmp/tmpqzk9nx4z.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqzk9nx4z.cpp:2:\n/tmp/tmpqzk9nx4z.cpp:29:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code here\n    char check[4] = { '0', '0', '0', '0' };\n    for\
    \ (int i = 0; i < file_name.length(); i++) {\n        std::cout << i << \" \"\
    ;\n        if (file_name[i] == '.') {\n            if (file_name[i + 1] != '.'\
    \ || file_name[i + 2] != '.' || file_name[i + 3] != '.') {\n                std::cout\
    \ << \"No\" << std::endl;\n                return \"No\";\n            } else\
    \ {\n                std::cout << \"Yes\" << std::endl;\n            }\n     \
    \   } else if (file_name[i] >= 'a' && file_name[i] <= 'z' || file_name[i] >= 'A'\
    \ && file_name[i] <= 'Z') {\n            std::cout << i << \" \";\n        } else\
    \ {\n            std::cout << \"No\" << std::endl;\n            return \"No\"\
    ;\n        }\n    }\n    std::cout << \"No\" << std::endl;\n    return \"No\"\
    ;\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9qfx8us2.cpp: In function 'int main()':\n/tmp/tmp9qfx8us2.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9qfx8us2.cpp:2:\n/tmp/tmp9qfx8us2.cpp:39:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tassert(file_name.size() <= 6);\n\tassert((file_name[0] == '.') || (file_name[0]\
    \ == '-'));\n\tassert((file_name[1] < 'a') || (file_name[1] > 'z'));\n\tassert((file_name[2]\
    \ < 'A') || (file_name[2] > 'Z'));\n\tassert(file_name[3] == file_name[4]);\n\t\
    return file_name;\n}\nint main() {\n    auto candidate = file_name_check;\n  \
    \  assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwr_x0ixz.cpp: In function 'int main()':\n/tmp/tmpwr_x0ixz.cpp:24:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwr_x0ixz.cpp:2:\n/tmp/tmpwr_x0ixz.cpp:25:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\t// Your code here\n\t// Declare two string variables:\n\t// One will store\
    \ your valid name if the file is valid\n\t// The other will store your invalid\
    \ name if the file is invalid.\n\tstd::string valid_name, invalid_name;\n\tfor\
    \ (int i = 0; i < file_name.length(); i++) {\n\t\tif (file_name[i] < '0' || file_name[i]\
    \ > '9') {\n\t\t\tinvalid_name = valid_name + file_name[i];\n\t\t}\n\t}\n\tif\
    \ (file_name.find('.') == file_name.length() - 1) {\n\t\tvalid_name = file_name.substr(0,\
    \ file_name.find('.'));\n\t}\n\telse {\n\t\tvalid_name = \"invalid\";\n\t}\n\t\
    std::replace(valid_name.begin(), valid_name.end(), '.', '');\n\tstd::replace(valid_name.begin(),\
    \ valid_name.begin(), tolower(valid_name.front()));\n\tstd::replace(valid_name.end(),\
    \ valid_name.end(), '.', '');\n\tfor (int i = 0; i < valid_name.length(); i++)\
    \ {\n\t\tif (valid_name[i] != 'a' && valid_name[i] != 'b' && valid_name[i] !=\
    \ 'c' && valid_name[i] != 'd' &&\n\t\t\tvalid_name[i] != 'e' && valid_name[i]\
    \ != 'f' && valid_name[i] != 'g' && valid_name[i] != 'h' &&\n\t\t\tvalid_name[i]\
    \ != 'i' && valid_name[i] != 'j' && valid_name[i] != 'k' && valid_name[i] != 'l'\
    \ &&\n\t\t\tvalid_name[i] != 'm' && valid_name[i] != 'n' && valid_name[i] != 'o'\
    \ && valid_name[i] != 'p' &&\n\t\t\tvalid_name[i] != 'q' && valid_name[i] != 'r'\
    \ && valid_name[i] != 's' && valid_name[i] != 't' &&\n\t\t\tvalid_name[i] != 'u'\
    \ && valid_name[i] != 'v' && valid_name[i] != 'w' && valid_name[i] != 'x' &&\n\
    \t\t\tvalid_name[i] != 'y' && valid_name[i] != 'z' && valid_name[i] != 'A' &&\
    \ valid_name[i] != 'B' &&\n\t\t\tvalid_name[i] != 'C' && valid_name[i] != 'D'\
    \ && valid_name[i] != 'E' && valid_name[i] != 'F' &&\n\t\t\tvalid_name[i] != 'G'\
    \ && valid_name[i] != 'H' && valid_name[i] != 'I' && valid_name[i] != 'J' &&\n\
    \t\t\tvalid_name[i] != 'K' && valid_name[i] != 'L' && valid_name[i] != 'M' &&\
    \ valid_name[i] != 'N' &&\n\t\t\tvalid_name[i] != 'O' && valid_name[i] != 'P'\
    \ && valid_name[i] != 'Q' && valid_name[i] != 'R' &&\n\t\t\tvalid_name[i] != 'S'\
    \ && valid_name[i] != 'T' && valid_name[i] != 'U' && valid_name[i] != 'V' &&\n\
    \t\t\tvalid_name[i] != 'W' && valid_name[i] != 'X' && valid_name\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpa828daeu.cpp:32:58: error: empty character constant\n  std::replace(valid_name.begin(),\
    \ valid_name.end(), '.', '');\n                                              \
    \            ^\n/tmp/tmpa828daeu.cpp:34:56: error: empty character constant\n\
    \  std::replace(valid_name.end(), valid_name.end(), '.', '');\n              \
    \                                          ^\n/tmp/tmpa828daeu.cpp: In function\
    \ 'std::string file_name_check(std::string)':\n/tmp/tmpa828daeu.cpp:33:74: error:\
    \ 'std::string' has no member named 'front'\n  std::replace(valid_name.begin(),\
    \ valid_name.begin(), tolower(valid_name.front()));\n                        \
    \                                                  ^\n/tmp/tmpa828daeu.cpp:48:49:\
    \ error: no match for 'operator&&' (operand types are 'bool' and 'std::string\
    \ {aka std::basic_string<char>}')\n    valid_name[i] != 'W' && valid_name[i] !=\
    \ 'X' && valid_name\n                                                 ^\n/tmp/tmpa828daeu.cpp:48:49:\
    \ note: candidates are:\n/tmp/tmpa828daeu.cpp:48:49: note: operator&&(bool, bool)\
    \ <built-in>\n/tmp/tmpa828daeu.cpp:48:49: note:   no known conversion for argument\
    \ 2 from 'std::string {aka std::basic_string<char>}' to 'bool'\nIn file included\
    \ from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n      \
    \           from /tmp/tmpa828daeu.cpp:2:\n/usr/include/c++/4.8.2/valarray:1177:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__logical_and, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__logical_and, _Tp>::result_type>\
    \ std::operator&&(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(&&,\
    \ __logical_and)\n ^\n/usr/include/c++/4.8.2/valarray:1177:1: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpa828daeu.cpp:48:52: note: \
    \  'std::string {aka std::basic_string<char>}' is not derived from 'const std::valarray<_Tp>'\n\
    \    valid_name[i] != 'W' && valid_name[i] != 'X' && valid_name\n            \
    \                                        ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string file_check;\n    bool found = false;\n    for (int i = 1;\
    \ i < file_name.size(); i++) {\n        char ch = file_name[i];\n        if ((ch\
    \ >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {\n            file_check\
    \ += ch;\n        } else if (ch == '.') {\n            found = true;\n       \
    \ }\n    }\n    if (found && file_check == \"exe\") {\n        file_check = \"\
    .exe\";\n    }\n    return file_check;\n}\nint main() {\n    auto candidate =\
    \ file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp258qoj4v.cpp: In function 'int main()':\n/tmp/tmp258qoj4v.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp258qoj4v.cpp:2:\n/tmp/tmp258qoj4v.cpp:33:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // your code here\n    return file_name;\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1km2vn6u.cpp: In function 'int main()':\n/tmp/tmp1km2vn6u.cpp:20:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1km2vn6u.cpp:2:\n/tmp/tmp1km2vn6u.cpp:21:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tassert(file_name.size() > 4);\n\tassert(file_name.find(\".\") == std::string::npos);\n\
    \tassert(file_name[0] == 'a' || file_name[0] == 'A');\n\tassert(file_name.find_first_not_of(\"\
    0123456789.\") == std::string::npos);\n\tassert(file_name.find_last_not_of(\"\
    0123456789.\") == std::string::npos);\n\tif (file_name.find(\".txt\") == std::string::npos)\
    \ {\n\t\treturn \"No\";\n\t} else if (file_name.find(\".exe\") == std::string::npos)\
    \ {\n\t\treturn \"No\";\n\t} else if (file_name.find(\".dll\") == std::string::npos)\
    \ {\n\t\treturn \"No\";\n\t} else {\n\t\treturn \"Yes\";\n\t}\n}\nint main() {\n\
    \    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpssoicxgt.cpp: In function 'int main()':\n/tmp/tmpssoicxgt.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpssoicxgt.cpp:2:\n/tmp/tmpssoicxgt.cpp:33:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Get the number of '.' in the file's name.\n  int dot_count = file_name.count(\"\
    .\");\n  // If the number of '.' is more than 3, return 'No'.\n  if (dot_count\
    \ > 3) {\n    return \"No\";\n  }\n  // Get the substring before the dot\n  std::string\
    \ before_dot = file_name.substr(0, dot_count);\n  // If there is no dot in the\
    \ substring, return 'No'.\n  if (dot_count == 0) {\n    return \"No\";\n  }\n\
    \  // Check if the substring starts with a latin alphapet letter\n  if (!isalpha(before_dot[0]))\
    \ {\n    return \"No\";\n  }\n  // Get the substring after the dot\n  std::string\
    \ after_dot = file_name.substr(dot_count);\n  // If there is no dot after the\
    \ dot, return 'No'.\n  if (after_dot == \"\") {\n    return \"No\";\n  }\n  //\
    \ Check if the substring after dot is one of these\n  if (after_dot == \"exe\"\
    \ || after_dot == \"dll\" || after_dot == \"txt\" || after_dot == \"JPEG\" ||\
    \ after_dot == \"JPG\" || after_dot == \"png\" || after_dot == \"svg\") {\n  \
    \  return \"Yes\";\n  }\n  // If all the above conditions fail, return 'No'.\n\
    \  return \"No\";\n}\nint main() {\n    auto candidate = file_name_check;\n  \
    \  assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpizksc6w1.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpizksc6w1.cpp:17:29: error: 'std::string' has no member named 'count'\n\
    \   int dot_count = file_name.count(\".\");\n                             ^\n\
    /tmp/tmpizksc6w1.cpp: In function 'int main()':\n/tmp/tmpizksc6w1.cpp:46:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = file_name_check;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpizksc6w1.cpp:2:\n/tmp/tmpizksc6w1.cpp:47:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  assert(file_name.size() < 5);\n  std::string temp = \".\" + file_name.substr(0,\
    \ 1);\n  assert(temp.size() > 0);\n  for (int i = 1; i < file_name.size(); i++)\
    \ {\n    assert(file_name[i] == '.');\n    assert(temp[temp.size() - 1] != '\\\
    0');\n    temp = temp + file_name[i]; \n    assert(temp.size() > 0);\n    assert(temp[0]\
    \ == 'a' || temp[0] == 'A');\n    assert(temp[temp.size() - 1] != '\\0');\n  }\n\
    \  if (temp.size() == 2 && temp[0] == 'a' && temp[1] == 'z') {\n    return std::string(\"\
    Yes\");\n  } else {\n    return std::string(\"No\");\n  }\n}\nint main() {\n \
    \   auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"))\
    \ == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n   \
    \ assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\"\
    )) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n\
    \    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp22bqpe6r.cpp: In function 'int main()':\n/tmp/tmp22bqpe6r.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp22bqpe6r.cpp:2:\n/tmp/tmp22bqpe6r.cpp:35:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code here\n    int count=0;\n    for(int i=0;i<file_name.size();i++)\n\
    \    {\n        if(file_name[i]>='0'&&file_name[i]<='9')\n        {\n        \
    \    count++;\n        }\n    }\n    if(count>3)\n    {\n        return \"No\"\
    ;\n    }\n    int count_s=0;\n    for(int i=0;i<file_name.size();i++)\n    {\n\
    \        if(file_name[i]>='a'&&file_name[i]<='z')\n        {\n            count_s++;\n\
    \        }\n        if(file_name[i]>='A'&&file_name[i]<='Z')\n        {\n    \
    \        count_s++;\n        }\n        if(file_name[i]=='.')\n        {\n   \
    \         count_s++;\n        }\n    }\n    if(count_s>1)\n    {\n        return\
    \ \"No\";\n    }\n    if(count_s==0&&file_name[0]!='.')\n    {\n        return\
    \ \"No\";\n    }\n    if(file_name[0]>='a'&&file_name[0]<='z')\n    {\n      \
    \  return \"No\";\n    }\n    if(file_name[0]>='A'&&file_name[0]<='Z')\n    {\n\
    \        return \"No\";\n    }\n    if(file_name[1]=='.'&&file_name[2]!='exe'&&file_name[2]!='dll')\n\
    \    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nint main() {\n\
    \    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwi14kufk.cpp:61:41: warning: multi-character character constant\
    \ [-Wmultichar]\n     if(file_name[1]=='.'&&file_name[2]!='exe'&&file_name[2]!='dll')\n\
    \                                         ^\n/tmp/tmpwi14kufk.cpp:61:62: warning:\
    \ multi-character character constant [-Wmultichar]\n     if(file_name[1]=='.'&&file_name[2]!='exe'&&file_name[2]!='dll')\n\
    \                                                              ^\n/tmp/tmpwi14kufk.cpp:\
    \ In function 'int main()':\n/tmp/tmpwi14kufk.cpp:68:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwi14kufk.cpp:2:\n/tmp/tmpwi14kufk.cpp:69:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code goes here\n    \n    if (file_name.size()==4 && file_name[0]=='0'\
    \ && file_name[1]=='0' && file_name[2]=='0' && file_name[3]=='9') {\n        if(file_name.size()==4&&file_name[2]=='\\\
    \\'){\n            file_name.erase(0,2);\n        }\n    }\n\n    int dotCount=0;\n\
    \    for (int i=0;i<file_name.size();i++) {\n        if(file_name[i]=='.'){\n\
    \            dotCount++;\n        }\n    }\n    \n    if(dotCount>1||dotCount==0){\n\
    \        return \"No\";\n    }\n    if (file_name[0] == '\\0' || file_name[0]\
    \ == '_' || file_name[0] == '-' || file_name[0] == '/') {\n        return \"No\"\
    ;\n    }\n    if (file_name.size() <6) {\n        return \"No\";\n    }\n    if\
    \ (file_name[0] == 'a' && file_name[1] == 'z' || file_name[0] == 'A' && file_name[1]\
    \ == 'Z') {\n        return \"No\";\n    }\n    if (file_name.size() > 3 && file_name[1]\
    \ == 't' && file_name[2] == 'x' && file_name[3] == 't' &&\n        file_name[4]\
    \ == 'x' && file_name[5] == 't') {\n        return \"No\";\n    }\n    \n    return\
    \ \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpiemsgub5.cpp: In function 'int main()':\n/tmp/tmpiemsgub5.cpp:51:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiemsgub5.cpp:2:\n/tmp/tmpiemsgub5.cpp:52:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    \n    std::vector<std::string> files;\n    files.push_back(\"example.txt\"\
    );\n    files.push_back(\"1example.dll\");\n    files.push_back(\"example.exe\"\
    );\n    files.push_back(\"example2.txt\");\n    files.push_back(\"example3.exe\"\
    );\n    files.push_back(\"example4.dll\");\n    files.push_back(\"example5.exe\"\
    );\n    files.push_back(\"example6.dll\");\n    files.push_back(\"example7.dll\"\
    );\n    files.push_back(\"example8.exe\");\n    files.push_back(\"example9.dll\"\
    );\n\n    std::vector<std::string> file_types;\n    file_types.push_back(\"txt\"\
    );\n    file_types.push_back(\"exe\");\n    file_types.push_back(\"dll\");\n\n\
    \    int i = 0;\n\n    std::string file_extension;\n    file_extension = file_name.substr(file_name.find_last_of('.'));\n\
    \    if (file_name.find_first_not_of(\".\") > 0)\n        file_name_check(files[i]);\n\
    \    else\n        return file_name;\n    \n    for (int i = 0; i < files.size();\
    \ i++) {\n        // Check each file's name with assertion.\n        ASSERT(file_types[i]\
    \ != \"exe\", \n            \"The file's name should not contain 'exe' as the\
    \ file type\");\n        ASSERT(!files[i].empty(), \"The file's name should not\
    \ be empty\");\n        ASSERT(!files[i].find_first_of('.').empty(), \n      \
    \      \"The file's name should contain exactly one dot '.'\");\n        ASSERT(files[i].find_first_not_of(\"\
    0123456789\") != std::string::npos, \n            \"The file's name should not\
    \ contain '0' -'9' in the file's name\");\n        ASSERT(file_types.find(files[i])\
    \ == file_types.end(),\n            \"The file's name should not contain 'exe'\
    \ as the file type\");\n    }\n\n    ASSERT(!file_extension.empty(), \n      \
    \  \"The file's name should not contain an empty string\");\n    ASSERT(file_extension\
    \ != \"exe\", \n        \"The file's name should not contain 'exe' as the file\
    \ type\");\n    return file_name;\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpryq2ctl8.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpryq2ctl8.cpp:47:72: error: 'ASSERT' was not declared in this scope\n \
    \            \"The file's name should not contain 'exe' as the file type\");\n\
    \                                                                        ^\n/tmp/tmpryq2ctl8.cpp:49:45:\
    \ error: request for member 'empty' in '(& files.std::vector<_Tp, _Alloc>::operator[]<std::basic_string<char>,\
    \ std::allocator<std::basic_string<char> > >(((std::vector<std::basic_string<char>\
    \ >::size_type)i)))->std::basic_string<_CharT, _Traits, _Alloc>::find_first_of<char,\
    \ std::char_traits<char>, std::allocator<char> >(46, 0ul)', which is of non-class\
    \ type 'std::basic_string<char>::size_type {aka long unsigned int}'\n        \
    \ ASSERT(!files[i].find_first_of('.').empty(), \n                            \
    \                 ^\n/tmp/tmpryq2ctl8.cpp:53:27: error: 'class std::vector<std::basic_string<char>\
    \ >' has no member named 'find'\n         ASSERT(file_types.find(files[i]) ==\
    \ file_types.end(),\n                           ^\n/tmp/tmpryq2ctl8.cpp:58:61:\
    \ error: 'ASSERT' was not declared in this scope\n         \"The file's name should\
    \ not contain an empty string\");\n                                          \
    \                   ^\n/tmp/tmpryq2ctl8.cpp: In function 'int main()':\n/tmp/tmpryq2ctl8.cpp:64:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpryq2ctl8.cpp:2:\n/tmp/tmpryq2ctl8.cpp:65:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code here\n    \n    for (int i = 0; i<file_name.length();i++)\
    \ {\n        if ((file_name[i]<'a') || (file_name[i]>'z') || (file_name[i]<'A')\
    \ || (file_name[i]>'Z')) {\n            return (\"No\");\n        }\n    }\n \
    \   if ((file_name.find(\".\") != std::string::npos) && (file_name.substr(0, 1).isalpha())\
    \ && (file_name.substr(0, 4) != \"example\") &&\n        (file_name.substr(0,\
    \ 3) != \"1example\") ) {\n        return (\"No\");\n    }\n    \n    return (\"\
    Yes\");\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpd6iu8qln.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpd6iu8qln.cpp:23:79: error: 'class std::basic_string<char>' has no member\
    \ named 'isalpha'\n     if ((file_name.find(\".\") != std::string::npos) && (file_name.substr(0,\
    \ 1).isalpha()) && (file_name.substr(0, 4) != \"example\") &&\n              \
    \                                                                 ^\n/tmp/tmpd6iu8qln.cpp:\
    \ In function 'int main()':\n/tmp/tmpd6iu8qln.cpp:31:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd6iu8qln.cpp:2:\n/tmp/tmpd6iu8qln.cpp:32:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tif (file_name.length() <= 3) {\n\t\treturn \"No\";\n\t}\n\tif (file_name.find('\
    \ ') != string::npos || file_name.find('.') == string::npos) {\n\t\treturn \"\
    No\";\n\t}\n\tif (file_name[0] >= 'a' && file_name[0] <= 'z' ||\n\t\tfile_name[0]\
    \ >= 'A' && file_name[0] <= 'Z') {\n\t\treturn \"Yes\";\n\t}\n\treturn \"No\"\
    ;\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0zmvr_6h.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp0zmvr_6h.cpp:19:29: error: 'string' has not been declared\n  if (file_name.find('\
    \ ') != string::npos || file_name.find('.') == string::npos) {\n             \
    \                ^\n/tmp/tmp0zmvr_6h.cpp:19:68: error: 'string' has not been declared\n\
    \  if (file_name.find(' ') != string::npos || file_name.find('.') == string::npos)\
    \ {\n                                                                    ^\n/tmp/tmp0zmvr_6h.cpp:\
    \ In function 'int main()':\n/tmp/tmp0zmvr_6h.cpp:29:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0zmvr_6h.cpp:2:\n/tmp/tmp0zmvr_6h.cpp:30:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::bitset<16> digits_bitset; \n    std::string filename_string;\n \
    \   std::string file_extension_string;\n    \n    // Loop through the file name\
    \ string and check if the file's name contains only \n    // digits and one dot\
    \ '.' \n    for(char &i : file_name) {\n        if(!((i == '0' || i == '1' ||\
    \ i == '2' || i == '3' || i == '4' || i == '5' || \n            i == '6' || i\
    \ == '7' || i == '8' || i == '9') && i == '.')) {\n            digits_bitset[i]\
    \ = '1';\n        } else {\n            digits_bitset[i] = '0';\n        }\n \
    \   }\n\n    // If the file name is valid, then add the '0' at the end of the\
    \ string\n    digits_bitset[file_name.size() -1] = '0';\n    filename_string =\
    \ std::bitset<16>(digits_bitset).to_string();\n\n    // Remove the dot from the\
    \ string and check if all the characters are allowed\n    // characters.\n   \
    \ if(file_name.find(\".\") == std::string::npos || file_name.substr(0,1) != \n\
    \        \"a\" || file_name.substr(0,2) != \"ab\" || file_name.substr(0,3) !=\
    \ \n        \"abc\" || file_name.substr(0,4) != \"abcd\" || file_name.substr(0,5)\
    \ != \n        \"abcde\" || file_name.substr(0,6) != \"abcdef\" || file_name.substr(0,7)\
    \ != \n        \"abcdefg\" || file_name.substr(0,8) != \"abcdefgh\" || file_name.substr(0,9)\
    \ != \n        \"abcdefghi\" || file_name.substr(0,10) != \"abcdefghij\" || file_name.substr(0,11)\
    \ != \n        \"abcdefghijk\" || file_name.substr(0,12) != \"abcdefghijkl\" ||\
    \ file_name.substr(0,13) != \n        \"abcdefghijklm\" || file_name.substr(0,14)\
    \ != \"abcdefghijklmno\" || file_name.substr(0,15) != \n        \"abcdefghijklmnop\"\
    \ || file_name.substr(0,16) != \"abcdefghijklmnopq\" || file_name.substr(0,17)\
    \ != \n        \"abcdefghijklmnopqrst\" || file_name.substr(0,18) != \"abcdefghijklmnopqrstu\"\
    \ || file_name.substr(0,19) != \n        \"abcdefghijklmnopqrstuv\" || file_name.substr(0,20)\
    \ != \"abcdefghijklmnopqrstuvw\" || file_name.substr(0,21) != \n        \"abcdefghijklmnopqrstuvwx\"\
    ) {\n        return \"No\";\n    }\n\n    // If all the conditions are met then\
    \ return the string.\n    return \"Yes\";\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb_0jzgd1.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpb_0jzgd1.cpp:22:19: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for(char &i : file_name) {\n                   ^\n/tmp/tmpb_0jzgd1.cpp:\
    \ In function 'int main()':\n/tmp/tmpb_0jzgd1.cpp:56:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb_0jzgd1.cpp:2:\n/tmp/tmpb_0jzgd1.cpp:57:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int index = 0;\n    while(index < file_name.size()) {\n        if(file_name[index]\
    \ >= '0' && file_name[index] <= '9') {\n            if((file_name[index] == '.')\
    \ && (index != 0)) {\n                if(file_name[index - 1] == '.') {\n    \
    \                if(file_name[index + 1] == '.') {\n                        if(file_name[index\
    \ + 2] == '.') {\n                            if(file_name[index + 3] == '\\0')\
    \ {\n                                return \"Yes\";\n                       \
    \     }\n                        }\n                    }\n                }\n\
    \            }\n        }\n        index++;\n    }\n    return \"No\";\n}\nint\
    \ main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdn4lcx14.cpp: In function 'int main()':\n/tmp/tmpdn4lcx14.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdn4lcx14.cpp:2:\n/tmp/tmpdn4lcx14.cpp:37:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Initialize the string that will hold the result.\n  std::string result;\n\
    \  // If there are more than three digits in the file_name, set result to \"No\"\
    .\n  if (file_name.size() > 3) {\n    result = \"No\";\n    // Return result \n\
    \    return result;\n  }\n  // Otherwise, if the substring before the dot is empty,\
    \ and it starts with a letter from \n  // the latin alphabet (a to z or A to Z),\
    \ set result to \"Yes\".\n  else if (file_name.substr(0, 1) == \"0\" && (file_name.substr(1,\
    \ 1) >= 'a' && file_name.substr(1, 1) <= 'z')) {\n    result = \"Yes\";\n    //\
    \ Return result\n    return result;\n  }\n  // Otherwise, if the substring after\
    \ the dot is one of these, set result to \"Yes\".\n  else if (file_name == \"\
    exe\" || file_name == \"dll\" || file_name == \"exe\") {\n    result = \"Yes\"\
    ;\n    // Return result\n    return result;\n  }\n  // Otherwise, set result to\
    \ \"No\".\n  else {\n    result = \"No\";\n    // Return result\n    return result;\n\
    \  }\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnipkpw1t.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpnipkpw1t.cpp:26:69: error: no match for 'operator>=' (operand types are\
    \ 'std::basic_string<char>' and 'char')\n   else if (file_name.substr(0, 1) ==\
    \ \"0\" && (file_name.substr(1, 1) >= 'a' && file_name.substr(1, 1) <= 'z')) {\n\
    \                                                                     ^\n/tmp/tmpnipkpw1t.cpp:26:69:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpnipkpw1t.cpp:2:\n/usr/include/c++/4.8.2/valarray:1184:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__greater_equal, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__greater_equal, _Tp>::result_type>\
    \ std::operator>=(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(>=,\
    \ __greater_equal)\n ^\n/usr/include/c++/4.8.2/valarray:1184:1: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpnipkpw1t.cpp:26:72: note: \
    \  mismatched types 'const std::valarray<_Tp>' and 'char'\n   else if (file_name.substr(0,\
    \ 1) == \"0\" && (file_name.substr(1, 1) >= 'a' && file_name.substr(1, 1) <= 'z'))\
    \ {\n                                                                        ^\n\
    In file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpnipkpw1t.cpp:2:\n/usr/include/c++/4.8.2/valarray:1184:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__greater_equal, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__greater_equal, _Tp>::result_type>\
    \ std::operator>=(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(>=,\
    \ __greater_equal)\n ^\n/usr/include/c++/4.8.2/valarray:1184:1: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpnipkpw1t.cpp:26:72: note: \
    \  'std::basic_string<char>' is not derived from 'const std::valarray<_Tp>'\n\
    \   else if (file_name.substr(0, 1) == \"0\" && (file_name.substr(1, 1) >= 'a'\
    \ && file_name.substr(1, 1) <= 'z')) {\n                    "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string dot_position;\n    int count = 0;\n    for (int i = 0; i\
    \ < file_name.size(); ++i) {\n        if (file_name[i] == '.') {\n           \
    \ dot_position = file_name.substr(0, i);\n            if (dot_position.size()\
    \ <= 3 || dot_position[0] < 'a' || dot_position[0] > 'z' \n                ||\
    \ dot_position[1] < 'a' || dot_position[1] > 'z' || dot_position[2] < 'a' || dot_position[2]\
    \ > 'z') {\n                std::cout << \"Error : File's name cannot have more\
    \ than three digits ('0'-'9') after dot.\" << std::endl;\n                return\
    \ \"No\";\n            }\n            ++count;\n        }\n    }\n    if (count\
    \ == 0) {\n        std::cout << \"Error : File's name must contains exactly one\
    \ dot ('.').\" << std::endl;\n        return \"No\";\n    }\n    \n    dot_position\
    \ = file_name.substr(0, dot_position.size() - 1);\n    for (char c : dot_position)\
    \ {\n        if ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z')) {\n           \
    \ std::cout << \"Error : File's name must start with latin alphapet letter ('a'-'z'\
    \ and 'A'-'Z').\" << std::endl;\n            return \"No\";\n        }\n    }\n\
    \    std::string extensions = \".txt .exe .dll\";\n    \n    for (int i = 0; i\
    \ < extensions.size(); ++i) {\n        if (dot_position == extensions[i]) {\n\
    \            return \"Yes\";\n        }\n    }\n    std::cout << \"Error : File's\
    \ name does not contain these extensions: \" << extensions << std::endl;\n   \
    \ return \"No\";\n}\nint main() {\n    auto candidate = file_name_check;\n   \
    \ assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphk8g6br6.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmphk8g6br6.cpp:35:19: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (char c : dot_position) {\n                   ^\n/tmp/tmphk8g6br6.cpp:44:26:\
    \ error: no match for 'operator==' (operand types are 'std::string {aka std::basic_string<char>}'\
    \ and 'char')\n         if (dot_position == extensions[i]) {\n               \
    \           ^\n/tmp/tmphk8g6br6.cpp:44:26: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n      \
    \           from /tmp/tmphk8g6br6.cpp:2:\n/usr/include/c++/4.8.2/valarray:1179:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__equal_to, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to, _Tp>::result_type>\
    \ std::operator==(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1179:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmphk8g6br6.cpp:44:41: note:   mismatched\
    \ types 'const std::valarray<_Tp>' and 'char'\n         if (dot_position == extensions[i])\
    \ {\n                                         ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmphk8g6br6.cpp:2:\n/usr/include/c++/4.8.2/valarray:1179:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__equal_to, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to, _Tp>::result_type>\
    \ std::operator==(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1179:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmphk8g6br6.cpp:44:41: note:   'std::string\
    \ {aka std::basic_string<char>}' is not derived from 'const std::valarray<_Tp>'\n\
    \         if (dot_position == extensions[i]) {\n                             \
    \            ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Your code goes here\n  std::string file_name = file_name.substr(0,4);\n\
    \  std::string file_extension = file_name.substr(file_name.find_last_of('.') +\
    \ 1);\n  if (file_name.size() > 4 && file_extension == \"exe\") {\n    return\
    \ \"Yes\";\n  } else if (file_name.size() > 4 && file_extension == \"dll\") {\n\
    \    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main() {\n \
    \   auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"))\
    \ == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n   \
    \ assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\"\
    )) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n\
    \    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7lzw4dl0.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp7lzw4dl0.cpp:17:15: error: declaration of 'std::string file_name' shadows\
    \ a parameter\n   std::string file_name = file_name.substr(0,4);\n           \
    \    ^\n/tmp/tmp7lzw4dl0.cpp: In function 'int main()':\n/tmp/tmp7lzw4dl0.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7lzw4dl0.cpp:2:\n/tmp/tmp7lzw4dl0.cpp:29:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code goes here\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_2phiaja.cpp: In function 'int main()':\n/tmp/tmp_2phiaja.cpp:19:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_2phiaja.cpp:2:\n/tmp/tmp_2phiaja.cpp:20:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    \n    // Write your function here.\n    int count = 0;\n    for (int\
    \ i = 0; i < file_name.length(); i++) {\n        if (file_name[i] > '9' || file_name[i]\
    \ < '0' || file_name[i] != '\\0' || file_name[i] != '\\0' || file_name[i] != '\\\
    0' || file_name[i] != '.' || file_name[i] != '\\0' && file_name[i] != '\\0' &&\
    \ file_name[i] != '\\0' && file_name[i] != '\\0' && file_name[i] != '\\0' && file_name[i]\
    \ != '\\0' && file_name[i] != '\\0' && file_name[i] != '\\0' && file_name[i] !=\
    \ '\\0' && file_name[i] != '\\0') {\n            count++;\n        }\n    }\n\
    \    if (count == 1 || file_name[0] == '.') {\n        return \"No\";\n    } else\
    \ {\n        return \"Yes\";\n    }\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplqyyrfwr.cpp: In function 'int main()':\n/tmp/tmplqyyrfwr.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplqyyrfwr.cpp:2:\n/tmp/tmplqyyrfwr.cpp:32:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Declare a bool type variable. \n    bool valid = true;\n    // Declare\
    \ a string type variable to store the file's name.\n    std::string file_name\
    \ = file_name;\n    // Declare a string type variable to store the file's extension.\n\
    \    std::string file_name = file_name;\n    // Declare a string type variable\
    \ to store the file's extension.\n    std::string file_name = file_name;\n   \
    \ // Declare an integer type variable to store the file's extension.\n    int\
    \ file_name = file_name;\n    // Declare an integer type variable to store the\
    \ file's extension.\n    int file_name = file_name;\n    // Declare a counter\
    \ type variable to count the number of digits in file's name.\n    int file_name\
    \ = file_name;\n    // Declare an integer type variable to count the number of\
    \ digits in file's name.\n    int file_name = file_name;\n    // Declare a bool\
    \ type variable to store the file's extension.\n    bool file_name = file_name;\n\
    \    // Declare a string type variable to store the file's extension.\n    std::string\
    \ file_name = file_name;\n    // Declare a char type variable to store the file's\
    \ extension.\n    char file_name = file_name;\n    // Declare a char type variable\
    \ to store the file's extension.\n    char file_name = file_name;\n    // Declare\
    \ a double type variable to store the file's extension.\n    double file_name\
    \ = file_name;\n    // Declare an integer type variable to count the number of\
    \ digits in file's name.\n    double file_name = file_name;\n    // Declare a\
    \ char type variable to store the file's extension.\n    char file_name = file_name;\n\
    \    // Declare a char type variable to store the file's extension.\n    char\
    \ file_name = file_name;\n    // Declare an integer type variable to count the\
    \ number of digits in file's name.\n    int file_name = file_name;\n    // Declare\
    \ a char type variable to store the file's extension.\n    char file_name = file_name;\n\
    \    // Declare a char type variable to store the file's extension.\n    char\
    \ file_name = file_name;\n    // Declare an integer type variable to count the\
    \ number of digits in file's name.\n    int file_name = file_name;\n    // Declare\
    \ a char type variable to store the file's extension.\n    char file_name = file_name;\n\
    \    // Declare a char type variable to store the file's extension.\n    char\
    \ file_name = file_name;\n    // Declare an integer type variable to count the\
    \ number of digits in file's name.\n    int file_name = file_name;\n    // Declare\
    \ a char type variable to store the file's extension.\n    char file_name = file_name;\n\
    \    // Declare a char type variable to store the file's extension.\n    char\
    \ file_name = file_name;\n    // \n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4erdazkr.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp4erdazkr.cpp:19:17: error: declaration of 'std::string file_name' shadows\
    \ a parameter\n     std::string file_name = file_name;\n                 ^\n/tmp/tmp4erdazkr.cpp:21:17:\
    \ error: redeclaration of 'std::string file_name'\n     std::string file_name\
    \ = file_name;\n                 ^\n/tmp/tmp4erdazkr.cpp:19:17: error: 'std::string\
    \ file_name' previously declared here\n     std::string file_name = file_name;\n\
    \                 ^\n/tmp/tmp4erdazkr.cpp:23:17: error: redeclaration of 'std::string\
    \ file_name'\n     std::string file_name = file_name;\n                 ^\n/tmp/tmp4erdazkr.cpp:19:17:\
    \ error: 'std::string file_name' previously declared here\n     std::string file_name\
    \ = file_name;\n                 ^\n/tmp/tmp4erdazkr.cpp:25:9: error: conflicting\
    \ declaration 'int file_name'\n     int file_name = file_name;\n         ^\n/tmp/tmp4erdazkr.cpp:19:17:\
    \ error: 'file_name' has a previous declaration as 'std::string file_name'\n \
    \    std::string file_name = file_name;\n                 ^\n/tmp/tmp4erdazkr.cpp:27:9:\
    \ error: conflicting declaration 'int file_name'\n     int file_name = file_name;\n\
    \         ^\n/tmp/tmp4erdazkr.cpp:19:17: error: 'file_name' has a previous declaration\
    \ as 'std::string file_name'\n     std::string file_name = file_name;\n      \
    \           ^\n/tmp/tmp4erdazkr.cpp:29:9: error: conflicting declaration 'int\
    \ file_name'\n     int file_name = file_name;\n         ^\n/tmp/tmp4erdazkr.cpp:19:17:\
    \ error: 'file_name' has a previous declaration as 'std::string file_name'\n \
    \    std::string file_name = file_name;\n                 ^\n/tmp/tmp4erdazkr.cpp:31:9:\
    \ error: conflicting declaration 'int file_name'\n     int file_name = file_name;\n\
    \         ^\n/tmp/tmp4erdazkr.cpp:19:17: error: 'file_name' has a previous declaration\
    \ as 'std::string file_name'\n     std::string file_name = file_name;\n      \
    \           ^\n/tmp/tmp4erdazkr.cpp:33:10: error: conflicting declaration 'bool\
    \ file_name'\n     bool file_name = file_name;\n          ^\n/tmp/tmp4erdazkr.cpp:19:17:\
    \ erro"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tassert(file_name != \"\\0\");\n\t\n\t// Get the substring before the dot\
    \ (\".\") from the file's name.\n\tauto begin = file_name.find_first_not_of(\"\
    \", 0);\n\tassert(begin != std::string::npos);\n\tauto end = file_name.find_first_of(\"\
    .\", 0);\n\tassert(end != std::string::npos);\n\t\n\t// If the substring before\
    \ the dot is empty, return a string containing \"No\".\n\tif (begin == 0 || end\
    \ == 0)\n\t\treturn \"No\";\n\t\n\t// If the substring after the dot is empty,\
    \ return a string containing \"Yes\".\n\tif (file_name.at(end) == '\\0')\n\t\t\
    return \"Yes\";\n\t\n\t// If the substring after the dot is not one of the valid\
    \ file types, \n\t// return \"No\".\n\tstd::string types = {\"txt\", \"exe\",\
    \ \"dll\"};\n\tif (std::find(types.begin(), types.end(), file_name.at(end)) !=\
    \ types.end())\n\t\treturn \"No\";\n\t\n\t// If the substring after the dot is\
    \ not empty, and it does not start with a \n\t// latin alphabet letter, return\
    \ \"No\".\n\tif (file_name.at(end) != '.')\n\t\treturn \"No\";\n\t\n\t// If the\
    \ substring after the dot is empty, and it starts with a latin alphabet \n\t//\
    \ letter, return \"Yes\".\n\tif (begin == 0)\n\t\treturn \"Yes\";\n\t\n\t// If\
    \ the file's name is valid. return \"Yes\".\n\treturn \"Yes\";\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3aiwb4ol.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp3aiwb4ol.cpp:19:7: error: 'begin' does not name a type\n  auto begin =\
    \ file_name.find_first_not_of(\"\", 0);\n       ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3aiwb4ol.cpp:2:\n/tmp/tmp3aiwb4ol.cpp:20:9: error:\
    \ 'begin' was not declared in this scope\n  assert(begin != std::string::npos);\n\
    \         ^\n/tmp/tmp3aiwb4ol.cpp:21:7: error: 'end' does not name a type\n  auto\
    \ end = file_name.find_first_of(\".\", 0);\n       ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3aiwb4ol.cpp:2:\n/tmp/tmp3aiwb4ol.cpp:22:9: error:\
    \ 'end' was not declared in this scope\n  assert(end != std::string::npos);\n\
    \         ^\n/tmp/tmp3aiwb4ol.cpp:34:42: error: in C++98 'types' must be initialized\
    \ by constructor, not by '{...}'\n  std::string types = {\"txt\", \"exe\", \"\
    dll\"};\n                                          ^\n/tmp/tmp3aiwb4ol.cpp:34:42:\
    \ error: invalid conversion from 'const char*' to 'std::basic_string<char>::size_type\
    \ {aka long unsigned int}' [-fpermissive]\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n\
    \                 from /usr/include/c++/4.8.2/bitset:47,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n             \
    \    from /tmp/tmp3aiwb4ol.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:183:5:\
    \ error:   initializing argument 2 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ std::basic_string<_CharT, _Traits, _Alloc>&, std::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, std::basic_string<_CharT, _Traits, _Alloc>::size_type) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]'\
    \ [-fpermissive]\n     basic_string<_CharT, _Traits, _Alloc>::"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int file_len = file_name.length();\n    if(file_len < 1 || file_len >\
    \ 3) \n        return \"No\";\n    int dot_count = file_name.count(\".\");\n \
    \   if(dot_count > 1) \n        return \"No\";\n    int start_index = 0;\n   \
    \ int end_index = 0;\n    for(int i = 0; i < file_len; ++i) {\n        if(file_name[i]\
    \ < 'a' || file_name[i] > 'z') \n            return \"No\";\n        if(file_name[i]\
    \ < 'A' || file_name[i] > 'Z') \n            return \"No\";\n        if(file_name[i]\
    \ == \".\") \n            end_index = i;\n        if(file_name[i] == file_name[start_index++])\
    \ \n            break;\n    }\n    if(start_index != end_index) \n        return\
    \ \"No\";\n    if(file_len == 1) \n        return \"Yes\";\n    if(file_name[0]\
    \ != file_name[file_len-1]) \n        return \"No\";\n    return \"Yes\";\n}\n\
    int main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7tap3cew.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp7tap3cew.cpp:19:31: error: 'std::string' has no member named 'count'\n\
    \     int dot_count = file_name.count(\".\");\n                              \
    \ ^\n/tmp/tmp7tap3cew.cpp:29:28: error: ISO C++ forbids comparison between pointer\
    \ and integer [-fpermissive]\n         if(file_name[i] == \".\") \n          \
    \                  ^\n/tmp/tmp7tap3cew.cpp: In function 'int main()':\n/tmp/tmp7tap3cew.cpp:43:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7tap3cew.cpp:2:\n/tmp/tmp7tap3cew.cpp:44:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int flag = 0;\n    if(file_name.length() <= 3){\n        flag = 1;\n\
    \    }\n    if (file_name.find(' ') != std::string::npos){\n        flag = 1;\n\
    \    }\n    if (file_name.find('.') == std::string::npos){\n        flag = 1;\n\
    \    }\n    if (file_name.substr(0, 1) == 'a' || file_name.substr(0, 1) == 'A'){\n\
    \        flag = 1;\n    }\n    if (file_name.substr(0, 2) == '0' || file_name.substr(0,\
    \ 2) == '1'){\n        flag = 1;\n    }\n    if (file_name.find(' ') != std::string::npos\
    \ || file_name.find('.') == std::string::npos || \n        file_name.substr(0,\
    \ 1) == 'a' || file_name.substr(0, 1) == 'A' || \n        file_name.substr(0,\
    \ 2) == '0' || file_name.substr(0, 2) == '1' || \n        file_name.find(' ')\
    \ != std::string::npos || file_name.find('.') == std::string::npos){\n       \
    \ flag = 1;\n    }\n    if(flag == 1){\n        return \"No\";\n    }\n    else{\n\
    \        return \"Yes\";\n    }\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3buhquef.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp3buhquef.cpp:26:32: error: no match for 'operator==' (operand types are\
    \ 'std::basic_string<char>' and 'char')\n     if (file_name.substr(0, 1) == 'a'\
    \ || file_name.substr(0, 1) == 'A'){\n                                ^\n/tmp/tmp3buhquef.cpp:26:32:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp3buhquef.cpp:2:\n/usr/include/c++/4.8.2/valarray:1179:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__equal_to, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to, _Tp>::result_type>\
    \ std::operator==(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1179:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp3buhquef.cpp:26:35: note:   mismatched\
    \ types 'const std::valarray<_Tp>' and 'char'\n     if (file_name.substr(0, 1)\
    \ == 'a' || file_name.substr(0, 1) == 'A'){\n                                \
    \   ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp3buhquef.cpp:2:\n/usr/include/c++/4.8.2/valarray:1179:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__equal_to, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to, _Tp>::result_type>\
    \ std::operator==(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1179:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp3buhquef.cpp:26:35: note:   'std::basic_string<char>'\
    \ is not derived from 'const std::valarray<_Tp>'\n     if (file_name.substr(0,\
    \ 1) == 'a' || file_name.substr(0, 1) == 'A'){\n                             \
    \      ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp3buhquef.cpp:2:\n/usr/include/c++/4.8.2/valarray:1179:1:\
    \ note: template<class _Tp> std::_E"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int no_dot_count = 0; // counter variable\n    for (char c: file_name)\
    \ {\n        if (c == '.') {\n            no_dot_count++;\n        }\n    }\n\
    \    if (no_dot_count <= 3) {\n        // Count number of digits in the file's\
    \ name\n        for (int i = 0; i < file_name.length(); i++) {\n            int\
    \ digit = file_name[i] - '0';\n            if (digit < '0' || digit > '9') {\n\
    \                break;\n            }\n        }\n        // If the number of\
    \ digits is less than or equal to three then \n        // file's name is valid\n\
    \        if (file_name.length() > 1 && file_name[0] == '.' && file_name[1] ==\
    \ '.') {\n            // Count the number of letters in the file's name before\
    \ the dot\n            int no_letters_before = 0;\n            for (int i = 0;\
    \ i < file_name.length(); i++) {\n                char c = file_name[i];\n   \
    \             if (c == '.') {\n                    break;\n                }\n\
    \                no_letters_before++;\n            }\n            // Count the\
    \ number of letters in the file's name after the dot\n            int no_letters_after\
    \ = 0;\n            for (int i = file_name.length() - 1; i >= 0; i--) {\n    \
    \            char c = file_name[i];\n                if (c == '.') {\n       \
    \             break;\n                }\n                no_letters_after++;\n\
    \            }\n            if (no_letters_before <= no_letters_after) {\n   \
    \             return \"Yes\";\n            } else {\n                return \"\
    No\";\n            }\n        } else {\n            // file's name is not valid\n\
    \            return \"No\";\n        }\n    } else {\n        return \"No\";\n\
    \    }\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpecyirn62.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpecyirn62.cpp:17:18: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (char c: file_name) {\n                  ^\n/tmp/tmpecyirn62.cpp:\
    \ In function 'int main()':\n/tmp/tmpecyirn62.cpp:65:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpecyirn62.cpp:2:\n/tmp/tmpecyirn62.cpp:66:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    unsigned int num_digits = 0;\n    // Get the size of the file name string\n\
    \    size_t size = file_name.size();\n    // Loop through each character of the\
    \ string\n    for (size_t i=0; i<size; i++) {\n        // If the current character\
    \ is not a digit, continue looping\n        if (file_name[i] < '0' || file_name[i]\
    \ > '9') {\n            continue;\n        }\n        // If the current character\
    \ is a digit, increase the count by 1\n        num_digits++;\n    }\n    // If\
    \ the number of digits in file's name is greater than 3, return 'No'\n    if (num_digits\
    \ > 3) {\n        return \"No\";\n    }\n    // If the number of digits in file's\
    \ name is equal to 3, but does not contain \n    // one dot ('.'), return 'No'\n\
    \    if (num_digits == 3 && !file_name.find(\".\") == std::string::npos) {\n \
    \       return \"No\";\n    }\n    // If the number of digits in file's name is\
    \ equal to 3, and contains one dot \n    // ('.'), return 'Yes'\n    if (num_digits\
    \ == 3 && file_name.find(\".\") == std::string::npos) {\n        return \"Yes\"\
    ;\n    }\n    // Otherwise return 'No'\n    return \"No\";\n}\nint main() {\n\
    \    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpucn0rqh6.cpp: In function 'int main()':\n/tmp/tmpucn0rqh6.cpp:46:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpucn0rqh6.cpp:2:\n/tmp/tmpucn0rqh6.cpp:47:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::set<char> symbols = {'.', '0', '1', '2', '3', '4', '5', '6', '7',\
    \ '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B',\
    \ 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F',\
    \ 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd',\
    \ 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F'};\n    for (int i = 0; i < file_name.length();\
    \ i++) {\n        if (symbols.find(file_name[i]) == std::string::npos) return\
    \ \"No\";\n        for (int j = i; j < file_name.length(); j++) {\n          \
    \  if (file_name[i] == file_name[j] && file_name[j] != '.') return \"No\";\n \
    \       }\n    }\n    return \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeb50jxyo.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpeb50jxyo.cpp:16:354: error: in C++98 'symbols' must be initialized by\
    \ constructor, not by '{...}'\n     std::set<char> symbols = {'.', '0', '1', '2',\
    \ '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c',\
    \ 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f', 'A',\
    \ 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E',\
    \ 'F', 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F'};\n        \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                          ^\n/tmp/tmpeb50jxyo.cpp:16:354: error:\
    \ could not convert '{'.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A',\
    \ 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E',\
    \ 'F', 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c',\
    \ 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f', 'A',\
    \ 'B', 'C', 'D', 'E', 'F'}' from '<brace-enclosed initializer list>' to 'std::set<char>'\n\
    /tmp/tmpeb50jxyo.cpp:18:40: error: no match for 'operator==' (operand types are\
    \ 'std::set<char>::iterator {aka std::_Rb_tree_const_iterator<char>}' and 'const\
    \ size_type {aka const long unsigned int}')\n         if (symbols.find(file_name[i])\
    \ == std::string::npos) return \"No\";\n                                     \
    \   ^\n/tmp/tmpeb50jxyo.cpp:18:40: note: candidates are:\nIn file included from\
    \ /usr/include/c++/4.8.2/map:60:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:80,\n\
    \                 from /tmp/tmpeb50jxyo.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_tree.h:298:7:\
    \ note: bool std::_Rb_tree_const_iterator<_Tp>::operator==(const _Self&) const\
    \ [with _Tp = char; std::_Rb_tree_c"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Initialize all required variables\n  int num_digits_found = 0;\n  int\
    \ num_dot_found = 0;\n  int num_letters_found = 0;\n  // Store all files' extensions\
    \ to store them into a string array\n  std::string exts[5] = {\"txt\", \"exe\"\
    , \"dll\", \"py\", \"pyc\", \"pyo\"};\n  // Iterate through the string\n  for\
    \ (char c : file_name) {\n    // If the char is not a digit, dot or a letter,\
    \ increment the variable 'num_letters_found'\n    if (!isdigit(c) && !isalpha(c)\
    \ && !isalnum(c)) {\n      num_letters_found++;\n    }\n    // If the char is\
    \ a digit, dot, or a letter, increment the variable 'num_letters_found'\n    if\
    \ (isdigit(c) || isalpha(c) || isalnum(c)) {\n      num_digits_found++;\n    }\n\
    \    // If the char is a dot, increment the variable 'num_dot_found'\n    if (isalpha(c))\
    \ {\n      num_dot_found++;\n    }\n  }\n  // If the string has three digits ('0'-'9'),\
    \ return 'Yes'\n  if (num_digits == 3 && num_dot_found > 0 && num_letters_found\
    \ > 0 && num_letters_found > num_dot_found) {\n    return \"Yes\";\n  }\n  //\
    \ If the string has more than three digits, return 'No'\n  else {\n    return\
    \ \"No\";\n  }\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpf4455g5t.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpf4455g5t.cpp:21:65: error: too many initializers for 'std::string [5]\
    \ {aka std::basic_string<char> [5]}'\n   std::string exts[5] = {\"txt\", \"exe\"\
    , \"dll\", \"py\", \"pyc\", \"pyo\"};\n                                      \
    \                           ^\n/tmp/tmpf4455g5t.cpp:23:17: error: range-based\
    \ 'for' loops are not allowed in C++98 mode\n   for (char c : file_name) {\n \
    \                ^\n/tmp/tmpf4455g5t.cpp:38:7: error: 'num_digits' was not declared\
    \ in this scope\n   if (num_digits == 3 && num_dot_found > 0 && num_letters_found\
    \ > 0 && num_letters_found > num_dot_found) {\n       ^\n/tmp/tmpf4455g5t.cpp:\
    \ In function 'int main()':\n/tmp/tmpf4455g5t.cpp:47:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpf4455g5t.cpp:2:\n/tmp/tmpf4455g5t.cpp:48:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int n = file_name.size();\n    if (n < 4) {\n        return \"No\";\n\
    \    }\n    if (n == 3) {\n        return \"Yes\";\n    }\n    if (file_name.at(0)\
    \ > '9' || file_name.at(0) < '0' || file_name.at(1) == '.' || file_name.at(2)\
    \ == '.' || file_name.at(3) != 'txt' && file_name.at(3) != 'exe' && file_name.at(3)\
    \ != 'dll') {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe9brpaxt.cpp:23:130: warning: multi-character character constant\
    \ [-Wmultichar]\n     if (file_name.at(0) > '9' || file_name.at(0) < '0' || file_name.at(1)\
    \ == '.' || file_name.at(2) == '.' || file_name.at(3) != 'txt' && file_name.at(3)\
    \ != 'exe' && file_name.at(3) != 'dll') {\n                                  \
    \                                                                            \
    \                    ^\n/tmp/tmpe9brpaxt.cpp:23:158: warning: multi-character\
    \ character constant [-Wmultichar]\n     if (file_name.at(0) > '9' || file_name.at(0)\
    \ < '0' || file_name.at(1) == '.' || file_name.at(2) == '.' || file_name.at(3)\
    \ != 'txt' && file_name.at(3) != 'exe' && file_name.at(3) != 'dll') {\n      \
    \                                                                            \
    \                                                                            ^\n\
    /tmp/tmpe9brpaxt.cpp:23:186: warning: multi-character character constant [-Wmultichar]\n\
    \     if (file_name.at(0) > '9' || file_name.at(0) < '0' || file_name.at(1) ==\
    \ '.' || file_name.at(2) == '.' || file_name.at(3) != 'txt' && file_name.at(3)\
    \ != 'exe' && file_name.at(3) != 'dll') {\n                                  \
    \                                                                            \
    \                                                                            ^\n\
    /tmp/tmpe9brpaxt.cpp: In function 'int main()':\n/tmp/tmpe9brpaxt.cpp:29:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = file_name_check;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe9brpaxt.cpp:2:\n/tmp/tmpe9brpaxt.cpp:30:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int dot_index = file_name.find_first_of(\".\");\n    if (dot_index !=\
    \ std::string::npos && dot_index > 0) {\n        if (file_name[dot_index - 1]\
    \ < 'a' || file_name[dot_index - 1] > 'z') {\n            return \"No\";\n   \
    \     }\n        if (file_name.find_first_not_of(\"0123456789.\") == dot_index\
    \ - 1) {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n\
    }\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1r30e_2l.cpp: In function 'int main()':\n/tmp/tmp1r30e_2l.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1r30e_2l.cpp:2:\n/tmp/tmp1r30e_2l.cpp:29:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  if(file_name.length() <= 3) return \"No\";\n  if(file_name.find(\".\")\
    \ < 0 || file_name.find(\".\") >= file_name.length()) return \"No\";\n  if(!std::isalpha(file_name[0])\
    \ || !std::isalpha(file_name[file_name.length()-1])) return \"No\";\n  if(file_name.find(\"\
    .\") == 0) return \"No\";\n  std::string file_end = file_name.substr(file_name.find(\"\
    .\") + 1);\n  if(file_end.find_first_not_of(\".\") == std::string::npos || file_end.find_first_not_of(\"\
    0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\") != std::string::npos)\n\
    \    return \"No\";\n  return \"Yes\";\n}\nint main() {\n    auto candidate =\
    \ file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkzshkr2x.cpp: In function 'int main()':\n/tmp/tmpkzshkr2x.cpp:26:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkzshkr2x.cpp:2:\n/tmp/tmpkzshkr2x.cpp:27:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int n = file_name.length();\n    if (n <= 3 || file_name.substr(0, 2)\
    \ == \"01\")\n        return \"No\";\n    if (file_name.substr(0, 1) != file_name[0])\n\
    \        return \"No\";\n    for (int i = 1; i < n - 1; i++)\n        if (file_name[i]\
    \ != '.' || file_name[i+1] < 'a' || file_name[i+1] > 'z')\n            return\
    \ \"No\";\n    if (file_name.substr(n-1, 1) != '.' || file_name[n - 2] < 'a' ||\
    \ file_name[n - 2] > 'z')\n        return \"No\";\n    return \"Yes\";\n}\nint\
    \ main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxha9477w.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpxha9477w.cpp:19:32: error: no match for 'operator!=' (operand types are\
    \ 'std::basic_string<char>' and 'char')\n     if (file_name.substr(0, 1) != file_name[0])\n\
    \                                ^\n/tmp/tmpxha9477w.cpp:19:32: note: candidates\
    \ are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpxha9477w.cpp:2:\n/usr/include/c++/4.8.2/valarray:1180:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__not_equal_to, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__not_equal_to, _Tp>::result_type>\
    \ std::operator!=(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(!=,\
    \ __not_equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1180:1: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpxha9477w.cpp:19:46: note: \
    \  mismatched types 'const std::valarray<_Tp>' and 'char'\n     if (file_name.substr(0,\
    \ 1) != file_name[0])\n                                              ^\nIn file\
    \ included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpxha9477w.cpp:2:\n/usr/include/c++/4.8.2/valarray:1180:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__not_equal_to, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__not_equal_to, _Tp>::result_type>\
    \ std::operator!=(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(!=,\
    \ __not_equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1180:1: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpxha9477w.cpp:19:46: note: \
    \  'std::basic_string<char>' is not derived from 'const std::valarray<_Tp>'\n\
    \     if (file_name.substr(0, 1) != file_name[0])\n                          \
    \                    ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpxha9477w.cpp:2:\n/usr/include/c++/4.8.2/valarray:1180:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__not_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string file_name = file_name;\n    int n = file_name.size();\n \
    \   if (file_name.size()<3 || file_name[0]>='9' || file_name[(n-1)]!='.' || (file_name.substr(0,1).findFirst(\n\
    \            std::bitset<26>('A'-'Z')) == std::string::npos) || (file_name.substr(0,1).findFirst(\n\
    \            std::bitset<26>('a' - 'z')) == std::string::npos))\n        return\
    \ \"No\";\n    for (int i=0;i<3;i++) {\n        std::swap(file_name[i],file_name[n-i]);\n\
    \    }\n    if (file_name.substr(0,1) == \".\")\n        return \"No\";\n    if\
    \ (file_name.substr(0,2) == \"..\" || ((file_name.substr(0,2) == \"..\") && (file_name.size()\
    \ == 3)))\n        return \"No\";\n    if (file_name.substr(0,1) == \"\\\\\")\n\
    \        return \"No\";\n    for (int i=0;i<5;i++) {\n        std::swap(file_name[i],file_name[n-i]);\n\
    \    }\n    for (int i=0;i<4;i++) {\n        if (file_name[i]>='A' && file_name[i]<='Z')\n\
    \            return \"No\";\n    }\n    for (int i=0;i<5;i++) {\n        if (file_name[i]>='a'\
    \ && file_name[i]<='z')\n            return \"No\";\n    }\n    if (file_name.find(\"\
    .txt\")==std::string::npos)\n        return \"No\";\n    for (int i=0;i<4;i++)\
    \ {\n        if (file_name[i]>='T' && file_name[i]<='Z')\n            return \"\
    No\";\n    }\n    for (int i=0;i<5;i++) {\n        if (file_name[i]>='t' && file_name[i]<='z')\n\
    \            return \"No\";\n    }\n    if (file_name.find(\".exe\")==std::string::npos)\n\
    \        return \"No\";\n    for (int i=0;i<4;i++) {\n        if (file_name[i]>='e'\
    \ && file_name[i]<='z')\n            return \"No\";\n    }\n    for (int i=0;i<5;i++)\
    \ {\n        if (file_name[i]>='e' && file_name[i]<='z')\n            return \"\
    No\";\n    }\n    if (file_name.find(\".dll\")==std::string::npos)\n        return\
    \ \"No\";\n    for (int i=0;i<4;i++) {\n        if (file_name[i]>='d' && file_name[i]<='z')\n\
    \            return \"No\";\n    }\n    for (int i=0;i<5;i++) {\n        if (file_name[i]>='d'\
    \ && file_name[i]<='z')\n            return \"No\";\n    }\n    return \"Yes\"\
    ;\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbm21hxwd.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpbm21hxwd.cpp:16:17: error: declaration of 'std::string file_name' shadows\
    \ a parameter\n     std::string file_name = file_name;\n                 ^\n/tmp/tmpbm21hxwd.cpp:18:100:\
    \ error: 'class std::basic_string<char>' has no member named 'findFirst'\n   \
    \  if (file_name.size()<3 || file_name[0]>='9' || file_name[(n-1)]!='.' || (file_name.substr(0,1).findFirst(\n\
    \                                                                            \
    \                        ^\n/tmp/tmpbm21hxwd.cpp:19:87: error: 'class std::basic_string<char>'\
    \ has no member named 'findFirst'\n             std::bitset<26>('A'-'Z')) == std::string::npos)\
    \ || (file_name.substr(0,1).findFirst(\n                                     \
    \                                                  ^\n/tmp/tmpbm21hxwd.cpp: In\
    \ function 'int main()':\n/tmp/tmpbm21hxwd.cpp:75:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbm21hxwd.cpp:2:\n/tmp/tmpbm21hxwd.cpp:76:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\t// Write your code here\n\t\n\treturn \"No\";\n}\nint main() {\n    auto\
    \ candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"\
    Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpw60uyoql.cpp: In function 'int main()':\n/tmp/tmpw60uyoql.cpp:21:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpw60uyoql.cpp:2:\n/tmp/tmpw60uyoql.cpp:22:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int count = 0; \n    char temp[100]; \n    int index = 0; \n    for (int\
    \ i = 0; file_name[i] != '\\0'; i++) {\n        temp = file_name[i]; \n      \
    \  if (file_name[i] >= 'a' && file_name[i] <= 'z') {\n            temp = temp\
    \ + 'A' - 'a'; \n        } else if (file_name[i] >= 'A' && file_name[i] <= 'Z')\
    \ {\n            temp = temp + 'a' - 'A'; \n        } else if (file_name[i] >=\
    \ '0' && file_name[i] <= '9') {\n            temp = temp + '0'-'9'; \n       \
    \ } \n        count++; \n    } \n    if (count > 2) {\n        return \"No\";\
    \ \n    } else if (count < 1) {\n        return \"Yes\"; \n    } else if (file_name[0]\
    \ == '.' && file_name[1] != '.') {\n        return \"No\"; \n    } else { \n \
    \       if (file_name[0] == '.') {\n            if (file_name[1] == '.' && (file_name[2]\
    \ != 'x' && file_name[2] != 'x')) {\n                return \"No\"; \n       \
    \     } else if (file_name[2] == 'x' && file_name[3] == '.') {\n             \
    \   return \"No\"; \n            } else if (file_name[2] == 'x' && file_name[3]\
    \ != '.') {\n                return \"No\"; \n            } else if (file_name[2]\
    \ == 'x') {\n                return \"Yes\"; \n            } else { \n       \
    \         return \"Yes\"; \n            } \n        } else { \n            return\
    \ \"Yes\"; \n        } \n    } \n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0wpb1_y7.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp0wpb1_y7.cpp:20:14: error: incompatible types in assignment of 'char'\
    \ to 'char [100]'\n         temp = file_name[i]; \n              ^\n/tmp/tmp0wpb1_y7.cpp:22:18:\
    \ error: incompatible types in assignment of 'char*' to 'char [100]'\n       \
    \      temp = temp + 'A' - 'a'; \n                  ^\n/tmp/tmp0wpb1_y7.cpp:24:18:\
    \ error: incompatible types in assignment of 'char*' to 'char [100]'\n       \
    \      temp = temp + 'a' - 'A'; \n                  ^\n/tmp/tmp0wpb1_y7.cpp:26:18:\
    \ error: incompatible types in assignment of 'char*' to 'char [100]'\n       \
    \      temp = temp + '0'-'9'; \n                  ^\n/tmp/tmp0wpb1_y7.cpp: In\
    \ function 'int main()':\n/tmp/tmp0wpb1_y7.cpp:55:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0wpb1_y7.cpp:2:\n/tmp/tmp0wpb1_y7.cpp:56:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int num_digits = 0;\n    for (char &digit : file_name) {\n        if\
    \ (digit < '0' || digit > '9') {\n            return std::string(\"No\");\n  \
    \      }\n        num_digits++;\n    }\n    if (num_digits != 3 || file_name.find_first_not_of(\"\
    .\") == std::string::npos) {\n        return std::string(\"No\");\n    }\n   \
    \ char first_char = file_name.at(0);\n    if (!(first_char >= 'a' && first_char\
    \ <= 'z') && !(first_char >= 'A' && first_char <= 'Z')) {\n        return std::string(\"\
    No\");\n    }\n    if (file_name.at(1) != '.') {\n        return std::string(\"\
    No\");\n    }\n    std::string extension = file_name.substr(3);\n    if (extension.size()\
    \ > 0) {\n        if (extension != \"txt\" && extension != \"exe\" && extension\
    \ != \"dll\") {\n            return std::string(\"No\");\n        }\n    }\n \
    \   return std::string(\"Yes\");\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpur1_i_7j.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpur1_i_7j.cpp:17:24: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (char &digit : file_name) {\n                        ^\n\
    /tmp/tmpur1_i_7j.cpp: In function 'int main()':\n/tmp/tmpur1_i_7j.cpp:42:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = file_name_check;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpur1_i_7j.cpp:2:\n/tmp/tmpur1_i_7j.cpp:43:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tassert(file_name.size() >= 3);\n\tauto dot_pos = file_name.find_first_of('.');\n\
    \tassert(dot_pos != std::string::npos);\n\tassert(file_name[0] >= 'a' && file_name[0]\
    \ <= 'z');\n\tassert(file_name[1] == file_name[0]);\n\tassert(file_name[2] >=\
    \ 'a' && file_name[2] <= 'z');\n\tassert(dot_pos + 1 < file_name.size());\n\t\n\
    \tif (dot_pos != std::string::npos)\n\t\tif (file_name[dot_pos + 1] >= 'a' &&\
    \ file_name[dot_pos + 1] <= 'z') \n\t\t\tif (file_name[dot_pos] >= 'a' && file_name[dot_pos]\
    \ <= 'z')\n\t\t\t\tif (file_name[dot_pos+1] >= 'a' && file_name[dot_pos+1] <=\
    \ 'z')\n\t\t\t\t\treturn \"Yes\";\n\telse \n\t\tif (file_name[0] >= 'a' && file_name[0]\
    \ <= 'z')\n\t\t\tif (file_name[1] >= 'a' && file_name[1] <= 'z')\n\t\t\t\tif (file_name[2]\
    \ >= 'a' && file_name[2] <= 'z')\n\t\t\t\t\treturn \"Yes\";\n\telse\n\t\treturn\
    \ \"No\";\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfyl6gymp.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpfyl6gymp.cpp:17:7: error: 'dot_pos' does not name a type\n  auto dot_pos\
    \ = file_name.find_first_of('.');\n       ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfyl6gymp.cpp:2:\n/tmp/tmpfyl6gymp.cpp:18:9: error:\
    \ 'dot_pos' was not declared in this scope\n  assert(dot_pos != std::string::npos);\n\
    \         ^\n/tmp/tmpfyl6gymp.cpp: In function 'int main()':\n/tmp/tmpfyl6gymp.cpp:38:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfyl6gymp.cpp:2:\n/tmp/tmpfyl6gymp.cpp:39:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Get the file's name.\n  std::string file_extension;\n  int dot = file_name.find_first_of(\"\
    .\");\n  if(dot != std::string::npos){\n    file_extension = file_name.substr(dot);\n\
    \    \n    // Check that we only have three digits.\n    std::string file_name\
    \ = file_name.substr(0, dot);\n    for(int i = 0; i < 10; i++){\n      if(file_name\
    \ != \"0\" + file_name && file_name != \"1\" + file_name && file_name != \"2\"\
    \ + file_name)\n        break;\n      else{\n        file_name = file_name + \"\
    0\";\n      }\n    }\n    \n    // Check that it starts with a letter from the\
    \ latin alphabet\n    std::string file_extension = file_name.substr(1, file_name.length()-1);\n\
    \    if(file_extension != \"txt\" && file_extension != \"exe\" && file_extension\
    \ != \"dll\")\n      return \"No\";\n  }\n\n  return \"Yes\";\n}\nint main() {\n\
    \    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptwdhpqbo.cpp: In function 'int main()':\n/tmp/tmptwdhpqbo.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptwdhpqbo.cpp:2:\n/tmp/tmptwdhpqbo.cpp:42:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string::size_type dot_pos = file_name.find_last_of(\".\");\n   \
    \ std::string file_extension = file_name.substr(dot_pos);\n    if (dot_pos ==\
    \ std::string::npos)\n        return 'No';\n    if (dot_pos == 0) {\n        if\
    \ (file_name[0] == 'a')\n            return 'No';\n        return 'Yes';\n   \
    \ }\n    if (file_name[0] == 'z' && file_name[1] == 'z')\n        return 'Yes';\n\
    \    return 'No';\n}\nint main() {\n    auto candidate = file_name_check;\n  \
    \  assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5_pvs3tn.cpp:19:16: warning: multi-character character constant\
    \ [-Wmultichar]\n         return 'No';\n                ^\n/tmp/tmp5_pvs3tn.cpp:22:20:\
    \ warning: multi-character character constant [-Wmultichar]\n             return\
    \ 'No';\n                    ^\n/tmp/tmp5_pvs3tn.cpp:23:16: warning: multi-character\
    \ character constant [-Wmultichar]\n         return 'Yes';\n                ^\n\
    /tmp/tmp5_pvs3tn.cpp:26:16: warning: multi-character character constant [-Wmultichar]\n\
    \         return 'Yes';\n                ^\n/tmp/tmp5_pvs3tn.cpp:27:12: warning:\
    \ multi-character character constant [-Wmultichar]\n     return 'No';\n      \
    \      ^\n/tmp/tmp5_pvs3tn.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp5_pvs3tn.cpp:19:16: error: invalid conversion from 'int' to 'const char*'\
    \ [-fpermissive]\n         return 'No';\n                ^\nIn file included from\
    \ /usr/include/c++/4.8.2/string:53:0,\n                 from /usr/include/c++/4.8.2/bitset:47,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5_pvs3tn.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmp5_pvs3tn.cpp:22:20: error: invalid conversion from\
    \ 'int' to 'const char*' [-fpermissive]\n             return 'No';\n         \
    \           ^\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n   \
    \              from /usr/include/c++/4.8.2/bitset:47,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5_pvs3tn.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\t// Your code here\n\tstd::string valid_extensions[3] = {\"txt\", \"exe\"\
    , \"dll\"};\n\tint count = 0;\n\tstd::cin >> file_name;\n\twhile (file_name.size()\
    \ <= 3) {\n\t\tstd::cout << \"Invalid file name!\" << std::endl;\n\t\tstd::cin\
    \ >> file_name;\n\t}\n\twhile (file_name.at(0) == '0' || file_name.at(0) == '1'\
    \ || file_name.at(0) == '2' ||\n\t\t\tfile_name.at(0) == '3' || file_name.at(0)\
    \ == '4' || file_name.at(0) == '5' ||\n\t\t\tfile_name.at(0) == '6' || file_name.at(0)\
    \ == '7' || file_name.at(0) == '8' ||\n\t\t\tfile_name.at(0) == '9' || file_name.at(0)\
    \ == 'A' || file_name.at(0) == 'B' ||\n\t\t\tfile_name.at(0) == 'C' || file_name.at(0)\
    \ == 'D' || file_name.at(0) == 'E' ||\n\t\t\tfile_name.at(0) == 'F' || file_name.at(0)\
    \ == 'G' || file_name.at(0) == 'H' ||\n\t\t\tfile_name.at(0) == 'I' || file_name.at(0)\
    \ == 'J' || file_name.at(0) == 'K' ||\n\t\t\tfile_name.at(0) == 'L' || file_name.at(0)\
    \ == 'M' || file_name.at(0) == 'N' ||\n\t\t\tfile_name.at(0) == 'O' || file_name.at(0)\
    \ == 'P' || file_name.at(0) == 'Q' ||\n\t\t\tfile_name.at(0) == 'R' || file_name.at(0)\
    \ == 'S' || file_name.at(0) == 'T' ||\n\t\t\tfile_name.at(0) == 'U' || file_name.at(0)\
    \ == 'V' || file_name.at(0) == 'W' ||\n\t\t\tfile_name.at(0) == 'X' || file_name.at(0)\
    \ == 'Y' || file_name.at(0) == 'Z') {\n\t\tstd::cout << \"Invalid file name!\"\
    \ << std::endl;\n\t\tstd::cin >> file_name;\n\t}\n\twhile (file_name.at(0) ==\
    \ '.') {\n\t\tstd::cout << \"Invalid file name!\" << std::endl;\n\t\tstd::cin\
    \ >> file_name;\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (file_name.size()\
    \ <= i) {\n\t\t\tstd::cout << \"Invalid file name!\" << std::endl;\n\t\t\tstd::cin\
    \ >> file_name;\n\t\t}\n\t\tif (file_name[i] >= 'a' && file_name[i] <= 'z') {\n\
    \t\t\tcount++;\n\t\t}\n\t\tif (file_name[i] >= 'A' && file_name[i] <= 'Z') {\n\
    \t\t\tcount++;\n\t\t}\n\t\tif (file_name[i] >= 'a' && file_name[i] <= 'z') {\n\
    \t\t\tcount++;\n\t\t}\n\t\tif (file_name[i] >= 'A' && file_name[i] <= 'Z') {\n\
    \t\t\tcount++;\n\t\t}\n\t\tif (\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4jdw1g_m.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp4jdw1g_m.cpp:61:1: error: expected primary-expression before '}' token\n\
    \ }\n ^\n/tmp/tmp4jdw1g_m.cpp:61:1: error: expected ')' before '}' token\n/tmp/tmp4jdw1g_m.cpp:61:1:\
    \ error: expected primary-expression before '}' token\n/tmp/tmp4jdw1g_m.cpp:61:1:\
    \ error: expected ';' before '}' token\n/tmp/tmp4jdw1g_m.cpp:62:12: error: a function-definition\
    \ is not allowed here before '{' token\n int main() {\n            ^\n/tmp/tmp4jdw1g_m.cpp:90:1:\
    \ error: expected '}' at end of input\n }\n ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string dot_position;\n    std::string file_name_without_dot;\n \
    \   int number_of_digits = file_name.length();\n    int number_of_letters = file_name.length()\
    \ - number_of_digits;\n    for (int i = 0; i < number_of_letters - 1; ++i) {\n\
    \        if (file_name[i] >= 'a' && file_name[i] <= 'z')\n            file_name_without_dot\
    \ = file_name_without_dot + file_name[i];\n        else if (file_name[i] >= 'A'\
    \ && file_name[i] <= 'Z')\n            file_name_without_dot = file_name_without_dot\
    \ + file_name[i];\n        else if (file_name[i] >= '0' && file_name[i] <= '9')\n\
    \            file_name_without_dot = file_name_without_dot + file_name[i];\n \
    \   }\n    for (int i = 0; i < number_of_letters; ++i) {\n        if (file_name[i]\
    \ != '.')\n            dot_position = file_name_without_dot + \".\" + file_name[i];\n\
    \    }\n    if (dot_position.length() > 3) {\n        std::cout << \"Too many\
    \ dots found. No valid file name found.\" << std::endl;\n        return \"No\"\
    ;\n    }\n    else if (dot_position.length() == 3) {\n        for (int i = 0;\
    \ i < dot_position.length() - 1; ++i) {\n            if (dot_position[i] >= 'a'\
    \ && dot_position[i] <= 'z')\n                file_name_without_dot = file_name_without_dot\
    \ + dot_position[i];\n            else if (dot_position[i] >= 'A' && dot_position[i]\
    \ <= 'Z')\n                file_name_without_dot = file_name_without_dot + dot_position[i];\n\
    \            else if (dot_position[i] >= '0' && dot_position[i] <= '9')\n    \
    \            file_name_without_dot = file_name_without_dot + dot_position[i];\n\
    \        }\n        if (file_name_without_dot.at(0) > 'a' || file_name_without_dot.at(0)\
    \ < 'z') {\n            std::cout << \"First character of the file name should\
    \ be a latin alpha letter. No valid file name found.\" << std::endl;\n       \
    \     return \"No\";\n        }\n        if (file_name_without_dot.at(1) > 'A'\
    \ || file_name_without_dot.at(1) < 'Z') {\n            std::cout << \"Second character\
    \ of the file name should be a latin alpha letter. No valid file name found.\"\
    \ << std::endl;\n            return \"No\";\n        }\n        else if (file_name_without_dot.at(2)\
    \ > 'a' || file_name_without_dot.at(2) < 'z') {\n            std::cout << \"Third\
    \ character of the file name should be a latin alpha letter. No valid file name\
    \ found.\" << std::endl;\n            return \"No\";\n        }\n        else\
    \ if (file_name_without_dot.at(3) > 'A' || file_name_without_dot.at(3) < 'Z')\
    \ {\n            std::cout << \"Fourth character of the file name should be a\
    \ latin alpha letter. No valid file name found.\" << std::endl;\n            return\
    \ \"No\";\n        }\n    }\n    else {\n        std::cout << \"No valid file\
    \ name \n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_agqjbbr.cpp:63:22: warning: missing terminating \" character [enabled\
    \ by default]\n         std::cout << \"No valid file name \n                 \
    \     ^\n/tmp/tmp_agqjbbr.cpp:63:9: error: missing terminating \" character\n\
    \         std::cout << \"No valid file name \n         ^\n/tmp/tmp_agqjbbr.cpp:\
    \ In function 'std::string file_name_check(std::string)':\n/tmp/tmp_agqjbbr.cpp:64:1:\
    \ error: expected primary-expression before '}' token\n }\n ^\n/tmp/tmp_agqjbbr.cpp:64:1:\
    \ error: expected ';' before '}' token\n/tmp/tmp_agqjbbr.cpp:65:12: error: a function-definition\
    \ is not allowed here before '{' token\n int main() {\n            ^\n/tmp/tmp_agqjbbr.cpp:93:1:\
    \ error: expected '}' at end of input\n }\n ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Write your code here\n    int num = file_name.find_first_not_of(\"\
    .\") + 1;\n    if(num >= file_name.size())\n        return \"No\";\n    if(num\
    \ == 0)\n        return \"Yes\";\n    int index = 0;\n    while(file_name[index]\
    \ >= 'a' && file_name[index] <= 'z' ||\n           file_name[index] >= 'A' &&\
    \ file_name[index] <= 'Z') {\n        ++index;\n    }\n    if(file_name[index]\
    \ >= '0' && file_name[index] <= '9') {\n        return \"No\";\n    }\n    return\
    \ \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjb2edraj.cpp: In function 'int main()':\n/tmp/tmpjb2edraj.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjb2edraj.cpp:2:\n/tmp/tmpjb2edraj.cpp:34:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tint file_length=file_name.length();\n\tassert(file_length<=3);\n\tassert(file_name[0]=='a'\
    \ || file_name[0]=='A' || (file_name[0]>='0' && file_name[0]<='9'));\n\tassert(file_name[file_length-1]=='.');\n\
    \tassert(file_name.find(\".\")!=std::string::npos);\n\tassert(file_name.substr(0,1)!='.'\
    \ || file_name.substr(0,1)[0]>='a' && file_name.substr(0,1)[0]<='z' || file_name.substr(0,1)[0]>='A'\
    \ && file_name.substr(0,1)[0]<='Z');\n\tassert(file_name.substr(file_length-1,1)=='exe'\
    \ || file_name.substr(file_length-1,1)=='dll' || file_name.substr(file_length-1,1)=='txt'\
    \ || file_name.substr(file_length-1,1)=='bmp' || file_name.substr(file_length-1,1)=='gif'\
    \ || file_name.substr(file_length-1,1)=='ico' || file_name.substr(file_length-1,1)=='jpg'\
    \ || file_name.substr(file_length-1,1)=='mov' || file_name.substr(file_length-1,1)=='mp4'\
    \ || file_name.substr(file_length-1,1)=='mpeg' || file_name.substr(file_length-1,1)=='mpg'\
    \ || file_name.substr(file_length-1,1)=='png' || file_name.substr(file_length-1,1)=='pdf'\
    \ || file_name.substr(file_length-1,1)=='ppt' || file_name.substr(file_length-1,1)=='rar'\
    \ || file_name.substr(file_length-1,1)=='tar' || file_name.substr(file_length-1,1)=='zip');\n\
    \treturn \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n  \
    \  assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzn8462_j.cpp:22:754: warning: multi-character character constant\
    \ [-Wmultichar]\n  assert(file_name.substr(file_length-1,1)=='exe' || file_name.substr(file_length-1,1)=='dll'\
    \ || file_name.substr(file_length-1,1)=='txt' || file_name.substr(file_length-1,1)=='bmp'\
    \ || file_name.substr(file_length-1,1)=='gif' || file_name.substr(file_length-1,1)=='ico'\
    \ || file_name.substr(file_length-1,1)=='jpg' || file_name.substr(file_length-1,1)=='mov'\
    \ || file_name.substr(file_length-1,1)=='mp4' || file_name.substr(file_length-1,1)=='mpeg'\
    \ || file_name.substr(file_length-1,1)=='mpg' || file_name.substr(file_length-1,1)=='png'\
    \ || file_name.substr(file_length-1,1)=='pdf' || file_name.substr(file_length-1,1)=='ppt'\
    \ || file_name.substr(file_length-1,1)=='rar' || file_name.substr(file_length-1,1)=='tar'\
    \ || file_name.substr(file_length-1,1)=='zip');\n                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                          ^\n/tmp/tmpzn8462_j.cpp:22:754: warning:\
    \ multi-character character constant [-Wmultichar]\n/tmp/tmpzn8462_j.cpp:22:754:\
    \ warning: multi-character character constant [-Wmultichar]\n/tmp/tmpzn8462_j.cpp:22:754:\
    \ warning: multi-character character constant [-Wmultichar]\n/tmp/tmpzn8462_j.cpp:22:754:\
    \ warning: multi-character character constant [-Wmultichar]\n/tmp/tmpzn8462_j.cpp:22:754:\
    \ warning: multi-character character constant [-Wmultichar]\n/tmp/tmpzn846"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int no_of_digits = 0;\n    int no_of_dots = 0;\n    int no_of_letters\
    \ = 0;\n    \n    for (int i = 0; i < file_name.length(); i++) {\n        char\
    \ c = file_name.at(i);\n        if (isdigit(c)) {\n            no_of_digits++;\n\
    \        }\n        else if (c == '.') {\n            no_of_dots++;\n        }\n\
    \        else if (isalpha(c)) {\n            no_of_letters++;\n        }\n   \
    \     else if (c == '.' & file_name.at(i-1) != '.') {\n            return std::string(\"\
    \"); // The file name should not contain a dot ('.') before the first letter\n\
    \        }\n        else if (isalpha(c) & file_name.at(i-1) != '.') {\n      \
    \      return std::string(\"\"); // The file name should not contain a dot ('.')\
    \ before the last letter\n        }\n    }\n    \n    if (no_of_digits == 0 &\
    \ no_of_dots == 0 & no_of_letters == 0) {\n        return std::string(\"Yes\"\
    ); // A valid file name\n    }\n    else if (no_of_digits > 3 & no_of_dots ==\
    \ 1 & no_of_letters != 3) {\n        return std::string(\"No\"); // A valid file\
    \ name\n    }\n    else {\n        return std::string(\"\");\n    }\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9s5bbwy4.cpp: In function 'int main()':\n/tmp/tmp9s5bbwy4.cpp:50:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9s5bbwy4.cpp:2:\n/tmp/tmp9s5bbwy4.cpp:51:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\t// Complete the implementation below.\n\tint check = 0;\n\t\n\treturn check;\n\
    }\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbfu6txla.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpbfu6txla.cpp:19:9: error: invalid conversion from 'int' to 'const char*'\
    \ [-fpermissive]\n  return check;\n         ^\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n\
    \                 from /usr/include/c++/4.8.2/bitset:47,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n             \
    \    from /tmp/tmpbfu6txla.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmpbfu6txla.cpp: In function 'int main()':\n/tmp/tmpbfu6txla.cpp:22:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbfu6txla.cpp:2:\n/tmp/tmpbfu6txla.cpp:23:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Declare variables to be used in a Boolean expression\n    bool is_valid\
    \ = false;\n    int number_of_digits = 0;\n    int number_of_dots = 0;\n    bool\
    \ is_first_letter_valid = false;\n    bool is_last_letter_valid = false;\n   \
    \ bool is_dot_valid = false;\n\n    // Declare a variable for storing the file's\
    \ name\n    std::string file_name_test;\n    file_name_test = file_name;\n\n \
    \   // Declare a variable for storing the dot '.'\n    char dot_test;\n    dot_test\
    \ = '.';\n\n    // Declare a variable for storing the substring before the dot\
    \ '.'\n    std::string substring_before_dot;\n    substring_before_dot = '';\n\
    \n    // Declare a variable for storing the substring after the dot '.'\n    std::string\
    \ substring_after_dot;\n    substring_after_dot = 'txt';\n\n    // Declare a variable\
    \ for storing the first letter of substring_after_dot\n    char substring_after_dot_first_letter;\n\
    \n    // Declare a variable for storing the last letter of substring_after_dot\n\
    \    char substring_after_dot_last_letter;\n\n    // Declare a variable for storing\
    \ the number of digits in substring_after_dot\n    int substring_after_dot_number_of_digits;\n\
    \n    // Declare a variable for storing the number of digits before 'example.txt'\n\
    \    int number_of_digits_before_example_txt;\n\n    // Declare a variable for\
    \ storing the number of digits before '1'\n    int number_of_digits_before_1;\n\
    \n    // Declare a variable for storing the number of digits before 'example'\n\
    \    int number_of_digits_before_example;\n\n    // Declare a variable for storing\
    \ the number of digits before 'example.txt'\n    int number_of_digits_before_example_txt;\n\
    \n    // Declare a variable for storing the number of digits before '1'\n    int\
    \ number_of_digits_before_1;\n\n    // Declare a variable for storing the number\
    \ of digits before 'example'\n    int number_of_digits_before_example;\n\n   \
    \ // Declare a variable for storing the number of digits before 'example.txt'\n\
    \    int number_of_digits_before_example_txt;\n\n    // Declare a variable for\
    \ storing the number of digits before '1'\n    int number_of_digits_before_1;\n\
    \n    // Declare a variable for storing the number of digits before 'example'\n\
    \    int number_of_digits_before_example;\n\n    // Declare a variable for storing\
    \ the number of digits before 'example.txt'\n    int number_of_digits_before_example_txt;\n\
    \n    // Declare a variable for storing the number of digits before '1'\n    int\
    \ number_of_digits_before_1;\n\n    // Declare a variable for storing the number\
    \ of digits before 'example'\n    int number_of_digits_before_example;\n\n\n}\n\
    int main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm2pjgbi8.cpp:34:28: error: empty character constant\n     substring_before_dot\
    \ = '';\n                            ^\n/tmp/tmpm2pjgbi8.cpp:38:27: warning: multi-character\
    \ character constant [-Wmultichar]\n     substring_after_dot = 'txt';\n      \
    \                     ^\n/tmp/tmpm2pjgbi8.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpm2pjgbi8.cpp:38:25: warning: overflow in implicit constant conversion\
    \ [-Woverflow]\n     substring_after_dot = 'txt';\n                         ^\n\
    /tmp/tmpm2pjgbi8.cpp:59:9: error: redeclaration of 'int number_of_digits_before_example_txt'\n\
    \     int number_of_digits_before_example_txt;\n         ^\n/tmp/tmpm2pjgbi8.cpp:50:9:\
    \ error: 'int number_of_digits_before_example_txt' previously declared here\n\
    \     int number_of_digits_before_example_txt;\n         ^\n/tmp/tmpm2pjgbi8.cpp:62:9:\
    \ error: redeclaration of 'int number_of_digits_before_1'\n     int number_of_digits_before_1;\n\
    \         ^\n/tmp/tmpm2pjgbi8.cpp:53:9: error: 'int number_of_digits_before_1'\
    \ previously declared here\n     int number_of_digits_before_1;\n         ^\n\
    /tmp/tmpm2pjgbi8.cpp:65:9: error: redeclaration of 'int number_of_digits_before_example'\n\
    \     int number_of_digits_before_example;\n         ^\n/tmp/tmpm2pjgbi8.cpp:56:9:\
    \ error: 'int number_of_digits_before_example' previously declared here\n    \
    \ int number_of_digits_before_example;\n         ^\n/tmp/tmpm2pjgbi8.cpp:68:9:\
    \ error: redeclaration of 'int number_of_digits_before_example_txt'\n     int\
    \ number_of_digits_before_example_txt;\n         ^\n/tmp/tmpm2pjgbi8.cpp:50:9:\
    \ error: 'int number_of_digits_before_example_txt' previously declared here\n\
    \     int number_of_digits_before_example_txt;\n         ^\n/tmp/tmpm2pjgbi8.cpp:71:9:\
    \ error: redeclaration of 'int number_of_digits_before_1'\n     int number_of_digits_before_1;\n\
    \         ^\n/tmp/tmpm2pjgbi8.cpp:53:9: error: 'int number_of_digits_before_1'\
    \ previously declared here\n     int number_of_digits_before_1;\n         ^\n\
    /tmp/tmpm2pjgbi8.cpp:74:9: error: redeclaration of 'int number_of_digits_before_example'\n\
    \     int numbe"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int counter = 0;\n    for (auto &c : file_name) {\n        ++counter;\n\
    \    }\n    if (counter > 3 || (counter < 3 && file_name.find_first_not_of(\"\
    .\") == file_name.size() - 1))\n        return \"No\";\n    else {\n        std::cout\
    \ << file_name << \" \" << std::endl; // printing only when there is a valid name\n\
    \        std::cin >> file_name;\n        if ((file_name.find_first_not_of(\".\"\
    ) == file_name.size() - 1) && (file_name[0] != ' '))\n            return \"No\"\
    ;\n        else if (file_name.find_first_not_of(\".\") == file_name.size() - 1)\n\
    \            return \"Yes\";\n        else\n            return \"Yes\";\n    }\n\
    }\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpapijiy2e.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpapijiy2e.cpp:17:16: error: ISO C++ forbids declaration of 'c' with no\
    \ type [-fpermissive]\n     for (auto &c : file_name) {\n                ^\n/tmp/tmpapijiy2e.cpp:17:20:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n     for (auto\
    \ &c : file_name) {\n                    ^\n/tmp/tmpapijiy2e.cpp: In function\
    \ 'int main()':\n/tmp/tmpapijiy2e.cpp:34:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = file_name_check;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpapijiy2e.cpp:2:\n/tmp/tmpapijiy2e.cpp:35:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string valid_chars = \"0123456789\";\n    // Check if number of\
    \ digits are more than 3\n    if (file_name.size() > 3) return \"No\";\n    //\
    \ Check if the string contains exactly one dot\n    if (file_name.find(\".\")\
    \ == file_name.npos) return \"No\";\n    // Check if the substring before the\
    \ dot is not empty\n    if (file_name.substr(0, 1) != \"\") return \"No\";\n \
    \   // Check if the substring after the dot is not in the list ['txt', 'exe',\
    \ 'dll']\n    std::vector<std::string> extensions = {\"txt\", \"exe\", \"dll\"\
    };\n    if (std::find(extensions.begin(), extensions.end(), file_name.substr(file_name.find_last_of(\"\
    .\"))) == extensions.end()) return \"No\";\n    return \"Yes\";\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptmo356if.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmptmo356if.cpp:24:63: error: in C++98 'extensions' must be initialized by\
    \ constructor, not by '{...}'\n     std::vector<std::string> extensions = {\"\
    txt\", \"exe\", \"dll\"};\n                                                  \
    \             ^\n/tmp/tmptmo356if.cpp:24:63: error: could not convert '{\"txt\"\
    , \"exe\", \"dll\"}' from '<brace-enclosed initializer list>' to 'std::vector<std::basic_string<char>\
    \ >'\n/tmp/tmptmo356if.cpp: In function 'int main()':\n/tmp/tmptmo356if.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptmo356if.cpp:2:\n/tmp/tmptmo356if.cpp:30:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Create a set which will contain all the valid files' names.\n  std::set<std::string>\
    \ files;\n  int index = 0;\n  // Traverse the string's characters, and check if\
    \ it starts with a latin \n  // alphapet letter. \n  while (index < file_name.length())\
    \ {\n    char c = file_name[index];\n    if (c >= 'a' && c <= 'z' || c >= 'A'\
    \ && c <= 'Z') {\n      files.insert(file_name.substr(0, index));\n    }\n   \
    \ index++;\n  }\n  // If there are more than 3 files, return 'No'.\n  if (files.size()\
    \ >= 3) {\n    return \"No\";\n  }\n  // Else, return 'Yes'.\n  return \"Yes\"\
    ;\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplp4txnbi.cpp: In function 'int main()':\n/tmp/tmplp4txnbi.cpp:36:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplp4txnbi.cpp:2:\n/tmp/tmplp4txnbi.cpp:37:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    if(file_name.length() < 3)\n        return \"No\";\n    if(file_name.find_first_not_of(\"\
    0123456789.\") != std::string::npos)\n        return \"No\";\n    else if(file_name.find(\"\
    .\") == std::string::npos)\n        return \"No\";\n    else if((file_name[0]\
    \ < 'a' || file_name[0] > 'z') && file_name[0] != 'A' && file_name[0] != 'Z')\n\
    \        return \"No\";\n    else if(file_name[file_name.size() - 1] == '.')\n\
    \        return \"No\";\n    else\n        return \"Yes\";\n}\nint main() {\n\
    \    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptev0hne1.cpp: In function 'int main()':\n/tmp/tmptev0hne1.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptev0hne1.cpp:2:\n/tmp/tmptev0hne1.cpp:31:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Write your code here\n    \n    \n    return file_name;\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb50_o0y2.cpp: In function 'int main()':\n/tmp/tmpb50_o0y2.cpp:22:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb50_o0y2.cpp:2:\n/tmp/tmpb50_o0y2.cpp:23:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Write code here\n  \n  int dot_index = file_name.find('.')\n  if(dot_index\
    \ == std::string::npos){\n      return \"No\";\n  }\n  else if (dot_index >= 10)\
    \ {\n      return \"No\";\n  }\n  else {\n      char firstChar = file_name[0];\n\
    \      bool isLetter = std::isalpha(firstChar);\n      if(isLetter){\n       \
    \   return \"No\";\n      }\n      else {\n          int spaceIndex = file_name.find_first_not_of('\
    \ ');\n          if (spaceIndex == std::string::npos) {\n              return\
    \ \"No\";\n          }\n          else {\n              char lastChar = file_name[spaceIndex];\n\
    \              if (std::isalpha(lastChar) || std::isdigit(lastChar)) {\n     \
    \             return \"No\";\n              }\n              else {\n        \
    \          return \"Yes\";\n              }\n          }\n      }\n  }\n}\nint\
    \ main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppgp3b08b.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmppgp3b08b.cpp:19:3: error: expected ',' or ';' before 'if'\n   if(dot_index\
    \ == std::string::npos){\n   ^\n/tmp/tmppgp3b08b.cpp:22:3: error: 'else' without\
    \ a previous 'if'\n   else if (dot_index >= 10) {\n   ^\n/tmp/tmppgp3b08b.cpp:\
    \ In function 'int main()':\n/tmp/tmppgp3b08b.cpp:49:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppgp3b08b.cpp:2:\n/tmp/tmppgp3b08b.cpp:50:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    if (file_name.size() <= 3 || file_name.find_first_of('.') <= 0 || file_name.substr(0,\
    \ 1) == '_' \n        || file_name.find_first_of('.') > file_name.size() - 1 ||\
    \ file_name.substr(file_name.size() - 1, 4) != \".txt\"\n        || file_name.find_first_of('.')\
    \ > file_name.size() - 1 || file_name.substr(file_name.size() - 4, 4) != \".dll\"\
    \n        || file_name.find_first_of('.') > file_name.size() - 1 || file_name.substr(file_name.size()\
    \ - 4, 4) != \".exe\") {\n        cout << \"\\nError: The file's name should contain\
    \ only 1 dot (.), starts with a latin alphapet letter, and ends with one of these\
    \ extensions: txt, exe, dll \\n\";\n        return \"No\";\n    } else {\n   \
    \     return \"Yes\";\n    }\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4dz0jom_.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp4dz0jom_.cpp:16:94: error: no match for 'operator==' (operand types are\
    \ 'std::basic_string<char>' and 'char')\n     if (file_name.size() <= 3 || file_name.find_first_of('.')\
    \ <= 0 || file_name.substr(0, 1) == '_' \n                                   \
    \                                                           ^\n/tmp/tmp4dz0jom_.cpp:16:94:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp4dz0jom_.cpp:2:\n/usr/include/c++/4.8.2/valarray:1179:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__equal_to, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to, _Tp>::result_type>\
    \ std::operator==(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1179:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp4dz0jom_.cpp:16:97: note:   mismatched\
    \ types 'const std::valarray<_Tp>' and 'char'\n     if (file_name.size() <= 3\
    \ || file_name.find_first_of('.') <= 0 || file_name.substr(0, 1) == '_' \n   \
    \                                                                            \
    \                  ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp4dz0jom_.cpp:2:\n/usr/include/c++/4.8.2/valarray:1179:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__equal_to, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to, _Tp>::result_type>\
    \ std::operator==(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1179:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp4dz0jom_.cpp:16:97: note:   'std::basic_string<char>'\
    \ is not derived from 'const std::valarray<_Tp>'\n     if (file_name.size() <=\
    \ 3 || file_name.find_first_of('.') <= 0 || file_name.substr(0, 1) == '_' \n \
    \                                "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // All checks are performed on strings which are stored in lower case\
    \ (all file names are in lower case)\n    // As a result, all character checks\
    \ will be done in lower case (which makes sense since the input\n    // is always\
    \ going to be in lower case).\n    int index = 0;\n    while(file_name[index]\
    \ != '\\0') {\n        if(file_name[index] == '.') {\n            index = index\
    \ + 1; // skip over the '.' character\n            while(file_name[index] != '\\\
    0') {\n                if(file_name[index] == '\\0') {\n                    return\
    \ \"No\";\n                }\n                if(file_name[index] < 'a' || file_name[index]\
    \ > 'z') {\n                    return \"No\";\n                }\n          \
    \      index = index + 1; // skip over all alphanumeric characters until we reach\
    \ the end of the string\n            }\n        } else {\n            if(file_name[index]\
    \ != '0') {\n                if(file_name[index] < 'a' || file_name[index] > 'z')\
    \ {\n                    return \"No\";\n                }\n                index\
    \ = index + 1; // skip over all alphanumeric characters until we reach the end\
    \ of the string\n            }\n        }\n    }\n    if(file_name[index] != '\\\
    0') {\n        return \"No\";\n    }\n    if(file_name[index] != '\\0') {\n  \
    \      if(file_name[index] != '\\0') {\n            if(file_name[index] < 'a'\
    \ || file_name[index] > 'z') {\n                return \"No\";\n            }\n\
    \            index = index + 1; // skip over all alphanumeric characters until\
    \ we reach the end of the string\n        }\n    }\n    if(file_name[index] !=\
    \ '\\0') {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplkuswtbb.cpp: In function 'int main()':\n/tmp/tmplkuswtbb.cpp:58:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplkuswtbb.cpp:2:\n/tmp/tmplkuswtbb.cpp:59:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int num_digits = 0;\n    int dot_count = 0;\n    for (int i = 0; i <\
    \ file_name.length(); i++) {\n        char c = file_name[i];\n        if (c ==\
    \ '.') {\n            dot_count++;\n            continue;\n        }\n       \
    \ if (c == '0' || c == '9') {\n            num_digits++;\n        }\n        if\
    \ ((num_digits == 0 && dot_count == 0) || (num_digits > 0 && dot_count > 1)) {\n\
    \            return file_name;\n        }\n    }\n    return 'No';\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpltq2fbp4.cpp:31:12: warning: multi-character character constant\
    \ [-Wmultichar]\n     return 'No';\n            ^\n/tmp/tmpltq2fbp4.cpp: In function\
    \ 'std::string file_name_check(std::string)':\n/tmp/tmpltq2fbp4.cpp:31:12: error:\
    \ invalid conversion from 'int' to 'const char*' [-fpermissive]\nIn file included\
    \ from /usr/include/c++/4.8.2/string:53:0,\n                 from /usr/include/c++/4.8.2/bitset:47,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpltq2fbp4.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmpltq2fbp4.cpp: In function 'int main()':\n/tmp/tmpltq2fbp4.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpltq2fbp4.cpp:2:\n/tmp/tmpltq2fbp4.cpp:35:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Initialize two boolean variables.\n    bool is_valid = true;\n   \
    \ bool is_valid_exename = false;\n    \n    // Make sure the length of file_name\
    \ is less than or equal to 3.\n    if (file_name.size() <= 3) {\n        is_valid\
    \ = false;\n    }\n    \n    // Make sure the file's name contains only one '.'.\n\
    \    if (file_name.find(\".\") == std::string::npos) {\n        is_valid = false;\n\
    \    }\n    \n    // Make sure that the substring before the dot is empty.\n \
    \   if (file_name.substr(0, 1) == \".\") {\n        is_valid = false;\n    }\n\
    \    \n    // Make sure that the substring after the dot is not empty.\n    if\
    \ (file_name.substr((file_name.find(\".\") + 1), 1) != \".txt\") {\n        is_valid\
    \ = false;\n    }\n    \n    // Check for valid exename characters.\n    for (int\
    \ i = 97; i <= 122; i++) {\n        if (file_name[i] >= 'a' && file_name[i] <=\
    \ 'z') {\n            is_valid_exename = true;\n        }\n        else if (file_name[i]\
    \ >= 'A' && file_name[i] <= 'Z') {\n            is_valid_exename = true;\n   \
    \     }\n        else if (file_name[i] == ' ') {\n            is_valid = false;\n\
    \        }\n        else {\n            is_valid = false;\n        }\n    }\n\
    \    \n    // If all of the conditions in the above conditions are met, then the\
    \ \n    // file's name is valid. \n    if (is_valid && is_valid_exename) {\n \
    \       return \"Yes\";\n    }\n    else {\n        return \"No\";\n    }\n}\n\
    int main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyy0css70.cpp: In function 'int main()':\n/tmp/tmpyy0css70.cpp:66:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyy0css70.cpp:2:\n/tmp/tmpyy0css70.cpp:67:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::cin >> file_name;\n    // your code here\n    if (file_name.size()\
    \ > 3) {\n        return \"No\";\n    }\n    if (file_name.find(\".\") == std::string::npos)\
    \ {\n        return \"No\";\n    }\n    if (file_name[0] != 'a' || file_name[0]\
    \ != 'A' || file_name[0] != 'z' || file_name[0] != 'Z') {\n        return \"No\"\
    ;\n    }\n    std::string first_char = file_name.substr(0, 1);\n    if (first_char\
    \ != \"txt\" && first_char != \"exe\" && first_char != \"dll\") {\n        return\
    \ \"No\";\n    }\n    return \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0569dmej.cpp: In function 'int main()':\n/tmp/tmp0569dmej.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0569dmej.cpp:2:\n/tmp/tmp0569dmej.cpp:35:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Your code here\n  assert(file_name.size() <= 4);\n  if (file_name.find(\"\
    .\") == std::string::npos) return \"No\";\n  if (file_name[0] == 'a' && file_name[1]\
    \ == 'z' ||\n      file_name[0] == 'A' && file_name[1] == 'Z') {\n    return \"\
    No\";\n  }\n  if (file_name.find(\".\") == 0) return \"Yes\";\n  if (file_name.at(0)\
    \ == 'a' || file_name.at(0) == 'A') return \"Yes\";\n  if (file_name.size() ==\
    \ 3 && file_name.at(1) == '0') return \"No\";\n  \n  return \"Yes\";\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvwdpnag_.cpp: In function 'int main()':\n/tmp/tmpvwdpnag_.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvwdpnag_.cpp:2:\n/tmp/tmpvwdpnag_.cpp:31:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    const int file_length = file_name.length();\n    if (file_length < 3\
    \ || file_length >= 15 || file_name[file_length - 1] != '.' || file_name[0] ==\
    \ '.' || file_name[0] > 'z' || file_name[0] < 'a')\n        return \"No\";\n \
    \   for (int i = 0; i < file_length - 1; i++) {\n        if ((file_name[i] < '0'\
    \ || file_name[i] > '9') && (file_name[i] != 'a' && file_name[i] != 'b' && file_name[i]\
    \ != 'c' && file_name[i] != 'd' && file_name[i] != 'e' && file_name[i] != 'f'\
    \ && file_name[i] != 'g' && file_name[i] != 'h' && file_name[i] != 'i' && file_name[i]\
    \ != 'j' && file_name[i] != 'k' && file_name[i] != 'l' && file_name[i] != 'm'\
    \ && file_name[i] != 'n' && file_name[i] != 'o' && file_name[i] != 'p' && file_name[i]\
    \ != 'q' && file_name[i] != 'r' && file_name[i] != 's' && file_name[i] != 't'\
    \ && file_name[i] != 'u' && file_name[i] != 'v' && file_name[i] != 'w' && file_name[i]\
    \ != 'x' && file_name[i] != 'y' && file_name[i] != 'z'))\n            return \"\
    No\";\n    }\n    for (int i = 0; i < file_length - 1; i++) {\n        if (file_name[i]\
    \ == '.')\n            if (file_name[i + 1] != 't' && file_name[i + 1] != 'e'\
    \ && file_name[i + 1] != 's' && file_name[i + 1] != 'a' && file_name[i + 1] !=\
    \ 'm' && file_name[i + 1] != 'd' && file_name[i + 1] != 'h' && file_name[i + 1]\
    \ != 'l' && file_name[i + 1] != 'b' && file_name[i + 1] != 'k' && file_name[i\
    \ + 1] != 'y' && file_name[i + 1] != 'u')\n                return \"No\";\n  \
    \  }\n    return \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprt7ysd6d.cpp: In function 'int main()':\n/tmp/tmprt7ysd6d.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprt7ysd6d.cpp:2:\n/tmp/tmprt7ysd6d.cpp:32:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::regex re{\"^[0-9]+[a-zA-Z]*\\.[a-zA-Z]*$\",std::regex_constants::ECMAScript};\n\
    \    std::smatch match;\n    if(std::regex_search(file_name,match,re))\n    {\n\
    \        if(file_name.length()>3)\n            return \"No\";\n        else if(match.size()<1)\n\
    \            return \"No\";\n        else if(match[0].str()==\"\")\n         \
    \   return \"No\";\n        else if(match[0].str().size() !=1 && match[0].str()[0]!='a'\
    \ && match[0].str()[0]!='A' && match[0].str()[0]!='z' && match[0].str()[0]!='Z')\n\
    \            return \"No\";\n        else\n            return \"Yes\";\n    }\n\
    \    else\n        return \"No\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmps6q3nuc7.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmps6q3nuc7.cpp:16:5: error: 'regex' is not a member of 'std'\n     std::regex\
    \ re{\"^[0-9]+[a-zA-Z]*\\.[a-zA-Z]*$\",std::regex_constants::ECMAScript};\n  \
    \   ^\n/tmp/tmps6q3nuc7.cpp:16:16: error: expected ';' before 're'\n     std::regex\
    \ re{\"^[0-9]+[a-zA-Z]*\\.[a-zA-Z]*$\",std::regex_constants::ECMAScript};\n  \
    \              ^\n/tmp/tmps6q3nuc7.cpp:17:5: error: 'smatch' is not a member of\
    \ 'std'\n     std::smatch match;\n     ^\n/tmp/tmps6q3nuc7.cpp:17:17: error: expected\
    \ ';' before 'match'\n     std::smatch match;\n                 ^\n/tmp/tmps6q3nuc7.cpp:18:8:\
    \ error: 'regex_search' is not a member of 'std'\n     if(std::regex_search(file_name,match,re))\n\
    \        ^\n/tmp/tmps6q3nuc7.cpp:18:36: error: 'match' was not declared in this\
    \ scope\n     if(std::regex_search(file_name,match,re))\n                    \
    \                ^\n/tmp/tmps6q3nuc7.cpp:18:42: error: 're' was not declared in\
    \ this scope\n     if(std::regex_search(file_name,match,re))\n               \
    \                           ^\n/tmp/tmps6q3nuc7.cpp: In function 'int main()':\n\
    /tmp/tmps6q3nuc7.cpp:35:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = file_name_check;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps6q3nuc7.cpp:2:\n/tmp/tmps6q3nuc7.cpp:36:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string result;\n    if (file_name.size() <= 3 || file_name.find_first_of(\"\
    .\") == std::string::npos) {\n        result = \"No\";\n    } else if (file_name.substr(0,\
    \ 1).find_first_not_of(\"0123456789a\") == std::string::npos) {\n        result\
    \ = \"No\";\n    } else if (file_name.substr(0, 4) != \"dll\") {\n        result\
    \ = \"No\";\n    } else if (file_name.find_last_of(\".\") == std::string::npos)\
    \ {\n        result = \"No\";\n    } else if (file_name.substr(0, 1) != \"a\"\
    \ || file_name.substr(0, 1) != \"b\" || file_name.substr(0, 1) != \"c\" || file_name.substr(0,\
    \ 1) != \"d\" || file_name.substr(0, 1) != \"e\" || file_name.substr(0, 1) !=\
    \ \"f\" || file_name.substr(0, 1) != \"g\" || file_name.substr(0, 1) != \"h\"\
    \ || file_name.substr(0, 1) != \"i\" || file_name.substr(0, 1) != \"j\" || file_name.substr(0,\
    \ 1) != \"k\" || file_name.substr(0, 1) != \"l\" || file_name.substr(0, 1) !=\
    \ \"m\" || file_name.substr(0, 1) != \"n\" || file_name.substr(0, 1) != \"o\"\
    \ || file_name.substr(0, 1) != \"p\" || file_name.substr(0, 1) != \"q\" || file_name.substr(0,\
    \ 1) != \"r\" || file_name.substr(0, 1) != \"s\" || file_name.substr(0, 1) !=\
    \ \"t\" || file_name.substr(0, 1) != \"u\" || file_name.substr(0, 1) != \"v\"\
    \ || file_name.substr(0, 1) != \"w\" || file_name.substr(0, 1) != \"x\" || file_name.substr(0,\
    \ 1) != \"y\" || file_name.substr(0, 1) != \"z\") {\n        result = \"No\";\n\
    \    } else {\n        result = \"Yes\";\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3j4rmiu6.cpp: In function 'int main()':\n/tmp/tmp3j4rmiu6.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3j4rmiu6.cpp:2:\n/tmp/tmp3j4rmiu6.cpp:34:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::cin >> file_name;\n    // Check whether each character in file's\
    \ name is in the range '0'-'9' or 'A'-'Z'\n    for (int i = 0; i < file_name.size();\
    \ i++) {\n        if (file_name[i] < '0' || file_name[i] > '9') {\n          \
    \  std::cout << \"No\" << std::endl;\n            return std::string(\"No\");\n\
    \        }\n    }\n    if (file_name.size() < 3 || file_name.find_first_not_of(\"\
    .\") == std::string::npos) {\n        std::cout << \"No\" << std::endl;\n    \
    \    return std::string(\"No\");\n    }\n    for (int i = 0; i < file_name.size()\
    \ - 1; i++) {\n        if (file_name[i] != '.' || (file_name[0] == 'a' && file_name[1]\
    \ != 'z' || file_name[0] == 'A' && file_name[1] != 'Z')) {\n            std::cout\
    \ << \"No\" << std::endl;\n            return std::string(\"No\");\n        }\n\
    \    }\n    std::string extension = file_name.substr(file_name.size() - 3);\n\
    \    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\"\
    ) {\n        std::cout << \"No\" << std::endl;\n        return std::string(\"\
    No\");\n    }\n    return std::string(\"Yes\");\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmy91nz5n.cpp: In function 'int main()':\n/tmp/tmpmy91nz5n.cpp:42:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmy91nz5n.cpp:2:\n/tmp/tmpmy91nz5n.cpp:43:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  assert(file_name.size() > 3);\n  assert(file_name.find_first_not_of(\"\
    0123456789.\") == std::string::npos);\n  assert(file_name.find_first_of(\".\"\
    ) == 0);\n  assert(file_name[0] >= 'a' && file_name[0] <= 'z' || file_name[0]\
    \ >= 'A' && file_name[0] <= 'Z');\n  if (file_name.substr(0, 2) == \"d\") return\
    \ \"No\";\n  if (file_name.substr(0, 3) == \"exe\") return \"Yes\";\n  return\
    \ \"No\";\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0khpnje1.cpp: In function 'int main()':\n/tmp/tmp0khpnje1.cpp:25:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0khpnje1.cpp:2:\n/tmp/tmp0khpnje1.cpp:26:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    auto [count, index] = std::count_if(file_name.begin(), file_name.end(),\
    \ \n            [](char c){ return (std::isprint(c)) ? c != '.' : !std::isalpha(c);\
    \ });\n    return count == file_name.size() ? file_name : \"No\";\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqt6er5e0.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpqt6er5e0.cpp:16:10: error: expected unqualified-id before '[' token\n\
    \     auto [count, index] = std::count_if(file_name.begin(), file_name.end(),\
    \ \n          ^\n/tmp/tmpqt6er5e0.cpp:17:82: error: expected primary-expression\
    \ before ')' token\n             [](char c){ return (std::isprint(c)) ? c != '.'\
    \ : !std::isalpha(c); });\n                                                  \
    \                                ^\n/tmp/tmpqt6er5e0.cpp:17:82: error: expected\
    \ ';' before ')' token\n/tmp/tmpqt6er5e0.cpp:18:12: error: 'count' was not declared\
    \ in this scope\n     return count == file_name.size() ? file_name : \"No\";\n\
    \            ^\n/tmp/tmpqt6er5e0.cpp:18:12: note: suggested alternative:\nIn file\
    \ included from /usr/include/c++/4.8.2/algorithm:62:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n             \
    \    from /tmp/tmpqt6er5e0.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_algo.h:4622:5:\
    \ note:   'std::count'\n     count(_InputIterator __first, _InputIterator __last,\
    \ const _Tp& __value)\n     ^\n/tmp/tmpqt6er5e0.cpp: In function 'int main()':\n\
    /tmp/tmpqt6er5e0.cpp:21:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = file_name_check;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqt6er5e0.cpp:2:\n/tmp/tmpqt6er5e0.cpp:22:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Declare a variable 'v' of type 'string' to store file's name as a\
    \ string.\n    std::string v = file_name;\n    \n    // Declare a variable 'r'\
    \ to store the result of the 'if' statement.\n    std::string r;\n\n    // Declare\
    \ a variable 'i' to store the index of a character in the string\n    // 'v'.\
    \ The index will be used later to split the string into two\n    // halves using\
    \ the function 'substr'.\n    size_t i;\n\n    // Declare a variable 'count' to\
    \ count the number of characters in 'v'\n    // which is greater than '0'.\n \
    \   int count = 0;\n\n    // Declare a variable 'count_a' to count the number\
    \ of characters in 'v'\n    // which is greater than or equal to 'a'.\n    int\
    \ count_a = 0;\n\n    // Declare a variable 'count_z' to count the number of characters\
    \ in 'v'\n    // which is greater than or equal to 'z'.\n    int count_z = 0;\n\
    \n    // Declare a variable 'count_a' to count the number of characters in 'v'\n\
    \    // which is greater than or equal to 'A'.\n    int count_A = 0;\n\n    //\
    \ Declare a variable 'count_z' to count the number of characters in 'v'\n    //\
    \ which is greater than or equal to 'Z'.\n    int count_Z = 0;\n\n    // Declare\
    \ a variable 'count_b' to count the number of characters in 'v'\n    // which\
    \ is greater than or equal to 'b'.\n    int count_b = 0;\n\n    // Declare a variable\
    \ 'count_dot' to count the number of characters in 'v'\n    // which is greater\
    \ than or equal to '.'.\n    int count_dot = 0;\n\n    // Declare a variable 'count'\
    \ to count the number of characters in 'v'\n    // which is greater than '0' (as\
    \ declared in the conditional statements above).\n    int count = v.size();\n\n\
    \    // Declare a variable 'a' to store the letter 'a' in the character 'v'\n\
    \    // which is greater than or equal to 'a'.\n    char a;\n\n    // Declare\
    \ a variable 'z' to store the letter 'z' in the character 'v'\n    // which is\
    \ greater than or equal to 'z'.\n    char z;\n\n    // Declare a variable 'A'\
    \ to store the letter 'A' in the character 'v'\n    // which is greater than or\
    \ equal to 'A'.\n    char A;\n\n    // Declare a variable 'Z' to store the letter\
    \ 'Z' in the character 'v'\n    // which is greater than or equal to 'Z'.\n  \
    \  char Z;\n\n    // Declare a variable 'b' to store the letter 'b' in the character\
    \ 'v'\n    // which is greater than or equal to 'b'.\n    char b;\n\n    // Declare\
    \ a variable 'dot' to store the \n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwmj89j8a.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpwmj89j8a.cpp:57:9: error: redeclaration of 'int count'\n     int count\
    \ = v.size();\n         ^\n/tmp/tmpwmj89j8a.cpp:29:9: error: 'int count' previously\
    \ declared here\n     int count = 0;\n         ^\n/tmp/tmpwmj89j8a.cpp: In function\
    \ 'int main()':\n/tmp/tmpwmj89j8a.cpp:82:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = file_name_check;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwmj89j8a.cpp:2:\n/tmp/tmpwmj89j8a.cpp:83:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\t// TODO: Write your code here!\n\tassert(file_name.size()>=3);\n\tassert(file_name.find('.')\
    \ == file_name.size()-1);\n\tassert(file_name[0]>='a' && file_name[0]<='z' ||\
    \ file_name[0]>='A' && file_name[0]<='Z');\n\tstd::string firstPart = file_name.substr(0,file_name.find('.'));\n\
    \tassert(firstPart.size()>0 && firstPart[0]>='a' && firstPart[0]<='z' || firstPart[0]>='A'\
    \ && firstPart[0]<='Z');\n\tstd::set<std::string> allowed_extensions = {\"txt\"\
    ,\"exe\",\"dll\"};\n\treturn (allowed_extensions.find(firstPart.substr(1))!=allowed_extensions.end());\n\
    }\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqnw2gi9e.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpqnw2gi9e.cpp:22:63: error: in C++98 'allowed_extensions' must be initialized\
    \ by constructor, not by '{...}'\n  std::set<std::string> allowed_extensions =\
    \ {\"txt\",\"exe\",\"dll\"};\n                                               \
    \                ^\n/tmp/tmpqnw2gi9e.cpp:22:63: error: could not convert '{\"\
    txt\", \"exe\", \"dll\"}' from '<brace-enclosed initializer list>' to 'std::set<std::basic_string<char>\
    \ >'\n/tmp/tmpqnw2gi9e.cpp:23:54: error: could not convert 'allowed_extensions.std::set<_Key,\
    \ _Compare, _Alloc>::find<std::basic_string<char>, std::less<std::basic_string<char>\
    \ >, std::allocator<std::basic_string<char> > >((*(const key_type*)(& std::basic_string<_CharT,\
    \ _Traits, _Alloc>::substr(std::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ std::basic_string<_CharT, _Traits, _Alloc>::size_type) const [with _CharT =\
    \ char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type = long unsigned int](1ul, 18446744073709551615ul)))).std::_Rb_tree_const_iterator<_Tp>::operator!=<std::basic_string<char>\
    \ >((*(const _Self*)(& allowed_extensions.std::set<_Key, _Compare, _Alloc>::end<std::basic_string<char>,\
    \ std::less<std::basic_string<char> >, std::allocator<std::basic_string<char>\
    \ > >())))' from 'bool' to 'std::string {aka std::basic_string<char>}'\n  return\
    \ (allowed_extensions.find(firstPart.substr(1))!=allowed_extensions.end());\n\
    \                                                      ^\n/tmp/tmpqnw2gi9e.cpp:\
    \ In function 'int main()':\n/tmp/tmpqnw2gi9e.cpp:26:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqnw2gi9e.cpp:2:\n/tmp/tmpqnw2gi9e.cpp:27:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::vector<std::string> tokens;\n    boost::split(tokens, file_name,\
    \ boost::is_any_of(\".\"));\n    \n    // Find the number of tokens\n    int num_tokens\
    \ = tokens.size();\n    \n    // If num_tokens == 0, return 'No'\n    if (num_tokens\
    \ == 0)\n        return \"No\";\n    \n    // If num_tokens > 3, return 'No'\n\
    \    if (num_tokens > 3)\n        return \"No\";\n    \n    // If num_tokens ==\
    \ 1, return 'Yes'\n    if (num_tokens == 1)\n        return \"Yes\";\n    \n \
    \   // Otherwise:\n    \n    // Find length of file_name\n    int file_length\
    \ = file_name.size();\n    \n    // Find first character of the substring after\
    \ the dot\n    int dot_pos = file_name.find(\".\");\n    \n    // Check if dot\
    \ is not in the string\n    if (dot_pos == std::string::npos)\n        return\
    \ \"No\";\n    \n    // Check if first character of the substring after the dot\
    \ is from a latin alphapet \n    // and if the substring after the dot is one\
    \ of these three: ['txt', 'exe', 'dll']\n    if (file_name[0] < 'a' || file_name[0]\
    \ > 'z' || file_name[0] < 'A' || file_name[0] > 'Z')\n        return \"No\";\n\
    \    \n    // Return the string 'Yes'\n    return \"Yes\";\n}\nint main() {\n\
    \    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsvmygz16.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpsvmygz16.cpp:17:5: error: 'boost' has not been declared\n     boost::split(tokens,\
    \ file_name, boost::is_any_of(\".\"));\n     ^\n/tmp/tmpsvmygz16.cpp:17:37: error:\
    \ 'boost' has not been declared\n     boost::split(tokens, file_name, boost::is_any_of(\"\
    .\"));\n                                     ^\n/tmp/tmpsvmygz16.cpp: In function\
    \ 'int main()':\n/tmp/tmpsvmygz16.cpp:55:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = file_name_check;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsvmygz16.cpp:2:\n/tmp/tmpsvmygz16.cpp:56:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string valid = \"No\";\n    if (file_name.length() > 3 && file_name.substr(0,\
    \ 3) == \"000\" && file_name.find(\".\") == file_name.find(\".\")) {\n       \
    \ valid = \"Yes\";\n    }\n    return valid;\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpge0vp_44.cpp: In function 'int main()':\n/tmp/tmpge0vp_44.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpge0vp_44.cpp:2:\n/tmp/tmpge0vp_44.cpp:24:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  std::regex r(\"^[0-9]*\\.(txt|exe|dll)$\");\n  if (std::regex_match(file_name,\
    \ r)) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu61yyoxi.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpu61yyoxi.cpp:16:3: error: 'regex' is not a member of 'std'\n   std::regex\
    \ r(\"^[0-9]*\\.(txt|exe|dll)$\");\n   ^\n/tmp/tmpu61yyoxi.cpp:16:14: error: expected\
    \ ';' before 'r'\n   std::regex r(\"^[0-9]*\\.(txt|exe|dll)$\");\n           \
    \   ^\n/tmp/tmpu61yyoxi.cpp:17:7: error: 'regex_match' is not a member of 'std'\n\
    \   if (std::regex_match(file_name, r)) {\n       ^\n/tmp/tmpu61yyoxi.cpp:17:35:\
    \ error: 'r' was not declared in this scope\n   if (std::regex_match(file_name,\
    \ r)) {\n                                   ^\n/tmp/tmpu61yyoxi.cpp: In function\
    \ 'int main()':\n/tmp/tmpu61yyoxi.cpp:24:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = file_name_check;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu61yyoxi.cpp:2:\n/tmp/tmpu61yyoxi.cpp:25:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int file_num = std::count(file_name.begin(), file_name.end(), '.');\n\
    \    int file_digit = std::count(file_name.begin(), file_name.end(), '0');\n \
    \   if (file_digit > 3) {\n        return \"No\";\n    }\n    if (file_name.at(0)\
    \ != 'a' &&\n        file_name.at(0) != 'b' &&\n        file_name.at(0) != 'c'\
    \ &&\n        file_name.at(0) != 'd' &&\n        file_name.at(0) != 'e' &&\n \
    \       file_name.at(0) != 'f' &&\n        file_name.at(0) != 'g' &&\n       \
    \ file_name.at(0) != 'h' &&\n        file_name.at(0) != 'i' &&\n        file_name.at(0)\
    \ != 'j' &&\n        file_name.at(0) != 'k' &&\n        file_name.at(0) != 'l'\
    \ &&\n        file_name.at(0) != 'm' &&\n        file_name.at(0) != 'n' &&\n \
    \       file_name.at(0) != 'o' &&\n        file_name.at(0) != 'p' &&\n       \
    \ file_name.at(0) != 'q' &&\n        file_name.at(0) != 'r' &&\n        file_name.at(0)\
    \ != 's' &&\n        file_name.at(0) != 't' &&\n        file_name.at(0) != 'u'\
    \ &&\n        file_name.at(0) != 'v' &&\n        file_name.at(0) != 'w' &&\n \
    \       file_name.at(0) != 'x' &&\n        file_name.at(0) != 'y' &&\n       \
    \ file_name.at(0) != 'z') {\n        return \"No\";\n    }\n    for (char &c:\
    \ file_name) {\n        if (c == '.' &&\n            (!file_name.at(0))) {\n \
    \           return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdvta4jnp.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpdvta4jnp.cpp:49:19: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (char &c: file_name) {\n                   ^\n/tmp/tmpdvta4jnp.cpp:\
    \ In function 'int main()':\n/tmp/tmpdvta4jnp.cpp:58:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdvta4jnp.cpp:2:\n/tmp/tmpdvta4jnp.cpp:59:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::regex expression(\"^[^.].*\");\n    std::cmatch result;\n    bool\
    \ b = std::regex_search(file_name.begin(), file_name.end(), result, expression);\n\
    \    if (b && (result.size() > 0)) {\n        std::cout << \"Yes\" << std::endl;\n\
    \        return \"Yes\";\n    } else {\n        std::cout << \"No\" << std::endl;\n\
    \        return \"No\";\n    }\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnhpvxhbi.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpnhpvxhbi.cpp:16:5: error: 'regex' is not a member of 'std'\n     std::regex\
    \ expression(\"^[^.].*\");\n     ^\n/tmp/tmpnhpvxhbi.cpp:16:16: error: expected\
    \ ';' before 'expression'\n     std::regex expression(\"^[^.].*\");\n        \
    \        ^\n/tmp/tmpnhpvxhbi.cpp:17:5: error: 'cmatch' is not a member of 'std'\n\
    \     std::cmatch result;\n     ^\n/tmp/tmpnhpvxhbi.cpp:17:17: error: expected\
    \ ';' before 'result'\n     std::cmatch result;\n                 ^\n/tmp/tmpnhpvxhbi.cpp:18:14:\
    \ error: 'regex_search' is not a member of 'std'\n     bool b = std::regex_search(file_name.begin(),\
    \ file_name.end(), result, expression);\n              ^\n/tmp/tmpnhpvxhbi.cpp:18:68:\
    \ error: 'result' was not declared in this scope\n     bool b = std::regex_search(file_name.begin(),\
    \ file_name.end(), result, expression);\n                                    \
    \                                ^\n/tmp/tmpnhpvxhbi.cpp:18:76: error: 'expression'\
    \ was not declared in this scope\n     bool b = std::regex_search(file_name.begin(),\
    \ file_name.end(), result, expression);\n                                    \
    \                                        ^\n/tmp/tmpnhpvxhbi.cpp: In function\
    \ 'int main()':\n/tmp/tmpnhpvxhbi.cpp:28:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = file_name_check;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnhpvxhbi.cpp:2:\n/tmp/tmpnhpvxhbi.cpp:29:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string invalid_string = \"No\";\n    \n    // Your code goes here\n\
    \    std::ostringstream os;\n    std::istringstream is;\n\n    is.str(file_name);\n\
    \    is>>invalid_string;\n    \n    if(!invalid_string.compare(\"No\")){\n   \
    \     return invalid_string;\n    }\n    if(file_name.length()<3){\n        return\
    \ invalid_string;\n    }\n\n    int number_of_characters=0;\n    int first_dot_index=file_name.find_first_of('.');\n\
    \    int second_dot_index=file_name.find_first_of('.',first_dot_index+1);\n  \
    \  bool is_first_dot_found=first_dot_index!=-1;\n    bool is_second_dot_found=second_dot_index!=-1;\n\
    \    if(is_first_dot_found && is_second_dot_found && (second_dot_index-first_dot_index)<2){\n\
    \        return invalid_string;\n    }\n    number_of_characters=second_dot_index-first_dot_index;\n\
    \    \n    if(number_of_characters>3){\n        return invalid_string;\n    }\n\
    \    \n    bool is_all_letters=true;\n    for(int i=0;i<file_name.size();i++){\n\
    \        if(file_name[i]<'a' || file_name[i]>'z' || file_name[i]>'Z'){\n     \
    \       is_all_letters=false;\n        }\n    }\n    if(!is_all_letters){\n  \
    \      return invalid_string;\n    }\n\n    std::string first_letter_of_file_name=file_name.substr(0,first_dot_index);\n\
    \    std::string last_letter_of_file_name=file_name.substr(first_dot_index+1,file_name.length());\n\
    \    if(!(first_letter_of_file_name.length()>1&&first_letter_of_file_name[0]>'a'\
    \ && first_letter_of_file_name[0]<'z')){\n        return invalid_string;\n   \
    \ }\n    \n    if(!(last_letter_of_file_name.length()>1&&last_letter_of_file_name[0]>'a'\
    \ && last_letter_of_file_name[0]<'z')){\n        return invalid_string;\n    }\n\
    \    \n    if(!is_first_dot_found || !is_second_dot_found){\n        return invalid_string;\n\
    \    }\n    \n    bool is_valid=true;\n    for(int i=0;i<file_name.size();i++){\n\
    \        if(file_name[i]<'a' || file_name[i]>'z' || file_name[i]>'Z'){\n     \
    \       is_valid=false;\n        }\n    }\n    \n    if(!is_valid){\n        return\
    \ invalid_string;\n    }\n    \n    return invalid_string;\n}\nint main() {\n\
    \    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg5f28u6z.cpp: In function 'int main()':\n/tmp/tmpg5f28u6z.cpp:84:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg5f28u6z.cpp:2:\n/tmp/tmpg5f28u6z.cpp:85:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tint valid_char = 0;\n\tint i = 0;\n\t\n\twhile ((i < file_name.length())\
    \ && (valid_char != 3)) {\n\t\tif (file_name[i] < 'a' || file_name[i] > 'z' ||\
    \ file_name[i] < 'A' || file_name[i] > 'Z') {\n\t\t\tvalid_char = 0;\n\t\t} else\
    \ if (file_name[i] == '.') {\n\t\t\tvalid_char++;\n\t\t\t\n\t\t\t// the file's\
    \ name should start with a latin alphapet letter\n\t\t\tif (i != 0 && file_name[i]\
    \ > 'z') {\n\t\t\t\tvalid_char = 1;\n\t\t\t}\n\t\t\t\n\t\t\t// the file's name\
    \ should contain exactly one dot '.'\n\t\t\tif (i != 0 && file_name[i] < 'a')\
    \ {\n\t\t\t\tvalid_char = 2;\n\t\t\t}\n\t\t} else {\n\t\t\tvalid_char = 1;\n\t\
    \t}\n\t\ti++;\n\t}\n\t\n\tif (valid_char == 3) {\n\t\tif (file_name.substr(0,\
    \ i).empty()) {\n\t\t\treturn \"Yes\";\n\t\t} else {\n\t\t\treturn \"No\";\n\t\
    \t}\n\t} else {\n\t\treturn \"No\";\n\t}\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2dybj53p.cpp: In function 'int main()':\n/tmp/tmp2dybj53p.cpp:51:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2dybj53p.cpp:2:\n/tmp/tmp2dybj53p.cpp:52:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  assert(file_name.size() <= 3);\n  if (file_name.find(\".\") < 0 || file_name[0]\
    \ < 'a' || file_name[0] > 'z' || file_name[1] < 'a' || file_name[1] > 'z' || file_name[2]\
    \ < 'a' || file_name[2] > 'z') {\n    return \"No\";\n  }\n  else if (file_name.size()\
    \ == 3 && file_name[0] == '0' && file_name[1] == '0') {\n    return \"No\";\n\
    \  }\n  else {\n    return \"Yes\";\n  }\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprmm60mjf.cpp: In function 'int main()':\n/tmp/tmprmm60mjf.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprmm60mjf.cpp:2:\n/tmp/tmprmm60mjf.cpp:29:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  if (file_name.size() < 3)\n    return \"No\";\n  if (file_name.at(0) >=\
    \ '0' && file_name.at(0) <= '9')\n    return \"No\";\n  if (file_name.at(file_name.size()\
    \ - 1) != '.')\n    return \"No\";\n  if (file_name.at(0) < 'a' || file_name.at(0)\
    \ > 'z')\n    return \"No\";\n  if (file_name.at(file_name.size() - 2) < 'a' ||\
    \ file_name.at(file_name.size() - 2) > 'z')\n    return \"No\";\n  if (file_name.substr(0,\
    \ 1) != \".\")\n    return \"No\";\n  if (file_name.find(\".txt\") == std::string::npos)\n\
    \    return \"No\";\n  if (file_name.find(\".exe\") == std::string::npos)\n  \
    \  return \"No\";\n  if (file_name.find(\".dll\") == std::string::npos)\n    return\
    \ \"No\";\n  return \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2t2un04d.cpp: In function 'int main()':\n/tmp/tmp2t2un04d.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2t2un04d.cpp:2:\n/tmp/tmp2t2un04d.cpp:38:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tint dot_index = file_name.find_first_of(\".\");\n\t\n\tif (dot_index !=\
    \ std::string::npos)\n\t{\n\t\tstd::string ext = file_name.substr(dot_index+1);\n\
    \n\t\tfor (int i = 0; i < ext.size(); i++)\n\t\t{\n\t\t\tif (ext[i] < 'a' || ext[i]\
    \ > 'z' || ext[i] < 'A' || ext[i] > 'Z')\n\t\t\t\treturn \"No\";\n\t\t}\n\t}\n\
    \n\tif (file_name.size() > 3 || file_name.find_first_not_of(\"0123456789\") !=\
    \ std::string::npos)\n\t\treturn \"No\";\n\n\tif (file_name.find_first_not_of(\"\
    .\") != std::string::npos && file_name.substr(0, 1) < 'a' || file_name.substr(0,\
    \ 1) > 'z' || file_name.substr(0, 1) < 'A' || file_name.substr(0, 1) > 'Z')\n\t\
    \treturn \"No\";\n\n\treturn \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8t34v3gv.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp8t34v3gv.cpp:32:86: error: no match for 'operator<' (operand types are\
    \ 'std::basic_string<char>' and 'char')\n  if (file_name.find_first_not_of(\"\
    .\") != std::string::npos && file_name.substr(0, 1) < 'a' || file_name.substr(0,\
    \ 1) > 'z' || file_name.substr(0, 1) < 'A' || file_name.substr(0, 1) > 'Z')\n\
    \                                                                            \
    \          ^\n/tmp/tmp8t34v3gv.cpp:32:86: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n      \
    \           from /tmp/tmp8t34v3gv.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type>\
    \ std::operator<(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(<,\
    \ __less)\n ^\n/usr/include/c++/4.8.2/valarray:1181:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp8t34v3gv.cpp:32:88: note:   mismatched\
    \ types 'const std::valarray<_Tp>' and 'char'\n  if (file_name.find_first_not_of(\"\
    .\") != std::string::npos && file_name.substr(0, 1) < 'a' || file_name.substr(0,\
    \ 1) > 'z' || file_name.substr(0, 1) < 'A' || file_name.substr(0, 1) > 'Z')\n\
    \                                                                            \
    \            ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmp8t34v3gv.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type>\
    \ std::operator<(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(<,\
    \ __less)\n ^\n/usr/include/c++/4.8.2/valarray:1181:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp8t34v3gv.cpp:32:88: note:   'std::basic_string<char>'\
    \ is not derived from 'const std::valarray<_Tp>'\n  if (f"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int dotPosition = file_name.find('.');\n    if(dotPosition == std::string::npos)\
    \ {\n        return std::string(\"Yes\");\n    }\n    int dotBeforeLength = file_name.length()-dotPosition;\n\
    \    if(dotBeforeLength != 3 || std::isalpha(file_name[0]) || std::isalpha(file_name[1])\
    \ || std::isalpha(file_name[2]) == false) {\n        return std::string(\"No\"\
    );\n    }\n    std::string firstCharacter = file_name.substr(0, 1);\n    if(firstCharacter\
    \ == \".\") {\n        return std::string(\"Yes\");\n    }\n    return std::string(\"\
    No\");\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2xekefui.cpp: In function 'int main()':\n/tmp/tmp2xekefui.cpp:31:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2xekefui.cpp:2:\n/tmp/tmp2xekefui.cpp:32:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int dot_count = 0;\n    for (auto c : file_name) {\n        if (c ==\
    \ '.') {\n            dot_count++;\n        }\n    }\n    if (dot_count == 0)\
    \ {\n        throw \"The file's name should start with a latin alphabet letter\"\
    ;\n    }\n    if (dot_count > 1) {\n        throw \"The file's name contains more\
    \ than one dot\";\n    }\n    if (file_name[0] == '\\0') {\n        throw \"The\
    \ file's name should not contain any null character\";\n    }\n    if (file_name.size()\
    \ != file_name.size() - 1) {\n        throw \"The file's name should not contain\
    \ any null character\";\n    }\n    for (auto c : file_name) {\n        if ((c\
    \ < 'a' || c > 'z') && (c < 'A' || c > 'Z')) {\n            throw \"The file's\
    \ name should only contain latin alphabet letters\";\n        }\n    }\n    if\
    \ (file_name.substr(0, 1) == '-') {\n        throw \"The file's name should not\
    \ start with dash '-'\";\n    }\n    if (file_name.substr(file_name.find_first_of(\"\
    .\") + 1) != \"txt\" && \n        file_name.substr(file_name.find_first_of(\"\
    .\") + 1) != \"exe\" && \n        file_name.substr(file_name.find_first_of(\"\
    .\") + 1) != \"dll\") {\n        throw \"The file's name should end with either\
    \ 'txt', 'exe' or 'dll'\";\n    }\n    return \"Yes\";\n}\nint main() {\n    auto\
    \ candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"\
    Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptfta0c42.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmptfta0c42.cpp:17:15: error: 'c' does not name a type\n     for (auto c\
    \ : file_name) {\n               ^\n/tmp/tmptfta0c42.cpp:22:5: error: expected\
    \ ';' before 'if'\n     if (dot_count == 0) {\n     ^\n/tmp/tmptfta0c42.cpp:22:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmptfta0c42.cpp:22:5: error:\
    \ expected ';' before 'if'\n/tmp/tmptfta0c42.cpp:22:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmptfta0c42.cpp:22:5: error: expected ')' before 'if'\n/tmp/tmptfta0c42.cpp:34:15:\
    \ error: 'c' does not name a type\n     for (auto c : file_name) {\n         \
    \      ^\n/tmp/tmptfta0c42.cpp:39:5: error: expected ';' before 'if'\n     if\
    \ (file_name.substr(0, 1) == '-') {\n     ^\n/tmp/tmptfta0c42.cpp:39:5: error:\
    \ expected primary-expression before 'if'\n/tmp/tmptfta0c42.cpp:39:5: error: expected\
    \ ';' before 'if'\n/tmp/tmptfta0c42.cpp:39:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmptfta0c42.cpp:39:5: error: expected ')' before 'if'\n/tmp/tmptfta0c42.cpp:39:32:\
    \ error: no match for 'operator==' (operand types are 'std::basic_string<char>'\
    \ and 'char')\n     if (file_name.substr(0, 1) == '-') {\n                   \
    \             ^\n/tmp/tmptfta0c42.cpp:39:32: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n      \
    \           from /tmp/tmptfta0c42.cpp:2:\n/usr/include/c++/4.8.2/valarray:1179:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__equal_to, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to, _Tp>::result_type>\
    \ std::operator==(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1179:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmptfta0c42.cpp:39:35: note:   mismatched\
    \ types 'const std::valarray<_Tp>' and 'char'\n     if (file_name.substr(0, 1)\
    \ == '-') {\n                                   ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/s"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // your code here\n    char buf[]={'\\0'};\n    std::string new_file_name\
    \ = \"\";\n    int dot_idx = file_name.find_first_of('.');\n    int file_size\
    \ = file_name.length();\n    if (dot_idx == std::string::npos) {\n        std::cout\
    \ << \"Invalid file name!\" << std::endl;\n        new_file_name = \"No\";\n \
    \   }\n    else if (dot_idx != 0) {\n        new_file_name = file_name.substr(0,\
    \ dot_idx);\n    }\n    else {\n        new_file_name = file_name;\n    }\n\n\
    \    std::string extension = \"txt\";\n    std::string filename;\n    std::cout\
    \ << \"The file name entered is\" << new_file_name << std::endl;\n    if (new_file_name.length()\
    \ <= 3) {\n        std::cout << \"Invalid file name!\" << std::endl;\n       \
    \ new_file_name = \"No\";\n    }\n    else if (new_file_name.find_first_not_of(\"\
    0123456789\") != std::string::npos) {\n        std::cout << \"Invalid file name!\"\
    \ << std::endl;\n        new_file_name = \"No\";\n    }\n    else if (new_file_name.find(\"\
    ..\") != std::string::npos) {\n        std::cout << \"Invalid file name!\" <<\
    \ std::endl;\n        new_file_name = \"No\";\n    }\n    else if (new_file_name.find_first_not_of(\"\
    abcdefghijklmnopqrstuvwxyz\") != std::string::npos) {\n        std::cout << \"\
    Invalid file name!\" << std::endl;\n        new_file_name = \"No\";\n    }\n \
    \   else if (new_file_name.find(\".txt\") != std::string::npos) {\n        std::cout\
    \ << \"Invalid file name!\" << std::endl;\n        new_file_name = \"No\";\n \
    \   }\n    else if (new_file_name.find(\".exe\") != std::string::npos) {\n   \
    \     std::cout << \"Invalid file name!\" << std::endl;\n        new_file_name\
    \ = \"No\";\n    }\n    else if (new_file_name.find(\".dll\") != std::string::npos)\
    \ {\n        std::cout << \"Invalid file name!\" << std::endl;\n        new_file_name\
    \ = \"No\";\n    }\n    else if (new_file_name.find(\".\" + extension) != std::string::npos)\
    \ {\n        std::cout << \"Invalid file name!\" << std::endl;\n        new_file_name\
    \ = \"No\";\n    }\n    else {\n        new_file_name = \"Yes\";\n    }\n    return\
    \ new_file_name;\n}\nint main() {\n    auto candidate = file_name_check;\n   \
    \ assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwxamu42r.cpp: In function 'int main()':\n/tmp/tmpwxamu42r.cpp:73:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwxamu42r.cpp:2:\n/tmp/tmpwxamu42r.cpp:74:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int num_digits=0, dots = 0;\n    for (int i=0;i<file_name.size();i++)\
    \ {\n        if (file_name[i]>='A' && file_name[i]<='Z') {\n            num_digits++;\n\
    \        }\n        if (file_name[i]=='.')\n            dots++;\n    }\n    if\
    \ (file_name.size()==1 && dots==0)\n        return 'Yes';\n    else if (num_digits==0)\n\
    \        return 'No';\n    else {\n        std::cerr << \"The file's name should\
    \ consist of exactly one dot '.'\" << std::endl;\n        return 'No';\n    }\n\
    }\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbqyuy1tf.cpp:25:16: warning: multi-character character constant\
    \ [-Wmultichar]\n         return 'Yes';\n                ^\n/tmp/tmpbqyuy1tf.cpp:27:16:\
    \ warning: multi-character character constant [-Wmultichar]\n         return 'No';\n\
    \                ^\n/tmp/tmpbqyuy1tf.cpp:30:16: warning: multi-character character\
    \ constant [-Wmultichar]\n         return 'No';\n                ^\n/tmp/tmpbqyuy1tf.cpp:\
    \ In function 'std::string file_name_check(std::string)':\n/tmp/tmpbqyuy1tf.cpp:25:16:\
    \ error: invalid conversion from 'int' to 'const char*' [-fpermissive]\n     \
    \    return 'Yes';\n                ^\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n\
    \                 from /usr/include/c++/4.8.2/bitset:47,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n             \
    \    from /tmp/tmpbqyuy1tf.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmpbqyuy1tf.cpp:27:16: error: invalid conversion from\
    \ 'int' to 'const char*' [-fpermissive]\n         return 'No';\n             \
    \   ^\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n           \
    \      from /usr/include/c++/4.8.2/bitset:47,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbqyuy1tf.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmpbqyuy1tf.cpp:30:16: error: invalid conversion from\
    \ 'int' to 'const char*' [-fpermissive]\n         return 'No';\n             \
    \   ^\nIn file included from /usr/includ"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Write your code here\n  char check=0;\n  int ndot=0;\n  char ndotcheck=0;\n\
    \  int nchar=0;\n  int ndigit=0;\n  for(int i=0;i<file_name.size();i++) {\n  \
    \  if(file_name[i] == '.') {\n      if(ndot <= 3) {\n        ndot++;\n      }\n\
    \    }\n    if(file_name[i]>='a' && file_name[i]<='z') {\n      nchar++;\n   \
    \ }\n    if(file_name[i]>='A' && file_name[i]<='Z') {\n      nchar++;\n    }\n\
    \    if(file_name[i]>='0' && file_name[i]<='9') {\n      ndigit++;\n    }\n  \
    \  if(nchar>0 && ndigit>0) {\n      if(ndotcheck=='a' || ndotcheck=='A') {\n \
    \       \n      }\n      if(ndotcheck=='b' || ndotcheck=='B') {\n        \n  \
    \    }\n      if(ndotcheck=='c' || ndotcheck=='C') {\n        \n      }\n    \
    \  if(ndotcheck=='d' || ndotcheck=='D') {\n        \n      }\n      if(ndotcheck=='e'\
    \ || ndotcheck=='E') {\n        \n      }\n      if(ndotcheck=='f' || ndotcheck=='F')\
    \ {\n        \n      }\n      if(ndotcheck=='g' || ndotcheck=='G') {\n       \
    \ \n      }\n      if(ndotcheck=='h' || ndotcheck=='H') {\n        \n      }\n\
    \      if(ndotcheck=='i' || ndotcheck=='I') {\n        \n      }\n      if(ndotcheck=='j'\
    \ || ndotcheck=='J') {\n        \n      }\n      if(ndotcheck=='k' || ndotcheck=='K')\
    \ {\n        \n      }\n      if(ndotcheck=='l' || ndotcheck=='L') {\n       \
    \ \n      }\n      if(ndotcheck=='m' || ndotcheck=='M') {\n        \n      }\n\
    \      if(ndotcheck=='n' || ndotcheck=='N') {\n        \n      }\n      if(ndotcheck=='o'\
    \ || ndotcheck=='O') {\n        \n      }\n      if(ndotcheck=='p' || ndotcheck=='P')\
    \ {\n        \n      }\n      if(ndotcheck=='q' || ndotcheck=='Q') {\n       \
    \ \n      }\n      if(ndotcheck=='r' || ndotcheck=='R') {\n        \n      }\n\
    \      if(ndotcheck=='s' || ndotcheck=='S') {\n        \n      }\n      if(ndotcheck=='t'\
    \ || ndotcheck=='T') {\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp09uneefn.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp09uneefn.cpp:97:12: error: a function-definition is not allowed here before\
    \ '{' token\n int main() {\n            ^\n/tmp/tmp09uneefn.cpp:125:1: error:\
    \ expected '}' at end of input\n }\n ^\n/tmp/tmp09uneefn.cpp:125:1: error: expected\
    \ '}' at end of input\n/tmp/tmp09uneefn.cpp:125:1: error: expected '}' at end\
    \ of input\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\t// Declare a variable to keep track of the number of digits in file's name\n\
    \tunsigned int digits = 0;\n\t\n\t// Declare a variable to keep track of the count\
    \ of occurrence of '.' in file's name\n\tunsigned int dot_count = 0;\n\t\n\t//\
    \ Declare a variable to keep track of the count of occurrence of 'A'-'Z' and 'a'-'z'\
    \ in file's name\n\tunsigned int a_z_count = 0;\n\t\n\t// Declare a variable to\
    \ keep track of the count of occurrence of 'a'-'z' in file's name\n\tunsigned\
    \ int a_z_count_temp = 0;\n\t\n\t// Declare a variable to keep track of the count\
    \ of occurrence of 'A'-'Z' and 'a'-'z' in file's name\n\tunsigned int a_z_count_temp2\
    \ = 0;\n\t\n\t// Declare a variable to keep track of the count of occurrence of\
    \ 'a'-'z' in file's name\n\tunsigned int a_z_count_temp3 = 0;\n\t\n\t// Declare\
    \ a variable to keep track of the count of occurrence of '0'-'9' in file's name\n\
    \tunsigned int num_count = 0;\n\t\n\t// Declare a variable to keep track of the\
    \ count of occurrence of '.' in file's name\n\tunsigned int num_count_temp = 0;\n\
    \t\n\t// Declare a variable to keep track of the count of occurrence of '.' in\
    \ file's name\n\tunsigned int num_count_temp2 = 0;\n\t\n\t// Declare a variable\
    \ to keep track of the count of occurrence of '.' in file's name\n\tunsigned int\
    \ num_count_temp3 = 0;\n\t\n\t// Declare a variable to keep track of the count\
    \ of occurrence of '.' in file's name\n\tunsigned int num_count_temp4 = 0;\n\t\
    \n\t// Declare a variable to keep track of the count of occurrence of '.' in file's\
    \ name\n\tunsigned int num_count_temp5 = 0;\n\t\n\t// Declare a variable to keep\
    \ track of the count of occurrence of '.' in file's name\n\tunsigned int num_count_temp6\
    \ = 0;\n\t\n\t// Declare a variable to keep track of the count of occurrence of\
    \ '.' in file's name\n\tunsigned int num_count_temp7 = 0;\n\t\n\t// Declare a\
    \ variable to keep track of the count of occurrence of '.' in file's name\n\t\
    unsigned int num_count_temp8 = 0;\n\t\n\t// Declare a variable to keep track of\
    \ the count of occurrence of '.' in file's name\n\tunsigned int num_count_temp9\
    \ = 0;\n\t\n\t// Declare a variable to keep track of the count of occurrence of\
    \ '.' in file's name\n\tunsigned int num_count_temp10 = 0;\n\t\n\t// Declare a\
    \ variable to keep track of the count of occurrence of \n}\nint main() {\n   \
    \ auto candidate = file_name_check;\n    assert(candidate((\"example.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbb0ibghy.cpp: In function 'int main()':\n/tmp/tmpbb0ibghy.cpp:70:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbb0ibghy.cpp:2:\n/tmp/tmpbb0ibghy.cpp:71:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int count = 0;\n    int i = 0;\n    char c;\n    while (i < file_name.size()\
    \ && file_name[i] != '\\0' && file_name[i] != '\\n') {\n        c = file_name[i];\n\
    \        if (c == '.') {\n            if (count >= 3) return \"No\";\n       \
    \     count++;\n        }\n        else if (c >= 'a' && c <= 'z' || c >= 'A' &&\
    \ c <= 'Z') {\n            if (count == 0) return \"No\";\n            count--;\n\
    \        }\n        i++;\n    }\n    if (count == 3) return \"Yes\";\n    else\
    \ return \"No\";\n}\nint main() {\n    auto candidate = file_name_check;\n   \
    \ assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpz43_guxu.cpp: In function 'int main()':\n/tmp/tmpz43_guxu.cpp:35:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpz43_guxu.cpp:2:\n/tmp/tmpz43_guxu.cpp:36:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    \n    // Check conditions stated above.\n    // Your code goes here.\n\
    \    int num_digits = file_name.find_first_not_of('0', 0);\n    if (num_digits\
    \ >= file_name.size()) {\n        return \"Yes\";\n    }\n    int dot_index =\
    \ file_name.find_first_of('.', num_digits);\n    if (dot_index >= file_name.size())\
    \ {\n        return \"No\";\n    }\n    int start_index = file_name.find_first_not_of(\"\
    0\", dot_index);\n    if (start_index > dot_index) {\n        return \"No\";\n\
    \    }\n    std::string extension = file_name.substr(dot_index);\n    if (extension\
    \ != \"exe\" && extension != \"dll\" && extension != \"txt\") {\n        return\
    \ \"No\";\n    }\n    \n    return \"Yes\";\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp57r_bupt.cpp: In function 'int main()':\n/tmp/tmp57r_bupt.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp57r_bupt.cpp:2:\n/tmp/tmp57r_bupt.cpp:40:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Declare a boolean array to check if all the conditions are satisfied.\n\
    \    bool satisfied[5] = { false };\n\n    // Declare another boolean array to\
    \ store whether the file name is empty or has more than 3 digits.\n    bool empty_check[3]\
    \ = { false };\n\n    // Declare a variable that will store the substring before\
    \ the dot.\n    std::string dot_check;\n\n    // Declare a variable that will\
    \ store the substring after the dot.\n    std::string dot_check2;\n\n    // Declare\
    \ a boolean to check if the first character of the file's name is a latin alphapet\
    \ ('a'-'z' or 'A'-'Z').\n    bool check_letter;\n\n    // Declare a variable to\
    \ store the count of '0' - '9' in the file's name.\n    int number_check;\n\n\
    \    // Declare a variable to store the count of '.' in the file's name.\n   \
    \ int dot_check2;\n\n    // Declare a variable to store the count of '.' in file's\
    \ name.\n    int dot_count;\n\n    // Declare a variable that will store the count\
    \ of '0' - '9' in the file's name.\n    int number_check2;\n\n    // Declare a\
    \ variable that will store the count of '.' in the file's name.\n    int dot_count2;\n\
    \n    // Declare a boolean to check if the last character of the file's name is\
    \ a latin alphabet ('a'-'z' or 'A'-'Z').\n    bool check_letter2;\n\n    // Declare\
    \ a variable to store the count of '0' - '9' in the file's name.\n    int number_check3;\n\
    \n    // Declare a variable to store the count of '.' in the file's name.\n  \
    \  int dot_count3;\n\n    // Declare a variable that will store the count of '.'\
    \ in the file's name.\n    int dot_count3;\n\n    // Declare a variable that will\
    \ store the count of '.' in the file's name.\n    int dot_count4;\n\n    // Declare\
    \ a variable that will store the count of '.' in the file's name.\n    int dot_count5;\n\
    \n    // Declare a variable that will store the count of '.' in the file's name.\n\
    \    int dot_count6;\n\n    // Declare a variable that will store the count of\
    \ '.' in the file's name.\n    int dot_count7;\n\n    // Declare a variable that\
    \ will store the count of '.' in the file's name.\n    int dot_count8;\n\n   \
    \ // Declare a variable that will store the count of '.' in the file's name.\n\
    \    int dot_count9;\n\n    // Declare a variable that will store the count of\
    \ '.' in the file's name.\n    int dot_check4;\n\n    // Declare a variable that\
    \ will store the count of '.' in the file's name.\n    int dot_check5;\n\n   \
    \ // Declare a variable that will store the \n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzs_mfhi6.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpzs_mfhi6.cpp:35:9: error: conflicting declaration 'int dot_check2'\n \
    \    int dot_check2;\n         ^\n/tmp/tmpzs_mfhi6.cpp:26:17: error: 'dot_check2'\
    \ has a previous declaration as 'std::string dot_check2'\n     std::string dot_check2;\n\
    \                 ^\n/tmp/tmpzs_mfhi6.cpp:56:9: error: redeclaration of 'int dot_count3'\n\
    \     int dot_count3;\n         ^\n/tmp/tmpzs_mfhi6.cpp:53:9: error: 'int dot_count3'\
    \ previously declared here\n     int dot_count3;\n         ^\n/tmp/tmpzs_mfhi6.cpp:\
    \ In function 'int main()':\n/tmp/tmpzs_mfhi6.cpp:85:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzs_mfhi6.cpp:2:\n/tmp/tmpzs_mfhi6.cpp:86:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string file_check;\n    if (file_name.find_first_not_of(\"0123456789.\"\
    ) != std::string::npos) {\n        file_check = \"No\";\n    }\n    else if (file_name.find_first_not_of(\"\
    .\") == std::string::npos) {\n        file_check = \"No\";\n    }\n    else if\
    \ (file_name.substr(0, 1) != file_name.at(0) || file_name.substr(0, 1) != file_name.at(1))\
    \ {\n        file_check = \"No\";\n    }\n    else if (file_name.substr(0, 2)\
    \ == file_name.at(0) && file_name.substr(1, 2) == file_name.at(1) \n         \
    \   && file_name.substr(2) != \".txt\" && file_name.substr(2) != \".exe\" && file_name.substr(2)\
    \ != \".dll\"\n            && file_name.substr(2) != \".py\") {\n        file_check\
    \ = \"No\";\n    }\n    else if (file_name.find_first_of(\".\") == std::string::npos)\
    \ {\n        file_check = \"No\";\n    }\n    else if (file_name.at(0) != file_name.at(1)\
    \ || file_name.at(0) == file_name.at(1) \n            || file_name.at(0) == '0')\
    \ {\n        file_check = \"No\";\n    }\n    else if (file_name.at(0) != file_name.at(1)\
    \ || file_name.at(0) == file_name.at(1) \n            || file_name.at(0) == '1'\
    \ || file_name.at(0) == '2' || file_name.at(0) == '3' || \n            file_name.at(0)\
    \ == '4' || file_name.at(0) == '5' || file_name.at(0) == '6' || \n           \
    \ file_name.at(0) == '7' || file_name.at(0) == '8' || file_name.at(0) == '9')\
    \ {\n        file_check = \"No\";\n    }\n    else if (file_name.at(0) != file_name.at(1)\
    \ || file_name.at(0) == file_name.at(1) \n            || file_name.at(0) == 'A'\
    \ || file_name.at(0) == 'B' || file_name.at(0) == 'C' || \n            file_name.at(0)\
    \ == 'D' || file_name.at(0) == 'E' || file_name.at(0) == 'F' || \n           \
    \ file_name.at(0) == 'G' || file_name.at(0) == 'H' || file_name.at(0) == 'I' ||\
    \ \n            file_name.at(0) == 'J' || file_name.at(0) == 'K' || file_name.at(0)\
    \ == 'L' || \n            file_name.at(0) == 'M' || file_name.at(0) == 'N' ||\
    \ file_name.at(0) == 'O' || \n            file_name.at(0) == 'P' || file_name.at(0)\
    \ == 'Q' || file_name.at(0) == 'R' || \n            file_name.at(0) == 'S' ||\
    \ file_name.at(0) == 'T' || file_name.at(0) == 'U' || \n            file_name.at(0)\
    \ == 'V' || file_name.at(0) == '\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx6hp5qs7.cpp:52:58: warning: missing terminating ' character [enabled\
    \ by default]\n             file_name.at(0) == 'V' || file_name.at(0) == '\n \
    \                                                         ^\n/tmp/tmpx6hp5qs7.cpp:52:13:\
    \ error: missing terminating ' character\n             file_name.at(0) == 'V'\
    \ || file_name.at(0) == '\n             ^\n/tmp/tmpx6hp5qs7.cpp: In function 'std::string\
    \ file_name_check(std::string)':\n/tmp/tmpx6hp5qs7.cpp:23:37: error: no match\
    \ for 'operator!=' (operand types are 'std::basic_string<char>' and 'char')\n\
    \     else if (file_name.substr(0, 1) != file_name.at(0) || file_name.substr(0,\
    \ 1) != file_name.at(1)) {\n                                     ^\n/tmp/tmpx6hp5qs7.cpp:23:37:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpx6hp5qs7.cpp:2:\n/usr/include/c++/4.8.2/valarray:1180:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__not_equal_to, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__not_equal_to, _Tp>::result_type>\
    \ std::operator!=(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(!=,\
    \ __not_equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1180:1: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpx6hp5qs7.cpp:23:54: note: \
    \  mismatched types 'const std::valarray<_Tp>' and 'char'\n     else if (file_name.substr(0,\
    \ 1) != file_name.at(0) || file_name.substr(0, 1) != file_name.at(1)) {\n    \
    \                                                  ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpx6hp5qs7.cpp:2:\n/usr/include/c++/4.8.2/valarray:1180:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__not_equal_to, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__not_equal_to, _Tp>::result_type>\
    \ std::operator!=(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(!=,\
    \ __not_equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1180:1: note:   template\
    \ argu"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tint length = 0;\n\tint dot = 0;\n\tint i = 0;\n\t\n\tfor(i = 0; i < file_name.size()\
    \ ; i++) {\n\t\tif(file_name[i] == '.') {\n\t\t\tif(dot != 0) {\n\t\t\t\treturn\
    \ \"No\";\n\t\t\t}\n\t\t\tdot++;\n\t\t\tlength++;\n\t\t\tcontinue;\n\t\t}\n\t\t\
    else {\n\t\t\tif(length < 3) {\n\t\t\t\treturn \"No\";\n\t\t\t}\n\t\t\tlength\
    \ = 0;\n\t\t}\n\t}\n\t\n\tif(length <= 3) {\n\t\treturn \"No\";\n\t}\n\t\n\tif(dot\
    \ != 0) {\n\t\treturn \"No\";\n\t}\n\t\n\twhile(i < file_name.size()) {\n\t\t\
    if(!isalpha(file_name[i]) || !isupper(file_name[i])) {\n\t\t\treturn \"No\";\n\
    \t\t}\n\t\ti++;\n\t}\n\t\n\treturn \"Yes\";\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgxmrasyb.cpp: In function 'int main()':\n/tmp/tmpgxmrasyb.cpp:55:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgxmrasyb.cpp:2:\n/tmp/tmpgxmrasyb.cpp:56:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int index = file_name.find_last_of('.');\n    if (index != std::string::npos)\
    \ {\n        int index = file_name.find_last_of('.', index-1);\n        int index\
    \ = file_name.find_last_of('.', index-1);\n    }\n    if (index == std::string::npos)\
    \ {\n        return \"No\";\n    }\n    else if ((file_name[index-1] != '0') &&\
    \ (file_name[index-1] != '1') &&\n            (file_name[index-1] != '2') && (file_name[index-1]\
    \ != '3') &&\n            (file_name[index-1] != '4') && (file_name[index-1] !=\
    \ '5') &&\n            (file_name[index-1] != '6') && (file_name[index-1] != '7')\
    \ &&\n            (file_name[index-1] != '8') && (file_name[index-1] != '9'))\
    \ {\n        return \"No\";\n    }\n    else if ((file_name[index-1] != '0') &&\
    \ (file_name[index-1] != '1') &&\n            (file_name[index-1] != '2') && (file_name[index-1]\
    \ != '3') &&\n            (file_name[index-1] != '4') && (file_name[index-1] !=\
    \ '5') &&\n            (file_name[index-1] != '6') && (file_name[index-1] != '7')\
    \ &&\n            (file_name[index-1] != '8') && (file_name[index-1] != '9'))\
    \ {\n        return \"No\";\n    }\n    else {\n        return \"Yes\";\n    }\n\
    }\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaqxdh3us.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpaqxdh3us.cpp:19:13: error: redeclaration of 'int index'\n         int\
    \ index = file_name.find_last_of('.', index-1);\n             ^\n/tmp/tmpaqxdh3us.cpp:18:13:\
    \ error: 'int index' previously declared here\n         int index = file_name.find_last_of('.',\
    \ index-1);\n             ^\n/tmp/tmpaqxdh3us.cpp: In function 'int main()':\n\
    /tmp/tmpaqxdh3us.cpp:43:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = file_name_check;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpaqxdh3us.cpp:2:\n/tmp/tmpaqxdh3us.cpp:44:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tint num_digits = 0;\n\tfor (int i = 0; i < file_name.length(); i++) {\n\
    \t\tif (file_name[i] < '0' || file_name[i] > '9')\n\t\t\treturn \"No\";\n\t\t\
    num_digits++;\n\t\tif (num_digits > 3)\n\t\t\treturn \"No\";\n\t}\n\tif ((file_name[file_name.length()-1]\
    \ == '.')||\n\t\t(file_name[file_name.length()-1] == '/'))\n\t\treturn \"No\"\
    ;\n\tif (file_name[0] < 'a' || file_name[0] > 'z')\n\t\treturn \"No\";\n\tif (file_name[file_name.length()-1]\
    \ < 'a' || file_name[file_name.length()-1] > 'z'\n\t\t|| file_name[0] != file_name[file_name.length()-1]\
    \ || file_name[0] != '.')\n\t\treturn \"No\";\n\tfor (int i = 1; i < file_name.length()-1;\
    \ i++) {\n\t\tif (file_name[i] < 'a' || file_name[i] > 'z')\n\t\t\treturn \"No\"\
    ;\n\t\tif (file_name[i-1] < 'a' || file_name[i-1] > 'z')\n\t\t\treturn \"No\"\
    ;\n\t\tif (file_name[i] != file_name[i-1])\n\t\t\treturn \"No\";\n\t}\n\tif (file_name[file_name.length()-1]\
    \ < 'a' || file_name[file_name.length()-1] > 'z')\n\t\treturn \"No\";\n\treturn\
    \ \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6vgylczt.cpp: In function 'int main()':\n/tmp/tmp6vgylczt.cpp:45:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6vgylczt.cpp:2:\n/tmp/tmp6vgylczt.cpp:46:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // your code here\n    bool invalid = false;\n    std::string name_without_extension;\n\
    \    name_without_extension = file_name.substr(0, file_name.find_last_of(\".\"\
    ));\n    if(name_without_extension.find_first_not_of(\"0123456789\") == std::string::npos)\
    \ {\n        return \"No\";\n    }\n    if(name_without_extension.find_first_of(\"\
    .\") == std::string::npos && name_without_extension[0] != '.') {\n        return\
    \ \"No\";\n    }\n    if(name_without_extension.find_first_of(\".\") != std::string::npos\
    \ && name_without_extension[0] != '.') {\n        return \"Yes\";\n    }\n   \
    \ if(name_without_extension[0] != '.' && name_without_extension.find_first_not_of(\"\
    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\") == std::string::npos)\
    \ {\n        return \"No\";\n    }\n    if(file_name.find_last_of(\".\") != std::string::npos)\
    \ {\n        return \"No\";\n    }\n    if(file_name.find_first_not_of(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ) == std::string::npos) {\n        return \"Yes\";\n    }\n    return \"No\";\n\
    }\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4oijmfqn.cpp: In function 'int main()':\n/tmp/tmp4oijmfqn.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4oijmfqn.cpp:2:\n/tmp/tmp4oijmfqn.cpp:42:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  std::set<std::string> valid_extensions = {\"txt\",\"exe\",\"dll\"};\n \
    \ int dot_count = 0;\n  // Check if there are more than 3 digits (digits are considered\
    \ to be one character in \n  // English)\n  if (file_name.length() < 3) {\n  \
    \  return \"NO\";\n  }\n  // Check if there are exactly 1 dot ('.'), if there\
    \ are, then...\n  if (file_name.find(\".\") != std::string::npos) {\n    // Check\
    \ if there is a dot before the extension, if there are, then the dot is\n    //\
    \ invalid\n    if (file_name.find(\".\") == 0) {\n      return \"NO\";\n    }\n\
    \    // Check if there is a dot after the extension, if there are, then the dot\
    \ is\n    // invalid\n    if (file_name.find(\".\") == file_name.length()-1) {\n\
    \      return \"NO\";\n    }\n    // Check the substring before the dot, and check\
    \ if it is alphabetic.\n    if (file_name.substr(0,1) < 'a' || file_name.substr(0,1)\
    \ > 'z') {\n      return \"NO\";\n    }\n  }\n  // Check if there is an extension\
    \ in the file's name\n  if (file_name.find(\".\") == std::string::npos && valid_extensions.find(file_name)\
    \ !=\n      std::string::npos) {\n    return \"Yes\";\n  }\n  \n  return \"No\"\
    ;\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplom8hy9w.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmplom8hy9w.cpp:16:62: error: in C++98 'valid_extensions' must be initialized\
    \ by constructor, not by '{...}'\n   std::set<std::string> valid_extensions =\
    \ {\"txt\",\"exe\",\"dll\"};\n                                               \
    \               ^\n/tmp/tmplom8hy9w.cpp:16:62: error: could not convert '{\"txt\"\
    , \"exe\", \"dll\"}' from '<brace-enclosed initializer list>' to 'std::set<std::basic_string<char>\
    \ >'\n/tmp/tmplom8hy9w.cpp:36:31: error: no match for 'operator<' (operand types\
    \ are 'std::basic_string<char>' and 'char')\n     if (file_name.substr(0,1) <\
    \ 'a' || file_name.substr(0,1) > 'z') {\n                               ^\n/tmp/tmplom8hy9w.cpp:36:31:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmplom8hy9w.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type>\
    \ std::operator<(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(<,\
    \ __less)\n ^\n/usr/include/c++/4.8.2/valarray:1181:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmplom8hy9w.cpp:36:33: note:   mismatched\
    \ types 'const std::valarray<_Tp>' and 'char'\n     if (file_name.substr(0,1)\
    \ < 'a' || file_name.substr(0,1) > 'z') {\n                                 ^\n\
    In file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmplom8hy9w.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type>\
    \ std::operator<(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(<,\
    \ __less)\n ^\n/usr/include/c++/4.8.2/valarray:1181:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmplom8hy9w.cpp:36:33: note:   'std::basic_string<char>'"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Your code goes here\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp49l3z4o4.cpp: In function 'int main()':\n/tmp/tmp49l3z4o4.cpp:19:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp49l3z4o4.cpp:2:\n/tmp/tmp49l3z4o4.cpp:20:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  std::map<char, int> number_map;\n  std::map<char, int>::iterator number_map_itr\
    \ = number_map.begin();\n  for (char c : file_name) {\n    if (std::isdigit(c))\
    \ \n      number_map[c]++;\n    else \n      number_map[std::tolower(c)]++;\n\
    \  }\n  if (number_map['.'] == 1 && number_map['0'] == 1)\n    return 'No';\n\
    \  else if (number_map['.'] > 2)\n    return 'No';\n  else if (number_map['.']\
    \ > 1)\n    return 'Yes';\n  else\n    return 'Yes';\n}\nint main() {\n    auto\
    \ candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"\
    Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbulfo6wf.cpp:25:12: warning: multi-character character constant\
    \ [-Wmultichar]\n     return 'No';\n            ^\n/tmp/tmpbulfo6wf.cpp:27:12:\
    \ warning: multi-character character constant [-Wmultichar]\n     return 'No';\n\
    \            ^\n/tmp/tmpbulfo6wf.cpp:29:12: warning: multi-character character\
    \ constant [-Wmultichar]\n     return 'Yes';\n            ^\n/tmp/tmpbulfo6wf.cpp:31:12:\
    \ warning: multi-character character constant [-Wmultichar]\n     return 'Yes';\n\
    \            ^\n/tmp/tmpbulfo6wf.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpbulfo6wf.cpp:18:17: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n   for (char c : file_name) {\n                 ^\n/tmp/tmpbulfo6wf.cpp:25:12:\
    \ error: invalid conversion from 'int' to 'const char*' [-fpermissive]\n     return\
    \ 'No';\n            ^\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n\
    \                 from /usr/include/c++/4.8.2/bitset:47,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n             \
    \    from /tmp/tmpbulfo6wf.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmpbulfo6wf.cpp:27:12: error: invalid conversion from\
    \ 'int' to 'const char*' [-fpermissive]\n     return 'No';\n            ^\nIn\
    \ file included from /usr/include/c++/4.8.2/string:53:0,\n                 from\
    \ /usr/include/c++/4.8.2/bitset:47,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbulfo6wf.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     b"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  std::cin >> file_name;\n  // Your code goes here\n  if (file_name.size()\
    \ > 3 && file_name.substr(0, 1) != \".\" \n      && file_name[0] != 'a' && file_name[0]\
    \ != 'A' \n      && file_name[1] != 'e' && file_name[1] != 'E' \n      && file_name[2]\
    \ != 's' && file_name[2] != 'S') {\n    return \"No\";\n  }\n  else {\n    return\
    \ \"Yes\";\n  }\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt14bf9zm.cpp: In function 'int main()':\n/tmp/tmpt14bf9zm.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt14bf9zm.cpp:2:\n/tmp/tmpt14bf9zm.cpp:30:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  int counter = 0;\n  counter = file_name.size();\n  if(counter>=4){\n  \
    \  return file_name;\n  }\n  if(counter==3){\n    if(file_name[0]>='a' && file_name[0]<='z'){\n\
    \      return file_name;\n    }\n    else{\n      return 'No';\n    }\n  }\n \
    \ if(counter==2){\n    if(file_name[0]>='A' && file_name[0]<='Z'){\n      return\
    \ file_name;\n    }\n    else{\n      return 'No';\n    }\n  }\n  return 'No';\n\
    }\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppplwoktg.cpp:26:14: warning: multi-character character constant\
    \ [-Wmultichar]\n       return 'No';\n              ^\n/tmp/tmppplwoktg.cpp:34:14:\
    \ warning: multi-character character constant [-Wmultichar]\n       return 'No';\n\
    \              ^\n/tmp/tmppplwoktg.cpp:37:10: warning: multi-character character\
    \ constant [-Wmultichar]\n   return 'No';\n          ^\n/tmp/tmppplwoktg.cpp:\
    \ In function 'std::string file_name_check(std::string)':\n/tmp/tmppplwoktg.cpp:26:14:\
    \ error: invalid conversion from 'int' to 'const char*' [-fpermissive]\n     \
    \  return 'No';\n              ^\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n\
    \                 from /usr/include/c++/4.8.2/bitset:47,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n             \
    \    from /tmp/tmppplwoktg.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmppplwoktg.cpp:34:14: error: invalid conversion from\
    \ 'int' to 'const char*' [-fpermissive]\n       return 'No';\n              ^\n\
    In file included from /usr/include/c++/4.8.2/string:53:0,\n                 from\
    \ /usr/include/c++/4.8.2/bitset:47,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppplwoktg.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmppplwoktg.cpp:37:10: error: invalid conversion from\
    \ 'int' to 'const char*' [-fpermissive]\n   return 'No';\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/string:53:0,\n                 "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  int count = 0;\n  for (int i = 0; i < file_name.size(); i++) {\n    if\
    \ (file_name[i] >= '0' && file_name[i] <= '9') {\n      count++;\n    } else if\
    \ (file_name[i] == '.') {\n      if (i > 0 && file_name[i-1] >= 'a' && file_name[i-1]\
    \ <= 'z') {\n        count++;\n      }\n    }\n  }\n  if (file_name.size() !=\
    \ count) {\n    return \"No\";\n  }\n  int pos = file_name.find('.');\n  if (pos\
    \ == std::string::npos) {\n    return \"No\";\n  }\n  std::string file = file_name.substr(0,\
    \ pos);\n  std::string extension = file_name.substr(pos+1);\n  if (extension !=\
    \ \"txt\" && extension != \"exe\" && extension != \"dll\") {\n    return \"No\"\
    ;\n  }\n  if (file != \"example\" && file != \"1example\") {\n    return \"No\"\
    ;\n  }\n  return \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt1ei0ah_.cpp: In function 'int main()':\n/tmp/tmpt1ei0ah_.cpp:44:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt1ei0ah_.cpp:2:\n/tmp/tmpt1ei0ah_.cpp:45:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Initialize your variables here.\n    std::string file_extension =\
    \ \"\";\n    std::string file_name_before = \"\";\n    std::string file_name_after\
    \ = \"\";\n\n    // Compute your variables here.\n    // Use of 'assert' statement\
    \ is recommended.\n    assert(file_name.size() > 4);\n    assert(file_name.find('\
    \ ') == std::string::npos);\n    assert(file_name.find_first_of(\".\") == 0);\n\
    \    assert(file_name.find_last_of(\".\") != std::string::npos);\n    assert(file_name_before\
    \ != \"\");\n    assert(file_name_after != \"\");\n    assert(!file_name_before.empty());\n\
    \    assert(file_name_after.find(\"txt\") != std::string::npos);\n    assert(file_name_after.find(\"\
    exe\") != std::string::npos);\n    assert(file_name_after.find(\"dll\") != std::string::npos);\n\
    \    assert(file_name_extension == \"\");\n\n    // Return the computed value.\n\
    \    return \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "In file included from /usr/include/c++/4.8.2/cassert:43:0,\n          \
    \       from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n  \
    \               from /tmp/tmp36xw2uej.cpp:2:\n/tmp/tmp36xw2uej.cpp: In function\
    \ 'std::string file_name_check(std::string)':\n/tmp/tmp36xw2uej.cpp:33:12: error:\
    \ 'file_name_extension' was not declared in this scope\n     assert(file_name_extension\
    \ == \"\");\n            ^\n/tmp/tmp36xw2uej.cpp: In function 'int main()':\n\
    /tmp/tmp36xw2uej.cpp:39:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = file_name_check;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp36xw2uej.cpp:2:\n/tmp/tmp36xw2uej.cpp:40:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Your code goes here\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpprgi4qho.cpp: In function 'int main()':\n/tmp/tmpprgi4qho.cpp:19:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpprgi4qho.cpp:2:\n/tmp/tmpprgi4qho.cpp:20:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Write your code here\n  return \"No\";\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpw93dpmlx.cpp: In function 'int main()':\n/tmp/tmpw93dpmlx.cpp:20:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpw93dpmlx.cpp:2:\n/tmp/tmpw93dpmlx.cpp:21:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int count = 0;\n    for (int i = 0; i < file_name.length(); i++) {\n\
    \        if (file_name[i] >= 'a' && file_name[i] <= 'z') {\n            count\
    \ += 1;\n        } else if (file_name[i] >= 'A' && file_name[i] <= 'Z') {\n  \
    \          count += 1;\n        } else if (file_name[i] == '.') {\n          \
    \  if (file_name.length() > i + 1) {\n                char a = file_name[i+1];\n\
    \                if (a >= 'a' && a <= 'z') {\n                    count += 1;\n\
    \                } else if (a >= 'A' && a <= 'Z') {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    if (count >=\
    \ 3 && count == file_name.length() - 1) {\n        if (std::count(file_name.begin(),\
    \ file_name.begin() + 1, '.') != 0) {\n            std::string sub_string = file_name.substr(0,\
    \ 1);\n            if (std::count(sub_string.begin(), sub_string.end(), '.') !=\
    \ 0 &&\n                std::count(sub_string.begin(), sub_string.end(), 'a')\
    \ == 0 &&\n                std::count(sub_string.begin(), sub_string.end(), 'A')\
    \ == 0) {\n                return \"Yes\";\n            }\n        }\n    }\n\
    \    return \"No\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp794fzem5.cpp: In function 'int main()':\n/tmp/tmp794fzem5.cpp:46:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp794fzem5.cpp:2:\n/tmp/tmp794fzem5.cpp:47:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int digits = fileName.find_first_not_of(\"0123456789\");\n    int dots\
    \ = fileName.find_first_of(\".\");\n    std::string first_letter = fileName.substr(0,\
    \ 1);\n    std::string extension = fileName.substr(fileName.find_last_of(\".\"\
    ) + 1, fileName.length());\n    if (digits == -1 || digits > 3) {\n        return\
    \ \"No\";\n    }\n    if (dots == -1) {\n        return \"No\";\n    }\n    if\
    \ (first_letter == \"\") {\n        return \"No\";\n    }\n    if (first_letter[0]\
    \ >= 'a' && first_letter[0] <= 'z') {\n        return \"No\";\n    }\n    if (first_letter[0]\
    \ >= 'A' && first_letter[0] <= 'Z') {\n        return \"No\";\n    }\n    if (extension\
    \ == \"\") {\n        return \"No\";\n    }\n    if (extension == \"txt\" || extension\
    \ == \"exe\" || extension == \"dll\") {\n        return \"Yes\";\n    }\n    return\
    \ \"No\";\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp663yspfq.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp663yspfq.cpp:16:18: error: 'fileName' was not declared in this scope\n\
    \     int digits = fileName.find_first_not_of(\"0123456789\");\n             \
    \     ^\n/tmp/tmp663yspfq.cpp: In function 'int main()':\n/tmp/tmp663yspfq.cpp:44:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp663yspfq.cpp:2:\n/tmp/tmp663yspfq.cpp:45:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int length = file_name.length();\n    if (length < 3)\n        return\
    \ \"No\";\n    if (file_name.substr(0, 1) != \".\" || \n        file_name[length-1]\
    \ != '.' || \n        !((file_name[0] >= 'a' && file_name[0] <= 'z') || (file_name[0]\
    \ >= 'A' && file_name[0] <= 'Z')) || \n        ((file_name[1] >= 'a' && file_name[1]\
    \ <= 'z') || (file_name[1] >= 'A' && file_name[1] <= 'Z') &&\n         file_name[2]\
    \ >= 'a' && file_name[2] <= 'z') || (file_name[1] >= 'A' && file_name[1] <= 'Z')\
    \ &&\n         file_name[2] >= 'A' && file_name[2] <= 'Z'))\n        return \"\
    No\";\n    return \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprj8wns3w.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmprj8wns3w.cpp:24:53: error: expected primary-expression before ')' token\n\
    \          file_name[2] >= 'A' && file_name[2] <= 'Z'))\n                    \
    \                                 ^\n/tmp/tmprj8wns3w.cpp:24:53: error: expected\
    \ ';' before ')' token\n/tmp/tmprj8wns3w.cpp: In function 'int main()':\n/tmp/tmprj8wns3w.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprj8wns3w.cpp:2:\n/tmp/tmprj8wns3w.cpp:30:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Write your solution here.\n    \n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4435d3v2.cpp: In function 'int main()':\n/tmp/tmp4435d3v2.cpp:20:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4435d3v2.cpp:2:\n/tmp/tmp4435d3v2.cpp:21:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Your code goes here\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpoayhubt5.cpp: In function 'int main()':\n/tmp/tmpoayhubt5.cpp:19:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpoayhubt5.cpp:2:\n/tmp/tmpoayhubt5.cpp:20:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  assert(file_name.size() >= 3 && file_name.find(\".\") == file_name.size()\
    \ - 1);\n  assert(file_name.find(\".\") == 0);\n  assert(file_name[0] <= 'z' &&\
    \ file_name[0] <= 'Z');\n  assert(file_name.length() == 2 && file_name[1] == '.');\n\
    \  if (file_name.find(\"exe\") == 0)\n    return \"Yes\";\n  if (file_name.find(\"\
    dll\") == 0)\n    return \"Yes\";\n  \n  return \"No\";\n}\nint main() {\n   \
    \ auto candidate = file_name_check;\n    assert(candidate((\"example.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgt5lv654.cpp: In function 'int main()':\n/tmp/tmpgt5lv654.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgt5lv654.cpp:2:\n/tmp/tmpgt5lv654.cpp:29:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code here\n    \n    // return 'Yes' if file_name's length is\
    \ less than 3 and 'Yes' if the length of file\n    // name is less than or equal\
    \ to 3 and if 'exe' or 'dll' substring is not present in \n    // file_name\n\
    \    return file_name.size() <= 3 ? \"Yes\" : \"No\";\n}\nint main() {\n    auto\
    \ candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"\
    Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnnk_dbd0.cpp: In function 'int main()':\n/tmp/tmpnnk_dbd0.cpp:24:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnnk_dbd0.cpp:2:\n/tmp/tmpnnk_dbd0.cpp:25:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code here\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp09pprhvx.cpp: In function 'int main()':\n/tmp/tmp09pprhvx.cpp:19:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp09pprhvx.cpp:2:\n/tmp/tmp09pprhvx.cpp:20:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tif (file_name.size() > 3 || file_name.find('.') == std::string::npos) {\n\
    \t\treturn \"No\";\n\t}\n\tstd::string first_name = file_name.substr(0, file_name.find('.')\
    \ - 1);\n\tif (first_name.find_first_not_of(\" ABCDEFGHIJKLMNOPQRSTUVWXYZ\") ==\
    \ std::string::npos) {\n\t\treturn \"No\";\n\t}\n\tstd::string last_name = file_name.substr(file_name.find('.')\
    \ + 1);\n\tif (last_name.size() > 4 || last_name.find('.') == std::string::npos)\
    \ {\n\t\treturn \"No\";\n\t}\n\tstd::string extension = last_name.substr(last_name.find('.')\
    \ + 1);\n\tif (extension == \"txt\" || extension == \"exe\" || extension == \"\
    dll\") {\n\t\treturn \"Yes\";\n\t}\n\treturn \"No\";\n}\nint main() {\n    auto\
    \ candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"\
    Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaw3cmoi6.cpp: In function 'int main()':\n/tmp/tmpaw3cmoi6.cpp:34:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpaw3cmoi6.cpp:2:\n/tmp/tmpaw3cmoi6.cpp:35:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code here\n    bool is_valid;\n    for(int i = 0;i < file_name.length();\
    \ i++) {\n        if(file_name[i] < 'a' || file_name[i] > 'z') {\n           \
    \ is_valid = false;\n            break;\n        }\n        if(file_name[i] <\
    \ 'A' || file_name[i] > 'Z') {\n            is_valid = false;\n            break;\n\
    \        }\n        if(file_name[i] == '.') {\n            if(i != file_name.size()-1)\
    \ {\n                is_valid = false;\n                break;\n            }\n\
    \        }\n        \n    }\n    \n    return is_valid ? std::string(\"Yes\")\
    \ : std::string(\"No\");\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpox0r380p.cpp: In function 'int main()':\n/tmp/tmpox0r380p.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpox0r380p.cpp:2:\n/tmp/tmpox0r380p.cpp:40:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int i;\n    for (i = 0; i < file_name.length(); i++) {\n        if (file_name[i]\
    \ < '0' || file_name[i] > '9') {\n            return file_name;\n        }\n \
    \   }\n    \n    if (file_name.find_first_not_of(\"0123456789\") != std::string::npos)\
    \ {\n        return file_name;\n    }\n    \n    if (file_name.find_first_of(\"\
    .\") == 0) {\n        return file_name;\n    }\n    \n    for (i = 0; i < file_name.length();\
    \ i++) {\n        if (file_name[i] < 'a' || file_name[i] > 'z') {\n          \
    \  return file_name;\n        }\n    }\n    \n    return file_name;\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9920wnnp.cpp: In function 'int main()':\n/tmp/tmp9920wnnp.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9920wnnp.cpp:2:\n/tmp/tmp9920wnnp.cpp:41:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int dotIndex = file_name.find_last_of(\".\");\n    // If the file name's\
    \ number of characters is more than three, we cannot decide if \n    // the file's\
    \ name is valid.\n    if(file_name.size() > 3) {\n        return \"No\";\n   \
    \ }\n    // If there are more than 2 dots in the file name, we cannot decide if\
    \ the file's \n    // name is valid.\n    if(dotIndex == string::npos) {\n   \
    \     return \"No\";\n    }\n    // We know that the file's name does not contain\
    \ more than one dot\n    if(file_name.find(\".\") == dotIndex - 1) {\n       \
    \ return \"No\";\n    }\n    // We know that the file's name doesn't contain any\
    \ dot in the first and last index\n    if(file_name[0] != 'a' || file_name[1]\
    \ != 'z' || file_name[file_name.size() - 1] != 'z') {\n        return \"No\";\n\
    \    }\n    // If any characters in the file's name are not from latin alphapet,\
    \ we cannot decide \n    // if the file's name is valid.\n    for(int i = 0; i\
    \ < file_name.size(); i++) {\n        if(file_name[i] < 'a' || file_name[i] >\
    \ 'z' || file_name[i] < 'A' || file_name[i] > 'Z') {\n            return \"No\"\
    ;\n        }\n    }\n    return \"Yes\";\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpd7kkutb4.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpd7kkutb4.cpp:24:20: error: 'string' has not been declared\n     if(dotIndex\
    \ == string::npos) {\n                    ^\n/tmp/tmpd7kkutb4.cpp: In function\
    \ 'int main()':\n/tmp/tmpd7kkutb4.cpp:45:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = file_name_check;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd7kkutb4.cpp:2:\n/tmp/tmpd7kkutb4.cpp:46:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Declare a variable to hold the number of digits (0-9) in the file's\
    \ name.\n  int num_digits = 0;\n  \n  // Declare a variable to hold the character\
    \ at the start of the file's name.\n  char first_letter = 'a';\n  \n  // Declare\
    \ a variable to hold the character at the end (one past the last) of the file's\
    \ name.\n  char last_letter = 'z';\n  \n  // Declare a variable to hold the number\
    \ of consecutive occurrences of 'dot '.\n  int consecutive_dots = 0;\n  \n  //\
    \ Declare a variable to hold the number of consecutive occurrences of 'exe a '.\n\
    \  int consecutive_exes = 0;\n  \n  // Declare a variable to hold the number of\
    \ consecutive occurrences of 'dll '.\n  int consecutive_dlls = 0;\n  \n  // Iterate\
    \ through every character in the file's name.\n  for (int i = 0; i < file_name.length();\
    \ i++) {\n    // Check the character at the current position.\n    char letter\
    \ = file_name[i];\n    \n    // If the current character is a digit, add it to\
    \ the number of digits.\n    if (std::isdigit(letter)) {\n      num_digits +=\
    \ 1;\n    }\n    \n    // If the current character is a dot, add it to the number\
    \ of consecutive dots.\n    if (letter == '.') {\n      consecutive_dots += 1;\n\
    \    }\n    \n    // If the current character is 'exe a ', add it to the number\
    \ of consecutive exes.\n    if (letter == 'e x e ') {\n      consecutive_exes\
    \ += 1;\n    }\n    \n    // If the current character is 'dll ', add it to the\
    \ number of consecutive dlls.\n    if (letter == 'd l l ') {\n      consecutive_dlls\
    \ += 1;\n    }\n    \n    // If the current character is not a digit, check if\
    \ the previous character is a dot, a \n    // 'exe a ', or a 'dll '. If it isn't,\
    \ then check if the previous character is \n    // 'a or an alphabet'. All these\
    \ conditions are met, increment the variable by 1, \n    // otherwise, increment\
    \ the variable by 0.\n    if ((i != 0) && (letter == ' ') && ((file_name[i-1]\
    \ == '.') || (file_name[i-1] == 'e x e ') || (file_name[i-1] == 'd l l '))) {\n\
    \      if (((i-1) != 0) && !((file_name[i-1] == '.') || (file_name[i-1] == 'e\
    \ x e ') || (file_name[i-1] == 'd l l '))) {\n        letter = file_name[i-1];\n\
    \      }\n      letter++;\n      consecutive_dots++;\n    }\n    \n    // If the\
    \ current character is not a digit, check if the previous character is a 'a or\
    \ an \n    // alphabet'. All these conditions are met, increment the variable\
    \ by 1, otherwise, \n    // increment the \n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdsw1abey.cpp:50:19: warning: character constant too long for its\
    \ type [enabled by default]\n     if (letter == 'e x e ') {\n                \
    \   ^\n/tmp/tmpdsw1abey.cpp:55:19: warning: character constant too long for its\
    \ type [enabled by default]\n     if (letter == 'd l l ') {\n                \
    \   ^\n/tmp/tmpdsw1abey.cpp:63:87: warning: character constant too long for its\
    \ type [enabled by default]\n     if ((i != 0) && (letter == ' ') && ((file_name[i-1]\
    \ == '.') || (file_name[i-1] == 'e x e ') || (file_name[i-1] == 'd l l '))) {\n\
    \                                                                            \
    \           ^\n/tmp/tmpdsw1abey.cpp:63:119: warning: character constant too long\
    \ for its type [enabled by default]\n     if ((i != 0) && (letter == ' ') && ((file_name[i-1]\
    \ == '.') || (file_name[i-1] == 'e x e ') || (file_name[i-1] == 'd l l '))) {\n\
    \                                                                            \
    \                                           ^\n/tmp/tmpdsw1abey.cpp:64:75: warning:\
    \ character constant too long for its type [enabled by default]\n       if (((i-1)\
    \ != 0) && !((file_name[i-1] == '.') || (file_name[i-1] == 'e x e ') || (file_name[i-1]\
    \ == 'd l l '))) {\n                                                         \
    \                  ^\n/tmp/tmpdsw1abey.cpp:64:107: warning: character constant\
    \ too long for its type [enabled by default]\n       if (((i-1) != 0) && !((file_name[i-1]\
    \ == '.') || (file_name[i-1] == 'e x e ') || (file_name[i-1] == 'd l l '))) {\n\
    \                                                                            \
    \                               ^\n/tmp/tmpdsw1abey.cpp: In function 'std::string\
    \ file_name_check(std::string)':\n/tmp/tmpdsw1abey.cpp:75:12: error: a function-definition\
    \ is not allowed here before '{' token\n int main() {\n            ^\n/tmp/tmpdsw1abey.cpp:103:1:\
    \ error: expected '}' at end of input\n }\n ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  std::cerr << \"file_name_check: \" << file_name << std::endl;\n  assert(file_name.size()\
    \ <= 3);\n  std::cerr << \"file_name_check: \" << file_name << std::endl;\n  assert(file_name[0]\
    \ == 'a' || file_name[0] == 'A');\n  std::cerr << \"file_name_check: \" << file_name\
    \ << std::endl;\n  assert(file_name[1] == '.');\n  std::cerr << \"file_name_check:\
    \ \" << file_name << std::endl;\n  assert(!file_name[2].empty());\n  std::cerr\
    \ << \"file_name_check: \" << file_name << std::endl;\n  assert(file_name[2].size()\
    \ <= 3);\n  std::cerr << \"file_name_check: \" << file_name << std::endl;\n  assert(file_name[2][0]\
    \ == 't' || file_name[2][0] == 'T' || file_name[2][0] == 'e' || file_name[2][0]\
    \ == 'E');\n  std::cerr << \"file_name_check: \" << file_name << std::endl;\n\
    \  assert(file_name[2][1] == 'x' || file_name[2][1] == 'X' || file_name[2][1]\
    \ == 'e' || file_name[2][1] == 'E');\n  std::cerr << \"file_name_check: \" <<\
    \ file_name << std::endl;\n  assert(file_name[2][2] == 'f' || file_name[2][2]\
    \ == 'F' || file_name[2][2] == 'i' || file_name[2][2] == 'I' || file_name[2][2]\
    \ == 'l' || file_name[2][2] == 'L' || file_name[2][2] == 'o' || file_name[2][2]\
    \ == 'O' || file_name[2][2] == 'r' || file_name[2][2] == 'R' || file_name[2][2]\
    \ == 'y' || file_name[2][2] == 'Y' || file_name[2][2] == '.');\n  std::cerr <<\
    \ \"file_name_check: \" << file_name << std::endl;\n  std::string file_ext = file_name.substr(file_name.find_last_of('.'),\
    \ file_name.size());\n  std::cerr << \"file_name_check: \" << file_name << std::endl;\n\
    \  assert(file_ext == \"txt\" || file_ext == \"exe\" || file_ext == \"dll\");\n\
    \  std::cerr << \"file_name_check: \" << file_name << std::endl;\n  return \"\
    Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "In file included from /usr/include/c++/4.8.2/cassert:43:0,\n          \
    \       from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n  \
    \               from /tmp/tmp3euic5bg.cpp:2:\n/tmp/tmp3euic5bg.cpp: In function\
    \ 'std::string file_name_check(std::string)':\n/tmp/tmp3euic5bg.cpp:23:24: error:\
    \ request for member 'empty' in 'file_name.std::basic_string<_CharT, _Traits,\
    \ _Alloc>::operator[]<char, std::char_traits<char>, std::allocator<char> >(2ul)',\
    \ which is of non-class type 'char'\n   assert(!file_name[2].empty());\n     \
    \                   ^\n/tmp/tmp3euic5bg.cpp:25:23: error: request for member 'size'\
    \ in 'file_name.std::basic_string<_CharT, _Traits, _Alloc>::operator[]<char, std::char_traits<char>,\
    \ std::allocator<char> >(2ul)', which is of non-class type 'char'\n   assert(file_name[2].size()\
    \ <= 3);\n                       ^\n/tmp/tmp3euic5bg.cpp:27:24: error: invalid\
    \ types 'char[int]' for array subscript\n   assert(file_name[2][0] == 't' || file_name[2][0]\
    \ == 'T' || file_name[2][0] == 'e' || file_name[2][0] == 'E');\n             \
    \           ^\n/tmp/tmp3euic5bg.cpp:27:50: error: invalid types 'char[int]' for\
    \ array subscript\n   assert(file_name[2][0] == 't' || file_name[2][0] == 'T'\
    \ || file_name[2][0] == 'e' || file_name[2][0] == 'E');\n                    \
    \                              ^\n/tmp/tmp3euic5bg.cpp:27:76: error: invalid types\
    \ 'char[int]' for array subscript\n   assert(file_name[2][0] == 't' || file_name[2][0]\
    \ == 'T' || file_name[2][0] == 'e' || file_name[2][0] == 'E');\n             \
    \                                                               ^\n/tmp/tmp3euic5bg.cpp:27:102:\
    \ error: invalid types 'char[int]' for array subscript\n   assert(file_name[2][0]\
    \ == 't' || file_name[2][0] == 'T' || file_name[2][0] == 'e' || file_name[2][0]\
    \ == 'E');\n                                                                 \
    \                                     ^\n/tmp/tmp3euic5bg.cpp:29:24: error: invalid\
    \ types 'char[int]' for array subscript\n   assert(file_name[2][1] == 'x' || file_name[2][1]\
    \ == 'X' || file_name[2][1] == 'e' || file_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int digits;\n    if (file_name.length() > 3) {\n        return std::to_string(file_name);\n\
    \    }\n    if (file_name.length() == 0) {\n        return std::to_string(file_name);\n\
    \    }\n    if (file_name.at(0) != 'a' && file_name.at(0) != 'b' && file_name.at(0)\
    \ != 'c' && file_name.at(0) != 'd' && file_name.at(0) != 'e' && file_name.at(0)\
    \ != 'f' && file_name.at(0) != 'g' && file_name.at(0) != 'h' && file_name.at(0)\
    \ != 'i' && file_name.at(0) != 'j' && file_name.at(0) != 'k' && file_name.at(0)\
    \ != 'l' && file_name.at(0) != 'm' && file_name.at(0) != 'n' && file_name.at(0)\
    \ != 'o' && file_name.at(0) != 'p' && file_name.at(0) != 'q' && file_name.at(0)\
    \ != 'r' && file_name.at(0) != 's' && file_name.at(0) != 't' && file_name.at(0)\
    \ != 'u' && file_name.at(0) != 'v' && file_name.at(0) != 'w' && file_name.at(0)\
    \ != 'x' && file_name.at(0) != 'y' && file_name.at(0) != 'z') {\n        return\
    \ std::to_string(file_name);\n    }\n    std::string first_word = file_name.substr(0,\
    \ 1);\n    if (file_name.length() == 1) {\n        return std::to_string(file_name);\n\
    \    }\n    if (first_word.length() != 1) {\n        return std::to_string(file_name);\n\
    \    }\n    if (file_name.at(1) != '.') {\n        return std::to_string(file_name);\n\
    \    }\n    if (file_name.at(2) != '.') {\n        return std::to_string(file_name);\n\
    \    }\n    \n    std::transform(first_word.begin(), first_word.end(), first_word.begin(),\
    \ ::tolower);\n    std::string word;\n    std::string word_check = \"txt|exe|dll\"\
    ;\n    bool has_word;\n    words = word_check.substr(0, word_check.length()-1).split('|');\n\
    \    has_word = false;\n    \n    for (auto &word : words) {\n        has_word\
    \ = (word.compare(0, word.length(), first_word) == 0);\n        if (has_word)\
    \ {\n            break;\n        }\n    }\n    if (!has_word) {\n        return\
    \ std::to_string(file_name);\n    }\n    return std::to_string(file_name);\n}\n\
    int main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk9yn3_3g.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpk9yn3_3g.cpp:18:16: error: 'to_string' is not a member of 'std'\n    \
    \     return std::to_string(file_name);\n                ^\n/tmp/tmpk9yn3_3g.cpp:21:16:\
    \ error: 'to_string' is not a member of 'std'\n         return std::to_string(file_name);\n\
    \                ^\n/tmp/tmpk9yn3_3g.cpp:24:16: error: 'to_string' is not a member\
    \ of 'std'\n         return std::to_string(file_name);\n                ^\n/tmp/tmpk9yn3_3g.cpp:28:16:\
    \ error: 'to_string' is not a member of 'std'\n         return std::to_string(file_name);\n\
    \                ^\n/tmp/tmpk9yn3_3g.cpp:31:16: error: 'to_string' is not a member\
    \ of 'std'\n         return std::to_string(file_name);\n                ^\n/tmp/tmpk9yn3_3g.cpp:34:16:\
    \ error: 'to_string' is not a member of 'std'\n         return std::to_string(file_name);\n\
    \                ^\n/tmp/tmpk9yn3_3g.cpp:37:16: error: 'to_string' is not a member\
    \ of 'std'\n         return std::to_string(file_name);\n                ^\n/tmp/tmpk9yn3_3g.cpp:44:5:\
    \ error: 'words' was not declared in this scope\n     words = word_check.substr(0,\
    \ word_check.length()-1).split('|');\n     ^\n/tmp/tmpk9yn3_3g.cpp:44:57: error:\
    \ 'class std::basic_string<char>' has no member named 'split'\n     words = word_check.substr(0,\
    \ word_check.length()-1).split('|');\n                                       \
    \                  ^\n/tmp/tmpk9yn3_3g.cpp:47:16: error: ISO C++ forbids declaration\
    \ of 'word' with no type [-fpermissive]\n     for (auto &word : words) {\n   \
    \             ^\n/tmp/tmpk9yn3_3g.cpp:47:23: error: range-based 'for' loops are\
    \ not allowed in C++98 mode\n     for (auto &word : words) {\n               \
    \        ^\n/tmp/tmpk9yn3_3g.cpp:48:26: error: request for member 'compare' in\
    \ 'word', which is of non-class type 'int'\n         has_word = (word.compare(0,\
    \ word.length(), first_word) == 0);\n                          ^\n/tmp/tmpk9yn3_3g.cpp:48:42:\
    \ error: request for member 'length' in 'word', which is of non-class type 'int'\n\
    \         has_word = (word.compare(0, word.length(), firs"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // write your code in C++17\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0e88decv.cpp: In function 'int main()':\n/tmp/tmp0e88decv.cpp:19:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0e88decv.cpp:2:\n/tmp/tmp0e88decv.cpp:20:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Declare a variable 'is_valid' of type bool\n  bool is_valid = false;\n\
    \  // Declare a variable 'valid_string' of type string\n  std::string valid_string;\n\
    \  // Declare a variable 'valid_parts' of type list\n  std::list<std::string>\
    \ valid_parts;\n  // Declare a variable 'dot_position' of type int\n  int dot_position;\n\
    \  // Declare a variable 'first_char' of type char\n  char first_char;\n  // Declare\
    \ a variable 'length' of type int\n  int length;\n  // Declare a variable 'num_parts'\
    \ of type int\n  int num_parts;\n  // Declare a variable 'num_letters' of type\
    \ int\n  int num_letters;\n  // Declare a variable 'num_digits' of type int\n\
    \  int num_digits;\n  // Declare a variable 'has_dot' of type bool\n  bool has_dot;\n\
    \  // Declare a variable 'dot_part' of type string\n  std::string dot_part;\n\
    \  // Declare a variable 'first_letter_part' of type string\n  std::string first_letter_part;\n\
    \  // Declare a variable 'length' of type int\n  length = file_name.length();\n\
    \  // If there are no characters in the string, \n  // the function returns 'Yes'.\n\
    \  if(length < 1){\n    return std::string(\"Yes\");\n  }\n  // Initialize 'num_parts'\
    \ to zero\n  num_parts = 0;\n  // Initialize 'dot_position' to zero\n  dot_position\
    \ = 0;\n  // Initialize 'num_letters' to zero\n  num_letters = 0;\n  // Initialize\
    \ 'num_digits' to zero\n  num_digits = 0;\n  // Initialize 'has_dot' to false\n\
    \  has_dot = false;\n  // Iterate over all the characters in the string\n  for(int\
    \ i = 0; i < length; i++){\n    // Set the current character to the current index\n\
    \    first_char = file_name[i];\n    // If the current character is an alphabetic\
    \ character or an underscore, \n    // add it to a variable called 'first_letter_part'\n\
    \    if(is_alpha(first_char) || first_char == '_'){\n      first_letter_part =\
    \ file_name[i];\n    }\n    // If the current character is a digit, add it to\
    \ 'num_digits'\n    if(is_digit(first_char)){\n      num_digits = num_digits +\
    \ 1;\n    }\n    // If the current character is a '.', add it to 'dot_position'\n\
    \    if(first_char == '.'){\n      dot_position = i;\n      // If there are no\
    \ characters in 'dot_part', \n      // add the initial character to the variable\
    \ 'dot_part'\n      if(dot_part == \"\"){\n        dot_part = first_char;\n  \
    \    }\n      // If the current character is the first character in the 'dot_part',\
    \ \n      // add the current \n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjbb6ruvj.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpjbb6ruvj.cpp:63:27: error: 'is_alpha' was not declared in this scope\n\
    \     if(is_alpha(first_char) || first_char == '_'){\n                       \
    \    ^\n/tmp/tmpjbb6ruvj.cpp:67:27: error: 'is_digit' was not declared in this\
    \ scope\n     if(is_digit(first_char)){\n                           ^\n/tmp/tmpjbb6ruvj.cpp:81:12:\
    \ error: a function-definition is not allowed here before '{' token\n int main()\
    \ {\n            ^\n/tmp/tmpjbb6ruvj.cpp:109:1: error: expected '}' at end of\
    \ input\n }\n ^\n/tmp/tmpjbb6ruvj.cpp:109:1: error: expected '}' at end of input\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code here\n    int count = 0;\n    for (int i = 0; i < file_name.size()\
    \ - 1; i++) {\n        if (file_name[i] < 'a' || file_name[i] > 'z') {\n     \
    \       count++;\n            if (file_name[i] >= '0' && file_name[i] <= '9')\
    \ {\n                count--;\n            }\n        }\n    }\n    for (int i\
    \ = 0; i < file_name.size() - 2; i++) {\n        if (file_name[i] < 'a' || file_name[i]\
    \ > 'z') {\n            count++;\n            if (file_name[i] >= 'A' && file_name[i]\
    \ <= 'Z') {\n                count--;\n            }\n        }\n    }\n    if\
    \ (file_name.find(\".\") == std::string::npos || (file_name[file_name.find(\"\
    .\")] == '.' && (file_name.at(0) > 'a' || file_name.at(0) > 'z'))) {\n       \
    \ count++;\n    }\n    if (count >= 3) {\n        return \"No\";\n    }\n    return\
    \ \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4j4cae1b.cpp: In function 'int main()':\n/tmp/tmp4j4cae1b.cpp:43:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4j4cae1b.cpp:2:\n/tmp/tmp4j4cae1b.cpp:44:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string file_name_check = file_name;\n    int index = file_name_check.find_first_of('.');\n\
    \    if(index != std::string::npos && file_name_check.find_first_not_of('0123456789'.c_str(),\
    \ index) == std::string::npos) {\n        return file_name_check;\n    }\n   \
    \ else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate =\
    \ file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4kctcfly.cpp:18:72: warning: character constant too long for its\
    \ type [enabled by default]\n     if(index != std::string::npos && file_name_check.find_first_not_of('0123456789'.c_str(),\
    \ index) == std::string::npos) {\n                                           \
    \                             ^\n/tmp/tmp4kctcfly.cpp: In function 'std::string\
    \ file_name_check(std::string)':\n/tmp/tmp4kctcfly.cpp:18:85: error: request for\
    \ member 'c_str' in '909588537', which is of non-class type 'int'\n     if(index\
    \ != std::string::npos && file_name_check.find_first_not_of('0123456789'.c_str(),\
    \ index) == std::string::npos) {\n                                           \
    \                                          ^\n/tmp/tmp4kctcfly.cpp: In function\
    \ 'int main()':\n/tmp/tmp4kctcfly.cpp:26:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = file_name_check;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4kctcfly.cpp:2:\n/tmp/tmp4kctcfly.cpp:27:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Write your code here\n    \n    // return \"Yes\";\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpf0j50ywl.cpp: In function 'int main()':\n/tmp/tmpf0j50ywl.cpp:21:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpf0j50ywl.cpp:2:\n/tmp/tmpf0j50ywl.cpp:22:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  int count = 0;\n  for (int i = 0; i < file_name.length(); i++) {\n    if\
    \ (isdigit(file_name[i]) && i != 0 && file_name[i] != '-') {\n      count++;\n\
    \    }\n  }\n  if (file_name.find_first_of('.') != std::string::npos) {\n    return\
    \ file_name;\n  }\n  if (count == 1) {\n    if (file_name[0] >= 'a' && file_name[0]\
    \ <= 'z' && file_name[0] != 'A' && file_name[0] != 'Z') {\n      return \"No\"\
    ;\n    }\n  }\n  return \"No\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcgkr6bxz.cpp: In function 'int main()':\n/tmp/tmpcgkr6bxz.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcgkr6bxz.cpp:2:\n/tmp/tmpcgkr6bxz.cpp:34:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Declare a variable named 'valid' of type 'bool'.\n    bool valid =\
    \ true;\n    // Declare a variable named 'str' of type 'std::string'.\n    std::string\
    \ str;\n    // Declare a variable named 'i' of type 'int'.\n    int i;\n    //\
    \ Declare a variable named 'i0' of type 'int'.\n    int i0;\n    // Get the length\
    \ of 'file_name'.\n    i = file_name.length();\n    // If 'file_name' is of length\
    \ 0 then return 'Yes'.\n    if (i == 0)\n        return \"Yes\";\n    // If 'file_name'\
    \ is of length 1 then return 'No'.\n    if (i == 1)\n        return \"No\";\n\
    \    // If 'file_name' is of length 2 or greater then return 'No'.\n    if (i\
    \ > 2) {\n        return \"No\";\n    }\n    // If 'file_name' starts with '0'\
    \ or '1' or '2' or '3' or '4' or '5' or '6' or\n    // '7' or '8' or '9' then\
    \ return 'Yes'.\n    i0 = file_name.find_first_not_of(\" \");\n    if (i0 == 0\
    \ || i0 == 1 || i0 == 2 || i0 == 3 || i0 == 4 || i0 == 5 || i0 == 6 || i0 == 7\
    \ || i0 == 8 || i0 == 9)\n        return \"Yes\";\n    // If 'file_name' starts\
    \ with any other character then return 'No'.\n    i0 = file_name.find_first_of(\"\
    \ \");\n    if (i0 != std::string::npos)\n        return \"No\";\n    // If 'file_name'\
    \ contains a dot ('.') then return 'No'.\n    if (file_name.find('.') == std::string::npos)\n\
    \        return \"No\";\n    // If 'file_name' contains a dot ('.') then return\
    \ 'No'.\n    if (file_name.find('.') == 0 || file_name.find('.') == 1 || file_name.find('.')\
    \ == 2 || file_name.find('.') == 3 || file_name.find('.') == 4 || file_name.find('.')\
    \ == 5 || file_name.find('.') == 6 || file_name.find('.') == 7 || file_name.find('.')\
    \ == 8 || file_name.find('.') == 9)\n        return \"No\";\n    // If 'file_name'\
    \ contains a dot ('.') then return 'No'.\n    if (file_name.find('.') == std::string::npos)\n\
    \        return \"No\";\n    // If 'file_name' contains a dot ('.') then return\
    \ 'No'.\n    if (file_name.find('.') == 0 || file_name.find('.') == 1 || file_name.find('.')\
    \ == 2 || file_name.find('.') == 3 || file_name.find('.') == 4 || file_name.find('.')\
    \ == 5 || file_name.find('.') == 6 || file_name.find('.') == 7 || file_name.find('.')\
    \ == 8 || file_name.find('.') == 9)\n        return \"No\";\n    // If 'file_name'\
    \ starts with a letter and 'exe' or 'dll' is in the end of \n\n}\nint main() {\n\
    \    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpapwknlm0.cpp: In function 'int main()':\n/tmp/tmpapwknlm0.cpp:61:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpapwknlm0.cpp:2:\n/tmp/tmpapwknlm0.cpp:62:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string answer;\n    // Write your code here.\n    return answer;\n\
    }\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqbgrpxzp.cpp: In function 'int main()':\n/tmp/tmpqbgrpxzp.cpp:21:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqbgrpxzp.cpp:2:\n/tmp/tmpqbgrpxzp.cpp:22:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Write your code here\n  assert(file_name.size() <= 3);\n  std::unordered_set<char>\
    \ dot{};\n  std::unordered_set<char> prefix{};\n  for (int i = 0; i < file_name.size()\
    \ - 1; ++i) {\n    bool found = false;\n    auto c = file_name[i];\n    do {\n\
    \      if (c.isdigit()) {\n        if ((i > 0) && (prefix.find(c) != prefix.end()))\n\
    \          return \"No\";\n        if (i < 3) {\n          assert(c == '0');\n\
    \          prefix = prefix;\n          continue;\n        }\n        assert(c\
    \ == '1');\n        found = true;\n        break;\n      }\n      c = static_cast<char>(c);\n\
    \      prefix.insert(c);\n    } while (!found);\n  }\n  std::string extension\
    \ = file_name.substr(file_name.size() - 3, 3);\n  if (extension.find(\"exe\")\
    \ != std::string::npos)\n    return \"No\";\n  if (extension.find(\"dll\") !=\
    \ std::string::npos)\n    return \"No\";\n  if (extension.find(\"txt\") != std::string::npos)\n\
    \    return \"Yes\";\n  return \"No\";\n}\nint main() {\n    auto candidate =\
    \ file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm3b0c_s_.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpm3b0c_s_.cpp:18:3: error: 'unordered_set' is not a member of 'std'\n \
    \  std::unordered_set<char> dot{};\n   ^\n/tmp/tmpm3b0c_s_.cpp:18:22: error: expected\
    \ primary-expression before 'char'\n   std::unordered_set<char> dot{};\n     \
    \                 ^\n/tmp/tmpm3b0c_s_.cpp:18:22: error: expected ';' before 'char'\n\
    /tmp/tmpm3b0c_s_.cpp:19:3: error: 'unordered_set' is not a member of 'std'\n \
    \  std::unordered_set<char> prefix{};\n   ^\n/tmp/tmpm3b0c_s_.cpp:19:22: error:\
    \ expected primary-expression before 'char'\n   std::unordered_set<char> prefix{};\n\
    \                      ^\n/tmp/tmpm3b0c_s_.cpp:19:22: error: expected ';' before\
    \ 'char'\n/tmp/tmpm3b0c_s_.cpp:22:10: error: 'c' does not name a type\n     auto\
    \ c = file_name[i];\n          ^\n/tmp/tmpm3b0c_s_.cpp:24:11: error: 'c' was not\
    \ declared in this scope\n       if (c.isdigit()) {\n           ^\n/tmp/tmpm3b0c_s_.cpp:25:25:\
    \ error: 'prefix' was not declared in this scope\n         if ((i > 0) && (prefix.find(c)\
    \ != prefix.end()))\n                         ^\n/tmp/tmpm3b0c_s_.cpp:29:11: error:\
    \ 'prefix' was not declared in this scope\n           prefix = prefix;\n     \
    \      ^\n/tmp/tmpm3b0c_s_.cpp:36:7: error: 'c' was not declared in this scope\n\
    \       c = static_cast<char>(c);\n       ^\n/tmp/tmpm3b0c_s_.cpp:37:7: error:\
    \ 'prefix' was not declared in this scope\n       prefix.insert(c);\n       ^\n\
    /tmp/tmpm3b0c_s_.cpp: In function 'int main()':\n/tmp/tmpm3b0c_s_.cpp:50:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = file_name_check;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpm3b0c_s_.cpp:2:\n/tmp/tmpm3b0c_s_.cpp:51:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code goes here\n    return file_name;\n}\nint main() {\n    auto\
    \ candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"\
    Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu6413rf3.cpp: In function 'int main()':\n/tmp/tmpu6413rf3.cpp:20:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu6413rf3.cpp:2:\n/tmp/tmpu6413rf3.cpp:21:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int num_digits = 0;\n    int first_dot_pos = 0;\n    int last_dot_pos\
    \ = file_name.size() - 1;\n    \n    while(first_dot_pos < last_dot_pos) {\n \
    \       if(file_name[first_dot_pos] >= '0' &&  file_name[first_dot_pos] <= '9')\
    \ {\n            ++num_digits;\n        }\n        else if(file_name[first_dot_pos]\
    \ == '.') {\n            ++num_digits;\n            ++first_dot_pos;\n       \
    \ }\n        else {\n            if((first_dot_pos == 0) && (file_name[first_dot_pos]\
    \ != 'a')) {\n                return \"No\";\n            }\n            else\
    \ {\n                if((first_dot_pos == 0) && (file_name[first_dot_pos] != 'A'))\
    \ {\n                    return \"No\";\n                }\n                if((num_digits\
    \ >= 2) && (file_name[first_dot_pos-1] != 'e') \n                    && (file_name[first_dot_pos-1]\
    \ != 'E') \n                    && (file_name[first_dot_pos] != 'i') \n      \
    \              && (file_name[first_dot_pos] != 'I') \n                    && (file_name[first_dot_pos]\
    \ != 'o') \n                    && (file_name[first_dot_pos] != 'O') \n      \
    \              && (file_name[first_dot_pos] != 'u') \n                    && (file_name[first_dot_pos]\
    \ != 'U')) {\n                    return \"No\";\n                }\n        \
    \        else {\n                    return \"Yes\";\n                }\n    \
    \        }\n        }\n    }\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpp89dmcbg.cpp: In function 'int main()':\n/tmp/tmpp89dmcbg.cpp:54:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp89dmcbg.cpp:2:\n/tmp/tmpp89dmcbg.cpp:55:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::stack<char> stack;\n    std::string str = \"\";\n\n    for (int\
    \ i = 0; i < file_name.size(); i++) {\n        if (isalnum(file_name[i])) {\n\
    \            str.append(file_name[i]);\n        } else {\n            while (!stack.empty()\
    \ && isalnum(stack.top())) {\n                str.append(stack.top());\n     \
    \           stack.pop();\n            }\n            stack.push(file_name[i]);\n\
    \        }\n    }\n\n    while (!stack.empty()) {\n        str.append(stack.top());\n\
    \        stack.pop();\n    }\n\n    if (str.length() == 0) \n        return \"\
    No\";\n    if (str.size() > 3) return false;\n    if (str[0] == '.') return \"\
    No\";\n    if (str[0] == 'a' && str[1] == 'z' && str[2] == 'z') return \"No\"\
    ;\n    if (str[0] == 'A' && str[1] == 'Z' && str[2] == 'Z') return \"No\";\n \
    \   return \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9f7_zru2.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp9f7_zru2.cpp:21:36: error: invalid conversion from 'char' to 'const char*'\
    \ [-fpermissive]\n             str.append(file_name[i]);\n                   \
    \                 ^\nIn file included from /usr/include/c++/4.8.2/string:52:0,\n\
    \                 from /usr/include/c++/4.8.2/bitset:47,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n             \
    \    from /tmp/tmp9f7_zru2.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.h:1006:7:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::basic_string<_CharT, _Traits, _Alloc>::append(const _CharT*) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]' [-fpermissive]\n\
    \       append(const _CharT* __s)\n       ^\n/tmp/tmp9f7_zru2.cpp:24:39: error:\
    \ invalid conversion from 'char' to 'const char*' [-fpermissive]\n           \
    \      str.append(stack.top());\n                                       ^\nIn\
    \ file included from /usr/include/c++/4.8.2/string:52:0,\n                 from\
    \ /usr/include/c++/4.8.2/bitset:47,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9f7_zru2.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.h:1006:7:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::basic_string<_CharT, _Traits, _Alloc>::append(const _CharT*) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]' [-fpermissive]\n\
    \       append(const _CharT* __s)\n       ^\n/tmp/tmp9f7_zru2.cpp:32:31: error:\
    \ invalid conversion from 'char' to 'const char*' [-fpermissive]\n         str.append(stack.top());\n\
    \                               ^\nIn file included from /usr/include/c++/4.8.2/string:52:0,\n\
    \                 from /usr/include/c++/4.8.2/bitset:47,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n             \
    \    from /tmp/tmp9f7_zru2.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_st"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string correct_answer;\n    \n    // Check string length\n    if\
    \ (file_name.size() > 3) {\n        correct_answer = \"No\";\n    }\n    else\
    \ if (file_name.find(\".\") != std::string::npos) {\n        correct_answer =\
    \ \"No\";\n    }\n    else {\n        char first_letter = file_name.at(0); //Get\
    \ the first letter\n        \n        if (first_letter >= 'a' && first_letter\
    \ <= 'z') {\n            correct_answer = \"Yes\";\n        }\n        else if\
    \ (first_letter >= 'A' && first_letter <= 'Z') {\n            correct_answer =\
    \ \"Yes\";\n        }\n        else {\n            correct_answer = \"No\";\n\
    \        }\n    }\n    return correct_answer;\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpda44cx2t.cpp: In function 'int main()':\n/tmp/tmpda44cx2t.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpda44cx2t.cpp:2:\n/tmp/tmpda44cx2t.cpp:42:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // code here\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplqwjm9_p.cpp: In function 'int main()':\n/tmp/tmplqwjm9_p.cpp:19:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplqwjm9_p.cpp:2:\n/tmp/tmplqwjm9_p.cpp:20:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Declare a boolean variable to check whether the file's name is valid\
    \ or not.\n    bool is_valid = true;\n    // Declare a boolean variable to check\
    \ whether the file's name is valid or not.\n    bool is_dot_valid = true;\n  \
    \  // Declare a boolean variable to check whether substring before the dot is\
    \ empty or not.\n    bool is_letter_valid = true;\n    // Declare a boolean variable\
    \ to check whether the substring after the dot is one of these : \n    bool is_txt_exe_dll_valid\
    \ = true;\n    // Declare a variable to store the file's name before the dot '.'\n\
    \    std::string file_before_dot;\n    // Declare a variable to store the file's\
    \ name after the dot '.'\n    std::string file_after_dot;\n    // Declare a variable\
    \ to store the substring before the dot '.'\n    std::string file_before_dot_sub;\n\
    \    // Declare a variable to store the substring after the dot '.'\n    std::string\
    \ file_after_dot_sub;\n    // Declare a variable to store the substring between\
    \ the first and last letter of the file's name before the dot '.'\n    std::string\
    \ first_letter_of_file;\n    // Declare a variable to store the substring between\
    \ the last and second last letter of the file's name before the dot '.'\n    std::string\
    \ second_letter_of_file;\n\n    // Iterate through each character in the string\
    \ and check the validity of the \n    // file's name string.\n    for (int i =\
    \ 0; i < file_name.length(); i++) {\n        // If the character is '0' or '9',\
    \ then it is invalid and should remain 'Yes'.\n        if (file_name[i] >= '0'\
    \ && file_name[i] <= '9') {\n            is_valid = false;\n        }\n      \
    \  // If the character is '-', then the file's name string contains no dot '.'\
    \ and should remain 'Yes'.\n        else if (file_name[i] == '-') {\n        \
    \    is_dot_valid = false;\n        }\n        // If the character is 'A'-'Z',\
    \ then the file's name string contains no dot '.' and should remain 'Yes'.\n \
    \       else if (file_name[i] == 'A' || file_name[i] == 'B' || file_name[i] ==\
    \ 'C' || file_name[i] == 'D' || \n                 file_name[i] == 'E' || file_name[i]\
    \ == 'F' || file_name[i] == 'G' || file_name[i] == 'H' || \n                 file_name[i]\
    \ == 'I' || file_name[i] == 'J' || file_name[i] == 'K' || file_name[i] == 'L'\
    \ || \n                 file_name[i] == 'M' || file_name[i] == 'N' || file_name[i]\
    \ == 'O' || file_name[i] == 'P' || \n                 file_name[i] == 'Q' || file_name[i]\
    \ == 'R' || file_name[i] == 'S' || file_name[i] == 'T' || \n                 file_name[i]\
    \ == 'U' || file_name[i] == 'V' || file_name[i] == 'W' || file_name[i] == 'X'\
    \ || \n                 file_name[i] == 'Y' || file_name[i] == '\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy6xkfz_t.cpp:55:57: warning: missing terminating ' character [enabled\
    \ by default]\n                  file_name[i] == 'Y' || file_name[i] == '\n  \
    \                                                       ^\n/tmp/tmpy6xkfz_t.cpp:55:18:\
    \ error: missing terminating ' character\n                  file_name[i] == 'Y'\
    \ || file_name[i] == '\n                  ^\n/tmp/tmpy6xkfz_t.cpp: In function\
    \ 'std::string file_name_check(std::string)':\n/tmp/tmpy6xkfz_t.cpp:56:1: error:\
    \ expected primary-expression before '}' token\n }\n ^\n/tmp/tmpy6xkfz_t.cpp:56:1:\
    \ error: expected ')' before '}' token\n/tmp/tmpy6xkfz_t.cpp:56:1: error: expected\
    \ primary-expression before '}' token\n/tmp/tmpy6xkfz_t.cpp:56:1: error: expected\
    \ ';' before '}' token\n/tmp/tmpy6xkfz_t.cpp:57:12: error: a function-definition\
    \ is not allowed here before '{' token\n int main() {\n            ^\n/tmp/tmpy6xkfz_t.cpp:85:1:\
    \ error: expected '}' at end of input\n }\n ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string dot(\".\")\n    std::string dot2(\"..\")\n    if (file_name.length()\
    \ <= 3) {\n        return \"No\";\n    }\n    if (file_name.find(dot) == std::string::npos)\
    \ {\n        return \"No\";\n    }\n    if (file_name.find(dot2) == std::string::npos)\
    \ {\n        return \"No\";\n    }\n    if (file_name.at(0) == 'a' && file_name.at(1)\
    \ == 'b' && file_name.at(2) == 'c') {\n        return \"Yes\";\n    }\n    if\
    \ (file_name.at(0) == 'A' && file_name.at(1) == 'B' && file_name.at(2) == 'C')\
    \ {\n        return \"Yes\";\n    }\n    if (file_name.at(0) == '0' && file_name.at(1)\
    \ == '1' && file_name.at(2) == '2') {\n        return \"Yes\";\n    }\n    if\
    \ (file_name.at(0) == '0' && file_name.at(1) == '1' && file_name.at(2) == '2')\
    \ {\n        return \"Yes\";\n    }\n    if (file_name.at(0) == 'a' && file_name.at(1)\
    \ == 'b' && file_name.at(2) == 'c') {\n        return \"Yes\";\n    }\n    if\
    \ (file_name.at(0) == 'A' && file_name.at(1) == 'B' && file_name.at(2) == 'C')\
    \ {\n        return \"Yes\";\n    }\n    if (file_name.at(0) == '0' && file_name.at(1)\
    \ == '1' && file_name.at(2) == '2') {\n        return \"Yes\";\n    }\n    if\
    \ (file_name.at(0) == '0' && file_name.at(1) == '1' && file_name.at(2) == '2')\
    \ {\n        return \"Yes\";\n    }\n    return \"No\";\n}\nint main() {\n   \
    \ auto candidate = file_name_check;\n    assert(candidate((\"example.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxwvn7xzm.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpxwvn7xzm.cpp:17:5: error: expected ',' or ';' before 'std'\n     std::string\
    \ dot2(\"..\")\n     ^\n/tmp/tmpxwvn7xzm.cpp:24:24: error: 'dot2' was not declared\
    \ in this scope\n     if (file_name.find(dot2) == std::string::npos) {\n     \
    \                   ^\n/tmp/tmpxwvn7xzm.cpp: In function 'int main()':\n/tmp/tmpxwvn7xzm.cpp:54:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxwvn7xzm.cpp:2:\n/tmp/tmpxwvn7xzm.cpp:55:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code here\n    \n    std::string invalid_chars = \"\\\\/:*?<>|\"\
    ;\n    int dot = file_name.find('.');\n    if(dot != std::string::npos && file_name[dot-1]\
    \ != '.' || (dot != std::string::npos && file_name[dot-1] == '.')) {\n       \
    \ return \"No\";\n    }\n    else if(!std::all_of(file_name.begin(), file_name.end(),\
    \ [&invalid_chars](char c)->bool{return !invalid_chars.find(c) != std::string::npos;}))\
    \ {\n        return \"No\";\n    }\n    if(file_name.find(\".txt\") != std::string::npos\
    \ || file_name.find(\".exe\") != std::string::npos || file_name.find(\".dll\"\
    ) != std::string::npos) {\n        return \"Yes\";\n    }\n    return \"No\";\n\
    }\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpiylehze7.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpiylehze7.cpp:23:14: error: 'all_of' is not a member of 'std'\n     else\
    \ if(!std::all_of(file_name.begin(), file_name.end(), [&invalid_chars](char c)->bool{return\
    \ !invalid_chars.find(c) != std::string::npos;})) {\n              ^\n/tmp/tmpiylehze7.cpp:23:144:\
    \ warning: lambda expressions only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     else if(!std::all_of(file_name.begin(), file_name.end(), [&invalid_chars](char\
    \ c)->bool{return !invalid_chars.find(c) != std::string::npos;})) {\n        \
    \                                                                            \
    \                                                            ^\n/tmp/tmpiylehze7.cpp:\
    \ In function 'int main()':\n/tmp/tmpiylehze7.cpp:32:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiylehze7.cpp:2:\n/tmp/tmpiylehze7.cpp:33:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int n = file_name.size(); // n is the number of characters in the file\
    \ name\n    if (n > 3) {\n        std::cout << \"Error: too many characters in\
    \ the file name\" << std::endl;\n        return \"No\";\n    }\n    if (file_name.find(\"\
    ..\") != n) {\n        std::cout << \"Error: no period ('.')\" << std::endl;\n\
    \        return \"No\";\n    }\n    std::string s = file_name.substr(0, file_name.find(\"\
    .\"));\n    bool ok = true;\n    \n    if (s[0] != (std::min)(65, std::max)(90))\
    \ {\n        std::cout << \"Error: file name is invalid\" << std::endl;\n    \
    \    return \"No\";\n    }\n    for (int i = 0; i < n; i++) {\n        if (s[i]\
    \ < 'a' || s[i] > 'z') {\n            std::cout << \"Error: file name is invalid\"\
    \ << std::endl;\n            return \"No\";\n        }\n    }\n    for (int i\
    \ = 0; i < n; i++) {\n        if (s[i] != '.') {\n            std::cout << \"\
    Error: file name is invalid\" << std::endl;\n            return \"No\";\n    \
    \    }\n    }\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '.') {\n\
    \            if (s[i+1] != ('t' || 'e' || 'x' || 'p' || 'e')) {\n            \
    \    std::cout << \"Error: file name is invalid\" << std::endl;\n            \
    \    return \"No\";\n            }\n        }\n    }\n    if (s[n - 1] != 'dll')\
    \ {\n        std::cout << \"Error: file name is invalid\" << std::endl;\n    \
    \    return \"No\";\n    }\n    \n    return std::string(s);\n}\nint main() {\n\
    \    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9yvidypf.cpp:52:21: warning: multi-character character constant\
    \ [-Wmultichar]\n     if (s[n - 1] != 'dll') {\n                     ^\n/tmp/tmp9yvidypf.cpp:\
    \ In function 'std::string file_name_check(std::string)':\n/tmp/tmp9yvidypf.cpp:28:40:\
    \ error: no matching function for call to 'min(int, <unresolved overloaded function\
    \ type>)'\n     if (s[0] != (std::min)(65, std::max)(90)) {\n                \
    \                        ^\n/tmp/tmp9yvidypf.cpp:28:40: note: candidates are:\n\
    In file included from /usr/include/c++/4.8.2/algorithm:61:0,\n               \
    \  from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:64,\n       \
    \          from /tmp/tmp9yvidypf.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_algobase.h:193:5:\
    \ note: const _Tp& std::min(const _Tp&, const _Tp&) [with _Tp = int]\n     min(const\
    \ _Tp& __a, const _Tp& __b)\n     ^\n/usr/include/c++/4.8.2/bits/stl_algobase.h:193:5:\
    \ note:   no known conversion for argument 2 from '<unresolved overloaded function\
    \ type>' to 'const int&'\n/usr/include/c++/4.8.2/bits/stl_algobase.h:239:5: note:\
    \ template<class _Tp, class _Compare> const _Tp& std::min(const _Tp&, const _Tp&,\
    \ _Compare)\n     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n     ^\n\
    /usr/include/c++/4.8.2/bits/stl_algobase.h:239:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9yvidypf.cpp:28:40: note:   candidate expects 3 arguments,\
    \ 2 provided\n     if (s[0] != (std::min)(65, std::max)(90)) {\n             \
    \                           ^\n/tmp/tmp9yvidypf.cpp: In function 'int main()':\n\
    /tmp/tmp9yvidypf.cpp:60:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = file_name_check;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9yvidypf.cpp:2:\n/tmp/tmp9yvidypf.cpp:61:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::vector<std::string> strings;\n    size_t i, len = file_name.length();\n\
    \    for (i = 0; i < len; i++) {\n        if (file_name[i] < 'a' || file_name[i]\
    \ > 'z') {\n            strings.push_back(file_name.substr(0, i));\n         \
    \   break;\n        }\n    }\n    bool is_exe = false;\n    for (i = 0; i < len;\
    \ i++) {\n        if (file_name[i] < 'a' || file_name[i] > 'z') {\n          \
    \  strings.push_back(file_name.substr(0, i));\n            break;\n        }\n\
    \    }\n    int num = 0;\n    for (i = 0; i < len; i++){\n        if (file_name[i]\
    \ == '.') {\n            strings.push_back(file_name.substr(0, i));\n        \
    \    break;\n        }\n    }\n    for (i = 0; i < len; i++){\n        if (strings[0].length()\
    \ == 0) {\n            if (strings[i].length() == 0) {\n                if (strings[1].length()\
    \ == 0) {\n                    if (strings[2].length() == 0) {\n             \
    \           is_exe = true;\n                    }\n                }\n       \
    \     }\n        }\n    }\n    std::string answer;\n    if (is_exe) {\n      \
    \  answer = \"Yes\";\n    } else {\n        answer = \"No\";\n    }\n    return\
    \ answer;\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt0wxbbmw.cpp: In function 'int main()':\n/tmp/tmpt0wxbbmw.cpp:58:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt0wxbbmw.cpp:2:\n/tmp/tmpt0wxbbmw.cpp:59:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  char file_name_check[100];\n  if(file_name.size()<=3 || file_name.contains(\"\
    .\") || file_name.substr(0,1)=='.' || file_name.substr(0,2)=='..'){\n    std::cout<<\"\
    Invalid file name!\\n\";\n  }\n  else{\n    snprintf(file_name_check,100,\"%s\"\
    ,file_name.c_str());\n  }\n  return file_name_check;\n}\nint main() {\n    auto\
    \ candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"\
    Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt6xl69pu.cpp:17:109: warning: multi-character character constant\
    \ [-Wmultichar]\n   if(file_name.size()<=3 || file_name.contains(\".\") || file_name.substr(0,1)=='.'\
    \ || file_name.substr(0,2)=='..'){\n                                         \
    \                                                                    ^\n/tmp/tmpt6xl69pu.cpp:\
    \ In function 'std::string file_name_check(std::string)':\n/tmp/tmpt6xl69pu.cpp:17:39:\
    \ error: 'std::string' has no member named 'contains'\n   if(file_name.size()<=3\
    \ || file_name.contains(\".\") || file_name.substr(0,1)=='.' || file_name.substr(0,2)=='..'){\n\
    \                                       ^\n/tmp/tmpt6xl69pu.cpp:17:77: error:\
    \ no match for 'operator==' (operand types are 'std::basic_string<char>' and 'char')\n\
    \   if(file_name.size()<=3 || file_name.contains(\".\") || file_name.substr(0,1)=='.'\
    \ || file_name.substr(0,2)=='..'){\n                                         \
    \                                    ^\n/tmp/tmpt6xl69pu.cpp:17:77: note: candidates\
    \ are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpt6xl69pu.cpp:2:\n/usr/include/c++/4.8.2/valarray:1179:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__equal_to, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to, _Tp>::result_type>\
    \ std::operator==(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1179:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpt6xl69pu.cpp:17:79: note:   mismatched\
    \ types 'const std::valarray<_Tp>' and 'char'\n   if(file_name.size()<=3 || file_name.contains(\"\
    .\") || file_name.substr(0,1)=='.' || file_name.substr(0,2)=='..'){\n        \
    \                                                                       ^\nIn\
    \ file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpt6xl69pu.cpp:2:\n/usr/include/c++/4.8.2/valarray:1179:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__equal"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tif (file_name.size() <= 3) {\n\t\treturn \"No\";\n\t}\n\tif (file_name.find_first_not_of(\"\
    0123456789\") == std::string::npos && \n\t\tfile_name.find_first_of(\".\") ==\
    \ std::string::npos && \n\t\tfile_name.substr(0, 1) == \"a\" && file_name.substr(0,\
    \ 1) == \"A\" &&\n\t\tfile_name.find_first_of(\".\") != file_name.find_last_of(\"\
    .\") - 1 &&\n\t\t(file_name.find_last_of(\".\") != std::string::npos || file_name.find_last_of(\"\
    .\") == file_name.find_first_of(\".\") - 1)) {\n\t\t\n\t\treturn \"Yes\";\n\t\
    }\n\treturn \"No\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg22ycoxj.cpp: In function 'int main()':\n/tmp/tmpg22ycoxj.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg22ycoxj.cpp:2:\n/tmp/tmpg22ycoxj.cpp:31:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int dot_pos = file_name.find_first_of(\".\");\n    if (dot_pos == std::string::npos)\
    \ return \"No\";\n    else if (!((file_name[0] == 'a' || file_name[0] == 'A')\
    \ && file_name[1] == file_name[0])) \n        return \"No\";\n    else if (!((file_name.size()\
    \ >= 2) && (file_name[dot_pos-1] == '.'))) \n        return \"No\";\n    else\
    \ if (!((file_name.size() >= 3) && (file_name.substr(0,dot_pos).find_first_not_of(\"\
    0123456789\") == std::string::npos))) \n        return \"No\";\n    else return\
    \ \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe9xjxg2k.cpp: In function 'int main()':\n/tmp/tmpe9xjxg2k.cpp:27:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe9xjxg2k.cpp:2:\n/tmp/tmpe9xjxg2k.cpp:28:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Declare variables to be used in the 'if' statements.\n  int num_digits\
    \ = 0;\n  int dot_count = 0;\n  std::string letters[26] = \n  {\n    \"A\",\"\
    B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"\
    O\",\n    \"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"\n\
    \  };\n  char first_letter = file_name[0];\n  \n  for (int i = 0; i < file_name.size();\
    \ i++) {\n    char c = file_name[i];\n    if (c == '.') {\n      dot_count++;\n\
    \    }\n    else {\n      num_digits++;\n    }\n  }\n  \n  assert(dot_count <=\
    \ 3);\n  assert(num_digits <= file_name.size());\n  assert(dot_count == 0 || num_digits\
    \ == 1);\n  \n  if (dot_count == 0) {\n    if (first_letter >= 'a' && first_letter\
    \ <= 'z') {\n      return 'Yes';\n    }\n    return 'No';\n  }\n  \n  \n  if (num_digits\
    \ == 1) {\n    // Check if the substring before the dot is a letter from the latin\
    \ alphabet, and \n    // it starts with a letter from the latin alphabet:\n  \
    \  if ((file_name.substr(0, dot_count) == letters[(int)first_letter - 65]) \n\
    \      && (file_name.substr(0, dot_count) == letters[(int)first_letter - 97]))\
    \ {\n      return 'Yes';\n    }\n    return 'No';\n  }\n  \n  return 'No';\n}\n\
    int main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7fqe7y86.cpp:42:14: warning: multi-character character constant\
    \ [-Wmultichar]\n       return 'Yes';\n              ^\n/tmp/tmp7fqe7y86.cpp:44:12:\
    \ warning: multi-character character constant [-Wmultichar]\n     return 'No';\n\
    \            ^\n/tmp/tmp7fqe7y86.cpp:53:14: warning: multi-character character\
    \ constant [-Wmultichar]\n       return 'Yes';\n              ^\n/tmp/tmp7fqe7y86.cpp:55:12:\
    \ warning: multi-character character constant [-Wmultichar]\n     return 'No';\n\
    \            ^\n/tmp/tmp7fqe7y86.cpp:58:10: warning: multi-character character\
    \ constant [-Wmultichar]\n   return 'No';\n          ^\n/tmp/tmp7fqe7y86.cpp:\
    \ In function 'std::string file_name_check(std::string)':\n/tmp/tmp7fqe7y86.cpp:42:14:\
    \ error: invalid conversion from 'int' to 'const char*' [-fpermissive]\n     \
    \  return 'Yes';\n              ^\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n\
    \                 from /usr/include/c++/4.8.2/bitset:47,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n             \
    \    from /tmp/tmp7fqe7y86.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmp7fqe7y86.cpp:44:12: error: invalid conversion from\
    \ 'int' to 'const char*' [-fpermissive]\n     return 'No';\n            ^\nIn\
    \ file included from /usr/include/c++/4.8.2/string:53:0,\n                 from\
    \ /usr/include/c++/4.8.2/bitset:47,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7fqe7y86.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tassert(file_name.size() <= 4);\n\tauto first_non_digit_index = file_name.find_first_not_of(\"\
    0123456789\");\n\tauto last_non_digit_index = file_name.find_last_not_of(\"0123456789\"\
    );\n\tif (first_non_digit_index != std::string::npos) {\n\t\treturn \"No\";\n\t\
    }\n\tif (file_name.find('.') == std::string::npos) {\n\t\treturn \"No\";\n\t}\n\
    \tassert(file_name[0] >= 'a' && file_name[0] <= 'z');\n\tassert(file_name[1] >=\
    \ 'a' && file_name[1] <= 'z');\n\tassert(file_name[2] >= 'a' && file_name[2] <=\
    \ 'z');\n\tassert(file_name[3] >= 'a' && file_name[3] <= 'z');\n\tassert(file_name.size()\
    \ == 4);\n\tif (file_name[0] == '.') {\n\t\treturn \"No\";\n\t}\n\tif (file_name[1]\
    \ == '.') {\n\t\treturn \"No\";\n\t}\n\tif (file_name[2] == '.') {\n\t\treturn\
    \ \"No\";\n\t}\n\tif (file_name[3] == '.') {\n\t\treturn \"No\";\n\t}\n\treturn\
    \ \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpejmxbdom.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpejmxbdom.cpp:17:7: error: 'first_non_digit_index' does not name a type\n\
    \  auto first_non_digit_index = file_name.find_first_not_of(\"0123456789\");\n\
    \       ^\n/tmp/tmpejmxbdom.cpp:18:7: error: 'last_non_digit_index' does not name\
    \ a type\n  auto last_non_digit_index = file_name.find_last_not_of(\"0123456789\"\
    );\n       ^\n/tmp/tmpejmxbdom.cpp:19:6: error: 'first_non_digit_index' was not\
    \ declared in this scope\n  if (first_non_digit_index != std::string::npos) {\n\
    \      ^\n/tmp/tmpejmxbdom.cpp: In function 'int main()':\n/tmp/tmpejmxbdom.cpp:45:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpejmxbdom.cpp:2:\n/tmp/tmpejmxbdom.cpp:46:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code here\n    if (file_name.length()!=9 || file_name.substr(0,\
    \ 1) != \".\" || file_name.substr(0, 1) !=(char) ('A'-'Z') || file_name.substr(file_name.size()-1,\
    \ 1) != \".\" || file_name.substr(0, 3) !=(char) ('a' -'z') || file_name.substr(0,\
    \ 4) !=(char) ('a' -'z') || file_name.substr(file_name.size()-1, 5) !=(char) ('t'\
    \ -'x') || file_name.substr(0, 6) !=(char) ('e' -'x') || file_name.substr(0, 7)\
    \ !=(char) ('s' -'x') || file_name.substr(0, 8) !=(char) ('d' -'x') || file_name.substr(0,\
    \ 9) !=(char) ('l' -'x') || file_name.substr(0, 10) !=(char) ('l' -'x')){\n  \
    \      return \"No\";\n    } else {\n        return \"Yes\";\n    }\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp013pducs.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp013pducs.cpp:17:90: error: no match for 'operator!=' (operand types are\
    \ 'std::basic_string<char>' and 'char')\n     if (file_name.length()!=9 || file_name.substr(0,\
    \ 1) != \".\" || file_name.substr(0, 1) !=(char) ('A'-'Z') || file_name.substr(file_name.size()-1,\
    \ 1) != \".\" || file_name.substr(0, 3) !=(char) ('a' -'z') || file_name.substr(0,\
    \ 4) !=(char) ('a' -'z') || file_name.substr(file_name.size()-1, 5) !=(char) ('t'\
    \ -'x') || file_name.substr(0, 6) !=(char) ('e' -'x') || file_name.substr(0, 7)\
    \ !=(char) ('s' -'x') || file_name.substr(0, 8) !=(char) ('d' -'x') || file_name.substr(0,\
    \ 9) !=(char) ('l' -'x') || file_name.substr(0, 10) !=(char) ('l' -'x')){\n  \
    \                                                                            \
    \            ^\n/tmp/tmp013pducs.cpp:17:90: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n      \
    \           from /tmp/tmp013pducs.cpp:2:\n/usr/include/c++/4.8.2/valarray:1180:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__not_equal_to, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__not_equal_to, _Tp>::result_type>\
    \ std::operator!=(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(!=,\
    \ __not_equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1180:1: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp013pducs.cpp:17:107: note:\
    \   mismatched types 'const std::valarray<_Tp>' and 'char'\n     if (file_name.length()!=9\
    \ || file_name.substr(0, 1) != \".\" || file_name.substr(0, 1) !=(char) ('A'-'Z')\
    \ || file_name.substr(file_name.size()-1, 1) != \".\" || file_name.substr(0, 3)\
    \ !=(char) ('a' -'z') || file_name.substr(0, 4) !=(char) ('a' -'z') || file_name.substr(file_name.size()-1,\
    \ 5) !=(char) ('t' -'x') || file_name.substr(0, 6) !=(char) ('e' -'x') || file_name.substr(0,\
    \ 7) !=(char) ('s' -'x') || file_name.substr(0, 8) !=(char) ('d' -'x') || file_name.substr(0,\
    \ 9) !=(char) ('l' -'x') || file_name.substr(0, 10) "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // write your code here\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplo612oua.cpp: In function 'int main()':\n/tmp/tmplo612oua.cpp:19:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplo612oua.cpp:2:\n/tmp/tmplo612oua.cpp:20:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Write your code here\n    // return 'Yes' or 'No' \n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmih8xrfb.cpp: In function 'int main()':\n/tmp/tmpmih8xrfb.cpp:20:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmih8xrfb.cpp:2:\n/tmp/tmpmih8xrfb.cpp:21:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int num = 0;\n    std::string first_digits = file_name.substr(0, file_name.length()\
    \ - 1);\n    first_digits = first_digits.substr(0, first_digits.length() - 1);\n\
    \    char first_char = file_name.at(0);\n    \n    for (int i = 0; i < first_digits.length();\
    \ i++) {\n        num = num * 10 + (first_digits.at(i) - '0');\n    }\n\n    char\
    \ second_char = file_name.at(1);\n    std::string suffix;\n    \n    if (second_char\
    \ == '.') {\n        suffix = file_name.substr(2);\n    } else {\n        suffix\
    \ = file_name.substr(1);\n    }\n\n    int index = 0;\n    int flag = 0;\n   \
    \ \n    for (int i = 0; i < suffix.length(); i++) {\n        index = index + suffix[i];\n\
    \        if (index >= num) {\n            flag = 1;\n            break;\n    \
    \    }\n    }\n    if (flag == 1) {\n        return \"No\";\n    } else {\n  \
    \      return \"Yes\";\n    }\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmypq96r3.cpp: In function 'int main()':\n/tmp/tmpmypq96r3.cpp:51:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmypq96r3.cpp:2:\n/tmp/tmpmypq96r3.cpp:52:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Get the size of the string.\n    int size = file_name.length();\n\
    \    // If there are no digits in the string\n    if (size <= 3) {\n        return\
    \ \"No\";\n    }\n    // If the string is only one dot '.'\n    if (file_name.size()\
    \ == 1) {\n        return \"No\";\n    }\n    // Check if the substring before\
    \ the dot starts with a latin alphapet letter\n    if (!(file_name.substr(0, 1).isalpha()))\
    \ {\n        return \"No\";\n    }\n    // Check if the substring after the dot\
    \ is one of these: ['txt', 'exe', 'dll']\n    if (!(file_name.substr(file_name.size()\
    \ - 1).find_first_of(\"txt\") != std::string::npos\n        && !file_name.substr(file_name.size()\
    \ - 1).find_first_of(\"exe\") != std::string::npos\n        && !file_name.substr(file_name.size()\
    \ - 1).find_first_of(\"dll\") != std::string::npos)) {\n        return \"No\"\
    ;\n    }\n    return \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjwoezrsd.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpjwoezrsd.cpp:27:34: error: 'class std::basic_string<char>' has no member\
    \ named 'isalpha'\n     if (!(file_name.substr(0, 1).isalpha())) {\n         \
    \                         ^\n/tmp/tmpjwoezrsd.cpp: In function 'int main()':\n\
    /tmp/tmpjwoezrsd.cpp:39:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = file_name_check;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjwoezrsd.cpp:2:\n/tmp/tmpjwoezrsd.cpp:40:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Write your solution here\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbiyu5crn.cpp: In function 'int main()':\n/tmp/tmpbiyu5crn.cpp:19:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbiyu5crn.cpp:2:\n/tmp/tmpbiyu5crn.cpp:20:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int len = file_name.length();\n    if (len < 4 || len > 6) return false;\n\
    \    \n    for (int i = 0; i < len; ++i) {\n        if (!isdigit(file_name[i]))\
    \ return false;\n    }\n    if (file_name[len - 1] == '.') return false;\n   \
    \ \n    for (int i = 0; i < len; ++i) {\n        if (file_name[i] < 'a' || file_name[i]\
    \ > 'z') return false;\n    }\n    if (file_name[0] == '.') return false;\n  \
    \  for (int i = 1; i < len; ++i) {\n        if (file_name[i] == '.') return false;\n\
    \        if (file_name[i] != 'd' && file_name[i] != 'e' && file_name[i] != 'f')\
    \ return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvcsr51hv.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpvcsr51hv.cpp:17:36: warning: converting 'false' to pointer type for argument\
    \ 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*,\
    \ const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>]' [-Wconversion-null]\n     if (len < 4 || len > 6) return\
    \ false;\n                                    ^\n/tmp/tmpvcsr51hv.cpp:20:44: warning:\
    \ converting 'false' to pointer type for argument 1 of 'std::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with _CharT =\
    \ char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]' [-Wconversion-null]\n\
    \         if (!isdigit(file_name[i])) return false;\n                        \
    \                    ^\n/tmp/tmpvcsr51hv.cpp:22:43: warning: converting 'false'\
    \ to pointer type for argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-Wconversion-null]\n     if (file_name[len\
    \ - 1] == '.') return false;\n                                           ^\n/tmp/tmpvcsr51hv.cpp:25:62:\
    \ warning: converting 'false' to pointer type for argument 1 of 'std::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with _CharT =\
    \ char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]' [-Wconversion-null]\n\
    \         if (file_name[i] < 'a' || file_name[i] > 'z') return false;\n      \
    \                                                        ^\n/tmp/tmpvcsr51hv.cpp:27:37:\
    \ warning: converting 'false' to pointer type for argument 1 of 'std::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with _CharT =\
    \ char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]' [-Wconversion-null]\n\
    \     if (file_name[0] == '.') return false;\n                               \
    \      ^\n/tmp/tmpvcsr51hv.cpp:29:41: warning: converting 'false' "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Only need to validate the file name when it is valid file name\n  if\
    \ (file_name.find_first_not_of(\"0123456789\") != std::string::npos) {\n    return\
    \ file_name;\n  }\n  // Make sure the file name starts with a latin letter\n \
    \ if (file_name.find_first_not_of(\"aA\") != std::string::npos) {\n    return\
    \ file_name;\n  }\n  // Make sure the file name has one dot\n  if (file_name.find_first_of(\"\
    .\") != std::string::npos) {\n    return file_name;\n  }\n  // Get the substring\
    \ before the first dot\n  std::string sub_before_first_dot = file_name.substr(0,\
    \ file_name.find_first_of(\".\") - 1);\n  // Make sure that the substring does\
    \ not start with a space \n  // and if it does starts with a letter from the latin\
    \ alphapet \n  if (sub_before_first_dot.find_first_not_of(\"0123456789\") != std::string::npos\
    \ && sub_before_first_dot.find_first_not_of(\"aA\") != std::string::npos) {\n\
    \    return file_name;\n  }\n  // Get the substring after the dot\n  std::string\
    \ sub_after_first_dot = file_name.substr(file_name.find_first_of(\".\") + 1, file_name.size()\
    \ - 1);\n  // If the substring after dot does not contain these 3 strings, return\
    \ false\n  if (sub_after_first_dot.find(\"exe\") != std::string::npos && sub_after_first_dot.find(\"\
    dll\") != std::string::npos && sub_after_first_dot.find(\"txt\") != std::string::npos)\
    \ {\n    return file_name;\n  }\n  return \"No\";\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy_lyo9sv.cpp: In function 'int main()':\n/tmp/tmpy_lyo9sv.cpp:44:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy_lyo9sv.cpp:2:\n/tmp/tmpy_lyo9sv.cpp:45:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\t// Declare a variable 'answer' which will contain the return value of function\
    \ 'is_valid_file_name'\n\t// It will be initialized to 'No' since no file's name\
    \ is valid.\n\tstd::string answer;\n\t// Declare a variable 'flag' which will\
    \ contain the value 'true' if the file's name starts with a latin \n\t// alphapet\
    \ letter, and 'false' otherwise\n\tbool flag = true;\n\t// Declare a variable\
    \ 'digit' which will contain the value '0' if the file's name contains more than\
    \ \n\t// three digits, and '1' otherwise\n\tint digit = 0;\n\t// Declare a variable\
    \ 'x' which will contain the substring before the dot ('.').\n\t// It should be\
    \ initialized to an empty string since we cannot extract the substring from an\
    \ empty string.\n\tstd::string x;\n\t// Declare a variable 'y' which will contain\
    \ the substring after the dot ('.').\n\t// It should be initialized to an empty\
    \ string since we cannot extract the substring from an empty string.\n\tstd::string\
    \ y;\n\t// Declare a variable 'i' which will contain the substring before the\
    \ dot ('.') after we extract \n\t// the substring after the dot ('.').\n\tint\
    \ i;\n\t// Declare a variable 'j' which will contain the substring after the dot\
    \ ('.') after we extract \n\t// the substring before the dot ('.').\n\tint j;\n\
    \t// Declare a variable 'y' which will contain '0' if the file's name contains\
    \ exactly one dot \n\t// ('.'), '1' otherwise.\n\tint y = 0;\n\t// Declare a variable\
    \ 'x' which will contain 'example' if the file's name is 'example.txt', \n\t//\
    \ '1' otherwise.\n\tstd::string x = \"example\";\n\t// Declare a variable 'y'\
    \ which will contain 'txt' if the file's name is 'example.txt', \n\t// 'exe' otherwise.\n\
    \tstd::string y = \"txt\";\n\t// Declare a variable 'i' which will contain the\
    \ position of character '0' in the substring before \n\t// the dot ('.').\n\t\
    for (int i = 0; i < x.length(); i++) {\n\t\tif (flag) {\n\t\t\tif (x.at(i) ==\
    \ '0' || x.at(i) == '1' || x.at(i) == '2' || x.at(i) == '3' || x.at(i) == '4'\
    \ || x.at(i) == '5' || x.at(i) == '6' || x.at(i) == '7' || x.at(i) == '8' || x.at(i)\
    \ == '9') {\n\t\t\t\tdigit = x.at(i);\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\
    \t}\n\t// Declare a variable 'j' which will contain the position of character\
    \ '9' in the substring after \n\t// the dot ('.').\n\tfor (int j = 0; j < y.length();\
    \ j++) {\n\t\tif (flag) {\n\t\t\tif (y.at(j) == '\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbemosar8.cpp:60:19: warning: missing terminating ' character [enabled\
    \ by default]\n    if (y.at(j) == '\n                   ^\n/tmp/tmpbemosar8.cpp:60:4:\
    \ error: missing terminating ' character\n    if (y.at(j) == '\n    ^\n/tmp/tmpbemosar8.cpp:\
    \ In function 'std::string file_name_check(std::string)':\n/tmp/tmpbemosar8.cpp:39:6:\
    \ error: conflicting declaration 'int y'\n  int y = 0;\n      ^\n/tmp/tmpbemosar8.cpp:30:14:\
    \ error: 'y' has a previous declaration as 'std::string y'\n  std::string y;\n\
    \              ^\n/tmp/tmpbemosar8.cpp:42:14: error: redeclaration of 'std::string\
    \ x'\n  std::string x = \"example\";\n              ^\n/tmp/tmpbemosar8.cpp:27:14:\
    \ error: 'std::string x' previously declared here\n  std::string x;\n        \
    \      ^\n/tmp/tmpbemosar8.cpp:45:14: error: redeclaration of 'std::string y'\n\
    \  std::string y = \"txt\";\n              ^\n/tmp/tmpbemosar8.cpp:30:14: error:\
    \ 'std::string y' previously declared here\n  std::string y;\n              ^\n\
    /tmp/tmpbemosar8.cpp:61:1: error: expected primary-expression before '}' token\n\
    \ }\n ^\n/tmp/tmpbemosar8.cpp:61:1: error: expected ')' before '}' token\n/tmp/tmpbemosar8.cpp:61:1:\
    \ error: expected primary-expression before '}' token\n/tmp/tmpbemosar8.cpp:61:1:\
    \ error: expected ';' before '}' token\n/tmp/tmpbemosar8.cpp:62:12: error: a function-definition\
    \ is not allowed here before '{' token\n int main() {\n            ^\n/tmp/tmpbemosar8.cpp:90:1:\
    \ error: expected '}' at end of input\n }\n ^\n/tmp/tmpbemosar8.cpp:90:1: error:\
    \ expected '}' at end of input\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Declare a variable to store the number of '.' that appear in the file\
    \ name \n    int dot_count = 0;\n    // Declare a variable to store the number\
    \ of 'e' that appear in the file name \n    int e_count = 0;\n    // Declare a\
    \ variable to store the 'e' that appear in the file name\n    char e = 'e';\n\
    \    // Declare a variable to store the 'e' that appear in the file name\n   \
    \ std::string e_str = \"e\";\n    // Declare a variable to store the number of\
    \ 'x' that appear in the file name \n    int x_count = 0;\n    // Declare a variable\
    \ to store the 'x' that appear in the file name\n    char x = 'x';\n    // Declare\
    \ a variable to store the 'x' that appear in the file name\n    std::string x_str\
    \ = \"x\";\n    // Declare a variable to store the number of 'r' that appear in\
    \ the file name \n    int r_count = 0;\n    // Declare a variable to store the\
    \ 'r' that appear in the file name\n    char r = 'r';\n    // Declare a variable\
    \ to store the 'r' that appear in the file name\n    std::string r_str = \"r\"\
    ;\n    // Declare a variable to store the number of 'e' that appear in the file\
    \ name \n    int n_count = 0;\n    // Declare a variable to store the 'n' that\
    \ appear in the file name\n    char n = 'n';\n    // Declare a variable to store\
    \ the 'n' that appear in the file name\n    std::string n_str = \"n\";\n    //\
    \ Declare a variable to store the number of 's' that appear in the file name \n\
    \    int s_count = 0;\n    // Declare a variable to store the 's' that appear\
    \ in the file name\n    char s = 's';\n    // Declare a variable to store the\
    \ 's' that appear in the file name\n    std::string s_str = \"s\";\n    // Declare\
    \ a variable to store the number of 'm' that appear in the file name \n    int\
    \ m_count = 0;\n    // Declare a variable to store the 'm' that appear in the\
    \ file name\n    char m = 'm';\n    // Declare a variable to store the 'm' that\
    \ appear in the file name\n    std::string m_str = \"m\";\n    // Declare a variable\
    \ to store the number of 'a' that appear in the file name \n    int a_count =\
    \ 0;\n    // Declare a variable to store the 'a' that appear in the file name\n\
    \    char a = 'a';\n    // Declare a variable to store the 'a' that appear in\
    \ the file name\n    std::string a_str = \"a\";\n    // Declare a variable to\
    \ store the number of 'l' that appear in the file name \n    int l_count = 0;\n\
    \    // Declare a variable to store the 'l' that appear in the file name\n   \
    \ \n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy28cvaep.cpp: In function 'int main()':\n/tmp/tmpy28cvaep.cpp:66:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy28cvaep.cpp:2:\n/tmp/tmpy28cvaep.cpp:67:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string file_check;\n    int num_valid_chars = 0;\n    for (auto\
    \ ch : file_name) {\n        if (std::isalnum(ch) || ch == '_' || ch == '.') {\n\
    \            file_check += \"a\"; // Append an \"a\" to the file_check if the\
    \ ch is a latin alphapet letter or a dot.\n            num_valid_chars++;\n  \
    \      }\n        else if (((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'))\
    \ && (ch != '_')) {\n            file_check += \"a\"; // Append an \"a\" to the\
    \ file_check if the ch is a latin alphapet letter. \n            num_valid_chars++;\n\
    \        }\n        else {\n            file_check += \"0\"; // Append a 0 to\
    \ the file_check if the ch is a non-latin alphapet letter, or '_'\n          \
    \  num_valid_chars++;\n        }\n    }\n    if (file_check.length() == 3) {\n\
    \        file_check += \"0\"; // Append a 0 to the file_check if the file_name\
    \ is less than 3 chars.\n    }\n    if (num_valid_chars == 1 && file_check[0]\
    \ == 'a') {\n        file_check = \"Yes\"; // If the file_name contains one latin\
    \ alphapet character, then file_name is valid.\n    }\n    else if (num_valid_chars\
    \ > 1 && file_check[0] == 'a' && file_check[1] == '.') {\n        file_check =\
    \ \"No\"; // If the file_name contains more than one latin alphapet character,\
    \ and if it starts with a dot, then file_name is invalid.\n    }\n    return file_check;\n\
    }\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzc87o54a.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpzc87o54a.cpp:18:15: error: 'ch' does not name a type\n     for (auto ch\
    \ : file_name) {\n               ^\n/tmp/tmpzc87o54a.cpp:32:5: error: expected\
    \ ';' before 'if'\n     if (file_check.length() == 3) {\n     ^\n/tmp/tmpzc87o54a.cpp:32:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmpzc87o54a.cpp:32:5: error:\
    \ expected ';' before 'if'\n/tmp/tmpzc87o54a.cpp:32:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmpzc87o54a.cpp:32:5: error: expected ')' before 'if'\n/tmp/tmpzc87o54a.cpp:\
    \ In function 'int main()':\n/tmp/tmpzc87o54a.cpp:44:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzc87o54a.cpp:2:\n/tmp/tmpzc87o54a.cpp:45:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Start by checking that the file name is valid\n    bool result = true;\n\
    \    \n    // Get the index of the dot '.' in the file name\n    auto dot = file_name.find_first_of(\"\
    .\");\n\n    // Check if the file name is valid\n    if (dot != std::string::npos)\
    \ {\n        // Make sure that the substring before the dot is valid\n       \
    \ std::string before_dot = file_name.substr(0, dot);\n        result = result\
    \ && (before_dot.size() == 1) && \n            (before_dot.front() >= 'a' && before_dot.front()\
    \ <= 'z') &&\n            (before_dot.front() >= 'A' && before_dot.front() <=\
    \ 'Z');\n    }\n    \n    // Check if the file name is valid\n    if (dot != std::string::npos)\
    \ {\n        // Get the substring after the dot\n        std::string after_dot\
    \ = file_name.substr(dot + 1);\n        \n        // Check if the substring after\
    \ the dot is valid\n        if (after_dot.size() > 0 && after_dot.front() >= 'a'\
    \ && after_dot.front() <= 'z' &&\n            after_dot.front() >= 'A' && after_dot.front()\
    \ <= 'Z') {\n            // Check if the substring after the dot ends with one\
    \ of the valid extensions\n            for (char extension : {\"txt\", \"exe\"\
    , \"dll\"}) {\n                if (after_dot.size() > extension.size() && after_dot.substr(after_dot.size()\
    \ - extension.size(), extension.size()) == extension) {\n                    result\
    \ = true;\n                    break;\n                }\n            }\n    \
    \    }\n        else {\n            result = false;\n        }\n    }\n\n    return\
    \ result ? \"Yes\" : \"No\";\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvk016jd2.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpvk016jd2.cpp:20:10: error: 'dot' does not name a type\n     auto dot =\
    \ file_name.find_first_of(\".\");\n          ^\n/tmp/tmpvk016jd2.cpp:23:9: error:\
    \ 'dot' was not declared in this scope\n     if (dot != std::string::npos) {\n\
    \         ^\n/tmp/tmpvk016jd2.cpp:27:25: error: 'std::string' has no member named\
    \ 'front'\n             (before_dot.front() >= 'a' && before_dot.front() <= 'z')\
    \ &&\n                         ^\n/tmp/tmpvk016jd2.cpp:27:54: error: 'std::string'\
    \ has no member named 'front'\n             (before_dot.front() >= 'a' && before_dot.front()\
    \ <= 'z') &&\n                                                      ^\n/tmp/tmpvk016jd2.cpp:28:25:\
    \ error: 'std::string' has no member named 'front'\n             (before_dot.front()\
    \ >= 'A' && before_dot.front() <= 'Z');\n                         ^\n/tmp/tmpvk016jd2.cpp:28:54:\
    \ error: 'std::string' has no member named 'front'\n             (before_dot.front()\
    \ >= 'A' && before_dot.front() <= 'Z');\n                                    \
    \                  ^\n/tmp/tmpvk016jd2.cpp:32:9: error: 'dot' was not declared\
    \ in this scope\n     if (dot != std::string::npos) {\n         ^\n/tmp/tmpvk016jd2.cpp:37:47:\
    \ error: 'std::string' has no member named 'front'\n         if (after_dot.size()\
    \ > 0 && after_dot.front() >= 'a' && after_dot.front() <= 'z' &&\n           \
    \                                    ^\n/tmp/tmpvk016jd2.cpp:37:75: error: 'std::string'\
    \ has no member named 'front'\n         if (after_dot.size() > 0 && after_dot.front()\
    \ >= 'a' && after_dot.front() <= 'z' &&\n                                    \
    \                                       ^\n/tmp/tmpvk016jd2.cpp:38:23: error:\
    \ 'std::string' has no member named 'front'\n             after_dot.front() >=\
    \ 'A' && after_dot.front() <= 'Z') {\n                       ^\n/tmp/tmpvk016jd2.cpp:38:51:\
    \ error: 'std::string' has no member named 'front'\n             after_dot.front()\
    \ >= 'A' && after_dot.front() <= 'Z') {\n                                    \
    \               ^\n/tmp/tmpvk016j"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string res;\n    if (file_name.size()==0 || file_name.find(\".\"\
    ) < 0 ||\n        file_name.substr(0, 1) < 'a' || file_name.substr(0, 1) > 'z'\
    \ ||\n        file_name.substr(file_name.size()-1,1) < 'a' || file_name.substr(file_name.size()-1,1)\
    \ > 'z' ||\n        file_name.substr(0,1) != file_name[0])\n        res = \"No\"\
    ;\n    else if (file_name.find(\".txt\") != std::string::npos)\n        res =\
    \ \"Yes\";\n    else if (file_name.find(\".exe\") != std::string::npos)\n    \
    \    res = \"Yes\";\n    else if (file_name.find(\".dll\") != std::string::npos)\n\
    \        res = \"Yes\";\n    else\n        res = \"No\";\n    return res;\n}\n\
    int main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpim846hh2.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpim846hh2.cpp:18:32: error: no match for 'operator<' (operand types are\
    \ 'std::basic_string<char>' and 'char')\n         file_name.substr(0, 1) < 'a'\
    \ || file_name.substr(0, 1) > 'z' ||\n                                ^\n/tmp/tmpim846hh2.cpp:18:32:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpim846hh2.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type>\
    \ std::operator<(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(<,\
    \ __less)\n ^\n/usr/include/c++/4.8.2/valarray:1181:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpim846hh2.cpp:18:34: note:   mismatched\
    \ types 'const std::valarray<_Tp>' and 'char'\n         file_name.substr(0, 1)\
    \ < 'a' || file_name.substr(0, 1) > 'z' ||\n                                 \
    \ ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpim846hh2.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type>\
    \ std::operator<(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(<,\
    \ __less)\n ^\n/usr/include/c++/4.8.2/valarray:1181:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpim846hh2.cpp:18:34: note:   'std::basic_string<char>'\
    \ is not derived from 'const std::valarray<_Tp>'\n         file_name.substr(0,\
    \ 1) < 'a' || file_name.substr(0, 1) > 'z' ||\n                              \
    \    ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpim846hh2.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // your code goes here\n  std::cin >> file_name;\n  assert(file_name.size()\
    \ <= 4);\n  std::cin >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin\
    \ >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n\
    \  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n  assert(file_name.size()\
    \ <= 4);\n  std::cin >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin\
    \ >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n\
    \  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n  assert(file_name.size()\
    \ <= 4);\n  std::cin >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin\
    \ >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n\
    \  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n  assert(file_name.size()\
    \ <= 4);\n  std::cin >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin\
    \ >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n\
    \  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n  assert(file_name.size()\
    \ <= 4);\n  std::cin >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin\
    \ >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n\
    \  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n  assert(file_name.size()\
    \ <= 4);\n  std::cin >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin\
    \ >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n\
    \  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n  assert(file_name.size()\
    \ <= 4);\n  std::cin >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin\
    \ >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n\
    \  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n  assert(file_name.size()\
    \ <= 4);\n  std::cin >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin\
    \ >> file_name;\n  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n\
    \  assert(file_name.size() <= 4);\n  std::cin >> file_name;\n  assert(file_name.size()\
    \ <= 4);\n  std::cin >> file_name;\n  assert(file_name.size() \n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnrcl5zrh.cpp:114:0: error: unterminated argument list invoking\
    \ macro \"assert\"\n }\n ^\n/tmp/tmpnrcl5zrh.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpnrcl5zrh.cpp:84:3: error: 'assert' was not declared in this scope\n  \
    \ assert(file_name.size() \n   ^\n/tmp/tmpnrcl5zrh.cpp:84:3: error: expected ';'\
    \ at end of input\n/tmp/tmpnrcl5zrh.cpp:84:3: error: expected '}' at end of input\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::cerr << \"file_name_check called\" << std::endl;\n    int count\
    \ = 0;\n    for (auto i : file_name) {\n        if (i == '.')\n            count++;\n\
    \        else if (i > '0' && i < '9')\n            count++;\n        else if (i\
    \ > 'a' && i < 'z' || i > 'A' && i < 'Z')\n            count++;\n        else\
    \ if (i == 0)\n            count++;\n        else if (i > 'a' && i < 'z' || i\
    \ > 'A' && i < 'Z' || i > '0' && i < '9')\n            count++;\n        else\n\
    \            break;\n    }\n    if (count == 0) {\n        return \"\";\n    }\
    \ else if (count == 1) {\n        return \"No\";\n    } else if (count == 2) {\n\
    \        return \"No\";\n    } else {\n        return \"Yes\";\n    }\n}\nint\
    \ main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp17trkce8.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp17trkce8.cpp:18:15: error: 'i' does not name a type\n     for (auto i\
    \ : file_name) {\n               ^\n/tmp/tmp17trkce8.cpp:32:5: error: expected\
    \ ';' before 'if'\n     if (count == 0) {\n     ^\n/tmp/tmp17trkce8.cpp:32:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmp17trkce8.cpp:32:5: error:\
    \ expected ';' before 'if'\n/tmp/tmp17trkce8.cpp:32:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmp17trkce8.cpp:32:5: error: expected ')' before 'if'\n/tmp/tmp17trkce8.cpp:\
    \ In function 'int main()':\n/tmp/tmp17trkce8.cpp:43:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp17trkce8.cpp:2:\n/tmp/tmp17trkce8.cpp:44:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n   // Your code here\n   //\n   // Your code here\n   //\n   // Your code\
    \ here\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb9x2_ll4.cpp: In function 'int main()':\n/tmp/tmpb9x2_ll4.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb9x2_ll4.cpp:2:\n/tmp/tmpb9x2_ll4.cpp:24:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string file_name_check(file_name.substr(0, 4)); // get rid of first\
    \ 4 chars because all file names are between 3-4 digits\n    char dot1[3];\n \
    \   std::string dot1_check = \".\";\n    dot1[0] = '\\0';\n    std::string file_name_dot1_check\
    \ = file_name_check + dot1_check;\n    if (std::all_of(file_name_dot1_check.begin(),\
    \ file_name_dot1_check.end(), isalpha)) {\n        return file_name_check;\n \
    \   } else {\n        return \"No\";\n    }\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5qbngj0c.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp5qbngj0c.cpp:21:9: error: 'all_of' is not a member of 'std'\n     if (std::all_of(file_name_dot1_check.begin(),\
    \ file_name_dot1_check.end(), isalpha)) {\n         ^\n/tmp/tmp5qbngj0c.cpp: In\
    \ function 'int main()':\n/tmp/tmp5qbngj0c.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = file_name_check;\n          ^\nIn file\
    \ included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5qbngj0c.cpp:2:\n/tmp/tmp5qbngj0c.cpp:29:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tint counter = 0;\n\tfor(int i=0; i<file_name.size() && counter < 3; i++)\
    \ {\n\t\tif(file_name[i]<'a' || file_name[i]>'z' || file_name[i]>'Z' || file_name[i]=='_')\
    \ {\n\t\t\treturn \"No\";\n\t\t}\n\t}\n\tif(file_name.size()==0 || file_name[0]=='.')\
    \ {\n\t\treturn \"No\";\n\t}\n\telse {\n\t\tstd::string file_ext = file_name.substr(file_name.size()-3);\n\
    \t\tif(file_ext != \"txt\" && file_ext != \"exe\" && file_ext != \"dll\")\n\t\t\
    \treturn \"No\";\n\t}\n\treturn \"Yes\";\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdfp2rbly.cpp: In function 'int main()':\n/tmp/tmpdfp2rbly.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdfp2rbly.cpp:2:\n/tmp/tmpdfp2rbly.cpp:34:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int count_ones = 0;\n    int count_zeros = 0;\n    for(int i = 0; i<file_name.length();\
    \ i++) {\n        if(file_name.at(i) == '1') {\n            count_ones++;\n  \
    \          if(count_ones >= 4) {\n                return \"No\";\n           \
    \ }\n        } else {\n            count_zeros++;\n        }\n    }\n    if(count_zeros\
    \ >= 3) {\n        return \"No\";\n    }\n    if(file_name.at(file_name.length()\
    \ - 1) != '.') {\n        return \"No\";\n    }\n    for(int i = 0; i < file_name.length()\
    \ - 1; i++) {\n        if(file_name.at(i) >= 'a' && file_name.at(i) <= 'z' ||\
    \ file_name.at(i) >= 'A' && file_name.at(i) <= 'Z') {\n            if(i == 0 ||\
    \ file_name.at(i - 1) != '\\\\') {\n                return \"No\";\n         \
    \   }\n        } else {\n            return \"No\";\n        }\n    }\n    for(int\
    \ i = file_name.length() - 2; i >= 0; i--) {\n        if(file_name.at(i) >= 'a'\
    \ && file_name.at(i) <= 'z' || file_name.at(i) >= 'A' && file_name.at(i) <= 'Z')\
    \ {\n            if(i == file_name.length() - 1 || file_name.at(i + 1) != '\\\\\
    ') {\n                return \"No\";\n            }\n        } else {\n      \
    \      return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nint main() {\n\
    \    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc3fzrk0y.cpp: In function 'int main()':\n/tmp/tmpc3fzrk0y.cpp:55:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpc3fzrk0y.cpp:2:\n/tmp/tmpc3fzrk0y.cpp:56:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Declare and initialize three variables a, b, and c to hold the file's\
    \ \n    // name and its extension.\n    // a will hold the file's name without\
    \ the extension.\n    // b will hold the file's extension.\n    // c will hold\
    \ the file's name after removing the extension.\n    std::string a;\n    std::string\
    \ b;\n    std::string c;\n    // Iterate over the string until the string's length\
    \ is zero, \n    // and ignore any additional characters in the string beyond\
    \ the \n    // characters in the range from 'a' to 'z' or 'A' to 'Z' \n    //\
    \ The string's length will be more than zero only if a file's name is \n    //\
    \ valid.\n    for (int i = 0, n = file_name.length(); i < n; ++i) {\n        char\
    \ ch = file_name[i];\n        if (ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <=\
    \ 'Z') {\n            a += ch;\n        } else if (ch == '.') {\n            ++i;\n\
    \            while (i < n && file_name[i] != '.') ++i;\n            a.erase(0,\
    \ i);\n            b.erase(0, i);\n            c.erase(0, i);\n            break;\n\
    \        }\n    }\n    if (a.length() == 0 || b.length() == 0 || c.length() ==\
    \ 0) {\n        return \"No\";\n    } else {\n        return \"Yes\";\n    }\n\
    }\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvutydmzm.cpp: In function 'int main()':\n/tmp/tmpvutydmzm.cpp:49:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvutydmzm.cpp:2:\n/tmp/tmpvutydmzm.cpp:50:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tint index = 0;\n\tstd::string file_name_before_dot = file_name.substr(0,\
    \ file_name.find(\".\", index));\n\t\n\t// Get the last character of the file\
    \ name.\n\tchar last_char = file_name[file_name.size() - 1];\n\n\t// Return Yes\
    \ if the file name contains one dot '.', or No if the file name contains more\
    \ than one dot '.'.\n\treturn (file_name_before_dot == \"\" || file_name_before_dot[file_name_before_dot.size()\
    \ - 1] != '.')\n\t\t&& (file_name_before_dot.find(\"..\") == std::string::npos)\n\
    \t\t&& ((file_name.find(\".\") != std::string::npos)\n\t\t\t&& ((file_name.find(\"\
    txt\") != std::string::npos)\n\t\t\t\t|| (file_name.find(\"exe\") != std::string::npos)\n\
    \t\t\t\t|| (file_name.find(\"dll\") != std::string::npos)))\n\t\t&& ((file_name.find(\"\
    .\") != std::string::npos)\n\t\t\t&& ((file_name.find(\"txt\") != std::string::npos)\n\
    \t\t\t\t|| (file_name.find(\"exe\") != std::string::npos)\n\t\t\t\t|| (file_name.find(\"\
    dll\") != std::string::npos)));\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaw5rw2lt.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpaw5rw2lt.cpp:29:3: error: could not convert '((((std::operator==<char,\
    \ std::char_traits<char>, std::allocator<char> >((*(const std::basic_string<char>*)(&\
    \ file_name_before_dot)), ((const char*)\"\")) || (((signed char)file_name_before_dot.std::basic_string<_CharT,\
    \ _Traits, _Alloc>::operator[]<char, std::char_traits<char>, std::allocator<char>\
    \ >((file_name_before_dot.std::basic_string<_CharT, _Traits, _Alloc>::size<char,\
    \ std::char_traits<char>, std::allocator<char> >() + 18446744073709551615ul)))\
    \ != 46)) && (file_name_before_dot.std::basic_string<_CharT, _Traits, _Alloc>::find<char,\
    \ std::char_traits<char>, std::allocator<char> >(((const char*)\"..\"), 0ul) ==\
    \ 18446744073709551615ul)) && ((file_name.std::basic_string<_CharT, _Traits, _Alloc>::find<char,\
    \ std::char_traits<char>, std::allocator<char> >(((const char*)\".\"), 0ul) !=\
    \ 18446744073709551615ul) && (((file_name.std::basic_string<_CharT, _Traits, _Alloc>::find<char,\
    \ std::char_traits<char>, std::allocator<char> >(((const char*)\"txt\"), 0ul)\
    \ != 18446744073709551615ul) || (file_name.std::basic_string<_CharT, _Traits,\
    \ _Alloc>::find<char, std::char_traits<char>, std::allocator<char> >(((const char*)\"\
    exe\"), 0ul) != 18446744073709551615ul)) || (file_name.std::basic_string<_CharT,\
    \ _Traits, _Alloc>::find<char, std::char_traits<char>, std::allocator<char> >(((const\
    \ char*)\"dll\"), 0ul) != 18446744073709551615ul)))) && ((file_name.std::basic_string<_CharT,\
    \ _Traits, _Alloc>::find<char, std::char_traits<char>, std::allocator<char> >(((const\
    \ char*)\".\"), 0ul) != 18446744073709551615ul) && (((file_name.std::basic_string<_CharT,\
    \ _Traits, _Alloc>::find<char, std::char_traits<char>, std::allocator<char> >(((const\
    \ char*)\"txt\"), 0ul) != 18446744073709551615ul) || (file_name.std::basic_string<_CharT,\
    \ _Traits, _Alloc>::find<char, std::char_traits<char>, std::allocator<char> >(((const\
    \ char*)\"exe\"), 0ul) != 18446744073709551615ul)) || (file_name.std::basic_string<_CharT,\
    \ _Traits, _Alloc>::find<char, std::cha"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    \n    std::string file_extension = file_name.substr(file_name.size()\
    \ - 3, 3);\n    \n    if (file_name.size() > 3 && file_name == \".\" && file_extension\
    \ == \"exe\") {\n        std::cout<<\"Yes\"<<std::endl;\n        return \"Yes\"\
    ;\n    }\n    else if (file_name.size() > 3 && file_name == \".\" && file_extension\
    \ == \"dll\") {\n        std::cout<<\"No\"<<std::endl;\n        return \"No\"\
    ;\n    }\n    else if (file_name.size() > 3 && file_name == \".\" && file_extension\
    \ == \"txt\") {\n        std::cout<<\"Yes\"<<std::endl;\n        return \"Yes\"\
    ;\n    }\n    else if (file_name.size() > 3 && file_name == \".\" && file_extension\
    \ == \"txt\") {\n        std::cout<<\"No\"<<std::endl;\n        return \"No\"\
    ;\n    }\n    else if (file_name.size() > 3 && file_name == \".\" && file_extension\
    \ == \"exe\") {\n        std::cout<<\"Yes\"<<std::endl;\n        return \"Yes\"\
    ;\n    }\n    else if (file_name.size() > 3 && file_name == \".\" && file_extension\
    \ == \"dll\") {\n        std::cout<<\"Yes\"<<std::endl;\n        return \"Yes\"\
    ;\n    }\n    else {\n        std::cout<<\"No\"<<std::endl;\n        return \"\
    No\";\n    }\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgxp970z2.cpp: In function 'int main()':\n/tmp/tmpgxp970z2.cpp:49:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgxp970z2.cpp:2:\n/tmp/tmpgxp970z2.cpp:50:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Write your code here\n    \n    // your code goes here\n    \n   \
    \ return \"\"; \n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptpu418nb.cpp: In function 'int main()':\n/tmp/tmptpu418nb.cpp:23:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptpu418nb.cpp:2:\n/tmp/tmptpu418nb.cpp:24:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  int n = file_name.size();\n  assert(n != 0);\n  assert(n % 3 != 0);\n \
    \ bool invalid = false;\n  bool dot_present = false;\n  bool starts_with_letter\
    \ = false;\n  std::string first_letter = \"\";\n  std::string ext;\n  int dot_pos\
    \ = 0;\n  for (int i = 0; i < (n / 3); i++) {\n    first_letter += file_name[i];\n\
    \    if (file_name[i] == \".\") {\n      dot_present = true;\n      dot_pos =\
    \ i;\n      if (file_name[i + 1] == '.') {\n        dot_pos += 1;\n        invalid\
    \ = true;\n      }\n    } else if (file_name[i] == first_letter[0]) {\n      starts_with_letter\
    \ = true;\n    } else {\n      invalid = true;\n      break;\n    }\n  }\n  if\
    \ (!invalid) {\n    if (dot_present) {\n      if (dot_pos == 0) {\n        ext\
    \ = \"txt\";\n      } else if (dot_pos == 1) {\n        ext = \"exe\";\n     \
    \ } else if (dot_pos == 2) {\n        ext = \"dll\";\n      }\n    }\n    if (first_letter[0]\
    \ == 'A' || first_letter[0] == 'a') {\n      return \"Yes\";\n    } else {\n \
    \     return \"No\";\n    }\n  }\n  return \"No\";\n}\nint main() {\n    auto\
    \ candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"\
    Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpysbr5zkb.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpysbr5zkb.cpp:27:25: error: ISO C++ forbids comparison between pointer\
    \ and integer [-fpermissive]\n     if (file_name[i] == \".\") {\n            \
    \             ^\n/tmp/tmpysbr5zkb.cpp: In function 'int main()':\n/tmp/tmpysbr5zkb.cpp:60:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpysbr5zkb.cpp:2:\n/tmp/tmpysbr5zkb.cpp:61:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  if (file_name.length() < 3) {\n    return \"No\";\n  }\n  if (file_name.find(\"\
    .\") == std::string::npos) {\n    return \"No\";\n  }\n  if (file_name.substr(0,\
    \ 1) < 'a' || file_name.substr(0, 1) > 'z') {\n    return \"No\";\n  }\n  if (file_name.substr(file_name.find_last_of(\"\
    .\") + 1) == \"txt\"\n    || file_name.substr(file_name.find_last_of(\".\") +\
    \ 1) == \"exe\"\n    || file_name.substr(file_name.find_last_of(\".\") + 1) ==\
    \ \"dll\") {\n    return \"Yes\";\n  }\n  return \"No\";\n}\nint main() {\n  \
    \  auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"))\
    \ == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n   \
    \ assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\"\
    )) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n\
    \    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkwmctbf2.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpkwmctbf2.cpp:22:30: error: no match for 'operator<' (operand types are\
    \ 'std::basic_string<char>' and 'char')\n   if (file_name.substr(0, 1) < 'a' ||\
    \ file_name.substr(0, 1) > 'z') {\n                              ^\n/tmp/tmpkwmctbf2.cpp:22:30:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpkwmctbf2.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type>\
    \ std::operator<(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(<,\
    \ __less)\n ^\n/usr/include/c++/4.8.2/valarray:1181:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpkwmctbf2.cpp:22:32: note:   mismatched\
    \ types 'const std::valarray<_Tp>' and 'char'\n   if (file_name.substr(0, 1) <\
    \ 'a' || file_name.substr(0, 1) > 'z') {\n                                ^\n\
    In file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpkwmctbf2.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__less, _Tp>::result_type>\
    \ std::operator<(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(<,\
    \ __less)\n ^\n/usr/include/c++/4.8.2/valarray:1181:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpkwmctbf2.cpp:22:32: note:   'std::basic_string<char>'\
    \ is not derived from 'const std::valarray<_Tp>'\n   if (file_name.substr(0, 1)\
    \ < 'a' || file_name.substr(0, 1) > 'z') {\n                                ^\n\
    In file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpkwmctbf2.cpp:2:\n/usr/include/c++/4.8.2/valarray:1181:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__less, std::_ValArray,"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    bool is_ok = true;\n\n    size_t number_of_digits = 0;\n    for (auto\
    \ c : file_name) {\n        if (std::isdigit(c)) {\n            number_of_digits++;\n\
    \        } else if (number_of_digits == 3 && c != '.') {\n            is_ok =\
    \ false;\n            break;\n        }\n    }\n\n    if (number_of_digits ==\
    \ 1) {\n        for (auto c : file_name) {\n            if (std::isalpha(c)) {\n\
    \                char first_letter = c[0];\n                if (first_letter >=\
    \ 'a' && first_letter <= 'z') {\n                    is_ok = true;\n         \
    \           break;\n                }\n            }\n        }\n    }\n\n   \
    \ std::vector<std::string> extension_list{\"txt\", \"exe\", \"dll\"};\n    int\
    \ extension_length = extension_list.size(); // Make it a constant if you wish.\n\
    \    for (size_t i = 0; i < extension_list.size(); i++) {\n        if (file_name.substr(extension_list[i].length()\
    \ + 1, extension_list[i].length() + 3) == extension_list[i]) {\n            extension_length--;\n\
    \        }\n    }\n\n    if (extension_length == 0) {\n        is_ok = true;\n\
    \    } else if (extension_length > 0) {\n        is_ok = false;\n    }\n\n   \
    \ return std::string(is_ok ? \"Yes\" : \"No\");\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp83qdrowi.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp83qdrowi.cpp:19:15: error: 'c' does not name a type\n     for (auto c\
    \ : file_name) {\n               ^\n/tmp/tmp83qdrowi.cpp:28:5: error: expected\
    \ ';' before 'if'\n     if (number_of_digits == 1) {\n     ^\n/tmp/tmp83qdrowi.cpp:28:5:\
    \ error: expected primary-expression before 'if'\n/tmp/tmp83qdrowi.cpp:28:5: error:\
    \ expected ';' before 'if'\n/tmp/tmp83qdrowi.cpp:28:5: error: expected primary-expression\
    \ before 'if'\n/tmp/tmp83qdrowi.cpp:28:5: error: expected ')' before 'if'\n/tmp/tmp83qdrowi.cpp:29:19:\
    \ error: 'c' does not name a type\n         for (auto c : file_name) {\n     \
    \              ^\n/tmp/tmp83qdrowi.cpp:38:5: error: expected ';' before '}' token\n\
    \     }\n     ^\n/tmp/tmp83qdrowi.cpp:38:5: error: expected primary-expression\
    \ before '}' token\n/tmp/tmp83qdrowi.cpp:38:5: error: expected ';' before '}'\
    \ token\n/tmp/tmp83qdrowi.cpp:38:5: error: expected primary-expression before\
    \ '}' token\n/tmp/tmp83qdrowi.cpp:38:5: error: expected ')' before '}' token\n\
    /tmp/tmp83qdrowi.cpp:38:5: error: expected primary-expression before '}' token\n\
    /tmp/tmp83qdrowi.cpp:38:5: error: expected ';' before '}' token\n/tmp/tmp83qdrowi.cpp:40:30:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     std::vector<std::string> extension_list{\"txt\",\
    \ \"exe\", \"dll\"};\n                              ^\n/tmp/tmp83qdrowi.cpp:40:64:\
    \ error: in C++98 'extension_list' must be initialized by constructor, not by\
    \ '{...}'\n     std::vector<std::string> extension_list{\"txt\", \"exe\", \"dll\"\
    };\n                                                                ^\n/tmp/tmp83qdrowi.cpp:40:64:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp83qdrowi.cpp:40:64: note:\
    \ candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // Your code here\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6_to4xzh.cpp: In function 'int main()':\n/tmp/tmp6_to4xzh.cpp:19:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6_to4xzh.cpp:2:\n/tmp/tmp6_to4xzh.cpp:20:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  std::string check;\n  char lastChar = file_name.back();\n  char firstChar\
    \ = file_name.front();\n  if (std::isdigit(lastChar)) {\n    check = file_name.substr(0,\
    \ 3);\n    file_name.pop_back();\n  } else if (std::isalpha(firstChar) && firstChar\
    \ != 'a' && firstChar != 'z') {\n    check = file_name.substr(0, 2);\n    file_name.pop_back();\n\
    \  } else if (file_name.back() == '.') {\n    std::string fileNameBeforeDot =\
    \ file_name.substr(0, file_name.find(\".\"));\n    check = fileNameBeforeDot;\n\
    \    file_name.erase(fileNameBeforeDot.end());\n  } else {\n    check = \"No\"\
    ;\n  }\n  return check;\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0dz46b8x.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp0dz46b8x.cpp:17:29: error: 'std::string' has no member named 'back'\n\
    \   char lastChar = file_name.back();\n                             ^\n/tmp/tmp0dz46b8x.cpp:18:30:\
    \ error: 'std::string' has no member named 'front'\n   char firstChar = file_name.front();\n\
    \                              ^\n/tmp/tmp0dz46b8x.cpp:21:15: error: 'std::string'\
    \ has no member named 'pop_back'\n     file_name.pop_back();\n               ^\n\
    /tmp/tmp0dz46b8x.cpp:24:15: error: 'std::string' has no member named 'pop_back'\n\
    \     file_name.pop_back();\n               ^\n/tmp/tmp0dz46b8x.cpp:25:24: error:\
    \ 'std::string' has no member named 'back'\n   } else if (file_name.back() ==\
    \ '.') {\n                        ^\n/tmp/tmp0dz46b8x.cpp: In function 'int main()':\n\
    /tmp/tmp0dz46b8x.cpp:35:10: error: 'candidate' does not name a type\n     auto\
    \ candidate = file_name_check;\n          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0dz46b8x.cpp:2:\n/tmp/tmp0dz46b8x.cpp:36:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int digit_count = 0;\n    char ch;\n    int len = file_name.length();\n\
    \    if (len > 3) {\n        return \"No\";\n    }\n    \n    for (auto itr =\
    \ file_name.begin(); itr != file_name.end(); itr++) {\n        ch = (*itr);\n\
    \        if (isdigit(ch)) {\n            digit_count += 1;\n        }\n      \
    \  if (digit_count > 3) {\n            return \"No\";\n        }\n    }\n    \n\
    \    if (file_name.find(\".\") == -1) {\n        return \"No\";\n    }\n    \n\
    \    if (file_name.substr(0, 1) != 'a' && file_name.substr(0, 1) != 'A') {\n \
    \       return \"No\";\n    }\n    \n    if (file_name.substr(file_name.find_first_not_of(\"\
    .\") + 1) == \"txt\" || \n        file_name.substr(file_name.find_first_not_of(\"\
    .\") + 1) == \"exe\" || \n        file_name.substr(file_name.find_first_not_of(\"\
    .\") + 1) == \"dll\") {\n        return \"Yes\";\n    }\n    else {\n        return\
    \ \"No\";\n    }\n}\nint main() {\n    auto candidate = file_name_check;\n   \
    \ assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmry1aqgo.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpmry1aqgo.cpp:23:15: error: 'itr' does not name a type\n     for (auto\
    \ itr = file_name.begin(); itr != file_name.end(); itr++) {\n               ^\n\
    /tmp/tmpmry1aqgo.cpp:23:40: error: expected ';' before 'itr'\n     for (auto itr\
    \ = file_name.begin(); itr != file_name.end(); itr++) {\n                    \
    \                    ^\n/tmp/tmpmry1aqgo.cpp:23:40: error: 'itr' was not declared\
    \ in this scope\n/tmp/tmpmry1aqgo.cpp:37:32: error: no match for 'operator!='\
    \ (operand types are 'std::basic_string<char>' and 'char')\n     if (file_name.substr(0,\
    \ 1) != 'a' && file_name.substr(0, 1) != 'A') {\n                            \
    \    ^\n/tmp/tmpmry1aqgo.cpp:37:32: note: candidates are:\nIn file included from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n           \
    \      from /tmp/tmpmry1aqgo.cpp:2:\n/usr/include/c++/4.8.2/valarray:1180:1: note:\
    \ template<class _Tp> std::_Expr<std::_BinClos<std::__not_equal_to, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__not_equal_to, _Tp>::result_type>\
    \ std::operator!=(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(!=,\
    \ __not_equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1180:1: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpmry1aqgo.cpp:37:35: note: \
    \  mismatched types 'const std::valarray<_Tp>' and 'char'\n     if (file_name.substr(0,\
    \ 1) != 'a' && file_name.substr(0, 1) != 'A') {\n                            \
    \       ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpmry1aqgo.cpp:2:\n/usr/include/c++/4.8.2/valarray:1180:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__not_equal_to, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__not_equal_to, _Tp>::result_type>\
    \ std::operator!=(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(!=,\
    \ __not_equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1180:1: note:   template\
    \ argument deduction/substitution failed"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code here\n    int length = file_name.length();\n    if(length>3\
    \ || length<3 || (length==3 && file_name[0]!='.'))\n        return \"No\";\n \
    \   if(length==3 && file_name[1]=='.')\n        return \"No\";\n    if(file_name[2]!='.'\
    \ && file_name[2]!='.')\n        return \"No\";\n    if(file_name[0]>='a' && file_name[0]<='z'\
    \ && file_name[1]>='a' && file_name[1]<='z')\n        return \"No\";\n    return\
    \ \"Yes\";\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmps3syldw7.cpp: In function 'int main()':\n/tmp/tmps3syldw7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps3syldw7.cpp:2:\n/tmp/tmps3syldw7.cpp:30:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    int counter=0;\n    for(int i=0;i<file_name.size();i++) {\n        if(file_name[i]>=48\
    \ && file_name[i]<=57) {\n            counter+=1;\n        }\n    }\n    if(file_name.size()<3\
    \ || counter>3 || (file_name[0]=='a' && file_name[1]=='z') || (file_name[0]=='A'\
    \ && file_name[1]=='Z')) {\n        return \"No\";\n    }\n    else {\n      \
    \  return \"Yes\";\n    }\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyzuimw03.cpp: In function 'int main()':\n/tmp/tmpyzuimw03.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyzuimw03.cpp:2:\n/tmp/tmpyzuimw03.cpp:31:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    \n    std::string file_name_return = \"No\";\n    // Extract the substring\
    \ before the dot ('.').\n    size_t dot_index = file_name.find_first_of(\".\"\
    );\n    \n    // Extract the substring after the dot ('.').\n    size_t dot_dot_index\
    \ = file_name.find_last_of(\".\");\n    \n    \n    \n    // Check if the substring\
    \ before the dot is not empty.\n    if (dot_index != std::string::npos) {\n  \
    \      // Check if the substring before the dot starts with a latin alphapet ('a'-'z'\
    \ or 'A'-'Z').\n        if (file_name.at(dot_index) >= 'a' && file_name.at(dot_index)\
    \ <= 'z' || file_name.at(dot_index) >= 'A' && file_name.at(dot_index) <= 'Z')\
    \ {\n            file_name_return = \"Yes\";\n        }\n    }\n    \n    // Check\
    \ if the substring after the dot is one of these three files: 'txt', 'exe', 'dll'.\n\
    \    if (dot_dot_index != std::string::npos) {\n        if (file_name.at(dot_dot_index)\
    \ != 'x' && file_name.at(dot_dot_index) != 'e' && file_name.at(dot_dot_index)\
    \ != 'm' && file_name.at(dot_dot_index) != 'l') {\n            file_name_return\
    \ = \"Yes\";\n        }\n    }\n    \n    return file_name_return;\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsieksv05.cpp: In function 'int main()':\n/tmp/tmpsieksv05.cpp:44:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsieksv05.cpp:2:\n/tmp/tmpsieksv05.cpp:45:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Your code goes here\n    if( file_name.size()<3 || file_name.substr(0,1)\
    \ == '0' || file_name.substr(0,1) == '9' ) {\n        return \"No\";\n    }\n\
    \    if( file_name.substr(0,1) == \".\" ) {\n        return \"No\";\n    }\n \
    \   for(int i=0; i<file_name.size();i++) {\n        if( !( file_name[i]<'a' ||\
    \ file_name[i]>'z' || file_name[i]<'A' || file_name[i]>'Z' ) ) {\n           \
    \ return \"No\";\n        }\n    }\n    for(int i=1;i<file_name.size();i++) {\n\
    \        if( (file_name[i]=='.') && (file_name[i-1]=='.') ) {\n            return\
    \ \"No\";\n        }\n    }\n    return \"Yes\";\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpz6bowz0v.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpz6bowz0v.cpp:17:53: error: no match for 'operator==' (operand types are\
    \ 'std::basic_string<char>' and 'char')\n     if( file_name.size()<3 || file_name.substr(0,1)\
    \ == '0' || file_name.substr(0,1) == '9' ) {\n                               \
    \                      ^\n/tmp/tmpz6bowz0v.cpp:17:53: note: candidates are:\n\
    In file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpz6bowz0v.cpp:2:\n/usr/include/c++/4.8.2/valarray:1179:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__equal_to, std::_Constant,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to, _Tp>::result_type>\
    \ std::operator==(const _Tp&, const std::valarray<_Tp>&)\n _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1179:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpz6bowz0v.cpp:17:56: note:   mismatched\
    \ types 'const std::valarray<_Tp>' and 'char'\n     if( file_name.size()<3 ||\
    \ file_name.substr(0,1) == '0' || file_name.substr(0,1) == '9' ) {\n         \
    \                                               ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:94:0,\n\
    \                 from /tmp/tmpz6bowz0v.cpp:2:\n/usr/include/c++/4.8.2/valarray:1179:1:\
    \ note: template<class _Tp> std::_Expr<std::_BinClos<std::__equal_to, std::_ValArray,\
    \ std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to, _Tp>::result_type>\
    \ std::operator==(const std::valarray<_Tp>&, const _Tp&)\n _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n ^\n/usr/include/c++/4.8.2/valarray:1179:1: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpz6bowz0v.cpp:17:56: note:   'std::basic_string<char>'\
    \ is not derived from 'const std::valarray<_Tp>'\n     if( file_name.size()<3\
    \ || file_name.substr(0,1) == '0' || file_name.substr(0,1) == '9' ) {\n      \
    \                                                  ^\nIn file included from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc+"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\tassert(file_name.size() >= 3);\n\tassert(file_name.find('.') == std::string::npos);\n\
    \tassert(file_name[0] >= 'a' && file_name[0] <= 'z');\n\tassert(file_name[1] ==\
    \ file_name[0]);\n\t\n\tstd::ostringstream os;\n\t\n\t// Substring before dot\n\
    \tstd::string file_ext = file_name.substr(file_name.find_first_of(\".\"));\n\t\
    \n\tassert(file_ext.size() >= 1);\n\t\n\t// Check if the substring after the dot\
    \ is txt, exe or dll\n\tstd::string file_ext_2 = file_ext.substr(0, file_ext.size()\
    \ - 1);\n\tif (file_ext_2 == \"txt\" || file_ext_2 == \"exe\" || file_ext_2 ==\
    \ \"dll\") {\n\t\tos << \"Yes\" << endl;\n\t} else {\n\t\tos << \"No\" << endl;\n\
    \t}\n\treturn os.str();\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpenhhq7j2.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpenhhq7j2.cpp:31:18: error: 'endl' was not declared in this scope\n   os\
    \ << \"Yes\" << endl;\n                  ^\n/tmp/tmpenhhq7j2.cpp:31:18: note:\
    \ suggested alternative:\nIn file included from /usr/include/c++/4.8.2/istream:39:0,\n\
    \                 from /usr/include/c++/4.8.2/sstream:38,\n                 from\
    \ /usr/include/c++/4.8.2/complex:45,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:66,\n\
    \                 from /tmp/tmpenhhq7j2.cpp:2:\n/usr/include/c++/4.8.2/ostream:564:5:\
    \ note:   'std::endl'\n     endl(basic_ostream<_CharT, _Traits>& __os)\n     ^\n\
    /tmp/tmpenhhq7j2.cpp:33:17: error: 'endl' was not declared in this scope\n   os\
    \ << \"No\" << endl;\n                 ^\n/tmp/tmpenhhq7j2.cpp:33:17: note: suggested\
    \ alternative:\nIn file included from /usr/include/c++/4.8.2/istream:39:0,\n \
    \                from /usr/include/c++/4.8.2/sstream:38,\n                 from\
    \ /usr/include/c++/4.8.2/complex:45,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:66,\n\
    \                 from /tmp/tmpenhhq7j2.cpp:2:\n/usr/include/c++/4.8.2/ostream:564:5:\
    \ note:   'std::endl'\n     endl(basic_ostream<_CharT, _Traits>& __os)\n     ^\n\
    /tmp/tmpenhhq7j2.cpp: In function 'int main()':\n/tmp/tmpenhhq7j2.cpp:38:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = file_name_check;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpenhhq7j2.cpp:2:\n/tmp/tmpenhhq7j2.cpp:39:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    \n    // YOUR CODE HERE\n    \n    if (file_name.length() <= 3 && file_name.at(0)\
    \ > '9' && file_name.at(0) > '0' && file_name.at(0) <= '9'){\n        if (file_name.find('.')\
    \ == std::string::npos && (file_name[0] == 'a' || file_name[0] == 'z' || file_name[0]\
    \ == 'A') && (file_name[1] == 't' || file_name[1] == 'e' || file_name[1] == 's'\
    \ || file_name[1] == 'd')){\n            if (file_name[2] == 't' || file_name[2]\
    \ == 'e' || file_name[2] == 's' || file_name[2] == 'd') {\n                return\
    \ \"Yes\";\n            }\n        }\n    }\n    return \"No\";\n}\nint main()\
    \ {\n    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu9k52dn_.cpp: In function 'int main()':\n/tmp/tmpu9k52dn_.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu9k52dn_.cpp:2:\n/tmp/tmpu9k52dn_.cpp:30:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n  // your code here\n  std::cin>>file_name;\n  if(file_name.size() <= 3)\n\
    \    return \"No\";\n  if(file_name.at(0) == 'a' && file_name.at(1) == 'b' &&\
    \ file_name.at(2) == 'c' || \n     file_name.at(0) == 'A' && file_name.at(1) ==\
    \ 'B' && file_name.at(2) == 'C')\n    return \"No\";\n  if(file_name.at(0) ==\
    \ '.' || file_name.at(0) == '_')\n    return \"No\";\n  if(file_name.at(0).at(0)\
    \ == 'a' || file_name.at(0).at(0) == 'A')\n    return \"No\";\n  if(file_name.at(file_name.size()-1).at(0)\
    \ == 'a' || file_name.at(file_name.size()-1).at(0) == 'A')\n    return \"No\"\
    ;\n  if(file_name.at(file_name.size()-1).at(file_name.size()-1) == 'a' || file_name.at(file_name.size()-1).at(file_name.size()-1)\
    \ == 'A')\n    return \"No\";\n  if(file_name.at(file_name.size()-2).at(0) ==\
    \ 'a' || file_name.at(file_name.size()-2).at(0) == 'A')\n    return \"No\";\n\
    \  if(file_name.at(file_name.size()-1).at(file_name.size()-2) == 'a' || file_name.at(file_name.size()-1).at(file_name.size()-2)\
    \ == 'A')\n    return \"No\";\n  if(file_name.at(file_name.size()-3).at(0) ==\
    \ 'a' || file_name.at(file_name.size()-3).at(0) == 'A')\n    return \"No\";\n\
    \  if(file_name.at(file_name.size()-1).at(file_name.size()-3) == 'a' || file_name.at(file_name.size()-1).at(file_name.size()-3)\
    \ == 'A')\n    return \"No\";\n  return \"Yes\";\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2e2aenyu.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmp2e2aenyu.cpp:25:22: error: request for member 'at' in 'file_name.std::basic_string<_CharT,\
    \ _Traits, _Alloc>::at<char, std::char_traits<char>, std::allocator<char> >(0ul)',\
    \ which is of non-class type 'char'\n   if(file_name.at(0).at(0) == 'a' || file_name.at(0).at(0)\
    \ == 'A')\n                      ^\n/tmp/tmp2e2aenyu.cpp:25:54: error: request\
    \ for member 'at' in 'file_name.std::basic_string<_CharT, _Traits, _Alloc>::at<char,\
    \ std::char_traits<char>, std::allocator<char> >(0ul)', which is of non-class\
    \ type 'char'\n   if(file_name.at(0).at(0) == 'a' || file_name.at(0).at(0) ==\
    \ 'A')\n                                                      ^\n/tmp/tmp2e2aenyu.cpp:27:39:\
    \ error: request for member 'at' in 'file_name.std::basic_string<_CharT, _Traits,\
    \ _Alloc>::at<char, std::char_traits<char>, std::allocator<char> >((file_name.std::basic_string<_CharT,\
    \ _Traits, _Alloc>::size<char, std::char_traits<char>, std::allocator<char> >()\
    \ + 18446744073709551615ul))', which is of non-class type 'char'\n   if(file_name.at(file_name.size()-1).at(0)\
    \ == 'a' || file_name.at(file_name.size()-1).at(0) == 'A')\n                 \
    \                      ^\n/tmp/tmp2e2aenyu.cpp:27:88: error: request for member\
    \ 'at' in 'file_name.std::basic_string<_CharT, _Traits, _Alloc>::at<char, std::char_traits<char>,\
    \ std::allocator<char> >((file_name.std::basic_string<_CharT, _Traits, _Alloc>::size<char,\
    \ std::char_traits<char>, std::allocator<char> >() + 18446744073709551615ul))',\
    \ which is of non-class type 'char'\n   if(file_name.at(file_name.size()-1).at(0)\
    \ == 'a' || file_name.at(file_name.size()-1).at(0) == 'A')\n                 \
    \                                                                       ^\n/tmp/tmp2e2aenyu.cpp:29:39:\
    \ error: request for member 'at' in 'file_name.std::basic_string<_CharT, _Traits,\
    \ _Alloc>::at<char, std::char_traits<char>, std::allocator<char> >((file_name.std::basic_string<_CharT,\
    \ _Traits, _Alloc>::size<char, std::char_traits<char>, std::allocator<char> >()\
    \ +"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string pattern = \"[a-zA-Z][a-zA-Z][a-zA-Z][^.]*\";\n    std::smatch\
    \ res;\n    bool b = std::regex_match(file_name, res,std::regex(pattern));\n \
    \   if (b) return \"Yes\";\n    else return \"No\";\n}\nint main() {\n    auto\
    \ candidate = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"\
    Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpujnca339.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpujnca339.cpp:17:5: error: 'smatch' is not a member of 'std'\n     std::smatch\
    \ res;\n     ^\n/tmp/tmpujnca339.cpp:17:17: error: expected ';' before 'res'\n\
    \     std::smatch res;\n                 ^\n/tmp/tmpujnca339.cpp:18:14: error:\
    \ 'regex_match' is not a member of 'std'\n     bool b = std::regex_match(file_name,\
    \ res,std::regex(pattern));\n              ^\n/tmp/tmpujnca339.cpp:18:42: error:\
    \ 'res' was not declared in this scope\n     bool b = std::regex_match(file_name,\
    \ res,std::regex(pattern));\n                                          ^\n/tmp/tmpujnca339.cpp:18:46:\
    \ error: 'regex' is not a member of 'std'\n     bool b = std::regex_match(file_name,\
    \ res,std::regex(pattern));\n                                              ^\n\
    /tmp/tmpujnca339.cpp: In function 'int main()':\n/tmp/tmpujnca339.cpp:23:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = file_name_check;\n \
    \         ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n    \
    \             from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpujnca339.cpp:2:\n/tmp/tmpujnca339.cpp:24:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\t// Your code goes here\n\t\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgmpjhejs.cpp: In function 'int main()':\n/tmp/tmpgmpjhejs.cpp:20:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgmpjhejs.cpp:2:\n/tmp/tmpgmpjhejs.cpp:21:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // Write your solution here\n    const std::string valid_filenames {\"\
    txt\", \"exe\", \"dll\"};\n    const std::string invalid_filenames {\"1example.dll\"\
    , \"01example.dll\", \"example.dll\", \"1example.exe\", \"01example.exe\", \"\
    example.exe\"};\n    int count = 0;\n    for (int i = 0; i < file_name.length();\
    \ i++) {\n        if (file_name[i] < '0' || file_name[i] > '9') {\n          \
    \  return invalid_filenames[count];\n        }\n    }\n    bool is_valid_filename\
    \ = true;\n    if (file_name.length() > 3) {\n        for (int i = 0; i < 3; i++)\
    \ {\n            if (file_name[i] != '0' && file_name[i] != '1' \n           \
    \     && file_name[i] != '2' && file_name[i] != '3' \n                && file_name[i]\
    \ != '4' && file_name[i] != '5' \n                && file_name[i] != '6' && file_name[i]\
    \ != '7' \n                && file_name[i] != '8' && file_name[i] != '9') {\n\
    \                is_valid_filename = false;\n                break;\n        \
    \    }\n        }\n    }\n    if (file_name[0] == '0' || file_name[0] == '1' \n\
    \        || file_name[0] == '2' || file_name[0] == '3' \n        || file_name[0]\
    \ == '4' || file_name[0] == '5' \n        || file_name[0] == '6' || file_name[0]\
    \ == '7' \n        || file_name[0] == '8' || file_name[0] == '9') {\n        is_valid_filename\
    \ = false;\n    }\n    if (!is_valid_filename) {\n        return invalid_filenames[count];\n\
    \    }\n    for (int i = 0; i < file_name.length(); i++) {\n        if (file_name[i]\
    \ == '.') {\n            if (count > 0) {\n                return invalid_filenames[count];\n\
    \            }\n            for (int j = 0; j < i; j++) {\n                if\
    \ (file_name[j] == file_name[i]) {\n                    return invalid_filenames[count];\n\
    \                }\n            }\n            count++;\n        }\n    }\n  \
    \  return valid_filenames[count];\n}\nint main() {\n    auto candidate = file_name_check;\n\
    \    assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgwerhm98.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpgwerhm98.cpp:17:23: warning: extended initializer lists only available\
    \ with -std=c++11 or -std=gnu++11 [enabled by default]\n     const std::string\
    \ valid_filenames {\"txt\", \"exe\", \"dll\"};\n                       ^\n/tmp/tmpgwerhm98.cpp:17:59:\
    \ error: in C++98 'valid_filenames' must be initialized by constructor, not by\
    \ '{...}'\n     const std::string valid_filenames {\"txt\", \"exe\", \"dll\"};\n\
    \                                                           ^\n/tmp/tmpgwerhm98.cpp:17:59:\
    \ error: invalid conversion from 'const char*' to 'std::basic_string<char>::size_type\
    \ {aka long unsigned int}' [-fpermissive]\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n\
    \                 from /usr/include/c++/4.8.2/bitset:47,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n             \
    \    from /tmp/tmpgwerhm98.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:183:5:\
    \ error:   initializing argument 2 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ std::basic_string<_CharT, _Traits, _Alloc>&, std::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, std::basic_string<_CharT, _Traits, _Alloc>::size_type) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]'\
    \ [-fpermissive]\n     basic_string<_CharT, _Traits, _Alloc>::\n     ^\n/tmp/tmpgwerhm98.cpp:17:59:\
    \ error: invalid conversion from 'const char*' to 'std::basic_string<char>::size_type\
    \ {aka long unsigned int}' [-fpermissive]\n     const std::string valid_filenames\
    \ {\"txt\", \"exe\", \"dll\"};\n                                             \
    \              ^\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n\
    \                 from /usr/include/c++/4.8.2/bitset:47,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n             \
    \    from /tmp/tmpgwerhm98.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:183:5:\
    \ error:   initi"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\t// Declare a boolean variable to hold the result.\n\tbool result = true;\n\
    \t// Iterate over the string\n\tfor (int i = 0; i < file_name.length(); i++) {\n\
    \t\t// If the current character is not a digit ('0'-'9'), \n\t\t// set 'result'\
    \ to 'false'\n\t\tif (file_name[i] < '0' || file_name[i] > '9')\n\t\t\tresult\
    \ = false;\n\t\t// If the current character is a digit, \n\t\t// increase 'i'\
    \ by 1\n\t\telse if (file_name[i] >= '0' && file_name[i] <= '9')\n\t\t\ti++;\n\
    \t\t// If the current character is not a dot ('.'),\n\t\t// set 'result' to 'false'\n\
    \t\telse if (file_name[i] != '.')\n\t\t\tresult = false;\n\t\t// If the current\
    \ character is a dot, \n\t\t// increase 'i' by 1\n\t\telse if (file_name[i] ==\
    \ '.')\n\t\t\ti++;\n\t\t// If the current character is not an alpha character,\n\
    \t\t// set 'result' to 'false'\n\t\telse if (!(file_name[i]>='a' && file_name[i]<='z')\
    \ && !(file_name[i]>='A' && file_name[i]<='Z'))\n\t\t\tresult = false;\n\t\t//\
    \ If the current character is a alpha character,\n\t\t// increase 'i' by 1\n\t\
    \telse if (!(file_name[i]>='a' && file_name[i]<='z') && !(file_name[i]>='A' &&\
    \ file_name[i]<='Z'))\n\t\t\ti++;\n\t\t// If the current character is not a letter\
    \ from the latin alphabet, \n\t\t// set 'result' to 'false'\n\t\telse if (!(file_name[i]>='a'\
    \ && file_name[i]<='z') && !(file_name[i]>='A' && file_name[i]<='Z'))\n\t\t\t\
    result = false;\n\t\t// If the current character is any non alpha character, \n\
    \t\t// set 'result' to 'false'\n\t\telse\n\t\t\tresult = false;\n\t\t// If the\
    \ result has been set to 'true' before, \n\t\t// return 'false'\n\t\tif (result)\n\
    \t\t\tbreak;\n\t}\n\t// If 'result' is still 'true', return 'No'\n\treturn (result\
    \ ? 'No' : 'Yes');\n}\nint main() {\n    auto candidate = file_name_check;\n \
    \   assert(candidate((\"example.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    1example.dll\")) == (\"No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"\
    No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n    assert(candidate((\"\
    MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"His12FILE94.exe\"))\
    \ == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"));\n    assert(candidate((\"\
    ?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"/this_is_valid.dll\")) ==\
    \ (\"No\"));\n    assert(candidate((\"this_is_valid.wow\")) == (\"No\"));\n  \
    \  assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n    assert(candidate((\"\
    this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"#this2_i4s_5valid.ten\"\
    )) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\")) == (\"No\"\
    ));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"No\"));\n   \
    \ assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7hzy_hwx.cpp:58:19: warning: multi-character character constant\
    \ [-Wmultichar]\n  return (result ? 'No' : 'Yes');\n                   ^\n/tmp/tmp7hzy_hwx.cpp:58:26:\
    \ warning: multi-character character constant [-Wmultichar]\n  return (result\
    \ ? 'No' : 'Yes');\n                          ^\n/tmp/tmp7hzy_hwx.cpp: In function\
    \ 'std::string file_name_check(std::string)':\n/tmp/tmp7hzy_hwx.cpp:58:31: error:\
    \ invalid conversion from 'int' to 'const char*' [-fpermissive]\n  return (result\
    \ ? 'No' : 'Yes');\n                               ^\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n\
    \                 from /usr/include/c++/4.8.2/bitset:47,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n             \
    \    from /tmp/tmp7hzy_hwx.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmp7hzy_hwx.cpp: In function 'int main()':\n/tmp/tmp7hzy_hwx.cpp:61:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7hzy_hwx.cpp:2:\n/tmp/tmp7hzy_hwx.cpp:62:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n\t// Write your code here\n\t\n\tconst auto dot_pos = file_name.find_first_of(\"\
    .\");\n\tif (dot_pos == std::string::npos) return \"No\";\n\tconst auto dot_start_pos\
    \ = file_name.find_first_not_of(\"0123456789\", dot_pos);\n\tif (dot_start_pos\
    \ == std::string::npos || dot_start_pos == dot_pos) return \"No\";\n\tconst auto\
    \ dot_end_pos = file_name.find_last_not_of(\"0123456789\", dot_start_pos);\n\t\
    if (dot_end_pos == std::string::npos || dot_end_pos == dot_start_pos) return \"\
    No\";\n\tconst auto dot_first_char = file_name[dot_start_pos];\n\tconst auto dot_last_char\
    \ = file_name[dot_end_pos-1];\n\tif (dot_first_char == '.' && (dot_last_char ==\
    \ 't' || dot_last_char == 'T') ||\n\t\t\tdot_first_char == '.' && (dot_last_char\
    \ == 'e' || dot_last_char == 'E') ||\n\t\t\tdot_first_char == '.' && (dot_last_char\
    \ == 'd' || dot_last_char == 'D') ||\n\t\t\tdot_first_char == '.' && (dot_last_char\
    \ == 'd' || dot_last_char == 'D')) {\n\t\treturn \"Yes\";\n\t}\n\treturn \"No\"\
    ;\n}\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpn3kilyzz.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpn3kilyzz.cpp:18:13: error: 'dot_pos' does not name a type\n  const auto\
    \ dot_pos = file_name.find_first_of(\".\");\n             ^\n/tmp/tmpn3kilyzz.cpp:19:6:\
    \ error: 'dot_pos' was not declared in this scope\n  if (dot_pos == std::string::npos)\
    \ return \"No\";\n      ^\n/tmp/tmpn3kilyzz.cpp:20:13: error: 'dot_start_pos'\
    \ does not name a type\n  const auto dot_start_pos = file_name.find_first_not_of(\"\
    0123456789\", dot_pos);\n             ^\n/tmp/tmpn3kilyzz.cpp:21:6: error: 'dot_start_pos'\
    \ was not declared in this scope\n  if (dot_start_pos == std::string::npos ||\
    \ dot_start_pos == dot_pos) return \"No\";\n      ^\n/tmp/tmpn3kilyzz.cpp:21:61:\
    \ error: 'dot_pos' was not declared in this scope\n  if (dot_start_pos == std::string::npos\
    \ || dot_start_pos == dot_pos) return \"No\";\n                              \
    \                               ^\n/tmp/tmpn3kilyzz.cpp:22:13: error: 'dot_end_pos'\
    \ does not name a type\n  const auto dot_end_pos = file_name.find_last_not_of(\"\
    0123456789\", dot_start_pos);\n             ^\n/tmp/tmpn3kilyzz.cpp:23:6: error:\
    \ 'dot_end_pos' was not declared in this scope\n  if (dot_end_pos == std::string::npos\
    \ || dot_end_pos == dot_start_pos) return \"No\";\n      ^\n/tmp/tmpn3kilyzz.cpp:23:57:\
    \ error: 'dot_start_pos' was not declared in this scope\n  if (dot_end_pos ==\
    \ std::string::npos || dot_end_pos == dot_start_pos) return \"No\";\n        \
    \                                                 ^\n/tmp/tmpn3kilyzz.cpp:24:13:\
    \ error: 'dot_first_char' does not name a type\n  const auto dot_first_char =\
    \ file_name[dot_start_pos];\n             ^\n/tmp/tmpn3kilyzz.cpp:25:13: error:\
    \ 'dot_last_char' does not name a type\n  const auto dot_last_char = file_name[dot_end_pos-1];\n\
    \             ^\n/tmp/tmpn3kilyzz.cpp:26:6: error: 'dot_first_char' was not declared\
    \ in this scope\n  if (dot_first_char == '.' && (dot_last_char == 't' || dot_last_char\
    \ == 'T') ||\n      ^\n/tmp/tmpn3kilyzz.cpp:26:32: error: 'dot_last_char' was\
    \ not declared in this scope\n  if (dot_first_char == '.' && (dot_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string pattern = \"[^0-9.]+\";\n    std::string pattern2 = \"[^a-z]+\"\
    ;\n    std::string pattern3 = \"[^a-z.]+\";\n    // This string will be used to\
    \ store the valid name\n    std::string valid_name;\n    // Initialize a bool\
    \ variable to store if the name can be valid\n    bool valid = false;\n    //\
    \ Loop through the string until it reaches the end of the string\n    while (valid\
    \ == false) {\n        valid = true;\n        // If the first character of the\
    \ string is not from the latin alphapet ('a'-'z' and 'A'-'Z')\n        if (file_name[0]\
    \ < 'a' || file_name[0] > 'z' || file_name[0] < 'A' || file_name[0] > 'Z') {\n\
    \            // Then the name can't be valid\n            valid = false;\n   \
    \         // Store the current string in the variable valid_name\n           \
    \ valid_name = file_name;\n        }\n        // If the first character of the\
    \ string is the dot ('.') and the substring after it is\n        // not one of\
    \ the allowed extensions then it can't be valid\n        else if (file_name[0]\
    \ == '.' && file_name.substr(1) == \"exe\" || file_name.substr(1) == \"dll\" ||\
    \ file_name.substr(1) == \"bin\" || file_name.substr(1) == \"obj\") {\n      \
    \      // Then the name can't be valid\n            valid = false;\n         \
    \   // Store the current string in the variable valid_name\n            valid_name\
    \ = file_name;\n        }\n        // If the first character of the string is\
    \ not from the latin alphabet ('a'-'z') \n        // or the substring after the\
    \ dot is not one of the allowed extensions then it can't be valid\n        else\
    \ if (file_name[0] < 'a' || file_name[0] > 'z') {\n            // Then the name\
    \ can't be valid\n            valid = false;\n            // Store the current\
    \ string in the variable valid_name\n            valid_name = file_name;\n   \
    \     }\n        // If the length of the string is more than three characters\
    \ then the name can't be valid\n        else if (file_name.length() > 3) {\n \
    \           // Then the name can't be valid\n            valid = false;\n    \
    \        // Store the current string in the variable valid_name\n            valid_name\
    \ = file_name;\n        }\n        // If the length of the string is less than\
    \ three characters then the name can't be valid\n        else if (file_name.length()\
    \ < 3) {\n            // Then the name can't be valid\n            valid = false;\n\
    \            // Store the current string in the variable valid_name\n        \
    \    valid_name = file_name;\n        }\n        // If the length of the string\
    \ is less than three characters then the name can't be valid\n        else if\
    \ (file_name.substr(0, 2) != \"..\") {\n            // Then the name can't be\
    \ valid\n            valid = false;\n            // Store the current string in\
    \ the variable valid_name\n            valid_name = file_name;\n        }\n  \
    \      // If the length of the string is less than three characters then the name\
    \ can't be valid\n        else if (file_name.substr(0, 1) != \"..\") {\n     \
    \       // Then the name can't be valid\n            valid = false;\n        \
    \    // Store the current string in the variable valid_name\n}\nint main() {\n\
    \    auto candidate = file_name_check;\n    assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"No\"));\n  \
    \  assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxccqidvb.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpxccqidvb.cpp:76:12: error: a function-definition is not allowed here before\
    \ '{' token\n int main() {\n            ^\n/tmp/tmpxccqidvb.cpp:104:1: error:\
    \ expected '}' at end of input\n }\n ^\n/tmp/tmpxccqidvb.cpp:104:1: error: expected\
    \ '}' at end of input\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    std::string result;\n    // Write your code here\n    if (file_name.size()\
    \ <= 3) return result;\n    if (file_name.at(0) != '.' || file_name.size() > 3\
    \ || file_name.at(1) != '.') return result;\n    if (file_name.at(0) >= 'a' &&\
    \ file_name.at(0) <= 'z' || file_name.at(0) >= 'A' && file_name.at(0) <= 'Z')\
    \ return result;\n    std::string before_dot = file_name.substr(0, file_name.find('.'));\n\
    \    std::string after_dot = file_name.substr(file_name.find('.') + 1);\n    if\
    \ (after_dot.size() == 3 && after_dot.at(0) == '.' && after_dot.at(1) == 'e' &&\
    \ after_dot.at(2) == 'x') return result;\n    if (after_dot.size() == 3 && after_dot.at(0)\
    \ == '.' && after_dot.at(1) == 'e' && after_dot.at(2) == 'x') {\n        result\
    \ = \"No\";\n    } else {\n        result = \"Yes\";\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = file_name_check;\n    assert(candidate((\"\
    example.txt\")) == (\"Yes\"));\n    assert(candidate((\"1example.dll\")) == (\"\
    No\"));\n    assert(candidate((\"s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"\
    K.dll\")) == (\"Yes\"));\n    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"\
    ));\n    assert(candidate((\"His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"\
    _Y.txt\")) == (\"No\"));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n\
    \    assert(candidate((\"/this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"\
    this_is_valid.wow\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\"\
    )) == (\"Yes\"));\n    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"\
    ));\n    assert(candidate((\"#this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"\
    @this1_is6_valid.exe\")) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\"\
    )) == (\"No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7ax4xpti.cpp: In function 'int main()':\n/tmp/tmp7ax4xpti.cpp:32:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = file_name_check;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7ax4xpti.cpp:2:\n/tmp/tmp7ax4xpti.cpp:33:37: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"example.txt\"\
    )) == (\"Yes\"));\n                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which\
    \ takes a string representing a file's name, and returns\n// 'Yes' if the the\
    \ file's name is valid, and returns 'No' otherwise.\n// A file's name is considered\
    \ to be valid if and only if all the following conditions \n// are met:\n// -\
    \ There should not be more than three digits ('0'-'9') in the file's name.\n//\
    \ - The file's name contains exactly one dot '.'\n// - The substring before the\
    \ dot should not be empty, and it starts with a letter from \n// the latin alphapet\
    \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
    \ ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # =>\
    \ 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start\
    \ with a latin alphapet letter)\nstd::string file_name_check(std::string file_name)\
    \ {\n    // your code here\n    int dot_index = file_name.find('.');\n    int\
    \ first_letter_afterDot = file_name.substr(dot_index+1);\n    bool is_valid_filename\
    \ = true;\n    for (int i = 0; i < 9; ++i) {\n        if(is_valid_filename &&\
    \ first_letter_afterDot >= 'a' && first_letter_afterDot <= 'z') {\n          \
    \  is_valid_filename = false;\n        }\n        if(is_valid_filename && first_letter_afterDot\
    \ >= 'A' && first_letter_afterDot <= 'Z') {\n            is_valid_filename = false;\n\
    \        }\n        if(is_valid_filename && first_letter_afterDot == 0) {\n  \
    \          is_valid_filename = false;\n        }\n    }\n    if(is_valid_filename)\
    \ {\n        if (dot_index != file_name.size() - 1) {\n            return 'No';\n\
    \        }\n        else {\n            for (auto &character : file_name) {\n\
    \                if (character != '.') {\n                    return 'No';\n \
    \               }\n            }\n            return 'Yes';\n        }\n    }\n\
    \    else {\n        return 'No';\n    }\n}\nint main() {\n    auto candidate\
    \ = file_name_check;\n    assert(candidate((\"example.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"1example.dll\")) == (\"No\"));\n    assert(candidate((\"\
    s1sdf3.asd\")) == (\"No\"));\n    assert(candidate((\"K.dll\")) == (\"Yes\"));\n\
    \    assert(candidate((\"MY16FILE3.exe\")) == (\"Yes\"));\n    assert(candidate((\"\
    His12FILE94.exe\")) == (\"No\"));\n    assert(candidate((\"_Y.txt\")) == (\"No\"\
    ));\n    assert(candidate((\"?aREYA.exe\")) == (\"No\"));\n    assert(candidate((\"\
    /this_is_valid.dll\")) == (\"No\"));\n    assert(candidate((\"this_is_valid.wow\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_valid.txt\")) == (\"Yes\"));\n\
    \    assert(candidate((\"this_is_valid.txtexe\")) == (\"No\"));\n    assert(candidate((\"\
    #this2_i4s_5valid.ten\")) == (\"No\"));\n    assert(candidate((\"@this1_is6_valid.exe\"\
    )) == (\"No\"));\n    assert(candidate((\"this_is_12valid.6exe4.txt\")) == (\"\
    No\"));\n    assert(candidate((\"all.exe.txt\")) == (\"No\"));\n    assert(candidate((\"\
    I563_No.exe\")) == (\"Yes\"));\n    assert(candidate((\"Is3youfault.txt\")) ==\
    \ (\"Yes\"));\n    assert(candidate((\"no_one#knows.dll\")) == (\"Yes\"));\n \
    \   assert(candidate((\"1I563_Yes3.exe\")) == (\"No\"));\n    assert(candidate((\"\
    I563_Yes3.txtt\")) == (\"No\"));\n    assert(candidate((\"final..txt\")) == (\"\
    No\"));\n    assert(candidate((\"final132\")) == (\"No\"));\n    assert(candidate((\"\
    _f4indsartal132.\")) == (\"No\"));\n    assert(candidate((\".txt\")) == (\"No\"\
    ));\n    assert(candidate((\"s.\")) == (\"No\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpta6jifqi.cpp:33:20: warning: multi-character character constant\
    \ [-Wmultichar]\n             return 'No';\n                    ^\n/tmp/tmpta6jifqi.cpp:38:28:\
    \ warning: multi-character character constant [-Wmultichar]\n                \
    \     return 'No';\n                            ^\n/tmp/tmpta6jifqi.cpp:41:20:\
    \ warning: multi-character character constant [-Wmultichar]\n             return\
    \ 'Yes';\n                    ^\n/tmp/tmpta6jifqi.cpp:45:16: warning: multi-character\
    \ character constant [-Wmultichar]\n         return 'No';\n                ^\n\
    /tmp/tmpta6jifqi.cpp: In function 'std::string file_name_check(std::string)':\n\
    /tmp/tmpta6jifqi.cpp:18:61: error: cannot convert 'std::basic_string<char>' to\
    \ 'int' in initialization\n     int first_letter_afterDot = file_name.substr(dot_index+1);\n\
    \                                                             ^\n/tmp/tmpta6jifqi.cpp:33:20:\
    \ error: invalid conversion from 'int' to 'const char*' [-fpermissive]\n     \
    \        return 'No';\n                    ^\nIn file included from /usr/include/c++/4.8.2/string:53:0,\n\
    \                 from /usr/include/c++/4.8.2/bitset:47,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:65,\n             \
    \    from /tmp/tmpta6jifqi.cpp:2:\n/usr/include/c++/4.8.2/bits/basic_string.tcc:212:5:\
    \ error:   initializing argument 1 of 'std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const\
    \ _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]' [-fpermissive]\n     basic_string<_CharT, _Traits,\
    \ _Alloc>::\n     ^\n/tmp/tmpta6jifqi.cpp:36:24: error: ISO C++ forbids declaration\
    \ of 'character' with no type [-fpermissive]\n             for (auto &character\
    \ : file_name) {\n                        ^\n/tmp/tmpta6jifqi.cpp:36:36: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n             for (auto\
    \ &character : file_name) {\n                                    ^\n/tmp/tmpta6jifqi.cpp:38:28:\
    \ error: invalid conversion from 'int' to 'const char*' [-fpermissive]\n     \
    \                re"
  exit_code: 1
  status: SyntaxError
