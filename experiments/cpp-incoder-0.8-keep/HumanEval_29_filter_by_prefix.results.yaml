language: cpp
name: HumanEval_29_filter_by_prefix
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  return std::remove_if(strings.begin(), strings.end(),\
    \ [&](std::string item) -> bool {\n    return item.starts_with(prefix);\n  });\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9r2qhxji.cpp: In lambda function:\n/tmp/tmp9r2qhxji.cpp:10:17:\
    \ error: \u2018std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018starts_with\u2019\n   10 |     return item.starts_with(prefix);\n\
    \      |                 ^~~~~~~~~~~\n/tmp/tmp9r2qhxji.cpp: In function \u2018\
    std::vector<std::__cxx11::basic_string<char> > filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)\u2019:\n/tmp/tmp9r2qhxji.cpp:9:24: error: could not convert\
    \ \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), <lambda\
    \ closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>{prefix})\u2019 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n    9 |   return std::remove_if(strings.begin(), strings.end(), [&](std::string\
    \ item) -> bool {\n      |          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                        |\n      |                        __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\n   10 |     return item.starts_with(prefix);\n\
    \      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   11 |   });\n      |   ~~   \
    \                 \n"
  stdout: ''
  timestamp: 1660098522
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    size_t\
    \ prefix_len = prefix.length();\n    for (auto &str : strings) {\n        if (str.size()\
    \ >= prefix_len) {\n            if (str.substr(0, prefix_len) == prefix) {\n \
    \               result.push_back(str);\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> filtered_strings;\n\
    \    for (std::string s : strings)\n        if (s.substr(0, prefix.size()) ==\
    \ prefix)\n            filtered_strings.push_back(s);\n    return filtered_strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  // Sort the strings by their first letter\
    \ and find the prefix.\n  std::sort(strings.begin(), strings.end(), [](const std::string\
    \ & s, const std::string & p) {\n    return s.front() < p.front();\n  });\n  auto\
    \ prefix_pos = std::find(strings.begin(), strings.end(), prefix);\n  // If prefix\
    \ not found.\n  if (prefix_pos == strings.end())\n    return strings;\n  // If\
    \ prefix is found, remove all the strings not starting with the prefix letter\n\
    \  strings.erase(std::remove_if(strings.begin(), strings.end(),\n            \
    \                   [&](const std::string & s) {\n    return !s.front() == prefix.front();\n\
    \  }), strings.end());\n  return strings;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpe_u0ycxq: /tmp/tmpe_u0ycxq.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098523
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto it = std::begin(strings);\n  std::string\
    \ prefix_str(prefix.begin(), prefix.end());\n  while (it != std::end(strings))\
    \ {\n    std::string str = *it;\n    if (str.find(prefix_str) == 0)\n      it\
    \ = std::erase(it);\n    else\n      ++it;\n  }\n  return strings;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgee1lm3m.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpgee1lm3m.cpp:14:17: error: \u2018erase\u2019 is not a member of \u2018\
    std\u2019\n   14 |       it = std::erase(it);\n      |                 ^~~~~\n"
  stdout: ''
  timestamp: 1660098522
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (size_t i = 0; i < strings.size(); i++) {\n        if (strings[i].startsWith(prefix))\
    \ {\n            result.push_back(strings[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoti7mfy7.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpoti7mfy7.cpp:11:24: error: \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018startsWith\u2019\n   11 |         if (strings[i].startsWith(prefix))\
    \ {\n      |                        ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660098522
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  std::for_each(strings.begin(),\
    \ strings.end(), [&](std::string s) {\n    if (s.substr(0, prefix.size()) == prefix)\
    \ {\n      result.push_back(s);\n    }\n  });\n  return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  // TODO : use std::regex instead of string\
    \ manipulation on prefix\n  return std::remove_if(strings.begin(), strings.end(),\
    \ [&](std::string s) {\n    return s.substr(0, prefix.size()) == prefix;\n  });\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyl7e9m67.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpyl7e9m67.cpp:10:24: error: could not convert \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), <lambda\
    \ closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>{prefix})\u2019 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n   10 |   return std::remove_if(strings.begin(), strings.end(), [&](std::string\
    \ s) {\n      |          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                        |\n      |                        __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\n   11 |     return s.substr(0,\
    \ prefix.size()) == prefix;\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \   12 |   });\n      |   ~~                    \n"
  stdout: ''
  timestamp: 1660098523
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  return std::remove_if(strings.begin(), strings.end(),\n\
    \      [&prefix](std::string s) { return s.substr(0, prefix.length()) == prefix;\
    \ });\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl4zok1_a.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpl4zok1_a.cpp:9:24: error: could not convert \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), <lambda\
    \ closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>{prefix})\u2019 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n    9 |   return std::remove_if(strings.begin(), strings.end(),\n \
    \     |          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |     \
    \                   |\n      |                        __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\n   10 |       [&prefix](std::string\
    \ s) { return s.substr(0, prefix.length()) == prefix; });\n      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660098523
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::set<std::string> stringSet;\n  for (std::string\
    \ s: strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      stringSet.insert(s);\n\
    \    }\n  }\n  return stringSet.empty() ? strings : stringSet.begin(), stringSet.end();\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprm4ko80z.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmprm4ko80z.cpp:15:28: error: operands to ?: have different types \u2018\
    std::vector<std::__cxx11::basic_string<char> >\u2019 and \u2018std::set<std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018std::_Rb_tree_const_iterator<std::__cxx11::basic_string<char>\
    \ >\u2019}\n   15 |   return stringSet.empty() ? strings : stringSet.begin(),\
    \ stringSet.end();\n      |          ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660098523
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    res.reserve(strings.size());\n\
    \    for (auto& str : strings) {\n        if (str.substr(0, prefix.size()) ==\
    \ prefix) {\n            res.push_back(str);\n        }\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    if (strings.empty()) return std::vector<std::string>();\n\
    \    bool match = false;\n    for (auto str : strings) {\n        if (str.compare(0,\
    \ prefix.size(), prefix) == 0) {\n            match = true;\n        } else {\n\
    \            match = false;\n            break;\n        }\n    }\n    if (match)\
    \ return strings;\n    else return std::vector<std::string>();\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmp5e5t0v45: /tmp/tmp5e5t0v45.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098523
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  return std::remove_if(strings.begin(), strings.end(),\n\
    \                        [&prefix](std::string s) { return s.starts_with(prefix);\
    \ });\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl62443vd.cpp: In lambda function:\n/tmp/tmpl62443vd.cpp:10:61:\
    \ error: \u2018std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018starts_with\u2019\n   10 |                       \
    \  [&prefix](std::string s) { return s.starts_with(prefix); });\n      |     \
    \                                                        ^~~~~~~~~~~\n/tmp/tmpl62443vd.cpp:\
    \ In function \u2018std::vector<std::__cxx11::basic_string<char> > filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)\u2019:\n/tmp/tmpl62443vd.cpp:9:24: error: could not convert\
    \ \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), <lambda\
    \ closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>{prefix})\u2019 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n    9 |   return std::remove_if(strings.begin(), strings.end(),\n \
    \     |          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |     \
    \                   |\n      |                        __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\n   10 |                  \
    \       [&prefix](std::string s) { return s.starts_with(prefix); });\n      |\
    \                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n           \
    \      from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpl62443vd.cpp:2:\n/usr"
  stdout: ''
  timestamp: 1660098523
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\
    \ // sort to ensure prefix is not an empty string.\n  if (prefix.empty()) return\
    \ strings;\n  auto prefix_pos = strings.begin();\n  while (prefix_pos != strings.end()\
    \ && prefix_pos->find(prefix) == 0) {\n    ++prefix_pos;\n  }\n  auto new_strings\
    \ = std::vector<std::string>(strings);\n  std::for_each(prefix_pos, new_strings.end(),\
    \ [](std::string* string) { delete string; });\n  return new_strings;\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/c++/9/algorithm:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n             \
    \    from /tmp/tmp5ucznd38.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h: In instantiation\
    \ of \u2018_Funct std::for_each(_IIter, _IIter, _Funct) [with _IIter = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Funct = filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string*)>]\u2019:\n/tmp/tmp5ucznd38.cpp:16:90:\
    \   required from here\n/usr/include/c++/9/bits/stl_algo.h:3882:5: error: no match\
    \ for call to \u2018(filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string*)>) (std::__cxx11::basic_string<char>&)\u2019\
    \n 3882 |  __f(*__first);\n      |  ~~~^~~~~~~~~~\n/usr/include/c++/9/bits/stl_algo.h:3882:5:\
    \ note: candidate: \u2018void (*)(std::string*)\u2019 {aka \u2018void (*)(std::__cxx11::basic_string<char>*)\u2019\
    } <conversion>\n/usr/include/c++/9/bits/stl_algo.h:3882:5: note:   candidate expects\
    \ 2 arguments, 2 provided\n/tmp/tmp5ucznd38.cpp:16:48: note: candidate: \u2018\
    filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)::<lambda(std::string*)>\u2019\
    \n   16 |   std::for_each(prefix_pos, new_strings.end(), [](std::string* string)\
    \ { delete string; });\n      |                                              \
    \  ^\n/tmp/tmp5ucznd38.cpp:16:48: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::string*\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>*\u2019}\n"
  stdout: ''
  timestamp: 1660098523
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::cout << \"filter_by_prefix strings: \"\
    \ << strings.size() << \"  prefix: \" << prefix.size() << std::endl;\n  std::string\
    \ pre = prefix.substr(0, prefix.size() - 1);\n  std::cout << \"pre: \" << pre\
    \ << std::endl;\n  std::vector<std::string> retVec;\n  for (int i = 0; i < strings.size();\
    \ i++) {\n    if (strings[i].substr(0, prefix.length()) == pre) {\n      retVec.push_back(strings[i]);\n\
    \    }\n  }\n  return retVec;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpnjr18o0m: /tmp/tmpnjr18o0m.cpp:23: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: 'filter_by_prefix strings: 0  prefix: 4

    pre: joh

    filter_by_prefix strings: 6  prefix: 3

    pre: xx

    '
  timestamp: 1660098522
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::cout << \"Strings passed: \" << strings\
    \ << \"\\n\";\n    std::cout << \"Prefix passed: \" << prefix << \"\\n\";\n  \
    \  \n    std::vector<std::string> new_strings;\n    \n    std::cout << \"Starting\
    \ loop through list \" << endl;\n    \n    for (int i = 0; i < strings.size();\
    \ i++) {\n        std::cout << \"Checking string \" << i << endl;\n        \n\
    \        if (strings[i].size() >= prefix.size() && strings[i].substr(0, prefix.length())\
    \ == prefix) {\n            new_strings.push_back(strings[i]);\n        }\n  \
    \  }\n    std::cout << \"End loop through list \" << endl;\n    \n    std::cout\
    \ << \"Returning new list of strings: \" << new_strings << \"\\n\";\n    \n  \
    \  return new_strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzqtftmqu.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpzqtftmqu.cpp:9:37: error: no match for \u2018operator<<\u2019 (operand\
    \ types are \u2018std::basic_ostream<char>\u2019 and \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019)\n    9 |     std::cout << \"Strings passed: \" << strings << \"\\n\"\
    ;\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~ ~~~~~~~\n      |           \
    \    |                        |\n      |               std::basic_ostream<char>\
    \ std::vector<std::__cxx11::basic_string<char> >\nIn file included from /usr/include/c++/9/istream:39,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpzqtftmqu.cpp:2:\n/usr/include/c++/9/ostream:108:7: note: candidate:\
    \ \u2018std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT,\
    \ _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__ostream_type& (*)(std::basic_ostream<_CharT,\
    \ _Traits>::__ostream_type&)) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>]\u2019\
    \n  108 |       operator<<(__ostream_type& (*__pf)(__ostream_type&))\n      |\
    \       ^~~~~~~~\n/usr/include/c++/9/ostream:108:36: note:   no known conversion\
    \ for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\
    \ to \u2018std::basic_ostream<char>::__ostream_type& (*)(std::basic_ostream<char>::__ostream_type&)\u2019\
    \ {aka \u2018std::basic_ostream<char>& (*)(std::basic_ostream<char>&)\u2019}\n\
    \  108 |       operator<<(__ostream_type& (*__pf)(__ostream_type&))\n      | \
    \                 ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/ostream:117:7:\
    \ note: candidate: \u2018std::basic_ostream<_CharT, _Traits>::__ostream_type&\
    \ std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, "
  stdout: ''
  timestamp: 1660098523
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  strings.erase(std::remove_if(strings.begin(), strings.end(), [&](std::string\
    \ s) { return s.front() != prefix; }), strings.end());\n  return strings;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplr9gtzvy.cpp: In lambda function:\n/tmp/tmplr9gtzvy.cpp:10:102:\
    \ error: no match for \u2018operator!=\u2019 (operand types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} and \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019})\n   10 |   strings.erase(std::remove_if(strings.begin(),\
    \ strings.end(), [&](std::string s) { return s.front() != prefix; }), strings.end());\n\
    \      |                                                                     \
    \                       ~~~~~~~~~ ^~ ~~~~~~\n      |                         \
    \                                                                          | \
    \    |\n      |                                                              \
    \                                     |     std::string {aka std::__cxx11::basic_string<char>}\n\
    \      |                                                                     \
    \                              __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmplr9gtzvy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1037:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1037 |     operator!=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1037:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmplr9gtzvy.cpp:10:105:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   10 |   strings.erase(std::remove_if(strings.begin(),\
    \ strings.end(), [&](std::string s) { return s.front() != prefix; }), strings.end());\n\
    \      |                                                                     \
    \                                    ^~~~~~\nIn file includ"
  stdout: ''
  timestamp: 1660098523
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> filtered(strings.size());\n\
    \  for (size_t i = 0; i < strings.size(); ++i) {\n    if (strings[i].substr(0,\
    \ prefix.size()) == prefix) {\n      filtered[i] = strings[i];\n    }\n  }\n \
    \ return filtered;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpytcms35a: /tmp/tmpytcms35a.cpp:20: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098523
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> filtered;\n   \
    \ std::for_each(strings.begin(), strings.end(), [&filtered, &prefix](std::string&\
    \ str) {\n        std::size_t found = str.find(prefix);\n        if (found !=\
    \ std::string_view::npos)\n            filtered.push_back(str);\n    });\n   \
    \ return filtered;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> ret;\n  for (auto\
    \ s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      ret.push_back(s);\n\
    \    }\n  }\n  return ret;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for(auto\
    \ &string : strings)\n    if (string.substr(0, prefix.size()) == prefix)\n   \
    \   result.emplace_back(string);\n  return result;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098522
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto prefix_iter = std::sfind_if(strings.begin(),\
    \ strings.end(),\n        [&](std::string x){ return x.substr(0, prefix.size())\
    \ == prefix; });\n    if (prefix_iter == strings.end())\n        return {};\n\
    \    strings.erase(prefix_iter, strings.end());\n    return strings;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprnmv05vg.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmprnmv05vg.cpp:9:29: error: \u2018sfind_if\u2019 is not a member of \u2018\
    std\u2019; did you mean \u2018find_if\u2019?\n    9 |     auto prefix_iter = std::sfind_if(strings.begin(),\
    \ strings.end(),\n      |                             ^~~~~~~~\n      |      \
    \                       find_if\n"
  stdout: ''
  timestamp: 1660098522
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size());\n  prefix = prefix.front();\n\
    \  std::sort(strings.begin(), strings.end());\n  strings.erase(std::remove_if(strings.begin(),\
    \ strings.end(),\n                             [&](std::string str) {\n      \
    \                         return !str.starts_with(prefix);\n                 \
    \            }),\n               strings.end());\n  return strings;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpweubm2mk.cpp: In lambda function:\n/tmp/tmpweubm2mk.cpp:14:44:\
    \ error: \u2018std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018starts_with\u2019\n   14 |                       \
    \         return !str.starts_with(prefix);\n      |                          \
    \                  ^~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpweubm2mk.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_pred<_Predicate>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Predicate = filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>]\u2019:\n/usr/include/c++/9/bits/stl_algo.h:875:13:\
    \   required from \u2018_ForwardIterator std::__remove_if(_ForwardIterator, _ForwardIterator,\
    \ _Predicate) [with _ForwardIterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Predicate = __gnu_cxx::__ops::_Iter_pred<filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)> >]\u2019\n/usr/include/c++/9/bits/stl_algo.h:945:30:\
    \   required from \u2018_FIter std::remove_if(_FIter, _FIter, _Predicate) [with\
    \ _FIter = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >; _Predicate = filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>]\u2019\n/tmp/tmpweubm2mk.cpp:15:31: \
    \  required from here\n/usr/include/c++/9/bits/predefined_ops.h:283:11: error:\
    \ void value not ignored as it ought to be\n  283 |  { return bool(_M_pred(*__it));\
    \ }\n      |           ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660098523
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto prefix_begin = prefix.begin();\n  auto\
    \ prefix_end = prefix.end();\n  std::sort(strings.begin(), strings.end());\n \
    \ std::set_difference(strings.begin(), strings.end(), strings.begin(), prefix_begin,\
    \ [prefix_end](std::string a, std::string b) {\n    return a.size() > prefix_end.size()\
    \ ? a < b : prefix_end < b;\n  });\n  return strings;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp73zwbvc.cpp: In lambda function:\n/tmp/tmpp73zwbvc.cpp:13:34:\
    \ error: \u2018const class __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019 has no member named \u2018size\u2019\n   13 |     return a.size() >\
    \ prefix_end.size() ? a < b : prefix_end < b;\n      |                       \
    \           ^~~~\n/tmp/tmpp73zwbvc.cpp:13:62: error: no match for \u2018operator<\u2019\
    \ (operand types are \u2018const __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   13 |     return a.size() > prefix_end.size() ? a < b : prefix_end < b;\n\
    \      |                                                   ~~~~~~~~~~ ^ ~\n  \
    \    |                                                   |            |\n    \
    \  |                                                   |            std::string\
    \ {aka std::__cxx11::basic_string<char>}\n      |                            \
    \                       const __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\nIn file included from /usr/include/c++/9/regex:62,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n                 from\
    \ /tmp/tmpp73zwbvc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1048:5: note: candidate:\
    \ \u2018template<class _BiIter> bool std::__cxx11::operator<(const std::__cxx11::sub_match<_BiIter>&,\
    \ const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1048 |     operator<(const\
    \ sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1048:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpp73zwbvc.cpp:13:64: note:   \u2018const __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   13 |     return a.size() > prefix_end.size() ? a < b : prefix_end < b;\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bi"
  stdout: ''
  timestamp: 1660098522
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> out;\n  std::copy_if(strings.begin(),\
    \ strings.end(), std::back_inserter(out),\n               [&](std::string &s)\
    \ { return s.compare(0, prefix.size(), prefix) == 0; });\n  return out;\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  // Iterate through the input and copy strings\
    \ to the output if they start with the\n  // prefix.\n  for (auto& string : strings)\
    \ {\n    if (string.substr(0, prefix.length()) == prefix) {\n      strings.push_back(string);\n\
    \    }\n  }\n  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpc1tqlp2v: /tmp/tmpc1tqlp2v.cpp:21: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098523
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto it = std::begin(strings);\n    for(;\
    \ it != std::end(strings); ++it) {\n        std::string s = *it;\n        if(s.find(prefix)\
    \ == 0) {\n            strings.erase(it);\n            strings.push_back(s);\n\
    \        }\n    }\n    return strings;\n}\nint main() {\n    auto candidate =\
    \ filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpprq671ah: /tmp/tmpprq671ah.cpp:22: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098523
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size() != 0);\n  if (strings.empty())\n\
    \    return strings;\n  auto it = std::find(strings.begin(), strings.end(), prefix);\n\
    \  if (it == strings.end())\n    return strings;\n  strings.erase(it);\n  return\
    \ strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpk51o4laz: /tmp/tmpk51o4laz.cpp:9: std::vector<std::__cxx11::basic_string<char>
    > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):
    Assertion `strings.size() != 0'' failed.

    '
  stdout: ''
  timestamp: 1660098524
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for(auto\
    \ &str : strings) {\n    if(str.substr(0, prefix.size()) == prefix) {\n      result.push_back(str);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<string> output;\n    for (auto\
    \ &s : strings) {\n        if (s.find(prefix) == 0) {\n            output.push_back(s);\n\
    \        }\n    }\n    return output;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkjqe85us.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpkjqe85us.cpp:9:17: error: \u2018string\u2019 was not declared in this\
    \ scope\n    9 |     std::vector<string> output;\n      |                 ^~~~~~\n\
    /tmp/tmpkjqe85us.cpp:9:17: note: suggested alternatives:\nIn file included from\
    \ /usr/include/c++/9/iosfwd:39,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpkjqe85us.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33:\
    \ note:   \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n\
    \      |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpkjqe85us.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmpkjqe85us.cpp:9:23: error: template argument 1 is invalid\n    9 |    \
    \ std::vector<string> output;\n      |                       ^\n/tmp/tmpkjqe85us.cpp:9:23:\
    \ error: template argument 2 is invalid\n/tmp/tmpkjqe85us.cpp:12:20: error: request\
    \ for member \u2018push_back\u2019 in \u2018output\u2019, which is of non-class\
    \ type \u2018int\u2019\n   12 |             output.push_back(s);\n      |    \
    \                ^~~~~~~~~\n/tmp/tmpkjqe85us.cpp:"
  stdout: ''
  timestamp: 1660098523
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    //\
    \ Loop over the input strings backwards to find the first one starting with prefix.\n\
    \    for (std::size_t i = 0; i < (std::size_t) strings.size(); ++i) {\n      \
    \  if (strings[i].compare(0, prefix.size(), prefix) == 0) {\n            result.push_back(strings[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> new_list;\n  for\
    \ (std::string elem : strings)\n    if (elem.startswith(prefix))\n      new_list.push_back(elem);\n\
    \  return new_list;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprdav4spd.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmprdav4spd.cpp:11:14: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018startswith\u2019\
    \n   11 |     if (elem.startswith(prefix))\n      |              ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660098523
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::string prefix_copy = prefix;\n    prefix_copy.insert(prefix_copy.begin(),\
    \ prefix.size());\n    std::vector<std::string> results;\n\n    for (std::string\
    \ &s : strings) {\n        if (prefix_copy == s) {\n            results.push_back(s);\n\
    \        }\n    }\n\n    return results;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmprragsg9y: /tmp/tmprragsg9y.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098523
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto &string : strings) {\n    if (string.substr(0, prefix.size()) == prefix)\
    \ {\n      result.emplace_back(string);\n    }\n  }\n  return result;\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  auto prefix = prefix.begin();\n  auto end = strings.end();\n  std::set<std::string>\
    \ res;\n  while (prefix != end) {\n    if (prefix.compare(0, prefix.length(),\
    \ *prefix) == 0) {\n      res.insert(strings.begin(), strings.end());\n    }\n\
    \    ++prefix;\n  }\n  return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1wdop8s4.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp1wdop8s4.cpp:10:8: error: declaration of \u2018auto prefix\u2019 shadows\
    \ a parameter\n   10 |   auto prefix = prefix.begin();\n      |        ^~~~~~\n\
    /tmp/tmp1wdop8s4.cpp:10:17: error: use of \u2018prefix\u2019 before deduction\
    \ of \u2018auto\u2019\n   10 |   auto prefix = prefix.begin();\n      |      \
    \           ^~~~~~\n/tmp/tmp1wdop8s4.cpp:19:10: error: could not convert \u2018\
    res\u2019 from \u2018std::set<std::__cxx11::basic_string<char> >\u2019 to \u2018\
    std::vector<std::__cxx11::basic_string<char> >\u2019\n   19 |   return res;\n\
    \      |          ^~~\n      |          |\n      |          std::set<std::__cxx11::basic_string<char>\
    \ >\n"
  stdout: ''
  timestamp: 1660098523
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size() > 0);\n  assert(strings[0].find(prefix)\
    \ == 0);\n  std::ostringstream stream;\n  stream << strings[0];\n  for (int i\
    \ = 1; i < strings.size(); i++) {\n    stream << \" \" << strings[i];\n  }\n \
    \ std::copy(std::istream_iterator<std::string>(std::cin(stream)),\n          \
    \  std::istream_iterator<std::string>(),\n            std::back_inserter(strings));\n\
    \  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmps0q2ebia.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmps0q2ebia.cpp:16:63: error: no match for call to \u2018(std::istream\
    \ {aka std::basic_istream<char>}) (std::ostringstream&)\u2019\n   16 |   std::copy(std::istream_iterator<std::string>(std::cin(stream)),\n\
    \      |                                                               ^\n"
  stdout: ''
  timestamp: 1660098523
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    return std::remove_if(strings.begin(), strings.end(),\
    \ [&](std::string &s) {\n        return s.find(prefix) == 0;\n    });\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_yemjtcg.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp_yemjtcg.cpp:9:26: error: could not convert \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string&)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), <lambda\
    \ closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string&)>{prefix})\u2019 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n    9 |     return std::remove_if(strings.begin(), strings.end(), [&](std::string\
    \ &s) {\n      |            ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                          |\n      |                          __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\n   10 |         return s.find(prefix)\
    \ == 0;\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   11 |     });\n      |\
    \     ~~                    \n"
  stdout: ''
  timestamp: 1660098523
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> retval;\n    std::copy_if(strings.begin(),\
    \ strings.end(), std::back_inserter(retval),\n                 [prefix](std::string\
    \ i) { return i.compare(0, prefix.size(), prefix) == 0; });\n    return retval;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  result.reserve(strings.size());\n\
    \  for (auto it = strings.begin(); it != strings.end(); ++it) {\n    if (it->compare(0,\
    \ prefix.size(), prefix) == 0) {\n      result.push_back(*it);\n    }\n  }\n \
    \ return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n  \
    \  assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> results;\n  std::copy_if(strings.begin(),\
    \ strings.end(),\n               std::back_inserter(results),\n              \
    \ [&prefix](std::string s) { return s.substr(0, prefix.length()) == prefix; });\n\
    \  return results;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto const& string : strings) {\n        if (string.find(prefix) == 0) {\n\
    \            result.push_back(string);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n\tstd::vector<std::string> out;\n\tfor (auto&\
    \ s: strings) {\n\t\tif (s.substr(0, prefix.size()) == prefix) {\n\t\t\tout.emplace_back(s);\n\
    \t\t}\n\t}\n\treturn out;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\
    \ // stable sort\n    // If the prefix is empty or it's equal to the first string,\
    \ return the\n    // original list.\n    if (prefix.empty() || strings.front()\
    \ == prefix) {\n        return strings;\n    }\n\n    // Create a vector to hold\
    \ the result of the iteration and initialize it to empty.\n    std::vector<std::string>\
    \ result;\n    result.reserve(strings.size());\n\n    // Iterate over the input\
    \ list and only add strings that begin with the given\n    // prefix to the result.\n\
    \    bool match = false;\n    for (std::string::const_iterator it = strings.begin();\
    \ it != strings.end(); ++it) {\n        if (std::equal(prefix.begin(), prefix.end(),\
    \ *it)) {\n            result.push_back(*it);\n            match = true;\n   \
    \     }\n    }\n\n    // If the input list does not match the prefix, return an\
    \ empty list.\n    if (!match) {\n        return result;\n    }\n\n    // Return\
    \ the result of the iteration.\n    return result;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1hcswh6v.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp1hcswh6v.cpp:23:56: error: conversion from \u2018__normal_iterator<std::__cxx11::basic_string<char>*,std::vector<std::__cxx11::basic_string<char>\
    \ >>\u2019 to non-scalar type \u2018__normal_iterator<const char*,std::__cxx11::basic_string<char>>\u2019\
    \ requested\n   23 |     for (std::string::const_iterator it = strings.begin();\
    \ it != strings.end(); ++it) {\n      |                                      \
    \     ~~~~~~~~~~~~~^~\n/tmp/tmp1hcswh6v.cpp:23:63: error: no match for \u2018\
    operator!=\u2019 (operand types are \u2018std::__cxx11::basic_string<char>::const_iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >\u2019} and \u2018std::vector<std::__cxx11::basic_string<char> >::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >\u2019})\n   23 |     for (std::string::const_iterator it = strings.begin();\
    \ it != strings.end(); ++it) {\n      |                                      \
    \                      ~~ ^~ ~~~~~~~~~~~~~\n      |                          \
    \                                  |                |\n      |               \
    \                                             |                __normal_iterator<std::__cxx11::basic_string<char>*,std::vector<std::__cxx11::basic_string<char>\
    \ >>\n      |                                                            __normal_iterator<const\
    \ char*,std::__cxx11::basic_string<char>>\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp1hcswh6v.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:897:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator!=(con"
  stdout: ''
  timestamp: 1660098523
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    // Return an empty list if the input is\
    \ empty or null.\n    if (strings.empty() || strings[0] == \"\")\n        return\
    \ strings;\n\n    // Initialize a vector of strings we will return.\n    std::vector<std::string>\
    \ result;\n\n    // The current first string to be returned for each input.\n\
    \    std::string first = \"\";\n\n    // Iterate over the input list\n    for\
    \ (int i = 0; i < strings.size(); i++) {\n        // If the current string starts\
    \ with the prefix, return it.\n        if (strings[i].substr(0, prefix.length())\
    \ == prefix) {\n            result.push_back(first);\n            first = strings[i];\n\
    \        }\n        else {\n            // If the current string doesn't start\
    \ with the prefix, but the\n            // first one we encounter, add it to the\
    \ result.\n            if (first != \"\")\n                result.push_back(first);\n\
    \n            // Set the current first string.\n            first = strings[i];\n\
    \        }\n    }\n\n    // If the current string doesn't start with the prefix,\
    \ but the first one\n    // we encounter, add it to the result.\n    if (first\
    \ != \"\")\n        result.push_back(first);\n\n    // Return the result.\n  \
    \  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n \
    \   assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpkpwjl23o: /tmp/tmpkpwjl23o.cpp:48: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098523
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::string rep(prefix);\n  for (const auto\
    \ &s : strings) {\n    if (s.compare(0, rep.size(), rep) == 0) {\n      strings.erase(std::remove(strings.begin(),\
    \ strings.end(), s));\n    }\n  }\n  return strings;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmptck2dhej: /tmp/tmptck2dhej.cpp:20: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098523
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> res;\n  for(auto\
    \ s: strings)\n    if(s.substr(0, prefix.size()) == prefix)\n      res.push_back(s);\n\
    \  return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098523
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto&\
    \ s: strings) {\n    if (s.substr(0, prefix.length()) == prefix) {\n      result.push_back(s);\
    \ // Store the string in the result list.\n    }\n  }\n  return result;\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098525
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto it=strings.begin();\n    while(it !=\
    \ strings.end() && it->compare(0, prefix.size(), prefix) == 0) {\n        ++it;\n\
    \    }\n    return std::move(it);\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk7vp_9dx.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpk7vp_9dx.cpp:13:21: error: could not convert \u2018std::move<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >&>(it)\u2019 from \u2018std::remove_reference<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >&>::type\u2019 {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019} to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n   13 |     return std::move(it);\n      |            ~~~~~~~~~^~~~\n\
    \      |                     |\n      |                     std::remove_reference<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >&>::type {aka __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >}\n"
  stdout: ''
  timestamp: 1660098525
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> out;\n    for (auto\
    \ &x : strings) {\n        if (x.startsWith(prefix)) {\n            out.push_back(x);\n\
    \        }\n    }\n    return out;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpak4_nzc5.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpak4_nzc5.cpp:11:15: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018startsWith\u2019\n   11 |         if (x.startsWith(prefix))\
    \ {\n      |               ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660098525
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto filter_func = [&prefix](const std::string\
    \ &s) {\n    return 0 == s.compare(0, prefix.size(), prefix);\n  };\n  return\
    \ std::remove_if(strings.begin(), strings.end(), filter_func);\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvo5lk4su.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpvo5lk4su.cpp:12:24: error: could not convert \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), filter_func)\u2019\
    \ from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\n  \
    \ 12 |   return std::remove_if(strings.begin(), strings.end(), filter_func);\n\
    \      |          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                        |\n      |                        __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\n"
  stdout: ''
  timestamp: 1660098525
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    size_t\
    \ prefix_length = prefix.size();\n    for (std::string &string : strings) {\n\
    \        if (string.size() >= prefix_length) {\n            if (string[0] == prefix)\
    \ {\n                result.push_back(string);\n            }\n        }\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_abjvt3j.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp_abjvt3j.cpp:13:27: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   13 |             if (string[0] == prefix) {\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp_abjvt3j.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp_abjvt3j.cpp:13:30:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   13 |             if (string[0] == prefix) {\n   \
    \   |                              ^~~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp_abjvt3j.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp_abjvt3j.cpp:13:30: note:   mismatched types \u2018std::__cxx11::__sub_match_string<"
  stdout: ''
  timestamp: 1660098525
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::cout << strings << std::endl;\n  if(strings.empty())\
    \ return strings;\n  std::string prefix = prefix + \"%\";\n  auto prefix_last\
    \ = prefix.rbegin();\n  std::string::reverse_iterator rit = std::search(prefix.begin(),\
    \ prefix.end(), strings[0].rbegin(), strings[0].rend());\n  std::string::reverse_iterator\
    \ it = std::search(prefix.begin(), prefix.end(), strings[0].begin(), strings[0].end());\n\
    \  if(it == strings[0].end() || it == prefix_last) return strings;\n  strings.erase(strings.begin(),\
    \ strings.begin()+rit);\n  return strings;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpplta6t_w.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpplta6t_w.cpp:9:13: error: no match for \u2018operator<<\u2019 (operand\
    \ types are \u2018std::ostream\u2019 {aka \u2018std::basic_ostream<char>\u2019\
    } and \u2018std::vector<std::__cxx11::basic_string<char> >\u2019)\n    9 |   std::cout\
    \ << strings << std::endl;\n      |   ~~~~~~~~~ ^~ ~~~~~~~\n      |        | \
    \      |\n      |        |       std::vector<std::__cxx11::basic_string<char>\
    \ >\n      |        std::ostream {aka std::basic_ostream<char>}\nIn file included\
    \ from /usr/include/c++/9/istream:39,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpplta6t_w.cpp:2:\n/usr/include/c++/9/ostream:108:7:\
    \ note: candidate: \u2018std::basic_ostream<_CharT, _Traits>::__ostream_type&\
    \ std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__ostream_type&\
    \ (*)(std::basic_ostream<_CharT, _Traits>::__ostream_type&)) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type\
    \ = std::basic_ostream<char>]\u2019\n  108 |       operator<<(__ostream_type&\
    \ (*__pf)(__ostream_type&))\n      |       ^~~~~~~~\n/usr/include/c++/9/ostream:108:36:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::basic_ostream<char>::__ostream_type& (*)(std::basic_ostream<char>::__ostream_type&)\u2019\
    \ {aka \u2018std::basic_ostream<char>& (*)(std::basic_ostream<char>&)\u2019}\n\
    \  108 |       operator<<(__ostream_type& (*__pf)(__ostream_type&))\n      | \
    \                 ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/ostream:117:7:\
    \ note: candidate: \u2018std::basic_ostream<_CharT, _Traits>::__ostream_type&\
    \ std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits"
  stdout: ''
  timestamp: 1660098525
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    std::for_each(strings.begin(),\
    \ strings.end(), [&](const std::string &s) {\n        if (s.substr(0, prefix.size())\
    \ == prefix) {\n            res.push_back(s);\n        }\n    });\n    return\
    \ res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098525
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto\
    \ s : strings)\n    if (s.compare(0, prefix.size(), prefix) == 0)\n      result.push_back(s);\n\
    \  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n \
    \   assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098525
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> filtered;\n   \
    \ for (auto &item : strings) {\n        if (item.find(prefix) == 0) {\n      \
    \      filtered.push_back(prefix);\n        } else {\n            filtered.push_back(item);\n\
    \        }\n    }\n    return filtered;\n}\nint main() {\n    auto candidate =\
    \ filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpqf4ejdsw: /tmp/tmpqf4ejdsw.cpp:22: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098525
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto & x: strings)\n        if (x.substr(0, prefix.size()) == prefix)\n   \
    \         result.push_back(x);\n    return result;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098525
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    // O(n) time complexity. Could be improved\
    \ to O(n*log(N)) using map here\n    std::vector<std::string> result;\n    std::unordered_map<std::string,int>\
    \ counter;\n    for(auto i : strings)\n    {\n        if(counter.find(prefix)\
    \ == counter.end())\n        {\n            counter[prefix] = 0;\n        }\n\
    \        counter[prefix] += 1;\n        if(counter[prefix] == 1)\n        {\n\
    \            result.push_back(i);\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmp_1x0bx7a: /tmp/tmp_1x0bx7a.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098526
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::string::size_type first = strings.begin();\n\
    \  std::string::size_type last = strings.end();\n  while (first != last) {\n \
    \   if (first[0] == prefix[0]) {\n      last = strings.erase(first);\n    } else\
    \ {\n      first++;\n    }\n  }\n  return strings;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpspxg8h29.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpspxg8h29.cpp:9:47: error: cannot convert \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019} to \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} in initialization\n    9 |   std::string::size_type\
    \ first = strings.begin();\n      |                                  ~~~~~~~~~~~~~^~\n\
    \      |                                               |\n      |            \
    \                                   std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator {aka __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >}\n/tmp/tmpspxg8h29.cpp:10:44:\
    \ error: cannot convert \u2018std::vector<std::__cxx11::basic_string<char> >::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >\u2019} to \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018\
    long unsigned int\u2019} in initialization\n   10 |   std::string::size_type last\
    \ = strings.end();\n      |                                 ~~~~~~~~~~~^~\n  \
    \    |                                            |\n      |                 \
    \                           std::vector<std::__cxx11::basic_string<char> >::iterator\
    \ {aka __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >}\n/tmp/tmpspxg8h29.cpp:12:16: error: invalid types \u2018std::__cxx11::basic_string<char>::size_type\
    \ {aka long unsigned int}[int]\u2019 for array subscript\n   12 |     if (first[0]\
    \ == prefix[0]) {\n      |                ^\n/tmp/tmpspxg8h29.cpp:13:33: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::erase(std::__cxx11::basic_string<char>::size_type&)\u2019\n   13 |      \
    \ last = string"
  stdout: ''
  timestamp: 1660098525
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> out;\n  for (const\
    \ auto& string : strings) {\n    if (string.substr(0, prefix.size()) == prefix)\
    \ {\n      out.emplace_back(string);\n    }\n  }\n  return out;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098525
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto it = strings.begin(); it != strings.end(); it++) {\n        if (it->substr(0,\
    \ prefix.size()) == prefix) {\n            result.emplace_back(*it);\n       \
    \ }\n    }\n    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098525
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto &string : strings) {\n    if (string.substr(0, prefix.size()) == prefix)\
    \ {\n      result.push_back(string);\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098525
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    std::stack<std::string>\
    \ stk;\n    stk.push(prefix);\n    for (std::string & str : strings) {\n     \
    \   if (stk.empty() || str != stk.top()) {\n            stk.push(str);\n     \
    \       res.push_back(str);\n        } else {\n            while (stk.size() >\
    \ 1 && str != stk.top()) {\n                stk.pop();\n                res.pop();\n\
    \            }\n            stk.pop();\n        }\n    }\n    return res;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvw1n6qbo.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpvw1n6qbo.cpp:19:21: error: \u2018class std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 has no member named \u2018pop\u2019\n   19 |                 res.pop();\n\
    \      |                     ^~~\n"
  stdout: ''
  timestamp: 1660098525
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\n\
    \    auto prefix_pos = strings.begin() + std::find(strings.begin(), strings.end(),\
    \ prefix);\n    std::vector<std::string> res;\n    res.reserve(strings.size());\n\
    \    for (auto it = prefix_pos; it != strings.end(); ++it) {\n        res.push_back(*it);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbc2k6m4c.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpbc2k6m4c.cpp:10:39: error: no match for \u2018operator+\u2019 (operand\
    \ types are \u2018std::vector<std::__cxx11::basic_string<char> >::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >\u2019} and \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019)\n   10 |     auto prefix_pos\
    \ = strings.begin() + std::find(strings.begin(), strings.end(), prefix);\n   \
    \   |                       ~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                    |             |\n      |         \
    \                           |             __normal_iterator<[...],[...]>\n   \
    \   |                                    __normal_iterator<[...],[...]>\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpbc2k6m4c.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:856:7:\
    \ note: candidate: \u2018__gnu_cxx::__normal_iterator<_Iterator, _Container> __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>::operator+(__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type)\
    \ const [with _Iterator = std::__cxx11::basic_string<char>*; _Container = std::vector<std::__cxx11::basic_string<char>\
    \ >; __gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type = long\
    \ int]\u2019\n  856 |       operator+(difference_type __n) const _GLIBCXX_NOEXCEPT\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:856:33: note:\
    \   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018__"
  stdout: ''
  timestamp: 1660098525
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  std::copy(std::begin(strings),\
    \ std::end(strings), std::back_inserter(result));\n  std::sort(std::begin(result),\
    \ std::end(result));\n  auto it = std::begin(result);\n  while (it != std::end(result))\
    \ {\n    if ((*it).compare(0, prefix.size(), prefix) == 0) {\n      it--;\n  \
    \  } else {\n      result.erase(it);\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660098526
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size() > 0);\n  assert(strings.size()\
    \ == prefix.size());\n\n  std::vector<std::string> result;\n  bool seen = false;\n\
    \  for (auto s: strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n\
    \      seen = true;\n      result.push_back(s);\n    }\n  }\n  if (seen) {\n \
    \   return result;\n  }\n  return {};\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmplbsw96wx: /tmp/tmplbsw96wx.cpp:9: std::vector<std::__cxx11::basic_string<char>
    > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):
    Assertion `strings.size() > 0'' failed.

    '
  stdout: ''
  timestamp: 1660098526
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.empty() || strings.size() >=\
    \ prefix.size());\n  if (strings.empty() || prefix.empty())\n    return strings;\n\
    \  std::vector<std::string> result;\n  result.reserve(strings.size());\n  auto\
    \ it = strings.begin();\n  auto it_prefix = prefix.begin();\n  for (; it != strings.end();\
    \ ++it, ++it_prefix) {\n    if (it_prefix != prefix.end() && it_prefix == it +\
    \ prefix.size()) {\n      result.push_back(*it);\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbl9bzpz_.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpbl9bzpz_.cpp:17:48: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019)\n   17 |     if (it_prefix\
    \ != prefix.end() && it_prefix == it + prefix.size()) {\n      |             \
    \                         ~~~~~~~~~ ^~ ~~~~~~~~~~~~~~~~~~\n      |           \
    \                           |               |\n      |                       \
    \               |               __normal_iterator<std::__cxx11::basic_string<char>*,std::vector<std::__cxx11::basic_string<char>\
    \ >>\n      |                                      __normal_iterator<char*,std::__cxx11::basic_string<char>>\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpbl9bzpz_.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpbl9bzpz_.cpp:17:68: note: \
    \  deduced conflicting types for parameter \u2018_Container\u2019 (\u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018std::vector<std::__cxx11::basic_string<char> >\u2019)\n   17 |   \
    \  if (it_prefix != prefix.end() && it_prefix == it + prefix.size()) {\n     \
    \ |                                                   "
  stdout: ''
  timestamp: 1660098525
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    // Write your code here.\n    std::vector<std::string>\
    \ result;\n    for (unsigned int i = 0; i < strings.size(); i++)\n    {\n    \
    \    if (strings[i].substr(0, prefix.length()) == prefix)\n        {\n       \
    \     result.push_back(strings[i]);\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098525
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> results;\n  for (std::string\
    \ string : strings)\n    if (string.substr(0, prefix.length()) == prefix)\n  \
    \    results.push_back(string);\n  return results;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098525
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\n\
    \    auto first_string_start = std::find_if(strings.begin(), strings.end(),\n\
    \            [&](std::string & s) { return s.substr(0, prefix.length()) == prefix;\
    \ });\n    return first_string_start != strings.end() ? std::move(strings) : std::vector<string>();\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2ea9zj01.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp2ea9zj01.cpp:12:83: error: \u2018string\u2019 was not declared in this\
    \ scope\n   12 |     return first_string_start != strings.end() ? std::move(strings)\
    \ : std::vector<string>();\n      |                                          \
    \                                         ^~~~~~\n/tmp/tmp2ea9zj01.cpp:12:83:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/iosfwd:39,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp2ea9zj01.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33: note:  \
    \ \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n \
    \     |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp2ea9zj01.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmp2ea9zj01.cpp:12:89: error: template argument 1 is invalid\n   12 |   \
    \  return first_string_start != strings.end() ? std::move(strings) : std::vector<string>();\n\
    \      |                                                                     \
    \                    ^\n/tmp/tmp2ea9zj01.cpp:12:89: err"
  stdout: ''
  timestamp: 1660098525
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (int\
    \ i = 0; i < strings.size(); ++i) {\n    if (strings[i].substr(0, prefix.length())\
    \ == prefix) {\n      result.push_back(strings[i]);\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098526
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    auto\
    \ pos = strings.begin();\n    while (pos != strings.end()) {\n        if (std::string(prefix)\
    \ == std::string(pos)) {\n            result.push_back(std::string(pos));\n  \
    \      }\n        ++pos;\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_h6k71dd.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp_h6k71dd.cpp:12:51: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::basic_string(__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >&)\u2019\n   12 |         if\
    \ (std::string(prefix) == std::string(pos)) {\n      |                       \
    \                            ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp_h6k71dd.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note: candidate: \u2018template<class _Tp, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&)\u2019\n  654 |  basic_string(const\
    \ _Tp& __t, const _Alloc& __a = _Alloc())\n      |  ^~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/move.h:55,\n                 from /usr/include/c++/9/bits/stl_pair.h:59,\n\
    \                 from /usr/include/c++/9/bits/stl_algobase.h:64,\n          \
    \       from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp_h6k71dd.cpp:2:\n/usr/include/c++/9/type_traits:\
    \ In substitution of \u2018template<bool _Cond, class _Tp> using enable_if_t =\
    \ typename std::enable_if::type [with bool _Cond = std:"
  stdout: ''
  timestamp: 1660098525
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> res;\n  for(unsigned\
    \ int i=0; i < strings.size(); ++i) {\n    if(strings[i].find(prefix) == 0) {\n\
    \      res.push_back(strings[i]);\n    }\n  }\n  return res;\n}\nint main() {\n\
    \    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098526
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto &s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n\
    \            result.push_back(s);\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098526
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  // Create a copy of the original list.\n \
    \ std::vector<std::string> copyStrings = strings;\n  std::sort(copyStrings.begin(),\
    \ copyStrings.end());\n\n  // Look for prefix at each index in string list.\n\
    \  std::vector<int> indexesToRemove;\n  for (int i = 0; i < copyStrings.size();\
    \ ++i) {\n    if (copyStrings[i].find(prefix) == 0) {\n      indexesToRemove.push_back(i);\n\
    \    }\n  }\n\n  // Remove prefix from original list.\n  for (int i = 0; i < indexesToRemove.size();\
    \ ++i) {\n    copyStrings.erase(copyStrings.begin() + indexesToRemove[i]);\n \
    \ }\n\n  return copyStrings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpge40wx1e: /tmp/tmpge40wx1e.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098526
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string>::iterator it = std::begin(strings);\n\
    \  while (it != std::end(strings)) {\n    std::string::size_type startPos = it->find(prefix);\n\
    \    if (startPos != std::string::npos) {\n      strings.erase(it);\n    } else\
    \ {\n      ++it;\n    }\n  }\n  return strings;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpkxgzuzyz: /tmp/tmpkxgzuzyz.cpp:23: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098526
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  if(strings.size() == 0) return strings;\n\
    \  std::vector<std::string> result;\n  for(unsigned int i = 0; i < strings.size();\
    \ ++i) {\n    if(strings[i].substr(0, prefix.length()) == prefix) {\n      result.push_back(strings[i]);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098526
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto it = std::begin(strings);\n  while (it\
    \ != std::end(strings)) {\n    auto n = std::distance(std::begin(strings), it);\n\
    \    if (0 == n.compare(0, prefix.size(), prefix)) {\n      it = std::next(it,\
    \ prefix.size());\n    } else {\n      it = std::next(it, n);\n    }\n  }\n  return\
    \ strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpopx4rt3x.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpopx4rt3x.cpp:12:16: error: request for member \u2018compare\u2019 in\
    \ \u2018n\u2019, which is of non-class type \u2018long int\u2019\n   12 |    \
    \ if (0 == n.compare(0, prefix.size(), prefix)) {\n      |                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660098525
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto& str : strings) {\n    if (str.find(prefix) == 0) {\n      result.push_back(str);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098401
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    std::for_each(strings.begin(),\
    \ strings.end(), [&](std::string& s) {\n        if (s.substr(0, prefix.length())\
    \ == prefix)\n            result.push_back(s);\n    });\n    return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098526
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> res;\n  res.reserve(strings.size());\n\
    \  for (auto &str : strings) {\n    if (str.substr(0, prefix.size()) == prefix)\
    \ {\n      res.push_back(str);\n    }\n  }\n  return res;\n}\nint main() {\n \
    \   auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098526
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    auto\
    \ it = std::begin(strings);\n    while (it != std::end(strings)) {\n        if\
    \ (it->substr(0, prefix.size()) == prefix) {\n            result.push_back(it->substr(prefix.size()));\n\
    \        }\n        ++it;\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpzigs0k1o: /tmp/tmpzigs0k1o.cpp:22: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098526
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto &string : strings) {\n        if (0 == string.compare(0, prefix.length(),\
    \ prefix))\n            result.emplace_back(std::move(string));\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098526
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (std::string&\
    \ s: strings) {\n    if (s.substr(0, prefix.length()) == prefix) {\n      result.push_back(s);\
    \ // if found, add\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098526
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    assert(strings.size() != 0);\n    size_t\
    \ prefix_len = prefix.length();\n    std::vector<std::string> new_strings;\n \
    \   for(auto &str : strings) {\n        size_t prefix_found = 0;\n        for(auto\
    \ &c : str) {\n            if(prefix_found == 0) {\n                if(c == prefix[0])\
    \ {\n                    prefix_found++;\n                } else {\n         \
    \           prefix_found = 0;\n                }\n            } else {\n     \
    \           if(c == prefix[prefix_found]) {\n                    prefix_found++;\n\
    \                } else {\n                    prefix_found = 0;\n           \
    \     }\n            }\n        }\n        if(prefix_found == prefix_len) {\n\
    \            new_strings.push_back(str);\n        }\n    }\n    return new_strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpljg5vh9s: /tmp/tmpljg5vh9s.cpp:9: std::vector<std::__cxx11::basic_string<char>
    > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):
    Assertion `strings.size() != 0'' failed.

    '
  stdout: ''
  timestamp: 1660098526
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto&\
    \ s: strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      result.push_back(s);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098526
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (const auto& str : strings) {\n        if (str.substr(0, prefix.length()) ==\
    \ prefix) {\n            result.push_back(str);\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098526
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> filtered;\n   \
    \ for (auto& str : strings)\n        if (str.substr(0, prefix.size()) == prefix)\n\
    \            filtered.push_back(str);\n    return filtered;\n}\nint main() {\n\
    \    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098526
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> ret(std::begin(strings),\
    \ std::end(strings));\n  std::remove_if(std::begin(ret), std::end(ret), [&](std::string\
    \ str) {\n    return str.find(prefix) == 0;\n  });\n  return ret;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpsvvat73a: /tmp/tmpsvvat73a.cpp:18: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098526
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto it = std::begin(strings);\n    while\
    \ (it != std::end(strings)) {\n        if (it->find(prefix) == 0)\n          \
    \  strings.erase(it++);\n        else\n            ++it;\n    }\n    return strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmp73c6u5hi: /tmp/tmp73c6u5hi.cpp:21: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098526
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto& elem : strings) {\n    if (elem.length() >= prefix.length() && elem.substr(0,\
    \ prefix.length()) == prefix) {\n      result.push_back(elem);\n    }\n  }\n \
    \ return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n  \
    \  assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098526
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto prefix_iter = strings.begin() + std::find(strings.begin(),\
    \ strings.end(), prefix);\n  strings.erase(prefix_iter);\n  return strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxouss341.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpxouss341.cpp:9:38: error: no match for \u2018operator+\u2019 (operand\
    \ types are \u2018std::vector<std::__cxx11::basic_string<char> >::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >\u2019} and \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019)\n    9 |   auto prefix_iter\
    \ = strings.begin() + std::find(strings.begin(), strings.end(), prefix);\n   \
    \   |                      ~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                   |             |\n      |          \
    \                         |             __normal_iterator<[...],[...]>\n     \
    \ |                                   __normal_iterator<[...],[...]>\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpxouss341.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:856:7:\
    \ note: candidate: \u2018__gnu_cxx::__normal_iterator<_Iterator, _Container> __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>::operator+(__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type)\
    \ const [with _Iterator = std::__cxx11::basic_string<char>*; _Container = std::vector<std::__cxx11::basic_string<char>\
    \ >; __gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type = long\
    \ int]\u2019\n  856 |       operator+(difference_type __n) const _GLIBCXX_NOEXCEPT\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:856:33: note:\
    \   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018__gnu_cx"
  stdout: ''
  timestamp: 1660098526
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> output;\n  \n  for\
    \ (auto s : strings) {\n    if (s[0] == prefix) {\n      output.push_back(s);\n\
    \    }\n  }\n  \n  return output;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp83cl1vld.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp83cl1vld.cpp:12:14: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   12 |     if (s[0] == prefix) {\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp83cl1vld.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp83cl1vld.cpp:12:17:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   12 |     if (s[0] == prefix) {\n      |         \
    \        ^~~~~~\nIn file included from /usr/include/c++/9/regex:62,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n      \
    \           from /tmp/tmp83cl1vld.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp83cl1vld.cpp:12:17: note:   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>\u2019 and"
  stdout: ''
  timestamp: 1660098526
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> out;\n    for (auto\
    \ & string : strings) {\n        if (string.substr(0, prefix.size()) == prefix)\
    \ {\n            out.push_back(string);\n        }\n    }\n    return out;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098526
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    // Initialize prefix and check it's non-empty.\n\
    \    if (prefix.empty()) return {strings[0]};\n\n    // Iterate over each string\
    \ and keep only those that start with the prefix.\n    std::vector<std::string>\
    \ result;\n    for (const auto &str : strings) {\n        if (str.substr(0, prefix.size())\
    \ == prefix) {\n            result.push_back(str);\n        }\n    }\n\n    //\
    \ Return result if any non-null string was found in strings.\n    return result.empty()\
    \ ? std::vector<std::string>() : result;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098527
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\
    \ // Sort ascending\n    auto prefix_pos = prefix.find_first_not_of(strings[0]);\
    \ // Find first prefix that is not in any of the strings\n    if (prefix_pos ==\
    \ std::string::npos) return strings; // No matches\n    // Return strings with\
    \ prefix not matched\n    auto start = strings.begin() + prefix_pos;\n    auto\
    \ end = start + strings.size();\n    return std::remove_copy_if(start, end, std::back_inserter(strings),\
    \ \n                              [prefix](std::string str) {return !str.compare(0,\
    \ prefix.size(), prefix);});\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4ti0cbii.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp4ti0cbii.cpp:15:31: error: could not convert \u2018std::remove_copy_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, std::back_insert_iterator<std::vector<std::__cxx11::basic_string<char>\
    \ > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)::<lambda(std::string)>\
    \ >(start, end, std::back_inserter<std::vector<std::__cxx11::basic_string<char>\
    \ > >(strings), <lambda closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>{std::__cxx11::basic_string<char>(prefix)})\u2019\
    \ from \u2018std::back_insert_iterator<std::vector<std::__cxx11::basic_string<char>\
    \ > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\n  \
    \ 15 |     return std::remove_copy_if(start, end, std::back_inserter(strings),\n\
    \      |            ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::back_insert_iterator<std::vector<std::__cxx11::basic_string<char> > >\n\
    \   16 |                               [prefix](std::string str) {return !str.compare(0,\
    \ prefix.size(), prefix);});\n      |                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660098527
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto prefix_size = prefix.size();\n    std::vector<std::string>\
    \ results;\n\n    for(auto i = strings.begin(); i != strings.end(); ++i) {\n \
    \       if(0==std::memcmp(i->c_str(), prefix.c_str(), prefix_size)) {\n      \
    \      results.emplace_back(*i);\n        }\n    }\n\n    return results;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098527
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> out;\n  auto iter\
    \ = std::begin(strings);\n  auto end = std::end(strings);\n  while(iter != end)\
    \ {\n    if (0 == prefix.compare(0, iter->size(), prefix)) {\n      out.emplace_back(*iter);\n\
    \    }\n    ++iter;\n  }\n  return out;\n}\nint main() {\n    auto candidate =\
    \ filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpudqqtaee: /tmp/tmpudqqtaee.cpp:23: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098528
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto prefix_iter = std::find_if(strings.begin(),\
    \ strings.end(),\n                                   [&prefix](const std::string&\
    \ s) {\n                                     return s[0] == prefix[0];\n     \
    \                              });\n  return std::remove_if(strings.begin(), strings.end(),\n\
    \                        [&prefix_iter](const std::string& s) { return prefix_iter\
    \ != strings.end() && *prefix_iter == prefix; });\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxwkev1cm.cpp: In lambda function:\n/tmp/tmpxwkev1cm.cpp:14:86:\
    \ error: \u2018strings\u2019 is not captured\n   14 |                        \
    \ [&prefix_iter](const std::string& s) { return prefix_iter != strings.end() &&\
    \ *prefix_iter == prefix; });\n      |                                       \
    \                                               ^~~~~~~\n/tmp/tmpxwkev1cm.cpp:14:38:\
    \ note: the lambda has no capture-default\n   14 |                         [&prefix_iter](const\
    \ std::string& s) { return prefix_iter != strings.end() && *prefix_iter == prefix;\
    \ });\n      |                                      ^\n/tmp/tmpxwkev1cm.cpp:8:68:\
    \ note: \u2018std::vector<std::__cxx11::basic_string<char> > strings\u2019 declared\
    \ here\n    8 | std::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n      |                                    \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpxwkev1cm.cpp:14:119: error:\
    \ \u2018prefix\u2019 is not captured\n   14 |                         [&prefix_iter](const\
    \ std::string& s) { return prefix_iter != strings.end() && *prefix_iter == prefix;\
    \ });\n      |                                                               \
    \                                                        ^~~~~~\n/tmp/tmpxwkev1cm.cpp:14:38:\
    \ note: the lambda has no capture-default\n   14 |                         [&prefix_iter](const\
    \ std::string& s) { return prefix_iter != strings.end() && *prefix_iter == prefix;\
    \ });\n      |                                      ^\n/tmp/tmpxwkev1cm.cpp:8:89:\
    \ note: \u2018std::string prefix\u2019 declared here\n    8 | std::vector<std::string>\
    \ filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n \
    \     |                                                                      \
    \       ~~~~~~~~~~~~^~~~~~\n/tmp/tmpxwkev1cm.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpxwkev1cm.cpp:13:24: error: could not convert \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::ba"
  stdout: ''
  timestamp: 1660098527
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    for (std::string\
    \ word : strings) {\n        if (word.substr(0, prefix.length()) == prefix) {\n\
    \            res.push_back(word);\n        }\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098527
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(!prefix.empty());\n  std::sort(strings.begin(),\
    \ strings.end());\n  auto it = std::mismatch(strings.begin(), strings.end(), prefix.begin(),\
    \ prefix.end());\n  if (it == strings.end()) {\n    return strings;\n  }\n  auto\
    \ start_index = std::distance(prefix.begin(), it.first);\n  auto end_index = std::distance(prefix.begin(),\
    \ it.second);\n  return std::vector<std::string>(strings.begin() + start_index,\
    \ strings.begin() + end_index);\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpaakbdq45.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpaakbdq45.cpp:12:10: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::pair<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > >\u2019 and \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019})\n   12 |   if (it ==\
    \ strings.end()) {\n      |       ~~ ^~ ~~~~~~~~~~~~~\n      |       |       \
    \         |\n      |       |                std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator {aka __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >}\n      |       std::pair<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > >\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpaakbdq45.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpaakbdq45.cpp:12:25: note: \
    \  \u2018std::pair<__gnu_cxx::__normal_iterator<std::__cxx11::basi"
  stdout: ''
  timestamp: 1660098527
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto it = std::begin(strings);\n  std::vector<std::string>\
    \ res;\n  while (it != std::end(strings)) {\n    if (it->substr(0, prefix.size())\
    \ == prefix) {\n      res.push_back(std::move(*it));\n    }\n    ++it;\n  }\n\
    \  return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098527
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::set<std::string> stringSet;\n  for (std::string\
    \ s : strings)\n    stringSet.insert(s.substr(0, prefix.size()));\n  return std::vector<std::string>(stringSet.begin(),\
    \ stringSet.end());\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmp6_msx3nk: /tmp/tmp6_msx3nk.cpp:17: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098528
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    return std::remove_if(strings.begin(), strings.end(),\n\
    \            [](const std::string& s) { return s.starts_with(prefix); }\n    \
    \    );\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo0uyysn4.cpp: In lambda function:\n/tmp/tmpo0uyysn4.cpp:10:49:\
    \ error: \u2018const string\u2019 {aka \u2018const class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018starts_with\u2019\n   10 |             [](const std::string&\
    \ s) { return s.starts_with(prefix); }\n      |                              \
    \                   ^~~~~~~~~~~\n/tmp/tmpo0uyysn4.cpp:10:61: error: \u2018prefix\u2019\
    \ is not captured\n   10 |             [](const std::string& s) { return s.starts_with(prefix);\
    \ }\n      |                                                             ^~~~~~\n\
    /tmp/tmpo0uyysn4.cpp:10:14: note: the lambda has no capture-default\n   10 | \
    \            [](const std::string& s) { return s.starts_with(prefix); }\n    \
    \  |              ^\n/tmp/tmpo0uyysn4.cpp:8:89: note: \u2018std::string prefix\u2019\
    \ declared here\n    8 | std::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n      |                                    \
    \                                         ~~~~~~~~~~~~^~~~~~\n/tmp/tmpo0uyysn4.cpp:\
    \ In function \u2018std::vector<std::__cxx11::basic_string<char> > filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)\u2019:\n/tmp/tmpo0uyysn4.cpp:9:26: error: could not convert\
    \ \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), (<lambda\
    \ closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)>{}, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)>()))\u2019 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n    9 |     return std::remove_if(stri"
  stdout: ''
  timestamp: 1660098527
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  std::sort(prefix.begin(), prefix.end());\n  strings.erase(std::remove_if(strings.begin(),\
    \ strings.end(), [&](std::string s) { return s.substr(0, prefix.size()) == prefix;\
    \ }), strings.end());\n  return strings;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpikuc0jif: /tmp/tmpikuc0jif.cpp:17: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098528
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<string> result;\n    for(auto\
    \ &s : strings) {\n        if(s.substr(0, prefix.size()) == prefix) {\n      \
    \      result.push_back(s);\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppd4kukqz.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmppd4kukqz.cpp:9:17: error: \u2018string\u2019 was not declared in this\
    \ scope\n    9 |     std::vector<string> result;\n      |                 ^~~~~~\n\
    /tmp/tmppd4kukqz.cpp:9:17: note: suggested alternatives:\nIn file included from\
    \ /usr/include/c++/9/iosfwd:39,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmppd4kukqz.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33:\
    \ note:   \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n\
    \      |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmppd4kukqz.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmppd4kukqz.cpp:9:23: error: template argument 1 is invalid\n    9 |    \
    \ std::vector<string> result;\n      |                       ^\n/tmp/tmppd4kukqz.cpp:9:23:\
    \ error: template argument 2 is invalid\n/tmp/tmppd4kukqz.cpp:12:20: error: request\
    \ for member \u2018push_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   12 |             result.push_back(s);\n      |    \
    \                ^~~~~~~~~\n/tmp/tmppd4kukqz.cpp:"
  stdout: ''
  timestamp: 1660098527
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (size_t i = 0; i < strings.size(); ++i) {\n        if (strings[i].substr(0,\
    \ prefix.size()) == prefix) {\n            result.push_back(strings[i]);\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098528
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto const &str : strings) {\n        if (str.substr(0, prefix.size()) == prefix)\n\
    \            result.push_back(str);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098528
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    // We need to use find because a vector\
    \ does not allow to pass a callable as parameter\n    auto prefix = prefix.begin();\n\
    \    std::vector<std::string> res;\n    std::find(strings.begin(), strings.end(),\
    \ [&]() {\n        return prefix.compare(strings.begin(), strings.end()) == 0;\n\
    \    }) != strings.end();\n    return res;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyo8qf7ox.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpyo8qf7ox.cpp:10:10: error: declaration of \u2018auto prefix\u2019 shadows\
    \ a parameter\n   10 |     auto prefix = prefix.begin();\n      |          ^~~~~~\n\
    /tmp/tmpyo8qf7ox.cpp:10:19: error: use of \u2018prefix\u2019 before deduction\
    \ of \u2018auto\u2019\n   10 |     auto prefix = prefix.begin();\n      |    \
    \               ^~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpyo8qf7ox.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_equals_val<_Value>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Value = const filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda()>]\u2019:\n/usr/include/c++/9/bits/stl_algo.h:120:14:\
    \   required from \u2018_RandomAccessIterator std::__find_if(_RandomAccessIterator,\
    \ _RandomAccessIterator, _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator\
    \ = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >; _Predicate = __gnu_cxx::__ops::_Iter_equals_val<const filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda()> >]\u2019\n/usr/include/c++/9/bits/stl_algo.h:161:23:\
    \   required from \u2018_Iterator std::__find_if(_Iterator, _Iterator, _Predicate)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Predicate = __gnu_cxx::__ops::_Iter_equals_val<const\
    \ filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)::<lambda()>\
    \ >]\u2019\n/u"
  stdout: ''
  timestamp: 1660098527
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto begin = strings.begin();\n    auto\
    \ end = strings.end();\n    while (begin != end) {\n        if (begin->find(prefix)\
    \ == 0) {\n            begin = strings.erase(begin);\n        } else {\n     \
    \       ++begin;\n        }\n    }\n    return strings;\n}\nint main() {\n   \
    \ auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660098528
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> results;\n  if (strings.size()\
    \ == 0)\n    return results;\n  if (prefix.empty())\n    return results;\n  auto\
    \ it = strings.begin();\n  while (it != strings.end()) {\n    if (it->length()\
    \ >= prefix.size() && it->substr(0, prefix.size()) == prefix) {\n      results.push_back(*it);\n\
    \    }\n    ++it;\n  }\n  return results;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098528
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> retstring;\n  for\
    \ (std::string s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n\
    \      retstring.push_back(s);\n    }\n  }\n  return retstring;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098528
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    for (auto&\
    \ s : strings) {\n        if (s.find(prefix) == 0)\n            res.push_back(s);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098528
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for(auto\
    \ it=strings.begin(); it!=strings.end(); ++it){\n        if(it->substr(0, prefix.size())\
    \ == prefix){\n            result.push_back(*it);\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098528
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  std::vector<std::string>::iterator iter = strings.begin();\n  while (iter !=\
    \ strings.end() && prefix == iter->substr(0, prefix.length())) {\n    ++iter;\n\
    \  }\n  return std::vector<std::string>(iter, strings.end());\n}\nint main() {\n\
    \    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpgwyc5nxv: /tmp/tmpgwyc5nxv.cpp:19: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098528
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    if (strings.empty()) return strings;\n \
    \   std::vector<bool> found(strings.size(), false);\n    for (auto it : strings)\
    \ {\n        if (it.startsWith(prefix)) {\n            found[it.size()-1] = true;\n\
    \        } else {\n            found[it.size()-1] = false;\n        }\n    }\n\
    \    std::vector<std::string> result;\n    for (auto it : found) {\n        if\
    \ (it) result.push_back(it);\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp89yqgw03.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp89yqgw03.cpp:12:16: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018startsWith\u2019\n   12 |         if (it.startsWith(prefix))\
    \ {\n      |                ^~~~~~~~~~\n/tmp/tmp89yqgw03.cpp:20:36: error: no\
    \ matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(std::_Bit_reference&)\u2019\n   20 |         if (it) result.push_back(it);\n\
    \      |                                    ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp89yqgw03.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018std::_Bit_reference\u2019\
    \ to \u2018const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/b"
  stdout: ''
  timestamp: 1660098528
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> res;\n  for (std::string\
    \ s : strings) {\n    if (s.substr(0, prefix.length()) == prefix) {\n      res.push_back(s);\n\
    \    }\n  }\n  return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098528
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> out;\n    for (std::string\
    \ s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n      \
    \      out.push_back(s);\n        }\n    }\n    return out;\n}\nint main() {\n\
    \    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098528
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  std::string prefix_str = prefix + \".\";\n  auto it = std::find_if(strings.begin(),\
    \ strings.end(),\n      [&prefix_str](const std::string &str) {\n        return\
    \ str.starts_with(prefix_str);\n      });\n  return std::vector<std::string>{it,\
    \ strings.end()};\n}\nint main() {\n    auto candidate = filter_by_prefix;\n \
    \   assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphgmoqka1.cpp: In lambda function:\n/tmp/tmphgmoqka1.cpp:13:20:\
    \ error: \u2018const string\u2019 {aka \u2018const class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018starts_with\u2019\n   13 |         return str.starts_with(prefix_str);\n\
    \      |                    ^~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmphgmoqka1.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_pred<_Predicate>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Predicate = filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)>]\u2019:\n/usr/include/c++/9/bits/stl_algo.h:120:14:\
    \   required from \u2018_RandomAccessIterator std::__find_if(_RandomAccessIterator,\
    \ _RandomAccessIterator, _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator\
    \ = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >; _Predicate = __gnu_cxx::__ops::_Iter_pred<filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)> >]\u2019\n/usr/include/c++/9/bits/stl_algo.h:161:23:\
    \   required from \u2018_Iterator std::__find_if(_Iterator, _Iterator, _Predicate)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Predicate = __gnu_cxx::__ops::_Iter_pred<filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)> >]\u2019\n/usr/include/c++/9/bits/stl_algo.h:3969:28:\
    \   required from \u2018_IIter std::find_if(_IIter, _IIter, _Predicate) [with\
    \ _IIter = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, "
  stdout: ''
  timestamp: 1660098528
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\
    \ // sorting the input strings makes them easier to read for testing\n  auto it\
    \ = std::find_if(strings.begin(), strings.end(), [&](const std::string & s) {\
    \ return s.starts_with(prefix); });\n  if (it != strings.end()) {\n    strings.erase(it,\
    \ strings.end());\n  }\n  return strings;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpse0y5dxr.cpp: In lambda function:\n/tmp/tmpse0y5dxr.cpp:10:96:\
    \ error: \u2018const string\u2019 {aka \u2018const class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018starts_with\u2019\n   10 |   auto it = std::find_if(strings.begin(),\
    \ strings.end(), [&](const std::string & s) { return s.starts_with(prefix); });\n\
    \      |                                                                     \
    \                           ^~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpse0y5dxr.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_pred<_Predicate>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Predicate = filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)>]\u2019:\n/usr/include/c++/9/bits/stl_algo.h:120:14:\
    \   required from \u2018_RandomAccessIterator std::__find_if(_RandomAccessIterator,\
    \ _RandomAccessIterator, _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator\
    \ = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >; _Predicate = __gnu_cxx::__ops::_Iter_pred<filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)> >]\u2019\n/usr/include/c++/9/bits/stl_algo.h:161:23:\
    \   required from \u2018_Iterator std::__find_if(_Iterator, _Iterator, _Predicate)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Predicate = __gnu_cxx::__ops::_Iter_pred<filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)> >]\u2019\n/usr/include/c++/9/bits/stl_algo.h:396"
  stdout: ''
  timestamp: 1660098528
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    for(auto\
    \ s: strings) {\n        if(s.substr(0, prefix.size()) == prefix) {\n        \
    \    res.push_back(s);\n        }\n    }\n    return res;\n}\nint main() {\n \
    \   auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098528
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  string filtered_prefix = prefix;\n  for (int\
    \ i=0; i<strings.size(); i++) {\n    if (strings[i].substr(0, filtered_prefix.length())\
    \ == filtered_prefix) {\n      filtered_prefix = strings[i].substr(filtered_prefix.length());\
    \ // remove the prefix.\n    }\n  }\n  return filtered_prefix != prefix ? std::vector<string>(filtered_prefix.begin(),\
    \ filtered_prefix.end()) : strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdt3otq9a.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpdt3otq9a.cpp:9:3: error: \u2018string\u2019 was not declared in this\
    \ scope\n    9 |   string filtered_prefix = prefix;\n      |   ^~~~~~\n/tmp/tmpdt3otq9a.cpp:9:3:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/iosfwd:39,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdt3otq9a.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33: note:  \
    \ \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n \
    \     |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdt3otq9a.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmpdt3otq9a.cpp:11:30: error: \u2018filtered_prefix\u2019 was not declared\
    \ in this scope; did you mean \u2018filter_by_prefix\u2019?\n   11 |     if (strings[i].substr(0,\
    \ filtered_prefix.length()) == filtered_prefix) {\n      |                   \
    \           ^~~~~~~~~~~~~~~\n      |                              filter_by_prefix\n\
    /tmp/tmpdt3otq9a.cpp:15:10: error: \u2018filtered_prefix\u2019 was not declared\
    \ in this scope; did you mean \u2018filter_by_prefi"
  stdout: ''
  timestamp: 1660098528
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> filteres;\n  for\
    \ (const auto &str : strings) {\n    if (str.substr(0, prefix.length()) == prefix)\
    \ {\n      filteres.push_back(str);\n    }\n  }\n  return filteres;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098528
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> retval;\n    for\
    \ (std::string s : strs) {\n        if (s.substr(0, prefix.size()) == prefix)\
    \ {\n            retval.push_back(s);\n        }\n    }\n    return retval;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp69katg_4.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp69katg_4.cpp:10:26: error: \u2018strs\u2019 was not declared in this\
    \ scope\n   10 |     for (std::string s : strs) {\n      |                   \
    \       ^~~~\n"
  stdout: ''
  timestamp: 1660098528
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::string pre = prefix + '.';\n  std::sort(strings.begin(),\
    \ strings.end());\n  std::set<std::string> result;\n  for (std::string &string\
    \ : strings) {\n    if (string.find(pre) == 0) {\n      result.insert(string);\n\
    \    }\n  }\n  return std::vector<std::string>(result.begin(), result.end());\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpa8kgou8r: /tmp/tmpa8kgou8r.cpp:22: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098529
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    size_t\
    \ prefix_len = prefix.size();\n\n    for(const auto &str : strings) {\n      \
    \  if(str.size() > prefix_len) {\n            continue;\n        }\n        if(str.substr(0,\
    \ prefix_len) == prefix) {\n            result.push_back(str);\n        }\n  \
    \  }\n\n    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmprhq0grwx: /tmp/tmprhq0grwx.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098529
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string>::iterator pos = std::find(strings.begin(),\
    \ strings.end(), prefix);\n  if (pos != strings.end()) {\n    strings.erase(pos);\n\
    \  }\n  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpxyyln_02: /tmp/tmpxyyln_02.cpp:18: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098529
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size());\n  assert(strings[0].length()\
    \ > prefix.length());\n  std::vector<std::string> res;\n  for (std::string &string\
    \ : strings) {\n    if (string.substr(0, prefix.length()) == prefix) {\n     \
    \ res.push_back(string);\n    }\n  }\n  return res;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpwphjong9: /tmp/tmpwphjong9.cpp:9: std::vector<std::__cxx11::basic_string<char>
    > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):
    Assertion `strings.size()'' failed.

    '
  stdout: ''
  timestamp: 1660098529
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto it = std::begin(strings);\n  for (; it\
    \ != std::end(strings); ++it)\n    if (it->compare(0, prefix.size(), prefix) ==\
    \ 0)\n      std::erase(std::remove_cbegin(std::begin(strings), it), std::end(strings));\n\
    \  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnwig0juq.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpnwig0juq.cpp:12:12: error: \u2018erase\u2019 is not a member of \u2018\
    std\u2019\n   12 |       std::erase(std::remove_cbegin(std::begin(strings), it),\
    \ std::end(strings));\n      |            ^~~~~\n/tmp/tmpnwig0juq.cpp:12:23: error:\
    \ \u2018remove_cbegin\u2019 is not a member of \u2018std\u2019; did you mean \u2018\
    remove_if\u2019?\n   12 |       std::erase(std::remove_cbegin(std::begin(strings),\
    \ it), std::end(strings));\n      |                       ^~~~~~~~~~~~~\n    \
    \  |                       remove_if\n"
  stdout: ''
  timestamp: 1660098528
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> res;\n  for (std::string\
    \ s : strings) {\n    if (s.substr(0, prefix.length()) == prefix) {\n      res.push_back(s);\n\
    \    }\n  }\n  return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098528
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    assert(strings.size() > 0);\n    std::vector<std::string>\
    \ result;\n    for (auto& s : strings) {\n        if (s.substr(0, prefix.size())\
    \ == prefix) {\n            result.push_back(s);\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmp8u_6ixio: /tmp/tmp8u_6ixio.cpp:9: std::vector<std::__cxx11::basic_string<char>
    > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):
    Assertion `strings.size() > 0'' failed.

    '
  stdout: ''
  timestamp: 1660098529
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto\
    \ &s : strings)\n    if (s.substr(0, prefix.size()) == prefix) {\n      result.push_back(s);\n\
    \    }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098529
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> results;\n  results.reserve(strings.size());\n\
    \  for (const auto& string : strings) {\n    if (string.compare(0, prefix.size(),\
    \ prefix) == 0) {\n      results.push_back(std::move(string));\n    }\n  }\n \
    \ return results;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n \
    \   assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098529
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto filtered_prefix = prefix;\n  for (auto\
    \ &s : strings) {\n    if (s.compare(0, prefix.size(), prefix) == 0)\n      filtered_prefix.erase(prefix.size());\n\
    \    else if (s.compare(0, prefix.size(), prefix) == 0)\n      filtered_prefix.push_back(s);\n\
    \  }\n  return filtered_prefix;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpefa471qb.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpefa471qb.cpp:14:33: error: cannot convert \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018char\u2019\n   14 |       filtered_prefix.push_back(s);\n      |  \
    \                               ^\n      |                                 |\n\
    \      |                                 std::__cxx11::basic_string<char>\nIn\
    \ file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpefa471qb.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1353:24: note:\
    \   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1353 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n/tmp/tmpefa471qb.cpp:16:10: error: could\
    \ not convert \u2018filtered_prefix\u2019 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\n   16 |   return\
    \ filtered_prefix;\n      |          ^~~~~~~~~~~~~~~\n      |          |\n   \
    \   |          std::__cxx11::basic_string<char>\n"
  stdout: ''
  timestamp: 1660098528
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    for (auto\
    \ const &i : strings)\n        if (i.substr(0, prefix.size()) == prefix)\n   \
    \         res.push_back(i);\n    return res;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098529
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    std::for_each(strings.begin(),\
    \ strings.end(), [&res, prefix](std::string s) {\n        auto pos = s.find(prefix);\n\
    \        if (pos == 0) return res.emplace_back(s);\n        size_t len = prefix.length();\n\
    \        if (len != 0) {\n            if (pos == std::string::npos) {\n      \
    \          return res.emplace_back(s, 0);\n            } else if (pos == s.size()-len)\
    \ {\n                return res.emplace_back(s, pos);\n            }\n       \
    \ }\n        return res.emplace_back(s);\n    });\n    return res;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmp5gi24pn7: /tmp/tmp5gi24pn7.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098529
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> results;\n  for (std::string\
    \ s : strings) {\n    if (s.compare(0, prefix.size(), prefix) == 0) {\n      results.push_back(s);\n\
    \    }\n  }\n  return results;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098529
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    for (auto it = strings.begin(); it != strings.end();\
    \ ++it) {\n        if (it->startswith(prefix)) {\n            strings.erase(it);\n\
    \        }\n    }\n    return strings;\n}\nint main() {\n    auto candidate =\
    \ filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfw82kavt.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpfw82kavt.cpp:10:17: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018startswith\u2019\n   10 |         if (it->startswith(prefix))\
    \ {\n      |                 ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660098528
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(prefix.size() > 0);\n  std::string::size_type\
    \ prefix_size = prefix.size();\n  return std::remove_if(strings.begin(), strings.end(),\
    \ [&](const std::string& str) {\n    std::string::size_type begin = str.find_first_not_of(prefix,\
    \ 0);\n    return (begin != std::string::npos);\n  });\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph297_x91.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmph297_x91.cpp:11:24: error: could not convert \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), <lambda\
    \ closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)>{prefix})\u2019 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n   11 |   return std::remove_if(strings.begin(), strings.end(), [&](const\
    \ std::string& str) {\n      |          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                        |\n      |                        __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\n   12 |     std::string::size_type\
    \ begin = str.find_first_not_of(prefix, 0);\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \   13 |     return (begin != std::string::npos);\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \   14 |   });\n      |   ~~                    \n"
  stdout: ''
  timestamp: 1660098529
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string>::iterator it;\n \
    \ for (it = strings.begin(); it != strings.end(); it++) {\n    if (0 == std::strncmp(prefix,\
    \ *it, prefix.size())) {\n      strings.erase(it);\n    }\n  }\n  return strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdz099qac.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpdz099qac.cpp:11:27: error: cannot convert \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const char*\u2019\n \
    \  11 |     if (0 == std::strncmp(prefix, *it, prefix.size())) {\n      |    \
    \                       ^~~~~~\n      |                           |\n      | \
    \                          std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/cstring:42,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:48,\n\
    \                 from /tmp/tmpdz099qac.cpp:2:\n/usr/include/string.h:140:33:\
    \ note:   initializing argument 1 of \u2018int strncmp(const char*, const char*,\
    \ size_t)\u2019\n  140 | extern int strncmp (const char *__s1, const char *__s2,\
    \ size_t __n)\n      |                     ~~~~~~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1660098529
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> output;\n  for (int\
    \ i = 0; i < strings.size(); i++) {\n    if (strings[i].startsWith(prefix)) {\n\
    \      output.push_back(strings[i]);\n    }\n  }\n  return output;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpah6z1ern.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpah6z1ern.cpp:11:20: error: \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018startsWith\u2019\n   11 |     if (strings[i].startsWith(prefix))\
    \ {\n      |                    ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660098529
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<bool> was(std::begin(strings),\
    \ std::end(strings));\n    std::vector<bool> found(std::begin(strings), std::end(strings));\n\
    \    std::vector<std::string> result;\n    auto pos = std::find(std::begin(was),\
    \ std::end(was), false);\n    for (auto it = std::begin(was); it != std::end(was);\
    \ ++it) {\n        if (it == pos || !found[*it]) {\n            continue;\n  \
    \      }\n        found[*it] = true;\n        result.push_back(strings[it - std::begin(was)]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/c++/9/bits/specfun.h:45,\n         \
    \        from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp3lmansm6.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:\
    \ In instantiation of \u2018static _OI std::__copy_move<false, false, std::random_access_iterator_tag>::__copy_m(_II,\
    \ _II, _OI) [with _II = std::__cxx11::basic_string<char>*; _OI = std::_Bit_iterator]\u2019\
    :\n/usr/include/c++/9/bits/stl_algobase.h:404:30:   required from \u2018_OI std::__copy_move_a(_II,\
    \ _II, _OI) [with bool _IsMove = false; _II = std::__cxx11::basic_string<char>*;\
    \ _OI = std::_Bit_iterator]\u2019\n/usr/include/c++/9/bits/stl_algobase.h:441:30:\
    \   required from \u2018_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove\
    \ = false; _II = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _OI = std::_Bit_iterator]\u2019\
    \n/usr/include/c++/9/bits/stl_algobase.h:474:7:   required from \u2018_OI std::copy(_II,\
    \ _II, _OI) [with _II = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _OI = std::_Bit_iterator]\u2019\
    \n/usr/include/c++/9/bits/stl_bvector.h:1189:13:   required from \u2018void std::vector<bool,\
    \ _Alloc>::_M_initialize_range(_ForwardIterator, _ForwardIterator, std::forward_iterator_tag)\
    \ [with _ForwardIterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Alloc = std::allocator<bool>]\u2019\
    \n/usr/include/c++/9/bits/stl_bvector.h:1170:4:   required from \u2018void std::vector<bool,\
    \ _Alloc>::_M_initialize_dispatch(_InputIterator, _InputIterator, std::__false_type)\
    \ [with _InputIterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Alloc = std::allocator<bool>]\u2019\
    \n/usr/include/c++/9/bits/stl_bvector.h:702:4:   required from \u2018std::vector<bool,\
    \ _Alloc>::vector(_InputIterator, _InputIterator, const allocato"
  stdout: ''
  timestamp: 1660098529
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  std::vector<std::string> filtered_strings;\n  for (auto const& s : strings)\
    \ {\n    if (s.substr(0, prefix.size()) == prefix) {\n      filtered_strings.push_back(s);\n\
    \    }\n  }\n  return filtered_strings;\n}\nint main() {\n    auto candidate =\
    \ filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpzqu8u6wr: /tmp/tmpzqu8u6wr.cpp:21: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098530
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    for(auto\
    \ &string : strings) {\n        if(string.substr(0, prefix.size()) == prefix)\
    \ {\n            res.push_back(string);\n        }\n    }\n    return res;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098530
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    // TODO: use a std::map for prefixes\n \
    \   std::vector<std::string> ret; \n    for (auto s : strings) {\n        if (s.find(prefix)\
    \ == 0) {\n            ret.push_back(s);\n        }\n    }\n    return ret;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098530
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::cout << \"Filtering input for prefix\
    \ \" << prefix << \" ==> \" << strings << std::endl;\n    std::vector<std::string>\
    \ res;\n    for (std::string s : strings) {\n        if (s.substr(0, prefix.size())\
    \ == prefix) {\n            res.push_back(s);\n        }\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdczvjb25.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpdczvjb25.cpp:9:69: error: no match for \u2018operator<<\u2019 (operand\
    \ types are \u2018std::basic_ostream<char>\u2019 and \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019)\n    9 |     std::cout << \"Filtering input for prefix \" << prefix\
    \ << \" ==> \" << strings << std::endl;\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~\n      |                                                        \
    \  |             |\n      |                                                  \
    \        |             std::vector<std::__cxx11::basic_string<char> >\n      |\
    \                                                          std::basic_ostream<char>\n\
    In file included from /usr/include/c++/9/istream:39,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdczvjb25.cpp:2:\n/usr/include/c++/9/ostream:108:7:\
    \ note: candidate: \u2018std::basic_ostream<_CharT, _Traits>::__ostream_type&\
    \ std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__ostream_type&\
    \ (*)(std::basic_ostream<_CharT, _Traits>::__ostream_type&)) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type\
    \ = std::basic_ostream<char>]\u2019\n  108 |       operator<<(__ostream_type&\
    \ (*__pf)(__ostream_type&))\n      |       ^~~~~~~~\n/usr/include/c++/9/ostream:108:36:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::basic_ostream<char>::__ostream_type& (*)(std::basic_ostream<char>::__ostream_type&)\u2019\
    \ {aka \u2018std::basic_ostream<char>& (*)(std::basic_ostream<char>&)\u2019}\n\
    \  108 |       operator<<(__ostream_type& (*__pf)(__ostream_type&))\n      | \
    \                 "
  stdout: ''
  timestamp: 1660098529
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for(auto\
    \ &s : strings) {\n        if(s.substr(0, prefix.length()) == prefix) {\n    \
    \        result.push_back(s);\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098530
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  \n  //\
    \ Write your code here\n  for (size_t i = 0; i < strings.size(); ++i) {\n    if\
    \ (strings.at(i).substr(0, prefix.length()) == prefix) result.push_back(strings.at(i));\n\
    \  }\n  \n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098530
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  for (auto& string : strings)\n    if (string.substr(0, prefix.size()) == prefix)\n\
    \      strings.erase(std::remove(strings.begin(), strings.end(), string), strings.end());\n\
    \n  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpc8au3k0o: /tmp/tmpc8au3k0o.cpp:19: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098531
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::regex reg(prefix);\n    std::vector<std::string>\
    \ ret(std::begin(strings), std::end(strings));\n    std::remove_copy_if(std::begin(strings),\
    \ std::end(strings), std::back_inserter(ret), std::bind(std::regex_search, std::cref(reg),\
    \ std::placeholders::_1));\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7y6a7f2o.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp7y6a7f2o.cpp:11:156: error: no matching function for call to \u2018\
    bind(<unresolved overloaded function type>, std::reference_wrapper<const std::__cxx11::basic_regex<char>\
    \ >, const std::_Placeholder<1>&)\u2019\n   11 |     std::remove_copy_if(std::begin(strings),\
    \ std::end(strings), std::back_inserter(ret), std::bind(std::regex_search, std::cref(reg),\
    \ std::placeholders::_1));\n      |                                          \
    \                                                                            \
    \                                      ^\nIn file included from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n\
    \                 from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmp7y6a7f2o.cpp:2:\n/usr/include/c++/9/functional:808:5: note: candidate:\
    \ \u2018template<class _Func, class ... _BoundArgs> typename std::_Bind_helper<std::__is_socketlike<_Func>::value,\
    \ _Func, _BoundArgs ...>::type std::bind(_Func&&, _BoundArgs&& ...)\u2019\n  808\
    \ |     bind(_Func&& __f, _BoundArgs&&... __args)\n      |     ^~~~\n/usr/include/c++/9/functional:808:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp7y6a7f2o.cpp:11:156:\
    \ note:   couldn\u2019t deduce template parameter \u2018_Func\u2019\n   11 | \
    \    std::remove_copy_if(std::begin(strings), std::end(strings), std::back_inserter(ret),\
    \ std::bind(std::regex_search, std::cref(reg), std::placeholders::_1));\n    \
    \  |                                                                         \
    \                                                                            \
    \       ^\nIn file included from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n\
    \                 from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmp7y6a7f2o.cpp:2:\n/usr/include/c++/9/funct"
  stdout: ''
  timestamp: 1660098530
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  for (int i = 0; i <= strings.size(); ++i)\
    \ {\n    if (strings[i].length() > prefix.length()) {\n      std::cout << \"Skipping\
    \ \" << strings[i] << std::endl;\n    } else {\n      if (strings[i].compare(0,\
    \ prefix.size(), prefix) == 0) {\n        std::cout << strings[i] << std::endl;\n\
    \      }\n    }\n  }\n  return strings;\n}\nint main() {\n    auto candidate =\
    \ filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660098530
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> out;\n    for (auto&\
    \ s : strings) {\n        if (s.substr(0, prefix.length()) == prefix) {\n    \
    \        out.push_back(s);\n        }\n    }\n    return out;\n}\nint main() {\n\
    \    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098530
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<string>::iterator itr = std::begin(strings);\n\
    \    while (std::begin(strings) < std::end(strings)) {\n        if (itr == std::begin(strings)\
    \ || std::find(itr, std::end(strings), prefix) == std::end(strings))\n       \
    \     itr = std::next(itr);\n        else\n            itr = std::find_if(std::next(itr),\
    \ std::end(strings), [&prefix](std::string str) { return (str.find(prefix) ==\
    \ 0);});\n    }\n    return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6wedrj0g.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp6wedrj0g.cpp:9:17: error: \u2018string\u2019 was not declared in this\
    \ scope\n    9 |     std::vector<string>::iterator itr = std::begin(strings);\n\
    \      |                 ^~~~~~\n/tmp/tmp6wedrj0g.cpp:9:17: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/iosfwd:39,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp6wedrj0g.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33:\
    \ note:   \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n\
    \      |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6wedrj0g.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmp6wedrj0g.cpp:9:23: error: template argument 1 is invalid\n    9 |    \
    \ std::vector<string>::iterator itr = std::begin(strings);\n      |          \
    \             ^\n/tmp/tmp6wedrj0g.cpp:9:23: error: template argument 2 is invalid\n\
    /tmp/tmp6wedrj0g.cpp:9:35: error: expected initializer before \u2018itr\u2019\n\
    \    9 |     std::vector<string>::iterator itr = std::begin(strings);\n      |\
    \                 "
  stdout: ''
  timestamp: 1660098530
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto &s : strings) {\n    if (s.startsWith(prefix)) {\n      result.push_back(s);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcifcfv_y.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpcifcfv_y.cpp:11:11: error: \u2018const class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018startsWith\u2019\n   11 |     if (s.startsWith(prefix))\
    \ {\n      |           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660098530
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\n\
    \    if (strings.size() == 0) {\n        return strings;\n    }\n    std::set<std::string::size_type>\
    \ prefix_lengths;\n    prefix_lengths.insert(prefix.size());\n    prefix_lengths.insert(prefix.size()\
    \ + 1);\n    prefix_lengths.insert(prefix.size() + 2);\n    prefix_lengths.insert(prefix.size()\
    \ + 3);\n    for (auto& string : strings) {\n        if (string.size() >= prefix.size()\
    \ && string[0:prefix.size()] == prefix) {\n            if (prefix_lengths.find(string.size()\
    \ - 1) != prefix_lengths.end()) {\n                prefix_lengths.erase(string.size()\
    \ - 1);\n            } else {\n                prefix_lengths.insert(string.size()\
    \ - 1);\n            }\n        }\n    }\n    return std::move(strings);\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6s6adild.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp6s6adild.cpp:19:55: error: expected \u2018]\u2019 before \u2018:\u2019\
    \ token\n   19 |         if (string.size() >= prefix.size() && string[0:prefix.size()]\
    \ == prefix) {\n      |                                                      \
    \ ^\n      |                                                       ]\n/tmp/tmp6s6adild.cpp:19:55:\
    \ error: expected \u2018)\u2019 before \u2018:\u2019 token\n   19 |         if\
    \ (string.size() >= prefix.size() && string[0:prefix.size()] == prefix) {\n  \
    \    |            ~                                          ^\n      |      \
    \                                                 )\n/tmp/tmp6s6adild.cpp:19:69:\
    \ error: expected primary-expression before \u2018]\u2019 token\n   19 |     \
    \    if (string.size() >= prefix.size() && string[0:prefix.size()] == prefix)\
    \ {\n      |                                                                 \
    \    ^\n"
  stdout: ''
  timestamp: 1660098530
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size() >= prefix.size());\n\
    \  std::vector<std::string> res;\n  std::string prefix = prefix;\n  while (strings.size()\
    \ > 0) {\n    if (strings[0].length() >= prefix.size()) {\n      res.push_back(strings.front());\n\
    \      strings.erase(strings.begin());\n    } else {\n      break;\n    }\n  }\n\
    \  return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp21ru8f8u.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp21ru8f8u.cpp:11:15: error: declaration of \u2018std::string prefix\u2019\
    \ shadows a parameter\n   11 |   std::string prefix = prefix;\n      |       \
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660098530
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto iter = strings.begin(); iter != strings.end(); ++iter) {\n        if (iter->find(prefix)\
    \ == 0) {\n            result.push_back(iter);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3jvfl_h7.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp3jvfl_h7.cpp:12:34: error: no matching function for call to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::push_back(__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >&)\u2019\n   12 |          \
    \   result.push_back(iter);\n      |                                  ^\nIn file\
    \ included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3jvfl_h7.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018const value_type&\u2019\
    \ {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 1184 |       push_back(const\
    \ value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector"
  stdout: ''
  timestamp: 1660098530
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    // Filter the input list to only the ones\
    \ starting with the given prefix.\n    auto it = std::sregex_iterator(strings.begin(),\
    \ strings.end(), std::regex(prefix));\n    std::vector<std::string> out;\n   \
    \ // Append the elements from the input list to our output list\n    std::copy(it,\
    \ std::sregex_iterator(), std::back_inserter(out));\n    return out;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqt3n0cw2.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpqt3n0cw2.cpp:10:86: error: no matching function for call to \u2018\
    std::__cxx11::regex_iterator<__gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ > >::regex_iterator(std::vector<std::__cxx11::basic_string<char> >::iterator,\
    \ std::vector<std::__cxx11::basic_string<char> >::iterator, std::__cxx11::regex)\u2019\
    \n   10 |     auto it = std::sregex_iterator(strings.begin(), strings.end(), std::regex(prefix));\n\
    \      |                                                                     \
    \                 ^\nIn file included from /usr/include/c++/9/regex:62,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n  \
    \               from /tmp/tmpqt3n0cw2.cpp:2:\n/usr/include/c++/9/bits/regex.h:2552:7:\
    \ note: candidate: \u2018std::__cxx11::regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>::regex_iterator(const\
    \ std::__cxx11::regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>&) [with _Bi_iter\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; _Ch_type = char; _Rx_traits = std::__cxx11::regex_traits<char>]\u2019\n 2552\
    \ |       regex_iterator(const regex_iterator&) = default;\n      |       ^~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:2552:7: note:   candidate expects 1 argument,\
    \ 3 provided\n/usr/include/c++/9/bits/regex.h:2536:7: note: candidate: \u2018\
    std::__cxx11::regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>::regex_iterator(_Bi_iter,\
    \ _Bi_iter, const regex_type&, std::regex_constants::match_flag_type) [with _Bi_iter\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; _Ch_type = char; _Rx_traits = std::__cxx11::regex_traits<char>; std::__cxx11::regex_iterator<_Bi_iter,\
    \ _Ch_type, _Rx_traits>::regex_type = std::__cxx11::basic_regex<char>]\u2019\n\
    \ 2536 |       regex_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n\
    \      |       ^~~~~~~~~~~~~~\n/usr/include/c++/9/bits/regex.h:2536:3"
  stdout: ''
  timestamp: 1660098531
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> new_strings;\n  for\
    \ (auto s: strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n     \
    \ new_strings.push_back(s);\n    }\n  }\n  return new_strings;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098531
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<bool> seen(prefix.size(), false);\n\
    \    for (auto it=strings.begin(); it!=strings.end(); ++it) {\n        std::string\
    \ str = *it;\n        if (str.find(prefix) == 0) {\n            seen[str.size()]\
    \ = true;\n        }\n    }\n    std::vector<std::string> result;\n    for (auto\
    \ it=strings.begin(); it!=strings.end(); ++it) {\n        if (seen[*it]) {\n \
    \           result.push_back(*it);\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp22fdeuh2.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp22fdeuh2.cpp:18:17: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::vector<bool>\u2019 and \u2018std::__cxx11::basic_string<char>\u2019\
    )\n   18 |         if (seen[*it]) {\n      |                 ^\nIn file included\
    \ from /usr/include/c++/9/vector:68,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp22fdeuh2.cpp:2:\n/usr/include/c++/9/bits/stl_bvector.h:886:7:\
    \ note: candidate: \u2018std::vector<bool, _Alloc>::reference std::vector<bool,\
    \ _Alloc>::operator[](std::vector<bool, _Alloc>::size_type) [with _Alloc = std::allocator<bool>;\
    \ std::vector<bool, _Alloc>::reference = std::_Bit_reference; std::vector<bool,\
    \ _Alloc>::size_type = long unsigned int]\u2019\n  886 |       operator[](size_type\
    \ __n)\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/stl_bvector.h:886:28:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018std::vector<bool>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    }\n  886 |       operator[](size_type __n)\n      |                  ~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_bvector.h:893:7: note: candidate: \u2018std::vector<bool,\
    \ _Alloc>::const_reference std::vector<bool, _Alloc>::operator[](std::vector<bool,\
    \ _Alloc>::size_type) const [with _Alloc = std::allocator<bool>; std::vector<bool,\
    \ _Alloc>::const_reference = bool; std::vector<bool, _Alloc>::size_type = long\
    \ unsigned int]\u2019\n  893 |       operator[](size_type __n) const\n      |\
    \       ^~~~~~~~\n/usr/include/c++/9/bits/stl_bvector.h:893:28: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018std::vector<bool>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    }\n  893 |       operator[](s"
  stdout: ''
  timestamp: 1660098530
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> results;\n    for\
    \ (std::string s : strings) {\n        if (s.substr(0, prefix.length()) == prefix)\
    \ {\n            results.push_back(s);\n        }\n    }\n    return results;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098531
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  // Keep a vector of strings that don't start\
    \ with the given prefix.\n  std::vector<std::string> filtered;\n\n  for (const\
    \ auto& str : strings) {\n    if (str.starts_with(prefix))\n      filtered.push_back(str);\n\
    \  }\n\n  return filtered;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_q7_eune.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp_q7_eune.cpp:13:13: error: \u2018const class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018starts_with\u2019\n   13 |     if (str.starts_with(prefix))\n\
    \      |             ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660098530
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(!prefix.empty() && \"empty prefix shouldn't\
    \ be allowed\");\n  auto itBegin = strings.begin();\n  auto itEnd = strings.end();\n\
    \  for (; itBegin != itEnd; ++itBegin) {\n    if (std::strncmp(prefix.c_str(),\
    \ itBegin->c_str(), prefix.size()) == 0) {\n      it = itBegin;\n      break;\n\
    \    }\n  }\n  if (it == strings.end()) {\n    return {};\n  }\n  return std::vector<std::string>{itBegin,\
    \ it};\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcvaxer7y.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpcvaxer7y.cpp:14:7: error: \u2018it\u2019 was not declared in this scope;\
    \ did you mean \u2018int\u2019?\n   14 |       it = itBegin;\n      |       ^~\n\
    \      |       int\n/tmp/tmpcvaxer7y.cpp:18:7: error: \u2018it\u2019 was not declared\
    \ in this scope; did you mean \u2018int\u2019?\n   18 |   if (it == strings.end())\
    \ {\n      |       ^~\n      |       int\n/tmp/tmpcvaxer7y.cpp:21:44: error: \u2018\
    it\u2019 was not declared in this scope; did you mean \u2018int\u2019?\n   21\
    \ |   return std::vector<std::string>{itBegin, it};\n      |                 \
    \                           ^~\n      |                                      \
    \      int\n/tmp/tmpcvaxer7y.cpp:21:46: error: no matching function for call to\
    \ \u2018std::vector<std::__cxx11::basic_string<char> >::vector(<brace-enclosed\
    \ initializer list>)\u2019\n   21 |   return std::vector<std::string>{itBegin,\
    \ it};\n      |                                              ^\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcvaxer7y.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:650:2:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::vector<_Tp,\
    \ _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&)\u2019\
    \n  650 |  vector(_InputIterator __first, _InputIterator __last,\n      |  ^~~~~~\n\
    /usr/include/c++/9/bits/stl_vector.h:650:2: note:   template argument deduction/substitution\
    \ failed:\n/usr/include/c++/9/bits/stl_vector.h:622:7: note: candidate: \u2018\
    std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>:"
  stdout: ''
  timestamp: 1660098530
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> out(std::begin(strings),\
    \ std::end(strings));\n    std::remove_copy_if(std::begin(out), std::end(out),\
    \ [&prefix](std::string s) {\n        return s.starts_with(prefix);\n    });\n\
    \    return out;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n  \
    \  assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7xm4fbsv.cpp: In lambda function:\n/tmp/tmp7xm4fbsv.cpp:11:18:\
    \ error: \u2018std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018starts_with\u2019\n   11 |         return s.starts_with(prefix);\n\
    \      |                  ^~~~~~~~~~~\n/tmp/tmp7xm4fbsv.cpp: In function \u2018\
    std::vector<std::__cxx11::basic_string<char> > filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)\u2019:\n/tmp/tmp7xm4fbsv.cpp:12:6: error: no matching function\
    \ for call to \u2018remove_copy_if(std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator, std::vector<std::__cxx11::basic_string<char> >::iterator, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>)\u2019\n   12 |     });\n      |    \
    \  ^\nIn file included from /usr/include/c++/9/algorithm:62,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n              \
    \   from /tmp/tmp7xm4fbsv.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:703:5: note:\
    \ candidate: \u2018template<class _IIter, class _OIter, class _Predicate> _OIter\
    \ std::remove_copy_if(_IIter, _IIter, _OIter, _Predicate)\u2019\n  703 |     remove_copy_if(_InputIterator\
    \ __first, _InputIterator __last,\n      |     ^~~~~~~~~~~~~~\n/usr/include/c++/9/bits/stl_algo.h:703:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp7xm4fbsv.cpp:12:6:\
    \ note:   candidate expects 4 arguments, 3 provided\n   12 |     });\n      |\
    \      ^\nIn file included from /usr/include/c++/9/algorithm:71,\n           \
    \      from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n          \
    \       from /tmp/tmp7xm4fbsv.cpp:2:\n/usr/include/c++/9/pstl/glue_algorithm_defs.h:210:1:\
    \ note: candidate: \u2018template<class _ExecutionPolicy, class _ForwardIterator1,\
    \ class _ForwardIterator2, class _Predicate> __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,\
    \ _ForwardIterator2> std::remove_copy_if(_ExecutionPolicy&&, _ForwardIterator1,\
    \ _ForwardIterator1, _ForwardIterator2, _Predicate)\u2019\n  210 | remove_copy_if(_ExecutionPolicy&&\
    \ __exec, _ForwardIte"
  stdout: ''
  timestamp: 1660098530
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string>::iterator it;\n \
    \ it = std::find_if(strings.begin(), strings.end(), [&prefix](std::string s) {\
    \ return s.substr(0, prefix.length()) == prefix; });\n  strings.erase(it, strings.end());\n\
    \  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpw_9fdvlg: /tmp/tmpw_9fdvlg.cpp:17: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098531
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  std::copy_if(strings.begin(),\
    \ strings.end(), std::back_inserter(result),\n    [](const std::string& s) { return\
    \ s.find(prefix) == 0; });\n  return result;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpz01_hq20.cpp: In lambda function:\n/tmp/tmpz01_hq20.cpp:11:46:\
    \ error: \u2018prefix\u2019 is not captured\n   11 |     [](const std::string&\
    \ s) { return s.find(prefix) == 0; });\n      |                              \
    \                ^~~~~~\n/tmp/tmpz01_hq20.cpp:11:6: note: the lambda has no capture-default\n\
    \   11 |     [](const std::string& s) { return s.find(prefix) == 0; });\n    \
    \  |      ^\n/tmp/tmpz01_hq20.cpp:8:89: note: \u2018std::string prefix\u2019 declared\
    \ here\n    8 | std::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n      |                                    \
    \                                         ~~~~~~~~~~~~^~~~~~\nIn file included\
    \ from /usr/include/c++/9/algorithm:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz01_hq20.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:\
    \ In instantiation of \u2018_OIter std::copy_if(_IIter, _IIter, _OIter, _Predicate)\
    \ [with _IIter = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _OIter = std::back_insert_iterator<std::vector<std::__cxx11::basic_string<char>\
    \ > >; _Predicate = filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)>]\u2019:\n/tmp/tmpz01_hq20.cpp:11:61:\
    \   required from here\n/usr/include/c++/9/bits/stl_algo.h:749:12: error: could\
    \ not convert \u2018__pred.filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)>((*(const string*)(& __first.__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >::operator*())))\u2019 from\
    \ \u2018void\u2019 to \u2018bool\u2019\n  749 |  if (__pred(*__first))\n     \
    \ |      ~~~~~~^~~~~~~~~~\n      |            |\n      |            void\n"
  stdout: ''
  timestamp: 1660098530
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> ret;\n  for (auto\
    \ &s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      ret.push_back(s);\n\
    \    }\n  }\n  return ret;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098531
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string>::iterator it = std::begin(strings);\n\
    \  while (it != std::end(strings)) {\n    if (it->substr(0, prefix.length()) ==\
    \ prefix) {\n      it = std::erase(it);\n    } else {\n      ++it;\n    }\n  }\n\
    \  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpj_yurak_.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpj_yurak_.cpp:12:17: error: \u2018erase\u2019 is not a member of \u2018\
    std\u2019\n   12 |       it = std::erase(it);\n      |                 ^~~~~\n"
  stdout: ''
  timestamp: 1660098531
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\n\
    \    std::string::size_type found_pos = std::string::npos;\n    std::string prefix\
    \ = prefix;\n    for (auto const &string : strings) {\n        if (found_pos ==\
    \ std::string::npos && string.length() >= prefix.length()) {\n            found_pos\
    \ = 0;\n        }\n        if (found_pos == 0) {\n            found_pos = string.find(prefix);\n\
    \        }\n        if (found_pos != std::string::npos) {\n            strings.erase(std::remove(strings.begin(),\
    \ strings.end(), string), strings.end());\n        }\n    }\n    return strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpipzscrne.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpipzscrne.cpp:11:17: error: declaration of \u2018std::string prefix\u2019\
    \ shadows a parameter\n   11 |     std::string prefix = prefix;\n      |     \
    \            ^~~~~~\n"
  stdout: ''
  timestamp: 1660098531
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  auto iter\
    \ = strings.begin();\n  while (iter != strings.end()) {\n    if ((*iter).compare(0,\
    \ prefix.size(), prefix) == 0) {\n      result.push_back(*iter);\n    }\n    iter++;\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098531
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (std::string s : strings) {\n        if (s[0] == prefix) {\n            result.push_back(s);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpz_7ob65n.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpz_7ob65n.cpp:11:18: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   11 |         if (s[0] == prefix) {\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpz_7ob65n.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpz_7ob65n.cpp:11:21:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   11 |         if (s[0] == prefix) {\n      |     \
    \                ^~~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpz_7ob65n.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpz_7ob65n.cpp:11:21: note:   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_a"
  stdout: ''
  timestamp: 1660098531
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    if (strings.empty()) return {};\n    auto\
    \ it = std::begin(strings);\n    for (auto const & s : strings) {\n        if\
    \ (s.starts_with(prefix)) {\n            it = std::next(it, s.size());\n     \
    \   }\n    }\n    return std::vector<std::string>(it, std::end(strings));\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkgbsysh2.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpkgbsysh2.cpp:12:15: error: \u2018const class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018starts_with\u2019\n   12 |         if (s.starts_with(prefix))\
    \ {\n      |               ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660098531
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto& string : strings) {\n    if (string.substr(0, prefix.size()) == prefix)\
    \ {\n      result.push_back(string);\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098531
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    auto\
    \ it = strings.begin();\n    while (it != strings.end()) {\n        if (it->find(prefix)\
    \ == 0) {\n            result.push_back(*it);\n        }\n        ++it;\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098531
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string>::iterator it;\n \
    \ std::string prefix_str = prefix + \".\";\n  assert(prefix_str.size() <= prefix.size());\n\
    \  it = std::find_if(strings.begin(), strings.end(), [&](std::string &s) {\n \
    \   return s.compare(0, prefix_str.size(), prefix_str) == 0;\n  });\n  return\
    \ it != strings.end() ? std::vector<std::string>{it, strings.end()} : std::vector<std::string>();\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmppkojzoly: /tmp/tmppkojzoly.cpp:11: std::vector<std::__cxx11::basic_string<char>
    > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):
    Assertion `prefix_str.size() <= prefix.size()'' failed.

    '
  stdout: ''
  timestamp: 1660098531
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> out;\n  std::string\
    \ prefix_str = prefix + std::string(\"*\");\n  for (auto& str : strings) {\n \
    \   if (str.find(prefix_str) == 0) {\n      out.push_back(str);\n    }\n  }\n\
    \  return out;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmp8phoiea_: /tmp/tmp8phoiea_.cpp:21: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098531
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size() != 0);\n  assert(strings.size()\
    \ >= prefix.size());\n  std::vector<std::string> result;\n  for (int i = 0; i\
    \ < prefix.size(); i++) {\n    result.push_back(strings[i]);\n  }\n  for (int\
    \ i = 0; i < strings.size(); i++) {\n    if (strings[i].compare(0, prefix.size(),\
    \ prefix) == 0) {\n      result.push_back(strings[i]);\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpfe8kgibx: /tmp/tmpfe8kgibx.cpp:9: std::vector<std::__cxx11::basic_string<char>
    > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):
    Assertion `strings.size() != 0'' failed.

    '
  stdout: ''
  timestamp: 1660098531
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\n\
    \    std::string s = prefix;\n    strings.erase(std::remove_if(strings.begin(),\
    \ strings.end(), [&](const std::string &str) {\n        return str.size() >= s.size()\
    \ && str.substr(0, s.size) == s;\n    }), strings.end());\n    return strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp86d6zyy3.cpp: In lambda function:\n/tmp/tmp86d6zyy3.cpp:12:58:\
    \ error: invalid use of non-static member function \u2018std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size()\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n   12 |         return str.size() >= s.size() && str.substr(0, s.size)\
    \ == s;\n      |                                                        ~~^~~~\n\
    In file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp86d6zyy3.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:934:7: note:\
    \ declared here\n  934 |       size() const _GLIBCXX_NOEXCEPT\n      |       ^~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n           \
    \      from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp86d6zyy3.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_pred<_Predicate>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Predicate = filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)>]\u2019:\n/usr/include/c++/9/bits/stl_algo.h:875:13:\
    \   required from \u2018_ForwardIterator std::__remove_if("
  stdout: ''
  timestamp: 1660098531
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto& s : strings) {\n    if (s.substr(0, prefix.length()) == prefix) {\n  \
    \    result.push_back(s);\n    }\n  }\n  return result;\n}\nint main() {\n   \
    \ auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098531
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(!strings.empty());\n  auto it = std::find_if(strings.begin(),\
    \ strings.end(), [&prefix](std::string s) {\n    return s.compare(0, prefix.size(),\
    \ prefix) == 0;\n  });\n  std::vector<std::string> res;\n  if (it != strings.end())\
    \ {\n    res.push_back(*it);\n  }\n  return res;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpdobigw32: /tmp/tmpdobigw32.cpp:9: std::vector<std::__cxx11::basic_string<char>
    > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):
    Assertion `!strings.empty()'' failed.

    '
  stdout: ''
  timestamp: 1660098531
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto& s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n    \
    \  result.push_back(s);\n    }\n  }\n  return result;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098531
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::ostringstream oss;\n    oss << prefix;\n\
    \    std::string prefix = oss.str();\n\n    for (std::string s : strings) {\n\
    \        if (s.substr(0, prefix.length()) == prefix) {\n            strings.erase(strings.begin());\n\
    \            break;\n        }\n    }\n    return strings;\n}\nint main() {\n\
    \    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpncqt3ie2.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpncqt3ie2.cpp:11:17: error: declaration of \u2018std::string prefix\u2019\
    \ shadows a parameter\n   11 |     std::string prefix = oss.str();\n      |  \
    \               ^~~~~~\n"
  stdout: ''
  timestamp: 1660098531
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto\
    \ &string : strings) {\n    if (string.substr(0, prefix.size()) == prefix) {\n\
    \      result.emplace_back(string);\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098531
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    for (std::string word : strings) {\n   \
    \     if (word.substr(0, prefix.size()) == prefix) {\n            strings.erase(strings.begin()\
    \ + string::npos);\n        }\n    }\n    return strings;\n}\nint main() {\n \
    \   auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpe9m22yvk.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpe9m22yvk.cpp:11:45: error: \u2018string\u2019 has not been declared\n\
    \   11 |             strings.erase(strings.begin() + string::npos);\n      | \
    \                                            ^~~~~~\n"
  stdout: ''
  timestamp: 1660098531
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::function<bool(std::string)> predicate\
    \ = [](std::string s) { return s.substr(0, prefix.length()) == prefix; };\n  \
    \  return std::remove_if(strings.begin(), strings.end(), predicate);\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsd8lng6n.cpp: In lambda function:\n/tmp/tmpsd8lng6n.cpp:9:89: error:\
    \ \u2018prefix\u2019 is not captured\n    9 |     std::function<bool(std::string)>\
    \ predicate = [](std::string s) { return s.substr(0, prefix.length()) == prefix;\
    \ };\n      |                                                                \
    \                         ^~~~~~\n/tmp/tmpsd8lng6n.cpp:9:51: note: the lambda\
    \ has no capture-default\n    9 |     std::function<bool(std::string)> predicate\
    \ = [](std::string s) { return s.substr(0, prefix.length()) == prefix; };\n  \
    \    |                                                   ^\n/tmp/tmpsd8lng6n.cpp:8:89:\
    \ note: \u2018std::string prefix\u2019 declared here\n    8 | std::vector<std::string>\
    \ filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n \
    \     |                                                                      \
    \       ~~~~~~~~~~~~^~~~~~\n/tmp/tmpsd8lng6n.cpp:9:109: error: \u2018prefix\u2019\
    \ is not captured\n    9 |     std::function<bool(std::string)> predicate = [](std::string\
    \ s) { return s.substr(0, prefix.length()) == prefix; };\n      |            \
    \                                                                            \
    \                     ^~~~~~\n/tmp/tmpsd8lng6n.cpp:9:51: note: the lambda has\
    \ no capture-default\n    9 |     std::function<bool(std::string)> predicate =\
    \ [](std::string s) { return s.substr(0, prefix.length()) == prefix; };\n    \
    \  |                                                   ^\n/tmp/tmpsd8lng6n.cpp:8:89:\
    \ note: \u2018std::string prefix\u2019 declared here\n    8 | std::vector<std::string>\
    \ filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n \
    \     |                                                                      \
    \       ~~~~~~~~~~~~^~~~~~\n/tmp/tmpsd8lng6n.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpsd8lng6n.cpp:9:117: error: conversion from \u2018filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>\u2019 to no"
  stdout: ''
  timestamp: 1660098531
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto &str : strings) {\n    if (str.starts_with(prefix)) {\n      result.push_back(str);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwcyp3jxo.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpwcyp3jxo.cpp:11:13: error: \u2018const class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018starts_with\u2019\n   11 |     if (str.starts_with(prefix))\
    \ {\n      |             ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660098531
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto\
    \ &string : strings) {\n    if (string.substr(0, prefix.size()) == prefix) {\n\
    \      result.push_back(std::move(string));\n    }\n  }\n  return result;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098531
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (std::string\
    \ s : strings) {\n    if (0 == s.find(prefix)) {\n      result.push_back(s);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098531
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  if (strings.size() < 2)\n    return strings;\n  auto prefix_index = std::find_if(strings.begin(),\
    \ strings.end(), [&](const string& s) {\n    return s.compare(0, prefix.size(),\
    \ prefix) == 0;\n  });\n  std::vector<std::string> result;\n  auto it = prefix_index;\n\
    \  while (it != strings.end()) {\n    result.emplace_back(*it);\n    it = std::find_if(++it,\
    \ strings.end(), [&](const string& s) {\n      return s.compare(0, prefix.size(),\
    \ prefix) == 0;\n    });\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk70npf_4.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpk70npf_4.cpp:12:78: error: \u2018string\u2019 does not name a type;\
    \ did you mean \u2018strings\u2019?\n   12 |   auto prefix_index = std::find_if(strings.begin(),\
    \ strings.end(), [&](const string& s) {\n      |                             \
    \                                                 ^~~~~~\n      |            \
    \                                                                  strings\n/tmp/tmpk70npf_4.cpp:\
    \ In lambda function:\n/tmp/tmpk70npf_4.cpp:14:5: error: expected \u2018{\u2019\
    \ before \u2018;\u2019 token\n   14 |   });\n      |     ^\n/tmp/tmpk70npf_4.cpp:\
    \ In function \u2018std::vector<std::__cxx11::basic_string<char> > filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)\u2019:\n/tmp/tmpk70npf_4.cpp:14:5: error: expected \u2018)\u2019\
    \ before \u2018;\u2019 token\n   14 |   });\n      |     ^\n      |     )\n/tmp/tmpk70npf_4.cpp:12:35:\
    \ note: to match this \u2018(\u2019\n   12 |   auto prefix_index = std::find_if(strings.begin(),\
    \ strings.end(), [&](const string& s) {\n      |                             \
    \      ^\n/tmp/tmpk70npf_4.cpp:19:54: error: \u2018string\u2019 does not name\
    \ a type; did you mean \u2018strings\u2019?\n   19 |     it = std::find_if(++it,\
    \ strings.end(), [&](const string& s) {\n      |                             \
    \                         ^~~~~~\n      |                                    \
    \                  strings\n/tmp/tmpk70npf_4.cpp: In lambda function:\n/tmp/tmpk70npf_4.cpp:21:7:\
    \ error: expected \u2018{\u2019 before \u2018;\u2019 token\n   21 |     });\n\
    \      |       ^\n/tmp/tmpk70npf_4.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpk70npf_4.cpp:21:7: error: expected \u2018)\u2019 before \u2018;\u2019\
    \ token\n   21 |     });\n      |       ^\n      |       )\n/tmp/tmpk70npf_4.cpp:19:22:\
    \ note: to match this \u2018(\u2019\n   19 |     it = std::find_if(++it, strings.end(),\
    \ [&](const string& s) {\n      |   "
  stdout: ''
  timestamp: 1660098531
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  // Initialize output list.\n  std::vector<std::string>\
    \ output;\n  // Scan through strings and copy only the ones starting with the\
    \ given prefix.\n  for (const auto& s : strings) {\n    if (s.find(prefix) ==\
    \ 0) {\n      output.push_back(s);\n    }\n  }\n  // Return result.\n  return\
    \ output;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098532
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size() > 0);\n  assert(strings[0].size()\
    \ > 0);\n  std::size_t prefix_len = prefix.size();\n  std::vector<std::string>\
    \ output_strings;\n  for (auto & s : strings) {\n    if (s.substr(0, prefix_len)\
    \ == prefix) {\n      output_strings.push_back(s);\n    }\n  }\n  return output_strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpp04magns: /tmp/tmpp04magns.cpp:9: std::vector<std::__cxx11::basic_string<char>
    > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):
    Assertion `strings.size() > 0'' failed.

    '
  stdout: ''
  timestamp: 1660098532
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::string prefix_copy = prefix + strings[0];\n\
    \  std::for_each(strings.begin(), strings.end(), [&](std::string string) {\n \
    \   std::string copy = prefix_copy + string;\n    if (copy.substr(0, prefix_copy.size())\
    \ == prefix_copy)\n      strings.erase(strings.begin() + strings.begin() + 1);\n\
    \  });\n  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4d1u8ry3.cpp: In lambda function:\n/tmp/tmp4d1u8ry3.cpp:13:37:\
    \ error: no match for \u2018operator+\u2019 (operand types are \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019} and \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019})\n   13 |       strings.erase(strings.begin()\
    \ + strings.begin() + 1);\n      |                     ~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~\n\
    \      |                                  |                 |\n      |       \
    \                           |                 __normal_iterator<[...],[...]>\n\
    \      |                                  __normal_iterator<[...],[...]>\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp4d1u8ry3.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:856:7:\
    \ note: candidate: \u2018__gnu_cxx::__normal_iterator<_Iterator, _Container> __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>::operator+(__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type)\
    \ const [with _Iterator = std::__cxx11::basic_string<char>*; _Container = std::vector<std::__cxx11::basic_string<char>\
    \ >; __gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type = long\
    \ int]\u2019\n  856 |       operator+(difference_type __n) const _GLIBCXX_NOEXCEPT\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:856:33: note:\
    \   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019} to \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_stri"
  stdout: ''
  timestamp: 1660098532
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> results;\n    for\
    \ (std::string s : strings) {\n        if (s.substr(0, prefix.size()) == prefix)\
    \ {\n            results.push_back(s);\n        }\n    }\n    return results;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098532
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\n\
    \    auto begin = std::find_if(strings.begin(), strings.end(), [&](const auto&\
    \ s) { return s.substr(0, prefix.size()) == prefix; });\n    std::vector<std::string>\
    \ result;\n    std::copy(begin, strings.end(), std::back_inserter(result));\n\
    \    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmp5hmmvwdu: /tmp/tmp5hmmvwdu.cpp:18: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098532
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto it = std::begin(strings);\n    auto\
    \ last = std::end(strings);\n    while (it != last) {\n        if (it->substr(0,\
    \ prefix.size()) == prefix) {\n            ++it;\n        } else {\n         \
    \   strings.erase(it++);\n        }\n    }\n    return strings;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmperjr_qzc: /tmp/tmperjr_qzc.cpp:23: int main(): Assertion `candidate((std::vector<std::string>({"xxx",
    "asd", "xxy", "john doe", "xxxAAA", "xxx"})), ("xxx")) == (std::vector<std::string>({"xxx",
    "xxxAAA", "xxx"}))'' failed.

    '
  stdout: ''
  timestamp: 1660098532
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto it = std::begin(strings);\n    while\
    \ (it != std::end(strings)) {\n        if (std::begin(*it) == prefix) {\n    \
    \        it = std::next(it);\n        } else {\n            ++it;\n        }\n\
    \    }\n    return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmps8ba5o5z.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmps8ba5o5z.cpp:11:29: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018\
    __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >\u2019}\
    \ and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   11 |         if (std::begin(*it) == prefix) {\n      |             ~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~\n      |                       |        |\n      |               \
    \        |        std::string {aka std::__cxx11::basic_string<char>}\n      |\
    \                       std::__cxx11::basic_string<char>::iterator {aka __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >}\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmps8ba5o5z.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmps8ba5o5z.cpp:11:32:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   11 |         if (std::begin(*it) == prefix) {\n      |                  \
    \              ^~~~~~\nIn file included from /usr/include/c++/9/regex:62,\n  \
    \               from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmps8ba5o5z.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::o"
  stdout: ''
  timestamp: 1660098532
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    assert(strings.size() >= prefix.size());\n\
    \    std::vector<std::string> result;\n    for (size_t i = 0; i < (size_t)(prefix.size());\
    \ ++i) {\n        if (strings[i].compare(0, prefix.size(), prefix) == 0) {\n \
    \           result.push_back(strings[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpd1ae9yec: /tmp/tmpd1ae9yec.cpp:9: std::vector<std::__cxx11::basic_string<char>
    > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):
    Assertion `strings.size() >= prefix.size()'' failed.

    '
  stdout: ''
  timestamp: 1660098532
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> out;\n    for (std::string\
    \ s : strings) {\n        if (s.compare(0, prefix.size(), prefix) == 0) {\n  \
    \          out.push_back(s);\n        }\n    }\n    return out;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098532
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto it = std::begin(strings);\n  while (it\
    \ != std::end(strings)) {\n    if (it->substr(0, prefix.size()) == prefix) {\n\
    \      it = std::erase(it);\n    } else {\n      ++it;\n    }\n  }\n  return strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkmshns79.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpkmshns79.cpp:12:17: error: \u2018erase\u2019 is not a member of \u2018\
    std\u2019\n   12 |       it = std::erase(it);\n      |                 ^~~~~\n"
  stdout: ''
  timestamp: 1660098532
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size() != 0);\n  assert(strings.size()\
    \ >= prefix.size());\n\n  std::string prefix_copy(prefix);\n  std::replace(prefix_copy.begin(),\
    \ prefix_copy.end(), '*', '?');\n\n  std::sort(strings.begin(), strings.end());\n\
    \n  std::string prefix_str(prefix_copy);\n\n  // Effective size of the prefix\
    \ after filtering is calculated.\n  std::size_t prefix_size = prefix_str.size();\n\
    \n  // Filter out those strings that do not start with the given prefix.\n  std::string\
    \ all_strings(std::accumulate(strings.begin(), strings.end(), std::string(), [](std::string\
    \ result, std::string const& s) {\n    return s + result;\n  }));\n  std::vector<std::string>\
    \ filtered_strings;\n\n  auto prefix_itr = std::search(all_strings.begin(), all_strings.end(),\
    \ prefix_str.begin(), prefix_str.end());\n  if (prefix_itr == all_strings.end())\
    \ {\n    filtered_strings.push_back(*strings.begin());\n  } else {\n    std::string\
    \ sub_strings(all_strings);\n    sub_strings.erase(prefix_itr, all_strings.end());\n\
    \    filtered_strings.push_back(std::string(sub_strings));\n  }\n  return filtered_strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: Exception
  stderr: 'tmpkb8u9ukq: /tmp/tmpkb8u9ukq.cpp:9: std::vector<std::__cxx11::basic_string<char>
    > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):
    Assertion `strings.size() != 0'' failed.

    '
  stdout: ''
  timestamp: 1660098532
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n\
    \            result.push_back(s);\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660098532
