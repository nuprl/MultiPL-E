name: HumanEval_29_filter_by_prefix
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  return std::remove_if(strings.begin(), strings.end(),\
    \ [&](std::string item) -> bool {\n    return item.starts_with(prefix);\n  });\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4xgtv8wd.cpp: In lambda function:\n/tmp/tmp4xgtv8wd.cpp:10:17:\
    \ error: \u2018std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018starts_with\u2019\n   10 |     return item.starts_with(prefix);\n\
    \      |                 ^~~~~~~~~~~\n/tmp/tmp4xgtv8wd.cpp: In function \u2018\
    std::vector<std::__cxx11::basic_string<char> > filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)\u2019:\n/tmp/tmp4xgtv8wd.cpp:9:24: error: could not convert\
    \ \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), <lambda\
    \ closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>{prefix})\u2019 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n    9 |   return std::remove_if(strings.begin(), strings.end(), [&](std::string\
    \ item) -> bool {\n      |          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                        |\n      |                        __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\n   10 |     return item.starts_with(prefix);\n\
    \      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   11 |   });\n      |   ~~   \
    \                 \n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    size_t\
    \ prefix_len = prefix.length();\n    for (auto &str : strings) {\n        if (str.size()\
    \ >= prefix_len) {\n            if (str.substr(0, prefix_len) == prefix) {\n \
    \               result.push_back(str);\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> filtered_strings;\n\
    \    for (std::string s : strings)\n        if (s.substr(0, prefix.size()) ==\
    \ prefix)\n            filtered_strings.push_back(s);\n    return filtered_strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  // Sort the strings by their first letter\
    \ and find the prefix.\n  std::sort(strings.begin(), strings.end(), [](const std::string\
    \ & s, const std::string & p) {\n    return s.front() < p.front();\n  });\n  auto\
    \ prefix_pos = std::find(strings.begin(), strings.end(), prefix);\n  // If prefix\
    \ not found.\n  if (prefix_pos == strings.end())\n    return strings;\n  // If\
    \ prefix is found, remove all the strings not starting with the prefix letter\n\
    \  strings.erase(std::remove_if(strings.begin(), strings.end(),\n            \
    \                   [&](const std::string & s) {\n    return !s.front() == prefix.front();\n\
    \  }), strings.end());\n  return strings;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmphby3e321: /tmp/tmphby3e321.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto it = std::begin(strings);\n  std::string\
    \ prefix_str(prefix.begin(), prefix.end());\n  while (it != std::end(strings))\
    \ {\n    std::string str = *it;\n    if (str.find(prefix_str) == 0)\n      it\
    \ = std::erase(it);\n    else\n      ++it;\n  }\n  return strings;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9n4_74aq.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp9n4_74aq.cpp:14:17: error: \u2018erase\u2019 is not a member of \u2018\
    std\u2019\n   14 |       it = std::erase(it);\n      |                 ^~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (size_t i = 0; i < strings.size(); i++) {\n        if (strings[i].startsWith(prefix))\
    \ {\n            result.push_back(strings[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5kdz64_6.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp5kdz64_6.cpp:11:24: error: \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018startsWith\u2019\n   11 |         if (strings[i].startsWith(prefix))\
    \ {\n      |                        ^~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  std::for_each(strings.begin(),\
    \ strings.end(), [&](std::string s) {\n    if (s.substr(0, prefix.size()) == prefix)\
    \ {\n      result.push_back(s);\n    }\n  });\n  return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  // TODO : use std::regex instead of string\
    \ manipulation on prefix\n  return std::remove_if(strings.begin(), strings.end(),\
    \ [&](std::string s) {\n    return s.substr(0, prefix.size()) == prefix;\n  });\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpo1hm98bv.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpo1hm98bv.cpp:10:24: error: could not convert \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), <lambda\
    \ closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>{prefix})\u2019 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n   10 |   return std::remove_if(strings.begin(), strings.end(), [&](std::string\
    \ s) {\n      |          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                        |\n      |                        __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\n   11 |     return s.substr(0,\
    \ prefix.size()) == prefix;\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \   12 |   });\n      |   ~~                    \n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  return std::remove_if(strings.begin(), strings.end(),\n\
    \      [&prefix](std::string s) { return s.substr(0, prefix.length()) == prefix;\
    \ });\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpigchro6t.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpigchro6t.cpp:9:24: error: could not convert \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), <lambda\
    \ closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>{prefix})\u2019 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n    9 |   return std::remove_if(strings.begin(), strings.end(),\n \
    \     |          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |     \
    \                   |\n      |                        __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\n   10 |       [&prefix](std::string\
    \ s) { return s.substr(0, prefix.length()) == prefix; });\n      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::set<std::string> stringSet;\n  for (std::string\
    \ s: strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      stringSet.insert(s);\n\
    \    }\n  }\n  return stringSet.empty() ? strings : stringSet.begin(), stringSet.end();\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpug_vxmpl.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpug_vxmpl.cpp:15:28: error: operands to ?: have different types \u2018\
    std::vector<std::__cxx11::basic_string<char> >\u2019 and \u2018std::set<std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018std::_Rb_tree_const_iterator<std::__cxx11::basic_string<char>\
    \ >\u2019}\n   15 |   return stringSet.empty() ? strings : stringSet.begin(),\
    \ stringSet.end();\n      |          ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    res.reserve(strings.size());\n\
    \    for (auto& str : strings) {\n        if (str.substr(0, prefix.size()) ==\
    \ prefix) {\n            res.push_back(str);\n        }\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    if (strings.empty()) return std::vector<std::string>();\n\
    \    bool match = false;\n    for (auto str : strings) {\n        if (str.compare(0,\
    \ prefix.size(), prefix) == 0) {\n            match = true;\n        } else {\n\
    \            match = false;\n            break;\n        }\n    }\n    if (match)\
    \ return strings;\n    else return std::vector<std::string>();\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpb_2d1grh: /tmp/tmpb_2d1grh.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  return std::remove_if(strings.begin(), strings.end(),\n\
    \                        [&prefix](std::string s) { return s.starts_with(prefix);\
    \ });\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5seshzqo.cpp: In lambda function:\n/tmp/tmp5seshzqo.cpp:10:61:\
    \ error: \u2018std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018starts_with\u2019\n   10 |                       \
    \  [&prefix](std::string s) { return s.starts_with(prefix); });\n      |     \
    \                                                        ^~~~~~~~~~~\n/tmp/tmp5seshzqo.cpp:\
    \ In function \u2018std::vector<std::__cxx11::basic_string<char> > filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)\u2019:\n/tmp/tmp5seshzqo.cpp:9:24: error: could not convert\
    \ \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), <lambda\
    \ closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>{prefix})\u2019 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n    9 |   return std::remove_if(strings.begin(), strings.end(),\n \
    \     |          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |     \
    \                   |\n      |                        __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\n   10 |                  \
    \       [&prefix](std::string s) { return s.starts_with(prefix); });\n      |\
    \                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:71,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\
    \ // sort to ensure prefix is not an empty string.\n  if (prefix.empty()) return\
    \ strings;\n  auto prefix_pos = strings.begin();\n  while (prefix_pos != strings.end()\
    \ && prefix_pos->find(prefix) == 0) {\n    ++prefix_pos;\n  }\n  auto new_strings\
    \ = std::vector<std::string>(strings);\n  std::for_each(prefix_pos, new_strings.end(),\
    \ [](std::string* string) { delete string; });\n  return new_strings;\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgvvnbeyo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:\
    \ In instantiation of \u2018_Funct std::for_each(_IIter, _IIter, _Funct) [with\
    \ _IIter = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >; _Funct = filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string*)>]\u2019:\n/tmp/tmpgvvnbeyo.cpp:16:90:\
    \   required from here\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3876:5:\
    \ error: no match for call to \u2018(filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string*)>) (std::__cxx11::basic_string<char>&)\u2019\
    \n 3876 |  __f(*__first);\n      |  ~~~^~~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3876:5:\
    \ note: candidate: \u2018void (*)(std::string*)\u2019 {aka \u2018void (*)(std::__cxx11::basic_string<char>*)\u2019\
    } <conversion>\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3876:5:\
    \ note:   candidate expects 2 arguments, 2 provided\n/tmp/tmpgvvnbeyo.cpp:16:48:\
    \ note: candidate: \u2018filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string*)>\u2019\n   16 |   std::for_each(prefix_pos,\
    \ new_strings.end(), [](std::string* string) { delete string; });\n      |   \
    \                                             ^\n/tmp/tmpgvvnbeyo.cpp:16:48: note:\
    \   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018std::string*\u2019 {aka \u2018std::__cxx11::basic_string<char>*\u2019\
    }\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::cout << \"filter_by_prefix strings: \"\
    \ << strings.size() << \"  prefix: \" << prefix.size() << std::endl;\n  std::string\
    \ pre = prefix.substr(0, prefix.size() - 1);\n  std::cout << \"pre: \" << pre\
    \ << std::endl;\n  std::vector<std::string> retVec;\n  for (int i = 0; i < strings.size();\
    \ i++) {\n    if (strings[i].substr(0, prefix.length()) == pre) {\n      retVec.push_back(strings[i]);\n\
    \    }\n  }\n  return retVec;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: "filter_by_prefix strings: 0  prefix: 4\npre: joh\nfilter_by_prefix strings:\
    \ 6  prefix: 3\npre: xx\n"
  stderr: "tmpqi_gvkn8: /tmp/tmpqi_gvkn8.cpp:23: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::cout << \"Strings passed: \" << strings\
    \ << \"\\n\";\n    std::cout << \"Prefix passed: \" << prefix << \"\\n\";\n  \
    \  \n    std::vector<std::string> new_strings;\n    \n    std::cout << \"Starting\
    \ loop through list \" << endl;\n    \n    for (int i = 0; i < strings.size();\
    \ i++) {\n        std::cout << \"Checking string \" << i << endl;\n        \n\
    \        if (strings[i].size() >= prefix.size() && strings[i].substr(0, prefix.length())\
    \ == prefix) {\n            new_strings.push_back(strings[i]);\n        }\n  \
    \  }\n    std::cout << \"End loop through list \" << endl;\n    \n    std::cout\
    \ << \"Returning new list of strings: \" << new_strings << \"\\n\";\n    \n  \
    \  return new_strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpo7x1v21s.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpo7x1v21s.cpp:9:37: error: no match for \u2018operator<<\u2019 (operand\
    \ types are \u2018std::basic_ostream<char>\u2019 and \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019)\n    9 |     std::cout << \"Strings passed: \" << strings << \"\\n\"\
    ;\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~ ~~~~~~~\n      |           \
    \    |                        |\n      |               std::basic_ostream<char>\
    \ std::vector<std::__cxx11::basic_string<char> >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpo7x1v21s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ostream:108:7:\
    \ note: candidate: \u2018std::basic_ostream<_CharT, _Traits>::__ostream_type&\
    \ std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__ostream_type&\
    \ (*)(std::basic_ostream<_CharT, _Traits>::__ostream_type&)) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type\
    \ = std::basic_ostream<char>]\u2019\n  108 |       operator<<(__ostream_type&\
    \ (*__pf)(__ostream_type&))\n      |       ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ostream:108:36:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::basic_ostream<char>::__ostream_type& (*)(std::basic_ostream<char>::__ostream_type&)\u2019\
    \ {aka \u2018std::basic_ostream<char>& (*)(std::basic_ostream<char>&)\u2019}\n\
    \  108 |       operator<<(__ostream_type& (*__pf)(__ostream_type&))\n      | \
    \                 ~~~~~~~~~~~~~~~~~~^~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  strings.erase(std::remove_if(strings.begin(), strings.end(), [&](std::string\
    \ s) { return s.front() != prefix; }), strings.end());\n  return strings;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuke1i207.cpp: In lambda function:\n/tmp/tmpuke1i207.cpp:10:102:\
    \ error: no match for \u2018operator!=\u2019 (operand types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} and \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019})\n   10 |   strings.erase(std::remove_if(strings.begin(),\
    \ strings.end(), [&](std::string s) { return s.front() != prefix; }), strings.end());\n\
    \      |                                                                     \
    \                       ~~~~~~~~~ ^~ ~~~~~~\n      |                         \
    \                                                                          | \
    \    |\n      |                                                              \
    \                                     |     std::string {aka std::__cxx11::basic_string<char>}\n\
    \      |                                                                     \
    \                              __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type {aka char}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpuke1i207.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1037:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1037 |     operator!=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1037:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpuke1i207.cpp:10:105:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   10 |   strings.erase(std::remove_if(strings.begin(),\
    \ strings.end(), [&](std::string s) { return s.front() != prefix; }), strings.end());\n\
    \      |                           "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> filtered(strings.size());\n\
    \  for (size_t i = 0; i < strings.size(); ++i) {\n    if (strings[i].substr(0,\
    \ prefix.size()) == prefix) {\n      filtered[i] = strings[i];\n    }\n  }\n \
    \ return filtered;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpcgu_nset: /tmp/tmpcgu_nset.cpp:20: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> filtered;\n   \
    \ std::for_each(strings.begin(), strings.end(), [&filtered, &prefix](std::string&\
    \ str) {\n        std::size_t found = str.find(prefix);\n        if (found !=\
    \ std::string_view::npos)\n            filtered.push_back(str);\n    });\n   \
    \ return filtered;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbik783pe.cpp: In lambda function:\n/tmp/tmpbik783pe.cpp:12:27:\
    \ error: \u2018std::string_view\u2019 has not been declared\n   12 |         if\
    \ (found != std::string_view::npos)\n      |                           ^~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> ret;\n  for (auto\
    \ s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      ret.push_back(s);\n\
    \    }\n  }\n  return ret;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for(auto\
    \ &string : strings)\n    if (string.substr(0, prefix.size()) == prefix)\n   \
    \   result.emplace_back(string);\n  return result;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto prefix_iter = std::sfind_if(strings.begin(),\
    \ strings.end(),\n        [&](std::string x){ return x.substr(0, prefix.size())\
    \ == prefix; });\n    if (prefix_iter == strings.end())\n        return {};\n\
    \    strings.erase(prefix_iter, strings.end());\n    return strings;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5enwoc2c.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp5enwoc2c.cpp:9:29: error: \u2018sfind_if\u2019 is not a member of \u2018\
    std\u2019; did you mean \u2018find_if\u2019?\n    9 |     auto prefix_iter = std::sfind_if(strings.begin(),\
    \ strings.end(),\n      |                             ^~~~~~~~\n      |      \
    \                       find_if\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size());\n  prefix = prefix.front();\n\
    \  std::sort(strings.begin(), strings.end());\n  strings.erase(std::remove_if(strings.begin(),\
    \ strings.end(),\n                             [&](std::string str) {\n      \
    \                         return !str.starts_with(prefix);\n                 \
    \            }),\n               strings.end());\n  return strings;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4p1yz7_a.cpp: In lambda function:\n/tmp/tmp4p1yz7_a.cpp:14:44:\
    \ error: \u2018std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018starts_with\u2019\n   14 |                       \
    \         return !str.starts_with(prefix);\n      |                          \
    \                  ^~~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:71,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp4p1yz7_a.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_pred<_Predicate>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Predicate = filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:869:13:\
    \   required from \u2018_ForwardIterator std::__remove_if(_ForwardIterator, _ForwardIterator,\
    \ _Predicate) [with _ForwardIterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Predicate = __gnu_cxx::__ops::_Iter_pred<filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)> >]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:939:30:\
    \   required"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto prefix_begin = prefix.begin();\n  auto\
    \ prefix_end = prefix.end();\n  std::sort(strings.begin(), strings.end());\n \
    \ std::set_difference(strings.begin(), strings.end(), strings.begin(), prefix_begin,\
    \ [prefix_end](std::string a, std::string b) {\n    return a.size() > prefix_end.size()\
    \ ? a < b : prefix_end < b;\n  });\n  return strings;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppaysuwvz.cpp: In lambda function:\n/tmp/tmppaysuwvz.cpp:13:34:\
    \ error: \u2018const class __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019 has no member named \u2018size\u2019\n   13 |     return a.size() >\
    \ prefix_end.size() ? a < b : prefix_end < b;\n      |                       \
    \           ^~~~\n/tmp/tmppaysuwvz.cpp:13:62: error: no match for \u2018operator<\u2019\
    \ (operand types are \u2018const __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   13 |     return a.size() > prefix_end.size() ? a < b : prefix_end < b;\n\
    \      |                                                   ~~~~~~~~~~ ^ ~\n  \
    \    |                                                   |            |\n    \
    \  |                                                   |            std::string\
    \ {aka std::__cxx11::basic_string<char>}\n      |                            \
    \                       const __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmppaysuwvz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1048:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1048 |     operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1048:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmppaysuwvz.cpp:13:64:\
    \ note:   \u2018const __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019 is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   13 |     return a.size() > prefix_end.size() ? a < b : prefix_end < b;\n\
    \      |                                                                ^\nIn\
    \ file incl"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> out;\n  std::copy_if(strings.begin(),\
    \ strings.end(), std::back_inserter(out),\n               [&](std::string &s)\
    \ { return s.compare(0, prefix.size(), prefix) == 0; });\n  return out;\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  // Iterate through the input and copy strings\
    \ to the output if they start with the\n  // prefix.\n  for (auto& string : strings)\
    \ {\n    if (string.substr(0, prefix.length()) == prefix) {\n      strings.push_back(string);\n\
    \    }\n  }\n  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmp5wzdtz4n: /tmp/tmp5wzdtz4n.cpp:21: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto it = std::begin(strings);\n    for(;\
    \ it != std::end(strings); ++it) {\n        std::string s = *it;\n        if(s.find(prefix)\
    \ == 0) {\n            strings.erase(it);\n            strings.push_back(s);\n\
    \        }\n    }\n    return strings;\n}\nint main() {\n    auto candidate =\
    \ filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpvh7i3scu: /tmp/tmpvh7i3scu.cpp:22: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size() != 0);\n  if (strings.empty())\n\
    \    return strings;\n  auto it = std::find(strings.begin(), strings.end(), prefix);\n\
    \  if (it == strings.end())\n    return strings;\n  strings.erase(it);\n  return\
    \ strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmp6xypxsu2: /tmp/tmp6xypxsu2.cpp:9: std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):\
    \ Assertion `strings.size() != 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for(auto\
    \ &str : strings) {\n    if(str.substr(0, prefix.size()) == prefix) {\n      result.push_back(str);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<string> output;\n    for (auto\
    \ &s : strings) {\n        if (s.find(prefix) == 0) {\n            output.push_back(s);\n\
    \        }\n    }\n    return output;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcs4p5r8t.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpcs4p5r8t.cpp:9:17: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n    9 |     std::vector<string>\
    \ output;\n      |                 ^~~~~~\n      |                 std::string\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpcs4p5r8t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpcs4p5r8t.cpp:9:23:\
    \ error: template argument 1 is invalid\n    9 |     std::vector<string> output;\n\
    \      |                       ^\n/tmp/tmpcs4p5r8t.cpp:9:23: error: template argument\
    \ 2 is invalid\n/tmp/tmpcs4p5r8t.cpp:12:20: error: request for member \u2018push_back\u2019\
    \ in \u2018output\u2019, which is of non-class type \u2018int\u2019\n   12 | \
    \            output.push_back(s);\n      |                    ^~~~~~~~~\n/tmp/tmpcs4p5r8t.cpp:15:12:\
    \ error: could not convert \u2018output\u2019 from \u2018int\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n   15 |     return output;\n      |            ^~~~~~\n      |    \
    \        |\n      |            int\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    //\
    \ Loop over the input strings backwards to find the first one starting with prefix.\n\
    \    for (std::size_t i = 0; i < (std::size_t) strings.size(); ++i) {\n      \
    \  if (strings[i].compare(0, prefix.size(), prefix) == 0) {\n            result.push_back(strings[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> new_list;\n  for\
    \ (std::string elem : strings)\n    if (elem.startswith(prefix))\n      new_list.push_back(elem);\n\
    \  return new_list;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjm4ukjax.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpjm4ukjax.cpp:11:14: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018startswith\u2019\
    \n   11 |     if (elem.startswith(prefix))\n      |              ^~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::string prefix_copy = prefix;\n    prefix_copy.insert(prefix_copy.begin(),\
    \ prefix.size());\n    std::vector<std::string> results;\n\n    for (std::string\
    \ &s : strings) {\n        if (prefix_copy == s) {\n            results.push_back(s);\n\
    \        }\n    }\n\n    return results;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpokas1zxj: /tmp/tmpokas1zxj.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto &string : strings) {\n    if (string.substr(0, prefix.size()) == prefix)\
    \ {\n      result.emplace_back(string);\n    }\n  }\n  return result;\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  auto prefix = prefix.begin();\n  auto end = strings.end();\n  std::set<std::string>\
    \ res;\n  while (prefix != end) {\n    if (prefix.compare(0, prefix.length(),\
    \ *prefix) == 0) {\n      res.insert(strings.begin(), strings.end());\n    }\n\
    \    ++prefix;\n  }\n  return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6q25exi9.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp6q25exi9.cpp:10:8: error: declaration of \u2018auto prefix\u2019 shadows\
    \ a parameter\n   10 |   auto prefix = prefix.begin();\n      |        ^~~~~~\n\
    /tmp/tmp6q25exi9.cpp:10:17: error: use of \u2018prefix\u2019 before deduction\
    \ of \u2018auto\u2019\n   10 |   auto prefix = prefix.begin();\n      |      \
    \           ^~~~~~\n/tmp/tmp6q25exi9.cpp:19:10: error: could not convert \u2018\
    res\u2019 from \u2018std::set<std::__cxx11::basic_string<char> >\u2019 to \u2018\
    std::vector<std::__cxx11::basic_string<char> >\u2019\n   19 |   return res;\n\
    \      |          ^~~\n      |          |\n      |          std::set<std::__cxx11::basic_string<char>\
    \ >\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size() > 0);\n  assert(strings[0].find(prefix)\
    \ == 0);\n  std::ostringstream stream;\n  stream << strings[0];\n  for (int i\
    \ = 1; i < strings.size(); i++) {\n    stream << \" \" << strings[i];\n  }\n \
    \ std::copy(std::istream_iterator<std::string>(std::cin(stream)),\n          \
    \  std::istream_iterator<std::string>(),\n            std::back_inserter(strings));\n\
    \  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxxjz17pf.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpxxjz17pf.cpp:16:63: error: no match for call to \u2018(std::istream\
    \ {aka std::basic_istream<char>}) (std::ostringstream&)\u2019\n   16 |   std::copy(std::istream_iterator<std::string>(std::cin(stream)),\n\
    \      |                                                               ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    return std::remove_if(strings.begin(), strings.end(),\
    \ [&](std::string &s) {\n        return s.find(prefix) == 0;\n    });\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphiz1_pbs.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmphiz1_pbs.cpp:9:26: error: could not convert \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string&)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), <lambda\
    \ closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string&)>{prefix})\u2019 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n    9 |     return std::remove_if(strings.begin(), strings.end(), [&](std::string\
    \ &s) {\n      |            ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                          |\n      |                          __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\n   10 |         return s.find(prefix)\
    \ == 0;\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   11 |     });\n      |\
    \     ~~                    \n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> retval;\n    std::copy_if(strings.begin(),\
    \ strings.end(), std::back_inserter(retval),\n                 [prefix](std::string\
    \ i) { return i.compare(0, prefix.size(), prefix) == 0; });\n    return retval;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  result.reserve(strings.size());\n\
    \  for (auto it = strings.begin(); it != strings.end(); ++it) {\n    if (it->compare(0,\
    \ prefix.size(), prefix) == 0) {\n      result.push_back(*it);\n    }\n  }\n \
    \ return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n  \
    \  assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> results;\n  std::copy_if(strings.begin(),\
    \ strings.end(),\n               std::back_inserter(results),\n              \
    \ [&prefix](std::string s) { return s.substr(0, prefix.length()) == prefix; });\n\
    \  return results;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto const& string : strings) {\n        if (string.find(prefix) == 0) {\n\
    \            result.push_back(string);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n\tstd::vector<std::string> out;\n\tfor (auto&\
    \ s: strings) {\n\t\tif (s.substr(0, prefix.size()) == prefix) {\n\t\t\tout.emplace_back(s);\n\
    \t\t}\n\t}\n\treturn out;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\
    \ // stable sort\n    // If the prefix is empty or it's equal to the first string,\
    \ return the\n    // original list.\n    if (prefix.empty() || strings.front()\
    \ == prefix) {\n        return strings;\n    }\n\n    // Create a vector to hold\
    \ the result of the iteration and initialize it to empty.\n    std::vector<std::string>\
    \ result;\n    result.reserve(strings.size());\n\n    // Iterate over the input\
    \ list and only add strings that begin with the given\n    // prefix to the result.\n\
    \    bool match = false;\n    for (std::string::const_iterator it = strings.begin();\
    \ it != strings.end(); ++it) {\n        if (std::equal(prefix.begin(), prefix.end(),\
    \ *it)) {\n            result.push_back(*it);\n            match = true;\n   \
    \     }\n    }\n\n    // If the input list does not match the prefix, return an\
    \ empty list.\n    if (!match) {\n        return result;\n    }\n\n    // Return\
    \ the result of the iteration.\n    return result;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpocmse5w5.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpocmse5w5.cpp:23:56: error: conversion from \u2018__normal_iterator<std::__cxx11::basic_string<char>*,std::vector<std::__cxx11::basic_string<char>\
    \ >>\u2019 to non-scalar type \u2018__normal_iterator<const char*,std::__cxx11::basic_string<char>>\u2019\
    \ requested\n   23 |     for (std::string::const_iterator it = strings.begin();\
    \ it != strings.end(); ++it) {\n      |                                      \
    \     ~~~~~~~~~~~~~^~\n/tmp/tmpocmse5w5.cpp:23:63: error: no match for \u2018\
    operator!=\u2019 (operand types are \u2018std::__cxx11::basic_string<char>::const_iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >\u2019} and \u2018std::vector<std::__cxx11::basic_string<char> >::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >\u2019})\n   23 |     for (std::string::const_iterator it = strings.begin();\
    \ it != strings.end(); ++it) {\n      |                                      \
    \                      ~~ ^~ ~~~~~~~~~~~~~\n      |                          \
    \                                  |                |\n      |               \
    \                                             |                __normal_iterator<std::__cxx11::basic_string<char>*,std::vector<std::__cxx11::basic_string<char>\
    \ >>\n      |                                                            __normal_iterator<const\
    \ char*,std::__cxx11::basic_string<char>>\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    // Return an empty list if the input is\
    \ empty or null.\n    if (strings.empty() || strings[0] == \"\")\n        return\
    \ strings;\n\n    // Initialize a vector of strings we will return.\n    std::vector<std::string>\
    \ result;\n\n    // The current first string to be returned for each input.\n\
    \    std::string first = \"\";\n\n    // Iterate over the input list\n    for\
    \ (int i = 0; i < strings.size(); i++) {\n        // If the current string starts\
    \ with the prefix, return it.\n        if (strings[i].substr(0, prefix.length())\
    \ == prefix) {\n            result.push_back(first);\n            first = strings[i];\n\
    \        }\n        else {\n            // If the current string doesn't start\
    \ with the prefix, but the\n            // first one we encounter, add it to the\
    \ result.\n            if (first != \"\")\n                result.push_back(first);\n\
    \n            // Set the current first string.\n            first = strings[i];\n\
    \        }\n    }\n\n    // If the current string doesn't start with the prefix,\
    \ but the first one\n    // we encounter, add it to the result.\n    if (first\
    \ != \"\")\n        result.push_back(first);\n\n    // Return the result.\n  \
    \  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n \
    \   assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmplgp25wut: /tmp/tmplgp25wut.cpp:48: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::string rep(prefix);\n  for (const auto\
    \ &s : strings) {\n    if (s.compare(0, rep.size(), rep) == 0) {\n      strings.erase(std::remove(strings.begin(),\
    \ strings.end(), s));\n    }\n  }\n  return strings;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpm7fq0kk7: /tmp/tmpm7fq0kk7.cpp:20: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> res;\n  for(auto\
    \ s: strings)\n    if(s.substr(0, prefix.size()) == prefix)\n      res.push_back(s);\n\
    \  return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto&\
    \ s: strings) {\n    if (s.substr(0, prefix.length()) == prefix) {\n      result.push_back(s);\
    \ // Store the string in the result list.\n    }\n  }\n  return result;\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto it=strings.begin();\n    while(it !=\
    \ strings.end() && it->compare(0, prefix.size(), prefix) == 0) {\n        ++it;\n\
    \    }\n    return std::move(it);\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxrqgzwqa.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpxrqgzwqa.cpp:13:21: error: could not convert \u2018std::move<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >&>(it)\u2019 from \u2018std::remove_reference<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >&>::type\u2019 {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019} to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n   13 |     return std::move(it);\n      |            ~~~~~~~~~^~~~\n\
    \      |                     |\n      |                     std::remove_reference<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >&>::type {aka __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >}\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> out;\n    for (auto\
    \ &x : strings) {\n        if (x.startsWith(prefix)) {\n            out.push_back(x);\n\
    \        }\n    }\n    return out;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_4ps119s.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp_4ps119s.cpp:11:15: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018startsWith\u2019\n   11 |         if (x.startsWith(prefix))\
    \ {\n      |               ^~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto filter_func = [&prefix](const std::string\
    \ &s) {\n    return 0 == s.compare(0, prefix.size(), prefix);\n  };\n  return\
    \ std::remove_if(strings.begin(), strings.end(), filter_func);\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe1lfsq1e.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpe1lfsq1e.cpp:12:24: error: could not convert \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), filter_func)\u2019\
    \ from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\n  \
    \ 12 |   return std::remove_if(strings.begin(), strings.end(), filter_func);\n\
    \      |          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                        |\n      |                        __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    size_t\
    \ prefix_length = prefix.size();\n    for (std::string &string : strings) {\n\
    \        if (string.size() >= prefix_length) {\n            if (string[0] == prefix)\
    \ {\n                result.push_back(string);\n            }\n        }\n   \
    \ }\n    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6nyy5275.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp6nyy5275.cpp:13:27: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   13 |             if (string[0] == prefix) {\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp6nyy5275.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp6nyy5275.cpp:13:30:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   13 |             if (string[0] == prefix) {\n   \
    \   |                              ^~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp6nyy5275.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::cout << strings << std::endl;\n  if(strings.empty())\
    \ return strings;\n  std::string prefix = prefix + \"%\";\n  auto prefix_last\
    \ = prefix.rbegin();\n  std::string::reverse_iterator rit = std::search(prefix.begin(),\
    \ prefix.end(), strings[0].rbegin(), strings[0].rend());\n  std::string::reverse_iterator\
    \ it = std::search(prefix.begin(), prefix.end(), strings[0].begin(), strings[0].end());\n\
    \  if(it == strings[0].end() || it == prefix_last) return strings;\n  strings.erase(strings.begin(),\
    \ strings.begin()+rit);\n  return strings;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprnwgi_qa.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmprnwgi_qa.cpp:9:13: error: no match for \u2018operator<<\u2019 (operand\
    \ types are \u2018std::ostream\u2019 {aka \u2018std::basic_ostream<char>\u2019\
    } and \u2018std::vector<std::__cxx11::basic_string<char> >\u2019)\n    9 |   std::cout\
    \ << strings << std::endl;\n      |   ~~~~~~~~~ ^~ ~~~~~~~\n      |        | \
    \      |\n      |        |       std::vector<std::__cxx11::basic_string<char>\
    \ >\n      |        std::ostream {aka std::basic_ostream<char>}\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:39,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmprnwgi_qa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ostream:108:7:\
    \ note: candidate: \u2018std::basic_ostream<_CharT, _Traits>::__ostream_type&\
    \ std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__ostream_type&\
    \ (*)(std::basic_ostream<_CharT, _Traits>::__ostream_type&)) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type\
    \ = std::basic_ostream<char>]\u2019\n  108 |       operator<<(__ostream_type&\
    \ (*__pf)(__ostream_type&))\n      |       ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ostream:108:36:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::basic_ostream<char>::__ostream_type& (*)(std::basic_ostream<char>::__ostream_type&)\u2019\
    \ {aka \u2018std::basic_ostream<char>& (*)(std::basic_ostream<char>&)\u2019}\n\
    \  108 |       operator<<(__ostream_type& (*__pf)(__ostream_type&))\n      | \
    \                 ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    std::for_each(strings.begin(),\
    \ strings.end(), [&](const std::string &s) {\n        if (s.substr(0, prefix.size())\
    \ == prefix) {\n            res.push_back(s);\n        }\n    });\n    return\
    \ res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto\
    \ s : strings)\n    if (s.compare(0, prefix.size(), prefix) == 0)\n      result.push_back(s);\n\
    \  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n \
    \   assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> filtered;\n   \
    \ for (auto &item : strings) {\n        if (item.find(prefix) == 0) {\n      \
    \      filtered.push_back(prefix);\n        } else {\n            filtered.push_back(item);\n\
    \        }\n    }\n    return filtered;\n}\nint main() {\n    auto candidate =\
    \ filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmphxui5bv6: /tmp/tmphxui5bv6.cpp:22: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto & x: strings)\n        if (x.substr(0, prefix.size()) == prefix)\n   \
    \         result.push_back(x);\n    return result;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    // O(n) time complexity. Could be improved\
    \ to O(n*log(N)) using map here\n    std::vector<std::string> result;\n    std::unordered_map<std::string,int>\
    \ counter;\n    for(auto i : strings)\n    {\n        if(counter.find(prefix)\
    \ == counter.end())\n        {\n            counter[prefix] = 0;\n        }\n\
    \        counter[prefix] += 1;\n        if(counter[prefix] == 1)\n        {\n\
    \            result.push_back(i);\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpq1gdlkpa: /tmp/tmpq1gdlkpa.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::string::size_type first = strings.begin();\n\
    \  std::string::size_type last = strings.end();\n  while (first != last) {\n \
    \   if (first[0] == prefix[0]) {\n      last = strings.erase(first);\n    } else\
    \ {\n      first++;\n    }\n  }\n  return strings;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphwf8_dkf.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmphwf8_dkf.cpp:9:47: error: cannot convert \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019} to \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} in initialization\n    9 |   std::string::size_type\
    \ first = strings.begin();\n      |                                  ~~~~~~~~~~~~~^~\n\
    \      |                                               |\n      |            \
    \                                   std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator {aka __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >}\n/tmp/tmphwf8_dkf.cpp:10:44:\
    \ error: cannot convert \u2018std::vector<std::__cxx11::basic_string<char> >::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >\u2019} to \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018\
    long unsigned int\u2019} in initialization\n   10 |   std::string::size_type last\
    \ = strings.end();\n      |                                 ~~~~~~~~~~~^~\n  \
    \    |                                            |\n      |                 \
    \                           std::vector<std::__cxx11::basic_string<char> >::iterator\
    \ {aka __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >}\n/tmp/tmphwf8_dkf.cpp:12:16: error: invalid types \u2018std::__cxx11::basic_string<char>::size_type\
    \ {aka long unsigned int}[int]\u2019 for array subscript\n   12 |     if (first[0]\
    \ == prefix[0]) {\n      |                ^\n/tmp/tmphwf8_dkf.cpp:13:33: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::erase(std::__cxx11::basic_string<char>::size_type&)\u2019\n   13 |      \
    \ last = strings.erase(first);\n      |                     "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> out;\n  for (const\
    \ auto& string : strings) {\n    if (string.substr(0, prefix.size()) == prefix)\
    \ {\n      out.emplace_back(string);\n    }\n  }\n  return out;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto it = strings.begin(); it != strings.end(); it++) {\n        if (it->substr(0,\
    \ prefix.size()) == prefix) {\n            result.emplace_back(*it);\n       \
    \ }\n    }\n    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto &string : strings) {\n    if (string.substr(0, prefix.size()) == prefix)\
    \ {\n      result.push_back(string);\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    std::stack<std::string>\
    \ stk;\n    stk.push(prefix);\n    for (std::string & str : strings) {\n     \
    \   if (stk.empty() || str != stk.top()) {\n            stk.push(str);\n     \
    \       res.push_back(str);\n        } else {\n            while (stk.size() >\
    \ 1 && str != stk.top()) {\n                stk.pop();\n                res.pop();\n\
    \            }\n            stk.pop();\n        }\n    }\n    return res;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwq1ws6_g.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpwq1ws6_g.cpp:19:21: error: \u2018class std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 has no member named \u2018pop\u2019\n   19 |                 res.pop();\n\
    \      |                     ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\n\
    \    auto prefix_pos = strings.begin() + std::find(strings.begin(), strings.end(),\
    \ prefix);\n    std::vector<std::string> res;\n    res.reserve(strings.size());\n\
    \    for (auto it = prefix_pos; it != strings.end(); ++it) {\n        res.push_back(*it);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx_sjnrf3.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpx_sjnrf3.cpp:10:39: error: no match for \u2018operator+\u2019 (operand\
    \ types are \u2018std::vector<std::__cxx11::basic_string<char> >::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >\u2019} and \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019)\n   10 |     auto prefix_pos\
    \ = strings.begin() + std::find(strings.begin(), strings.end(), prefix);\n   \
    \   |                       ~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                    |             |\n      |         \
    \                           |             __normal_iterator<[...],[...]>\n   \
    \   |                                    __normal_iterator<[...],[...]>\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx_sjnrf3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:859:7:\
    \ note: candidate: \u2018__gnu_cxx::__normal_iterator<_Iterator, _Container> __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>::operator+(__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type)\
    \ const [with _Iterator = std"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  std::copy(std::begin(strings),\
    \ std::end(strings), std::back_inserter(result));\n  std::sort(std::begin(result),\
    \ std::end(result));\n  auto it = std::begin(result);\n  while (it != std::end(result))\
    \ {\n    if ((*it).compare(0, prefix.size(), prefix) == 0) {\n      it--;\n  \
    \  } else {\n      result.erase(it);\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size() > 0);\n  assert(strings.size()\
    \ == prefix.size());\n\n  std::vector<std::string> result;\n  bool seen = false;\n\
    \  for (auto s: strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n\
    \      seen = true;\n      result.push_back(s);\n    }\n  }\n  if (seen) {\n \
    \   return result;\n  }\n  return {};\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmp1z9cg0lf: /tmp/tmp1z9cg0lf.cpp:9: std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):\
    \ Assertion `strings.size() > 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.empty() || strings.size() >=\
    \ prefix.size());\n  if (strings.empty() || prefix.empty())\n    return strings;\n\
    \  std::vector<std::string> result;\n  result.reserve(strings.size());\n  auto\
    \ it = strings.begin();\n  auto it_prefix = prefix.begin();\n  for (; it != strings.end();\
    \ ++it, ++it_prefix) {\n    if (it_prefix != prefix.end() && it_prefix == it +\
    \ prefix.size()) {\n      result.push_back(*it);\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6n3n9b31.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp6n3n9b31.cpp:17:48: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019)\n   17 |     if (it_prefix\
    \ != prefix.end() && it_prefix == it + prefix.size()) {\n      |             \
    \                         ~~~~~~~~~ ^~ ~~~~~~~~~~~~~~~~~~\n      |           \
    \                           |               |\n      |                       \
    \               |               __normal_iterator<std::__cxx11::basic_string<char>*,std::vector<std::__cxx11::basic_string<char>\
    \ >>\n      |                                      __normal_iterator<char*,std::__cxx11::basic_string<char>>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp6n3n9b31.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:886:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  886 |\
    \     operator==(const __normal_i"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    // Write your code here.\n    std::vector<std::string>\
    \ result;\n    for (unsigned int i = 0; i < strings.size(); i++)\n    {\n    \
    \    if (strings[i].substr(0, prefix.length()) == prefix)\n        {\n       \
    \     result.push_back(strings[i]);\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> results;\n  for (std::string\
    \ string : strings)\n    if (string.substr(0, prefix.length()) == prefix)\n  \
    \    results.push_back(string);\n  return results;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\n\
    \    auto first_string_start = std::find_if(strings.begin(), strings.end(),\n\
    \            [&](std::string & s) { return s.substr(0, prefix.length()) == prefix;\
    \ });\n    return first_string_start != strings.end() ? std::move(strings) : std::vector<string>();\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzdy1qtko.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpzdy1qtko.cpp:12:83: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   12 |     return first_string_start\
    \ != strings.end() ? std::move(strings) : std::vector<string>();\n      |    \
    \                                                                            \
    \   ^~~~~~\n      |                                                          \
    \                         std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpzdy1qtko.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpzdy1qtko.cpp:12:89:\
    \ error: template argument 1 is invalid\n   12 |     return first_string_start\
    \ != strings.end() ? std::move(strings) : std::vector<string>();\n      |    \
    \                                                                            \
    \         ^\n/tmp/tmpzdy1qtko.cpp:12:89: error: template argument 2 is invalid\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (int\
    \ i = 0; i < strings.size(); ++i) {\n    if (strings[i].substr(0, prefix.length())\
    \ == prefix) {\n      result.push_back(strings[i]);\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    auto\
    \ pos = strings.begin();\n    while (pos != strings.end()) {\n        if (std::string(prefix)\
    \ == std::string(pos)) {\n            result.push_back(std::string(pos));\n  \
    \      }\n        ++pos;\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp98k41yn9.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp98k41yn9.cpp:12:51: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::basic_string(__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >&)\u2019\n   12 |         if\
    \ (std::string(prefix) == std::string(pos)) {\n      |                       \
    \                            ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp98k41yn9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:625:9:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&)\u2019\
    \n  625 |         basic_string(_InputIterator __beg, _InputIterator __end,\n \
    \     |         ^~~~~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:625:9:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp98k41yn9.cpp:12:51:\
    \ note:   candidate expects 3 arguments, 1 provided\n   12 |         if (std::string(prefix)\
    \ == std::string(pos)) {\n      |                                "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> res;\n  for(unsigned\
    \ int i=0; i < strings.size(); ++i) {\n    if(strings[i].find(prefix) == 0) {\n\
    \      res.push_back(strings[i]);\n    }\n  }\n  return res;\n}\nint main() {\n\
    \    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto &s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n\
    \            result.push_back(s);\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  // Create a copy of the original list.\n \
    \ std::vector<std::string> copyStrings = strings;\n  std::sort(copyStrings.begin(),\
    \ copyStrings.end());\n\n  // Look for prefix at each index in string list.\n\
    \  std::vector<int> indexesToRemove;\n  for (int i = 0; i < copyStrings.size();\
    \ ++i) {\n    if (copyStrings[i].find(prefix) == 0) {\n      indexesToRemove.push_back(i);\n\
    \    }\n  }\n\n  // Remove prefix from original list.\n  for (int i = 0; i < indexesToRemove.size();\
    \ ++i) {\n    copyStrings.erase(copyStrings.begin() + indexesToRemove[i]);\n \
    \ }\n\n  return copyStrings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmp0942n545: /tmp/tmp0942n545.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string>::iterator it = std::begin(strings);\n\
    \  while (it != std::end(strings)) {\n    std::string::size_type startPos = it->find(prefix);\n\
    \    if (startPos != std::string::npos) {\n      strings.erase(it);\n    } else\
    \ {\n      ++it;\n    }\n  }\n  return strings;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpjvrys1jq: /tmp/tmpjvrys1jq.cpp:23: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  if(strings.size() == 0) return strings;\n\
    \  std::vector<std::string> result;\n  for(unsigned int i = 0; i < strings.size();\
    \ ++i) {\n    if(strings[i].substr(0, prefix.length()) == prefix) {\n      result.push_back(strings[i]);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto it = std::begin(strings);\n  while (it\
    \ != std::end(strings)) {\n    auto n = std::distance(std::begin(strings), it);\n\
    \    if (0 == n.compare(0, prefix.size(), prefix)) {\n      it = std::next(it,\
    \ prefix.size());\n    } else {\n      it = std::next(it, n);\n    }\n  }\n  return\
    \ strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvdd__lnj.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpvdd__lnj.cpp:12:16: error: request for member \u2018compare\u2019 in\
    \ \u2018n\u2019, which is of non-class type \u2018long int\u2019\n   12 |    \
    \ if (0 == n.compare(0, prefix.size(), prefix)) {\n      |                ^~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto& str : strings) {\n    if (str.find(prefix) == 0) {\n      result.push_back(str);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    std::for_each(strings.begin(),\
    \ strings.end(), [&](std::string& s) {\n        if (s.substr(0, prefix.length())\
    \ == prefix)\n            result.push_back(s);\n    });\n    return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> res;\n  res.reserve(strings.size());\n\
    \  for (auto &str : strings) {\n    if (str.substr(0, prefix.size()) == prefix)\
    \ {\n      res.push_back(str);\n    }\n  }\n  return res;\n}\nint main() {\n \
    \   auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    auto\
    \ it = std::begin(strings);\n    while (it != std::end(strings)) {\n        if\
    \ (it->substr(0, prefix.size()) == prefix) {\n            result.push_back(it->substr(prefix.size()));\n\
    \        }\n        ++it;\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmppb3mx_42: /tmp/tmppb3mx_42.cpp:22: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto &string : strings) {\n        if (0 == string.compare(0, prefix.length(),\
    \ prefix))\n            result.emplace_back(std::move(string));\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (std::string&\
    \ s: strings) {\n    if (s.substr(0, prefix.length()) == prefix) {\n      result.push_back(s);\
    \ // if found, add\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    assert(strings.size() != 0);\n    size_t\
    \ prefix_len = prefix.length();\n    std::vector<std::string> new_strings;\n \
    \   for(auto &str : strings) {\n        size_t prefix_found = 0;\n        for(auto\
    \ &c : str) {\n            if(prefix_found == 0) {\n                if(c == prefix[0])\
    \ {\n                    prefix_found++;\n                } else {\n         \
    \           prefix_found = 0;\n                }\n            } else {\n     \
    \           if(c == prefix[prefix_found]) {\n                    prefix_found++;\n\
    \                } else {\n                    prefix_found = 0;\n           \
    \     }\n            }\n        }\n        if(prefix_found == prefix_len) {\n\
    \            new_strings.push_back(str);\n        }\n    }\n    return new_strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmp6jvbtc75: /tmp/tmp6jvbtc75.cpp:9: std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):\
    \ Assertion `strings.size() != 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto&\
    \ s: strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      result.push_back(s);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (const auto& str : strings) {\n        if (str.substr(0, prefix.length()) ==\
    \ prefix) {\n            result.push_back(str);\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> filtered;\n   \
    \ for (auto& str : strings)\n        if (str.substr(0, prefix.size()) == prefix)\n\
    \            filtered.push_back(str);\n    return filtered;\n}\nint main() {\n\
    \    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> ret(std::begin(strings),\
    \ std::end(strings));\n  std::remove_if(std::begin(ret), std::end(ret), [&](std::string\
    \ str) {\n    return str.find(prefix) == 0;\n  });\n  return ret;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmp6jkni6f0: /tmp/tmp6jkni6f0.cpp:18: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto it = std::begin(strings);\n    while\
    \ (it != std::end(strings)) {\n        if (it->find(prefix) == 0)\n          \
    \  strings.erase(it++);\n        else\n            ++it;\n    }\n    return strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpxi8brkur: /tmp/tmpxi8brkur.cpp:21: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto& elem : strings) {\n    if (elem.length() >= prefix.length() && elem.substr(0,\
    \ prefix.length()) == prefix) {\n      result.push_back(elem);\n    }\n  }\n \
    \ return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n  \
    \  assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto prefix_iter = strings.begin() + std::find(strings.begin(),\
    \ strings.end(), prefix);\n  strings.erase(prefix_iter);\n  return strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwo5xua2k.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpwo5xua2k.cpp:9:38: error: no match for \u2018operator+\u2019 (operand\
    \ types are \u2018std::vector<std::__cxx11::basic_string<char> >::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >\u2019} and \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019)\n    9 |   auto prefix_iter\
    \ = strings.begin() + std::find(strings.begin(), strings.end(), prefix);\n   \
    \   |                      ~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                   |             |\n      |          \
    \                         |             __normal_iterator<[...],[...]>\n     \
    \ |                                   __normal_iterator<[...],[...]>\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpwo5xua2k.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:859:7:\
    \ note: candidate: \u2018__gnu_cxx::__normal_iterator<_Iterator, _Container> __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>::operator+(__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type)\
    \ const [with _Iterator = std::__cx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> output;\n  \n  for\
    \ (auto s : strings) {\n    if (s[0] == prefix) {\n      output.push_back(s);\n\
    \    }\n  }\n  \n  return output;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxt1ycby5.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpxt1ycby5.cpp:12:14: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   12 |     if (s[0] == prefix) {\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpxt1ycby5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpxt1ycby5.cpp:12:17:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   12 |     if (s[0] == prefix) {\n      |         \
    \        ^~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpxt1ycby5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylak"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> out;\n    for (auto\
    \ & string : strings) {\n        if (string.substr(0, prefix.size()) == prefix)\
    \ {\n            out.push_back(string);\n        }\n    }\n    return out;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    // Initialize prefix and check it's non-empty.\n\
    \    if (prefix.empty()) return {strings[0]};\n\n    // Iterate over each string\
    \ and keep only those that start with the prefix.\n    std::vector<std::string>\
    \ result;\n    for (const auto &str : strings) {\n        if (str.substr(0, prefix.size())\
    \ == prefix) {\n            result.push_back(str);\n        }\n    }\n\n    //\
    \ Return result if any non-null string was found in strings.\n    return result.empty()\
    \ ? std::vector<std::string>() : result;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\
    \ // Sort ascending\n    auto prefix_pos = prefix.find_first_not_of(strings[0]);\
    \ // Find first prefix that is not in any of the strings\n    if (prefix_pos ==\
    \ std::string::npos) return strings; // No matches\n    // Return strings with\
    \ prefix not matched\n    auto start = strings.begin() + prefix_pos;\n    auto\
    \ end = start + strings.size();\n    return std::remove_copy_if(start, end, std::back_inserter(strings),\
    \ \n                              [prefix](std::string str) {return !str.compare(0,\
    \ prefix.size(), prefix);});\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfcgs8v3h.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpfcgs8v3h.cpp:15:31: error: could not convert \u2018std::remove_copy_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, std::back_insert_iterator<std::vector<std::__cxx11::basic_string<char>\
    \ > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)::<lambda(std::string)>\
    \ >(start, end, std::back_inserter<std::vector<std::__cxx11::basic_string<char>\
    \ > >(strings), <lambda closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>{std::__cxx11::basic_string<char>(prefix)})\u2019\
    \ from \u2018std::back_insert_iterator<std::vector<std::__cxx11::basic_string<char>\
    \ > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\n  \
    \ 15 |     return std::remove_copy_if(start, end, std::back_inserter(strings),\n\
    \      |            ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::back_insert_iterator<std::vector<std::__cxx11::basic_string<char> > >\n\
    \   16 |                               [prefix](std::string str) {return !str.compare(0,\
    \ prefix.size(), prefix);});\n      |                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto prefix_size = prefix.size();\n    std::vector<std::string>\
    \ results;\n\n    for(auto i = strings.begin(); i != strings.end(); ++i) {\n \
    \       if(0==std::memcmp(i->c_str(), prefix.c_str(), prefix_size)) {\n      \
    \      results.emplace_back(*i);\n        }\n    }\n\n    return results;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> out;\n  auto iter\
    \ = std::begin(strings);\n  auto end = std::end(strings);\n  while(iter != end)\
    \ {\n    if (0 == prefix.compare(0, iter->size(), prefix)) {\n      out.emplace_back(*iter);\n\
    \    }\n    ++iter;\n  }\n  return out;\n}\nint main() {\n    auto candidate =\
    \ filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmp4zl8pq6q: /tmp/tmp4zl8pq6q.cpp:23: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto prefix_iter = std::find_if(strings.begin(),\
    \ strings.end(),\n                                   [&prefix](const std::string&\
    \ s) {\n                                     return s[0] == prefix[0];\n     \
    \                              });\n  return std::remove_if(strings.begin(), strings.end(),\n\
    \                        [&prefix_iter](const std::string& s) { return prefix_iter\
    \ != strings.end() && *prefix_iter == prefix; });\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi6aat34b.cpp: In lambda function:\n/tmp/tmpi6aat34b.cpp:14:86:\
    \ error: \u2018strings\u2019 is not captured\n   14 |                        \
    \ [&prefix_iter](const std::string& s) { return prefix_iter != strings.end() &&\
    \ *prefix_iter == prefix; });\n      |                                       \
    \                                               ^~~~~~~\n/tmp/tmpi6aat34b.cpp:14:38:\
    \ note: the lambda has no capture-default\n   14 |                         [&prefix_iter](const\
    \ std::string& s) { return prefix_iter != strings.end() && *prefix_iter == prefix;\
    \ });\n      |                                      ^\n/tmp/tmpi6aat34b.cpp:8:68:\
    \ note: \u2018std::vector<std::__cxx11::basic_string<char> > strings\u2019 declared\
    \ here\n    8 | std::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n      |                                    \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpi6aat34b.cpp:14:119: error:\
    \ \u2018prefix\u2019 is not captured\n   14 |                         [&prefix_iter](const\
    \ std::string& s) { return prefix_iter != strings.end() && *prefix_iter == prefix;\
    \ });\n      |                                                               \
    \                                                        ^~~~~~\n/tmp/tmpi6aat34b.cpp:14:38:\
    \ note: the lambda has no capture-default\n   14 |                         [&prefix_iter](const\
    \ std::string& s) { return prefix_iter != strings.end() && *prefix_iter == prefix;\
    \ });\n      |                                      ^\n/tmp/tmpi6aat34b.cpp:8:89:\
    \ note: \u2018std::string prefix\u2019 declared here\n    8 | std::vector<std::string>\
    \ filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n \
    \     |                                                                      \
    \       ~~~~~~~~~~~~^~~~~~\n/tmp/tmpi6aat34b.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpi6aat34b.cpp:13:24: error: could not convert \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    for (std::string\
    \ word : strings) {\n        if (word.substr(0, prefix.length()) == prefix) {\n\
    \            res.push_back(word);\n        }\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(!prefix.empty());\n  std::sort(strings.begin(),\
    \ strings.end());\n  auto it = std::mismatch(strings.begin(), strings.end(), prefix.begin(),\
    \ prefix.end());\n  if (it == strings.end()) {\n    return strings;\n  }\n  auto\
    \ start_index = std::distance(prefix.begin(), it.first);\n  auto end_index = std::distance(prefix.begin(),\
    \ it.second);\n  return std::vector<std::string>(strings.begin() + start_index,\
    \ strings.begin() + end_index);\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqs13m5gr.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpqs13m5gr.cpp:12:10: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::pair<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > >\u2019 and \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019})\n   12 |   if (it ==\
    \ strings.end()) {\n      |       ~~ ^~ ~~~~~~~~~~~~~\n      |       |       \
    \         |\n      |       |                std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator {aka __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >}\n      |       std::pair<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpqs13m5gr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:886:5:\
    \ note: candidate: \u2018template<class _Iterato"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto it = std::begin(strings);\n  std::vector<std::string>\
    \ res;\n  while (it != std::end(strings)) {\n    if (it->substr(0, prefix.size())\
    \ == prefix) {\n      res.push_back(std::move(*it));\n    }\n    ++it;\n  }\n\
    \  return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::set<std::string> stringSet;\n  for (std::string\
    \ s : strings)\n    stringSet.insert(s.substr(0, prefix.size()));\n  return std::vector<std::string>(stringSet.begin(),\
    \ stringSet.end());\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpx1hp__xj: /tmp/tmpx1hp__xj.cpp:17: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    return std::remove_if(strings.begin(), strings.end(),\n\
    \            [](const std::string& s) { return s.starts_with(prefix); }\n    \
    \    );\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplw29taem.cpp: In lambda function:\n/tmp/tmplw29taem.cpp:10:49:\
    \ error: \u2018const string\u2019 {aka \u2018const class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018starts_with\u2019\n   10 |             [](const std::string&\
    \ s) { return s.starts_with(prefix); }\n      |                              \
    \                   ^~~~~~~~~~~\n/tmp/tmplw29taem.cpp:10:61: error: \u2018prefix\u2019\
    \ is not captured\n   10 |             [](const std::string& s) { return s.starts_with(prefix);\
    \ }\n      |                                                             ^~~~~~\n\
    /tmp/tmplw29taem.cpp:10:14: note: the lambda has no capture-default\n   10 | \
    \            [](const std::string& s) { return s.starts_with(prefix); }\n    \
    \  |              ^\n/tmp/tmplw29taem.cpp:8:89: note: \u2018std::string prefix\u2019\
    \ declared here\n    8 | std::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n      |                                    \
    \                                         ~~~~~~~~~~~~^~~~~~\n/tmp/tmplw29taem.cpp:\
    \ In function \u2018std::vector<std::__cxx11::basic_string<char> > filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)\u2019:\n/tmp/tmplw29taem.cpp:9:26: error: could not convert\
    \ \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), (<lambda\
    \ closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)>{}, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)>()))\u2019 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n    9 |     return std::remove_if(strings.begin(), strings.end(),\n\
    \      | "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  std::sort(prefix.begin(), prefix.end());\n  strings.erase(std::remove_if(strings.begin(),\
    \ strings.end(), [&](std::string s) { return s.substr(0, prefix.size()) == prefix;\
    \ }), strings.end());\n  return strings;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpkq556zch: /tmp/tmpkq556zch.cpp:17: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<string> result;\n    for(auto\
    \ &s : strings) {\n        if(s.substr(0, prefix.size()) == prefix) {\n      \
    \      result.push_back(s);\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp20fpm0dv.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp20fpm0dv.cpp:9:17: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n    9 |     std::vector<string>\
    \ result;\n      |                 ^~~~~~\n      |                 std::string\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp20fpm0dv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmp20fpm0dv.cpp:9:23:\
    \ error: template argument 1 is invalid\n    9 |     std::vector<string> result;\n\
    \      |                       ^\n/tmp/tmp20fpm0dv.cpp:9:23: error: template argument\
    \ 2 is invalid\n/tmp/tmp20fpm0dv.cpp:12:20: error: request for member \u2018push_back\u2019\
    \ in \u2018result\u2019, which is of non-class type \u2018int\u2019\n   12 | \
    \            result.push_back(s);\n      |                    ^~~~~~~~~\n/tmp/tmp20fpm0dv.cpp:15:12:\
    \ error: could not convert \u2018result\u2019 from \u2018int\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n   15 |     return result;\n      |            ^~~~~~\n      |    \
    \        |\n      |            int\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (size_t i = 0; i < strings.size(); ++i) {\n        if (strings[i].substr(0,\
    \ prefix.size()) == prefix) {\n            result.push_back(strings[i]);\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto const &str : strings) {\n        if (str.substr(0, prefix.size()) == prefix)\n\
    \            result.push_back(str);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    // We need to use find because a vector\
    \ does not allow to pass a callable as parameter\n    auto prefix = prefix.begin();\n\
    \    std::vector<std::string> res;\n    std::find(strings.begin(), strings.end(),\
    \ [&]() {\n        return prefix.compare(strings.begin(), strings.end()) == 0;\n\
    \    }) != strings.end();\n    return res;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuv5j4g5n.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpuv5j4g5n.cpp:10:10: error: declaration of \u2018auto prefix\u2019 shadows\
    \ a parameter\n   10 |     auto prefix = prefix.begin();\n      |          ^~~~~~\n\
    /tmp/tmpuv5j4g5n.cpp:10:19: error: use of \u2018prefix\u2019 before deduction\
    \ of \u2018auto\u2019\n   10 |     auto prefix = prefix.begin();\n      |    \
    \               ^~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:71,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpuv5j4g5n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_equals_val<_Value>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Value = const filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda()>]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:120:14:\
    \   required from \u2018_RandomAccessIterator std::__find_if(_RandomAccessIterator,\
    \ _RandomAccessIterator, _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator\
    \ = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >; _Predicate = __gnu_cxx::__ops::"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto begin = strings.begin();\n    auto\
    \ end = strings.end();\n    while (begin != end) {\n        if (begin->find(prefix)\
    \ == 0) {\n            begin = strings.erase(begin);\n        } else {\n     \
    \       ++begin;\n        }\n    }\n    return strings;\n}\nint main() {\n   \
    \ auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> results;\n  if (strings.size()\
    \ == 0)\n    return results;\n  if (prefix.empty())\n    return results;\n  auto\
    \ it = strings.begin();\n  while (it != strings.end()) {\n    if (it->length()\
    \ >= prefix.size() && it->substr(0, prefix.size()) == prefix) {\n      results.push_back(*it);\n\
    \    }\n    ++it;\n  }\n  return results;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> retstring;\n  for\
    \ (std::string s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n\
    \      retstring.push_back(s);\n    }\n  }\n  return retstring;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    for (auto&\
    \ s : strings) {\n        if (s.find(prefix) == 0)\n            res.push_back(s);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for(auto\
    \ it=strings.begin(); it!=strings.end(); ++it){\n        if(it->substr(0, prefix.size())\
    \ == prefix){\n            result.push_back(*it);\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  std::vector<std::string>::iterator iter = strings.begin();\n  while (iter !=\
    \ strings.end() && prefix == iter->substr(0, prefix.length())) {\n    ++iter;\n\
    \  }\n  return std::vector<std::string>(iter, strings.end());\n}\nint main() {\n\
    \    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmp09qe3iyz: /tmp/tmp09qe3iyz.cpp:19: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    if (strings.empty()) return strings;\n \
    \   std::vector<bool> found(strings.size(), false);\n    for (auto it : strings)\
    \ {\n        if (it.startsWith(prefix)) {\n            found[it.size()-1] = true;\n\
    \        } else {\n            found[it.size()-1] = false;\n        }\n    }\n\
    \    std::vector<std::string> result;\n    for (auto it : found) {\n        if\
    \ (it) result.push_back(it);\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdye6gbe3.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpdye6gbe3.cpp:12:16: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018startsWith\u2019\n   12 |         if (it.startsWith(prefix))\
    \ {\n      |                ^~~~~~~~~~\n/tmp/tmpdye6gbe3.cpp:20:36: error: no\
    \ matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(std::_Bit_reference&)\u2019\n   20 |         if (it) result.push_back(it);\n\
    \      |                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpdye6gbe3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018std::_Bit_reference\u2019\
    \ to \u2018const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |    "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> res;\n  for (std::string\
    \ s : strings) {\n    if (s.substr(0, prefix.length()) == prefix) {\n      res.push_back(s);\n\
    \    }\n  }\n  return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> out;\n    for (std::string\
    \ s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n      \
    \      out.push_back(s);\n        }\n    }\n    return out;\n}\nint main() {\n\
    \    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  std::string prefix_str = prefix + \".\";\n  auto it = std::find_if(strings.begin(),\
    \ strings.end(),\n      [&prefix_str](const std::string &str) {\n        return\
    \ str.starts_with(prefix_str);\n      });\n  return std::vector<std::string>{it,\
    \ strings.end()};\n}\nint main() {\n    auto candidate = filter_by_prefix;\n \
    \   assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3l1zv1u9.cpp: In lambda function:\n/tmp/tmp3l1zv1u9.cpp:13:20:\
    \ error: \u2018const string\u2019 {aka \u2018const class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018starts_with\u2019\n   13 |         return str.starts_with(prefix_str);\n\
    \      |                    ^~~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:71,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp3l1zv1u9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_pred<_Predicate>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Predicate = filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)>]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:120:14:\
    \   required from \u2018_RandomAccessIterator std::__find_if(_RandomAccessIterator,\
    \ _RandomAccessIterator, _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator\
    \ = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >; _Predicate = __gnu_cxx::__ops::_Iter_pred<filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)> >]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\
    \ // sorting the input strings makes them easier to read for testing\n  auto it\
    \ = std::find_if(strings.begin(), strings.end(), [&](const std::string & s) {\
    \ return s.starts_with(prefix); });\n  if (it != strings.end()) {\n    strings.erase(it,\
    \ strings.end());\n  }\n  return strings;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6irs_4ss.cpp: In lambda function:\n/tmp/tmp6irs_4ss.cpp:10:96:\
    \ error: \u2018const string\u2019 {aka \u2018const class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018starts_with\u2019\n   10 |   auto it = std::find_if(strings.begin(),\
    \ strings.end(), [&](const std::string & s) { return s.starts_with(prefix); });\n\
    \      |                                                                     \
    \                           ^~~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:71,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp6irs_4ss.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_pred<_Predicate>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Predicate = filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)>]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:120:14:\
    \   required from \u2018_RandomAccessIterator std::__find_if(_RandomAccessIterator,\
    \ _RandomAccessIterator, _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator\
    \ = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >; _Predicate = __gnu_cxx::__ops::_Iter_pred<filter_by_prefix(std::v"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    for(auto\
    \ s: strings) {\n        if(s.substr(0, prefix.size()) == prefix) {\n        \
    \    res.push_back(s);\n        }\n    }\n    return res;\n}\nint main() {\n \
    \   auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  string filtered_prefix = prefix;\n  for (int\
    \ i=0; i<strings.size(); i++) {\n    if (strings[i].substr(0, filtered_prefix.length())\
    \ == filtered_prefix) {\n      filtered_prefix = strings[i].substr(filtered_prefix.length());\
    \ // remove the prefix.\n    }\n  }\n  return filtered_prefix != prefix ? std::vector<string>(filtered_prefix.begin(),\
    \ filtered_prefix.end()) : strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj34a0_l2.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpj34a0_l2.cpp:9:3: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n    9 |   string filtered_prefix\
    \ = prefix;\n      |   ^~~~~~\n      |   std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpj34a0_l2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpj34a0_l2.cpp:11:30:\
    \ error: \u2018filtered_prefix\u2019 was not declared in this scope; did you mean\
    \ \u2018filter_by_prefix\u2019?\n   11 |     if (strings[i].substr(0, filtered_prefix.length())\
    \ == filtered_prefix) {\n      |                              ^~~~~~~~~~~~~~~\n\
    \      |                              filter_by_prefix\n/tmp/tmpj34a0_l2.cpp:15:10:\
    \ error: \u2018filtered_prefix\u2019 was not declared in this scope; did you mean\
    \ \u2018filter_by_prefix\u2019?\n   15 |   return filtered_prefix != prefix ?\
    \ std::vector<string>(filtered_prefix.begin(), filtered_prefix.end()) : strings;\n\
    \      |          ^~~~~~~~~~~~~~~\n      |          filter_by_prefix\n/tmp/tmpj34a0_l2.cpp:15:56:\
    \ error: template argument 2 is invalid\n   15 |   return filtered_prefix != prefix\
    \ ? std::vector<string>(filtered_prefix.begin(), filtered_prefix.end()) : strings;\n\
    \      |           "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> filteres;\n  for\
    \ (const auto &str : strings) {\n    if (str.substr(0, prefix.length()) == prefix)\
    \ {\n      filteres.push_back(str);\n    }\n  }\n  return filteres;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> retval;\n    for\
    \ (std::string s : strs) {\n        if (s.substr(0, prefix.size()) == prefix)\
    \ {\n            retval.push_back(s);\n        }\n    }\n    return retval;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpiwcgzmkn.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpiwcgzmkn.cpp:10:26: error: \u2018strs\u2019 was not declared in this\
    \ scope\n   10 |     for (std::string s : strs) {\n      |                   \
    \       ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::string pre = prefix + '.';\n  std::sort(strings.begin(),\
    \ strings.end());\n  std::set<std::string> result;\n  for (std::string &string\
    \ : strings) {\n    if (string.find(pre) == 0) {\n      result.insert(string);\n\
    \    }\n  }\n  return std::vector<std::string>(result.begin(), result.end());\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmp8caiughs: /tmp/tmp8caiughs.cpp:22: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    size_t\
    \ prefix_len = prefix.size();\n\n    for(const auto &str : strings) {\n      \
    \  if(str.size() > prefix_len) {\n            continue;\n        }\n        if(str.substr(0,\
    \ prefix_len) == prefix) {\n            result.push_back(str);\n        }\n  \
    \  }\n\n    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmp6mg85gyc: /tmp/tmp6mg85gyc.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string>::iterator pos = std::find(strings.begin(),\
    \ strings.end(), prefix);\n  if (pos != strings.end()) {\n    strings.erase(pos);\n\
    \  }\n  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmp5kin_77v: /tmp/tmp5kin_77v.cpp:18: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size());\n  assert(strings[0].length()\
    \ > prefix.length());\n  std::vector<std::string> res;\n  for (std::string &string\
    \ : strings) {\n    if (string.substr(0, prefix.length()) == prefix) {\n     \
    \ res.push_back(string);\n    }\n  }\n  return res;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpxrbrxt_m: /tmp/tmpxrbrxt_m.cpp:9: std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):\
    \ Assertion `strings.size()' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto it = std::begin(strings);\n  for (; it\
    \ != std::end(strings); ++it)\n    if (it->compare(0, prefix.size(), prefix) ==\
    \ 0)\n      std::erase(std::remove_cbegin(std::begin(strings), it), std::end(strings));\n\
    \  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1y3i7vi_.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp1y3i7vi_.cpp:12:12: error: \u2018erase\u2019 is not a member of \u2018\
    std\u2019\n   12 |       std::erase(std::remove_cbegin(std::begin(strings), it),\
    \ std::end(strings));\n      |            ^~~~~\n/tmp/tmp1y3i7vi_.cpp:12:23: error:\
    \ \u2018remove_cbegin\u2019 is not a member of \u2018std\u2019\n   12 |      \
    \ std::erase(std::remove_cbegin(std::begin(strings), it), std::end(strings));\n\
    \      |                       ^~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> res;\n  for (std::string\
    \ s : strings) {\n    if (s.substr(0, prefix.length()) == prefix) {\n      res.push_back(s);\n\
    \    }\n  }\n  return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    assert(strings.size() > 0);\n    std::vector<std::string>\
    \ result;\n    for (auto& s : strings) {\n        if (s.substr(0, prefix.size())\
    \ == prefix) {\n            result.push_back(s);\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpaqgr3uq4: /tmp/tmpaqgr3uq4.cpp:9: std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):\
    \ Assertion `strings.size() > 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto\
    \ &s : strings)\n    if (s.substr(0, prefix.size()) == prefix) {\n      result.push_back(s);\n\
    \    }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> results;\n  results.reserve(strings.size());\n\
    \  for (const auto& string : strings) {\n    if (string.compare(0, prefix.size(),\
    \ prefix) == 0) {\n      results.push_back(std::move(string));\n    }\n  }\n \
    \ return results;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n \
    \   assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto filtered_prefix = prefix;\n  for (auto\
    \ &s : strings) {\n    if (s.compare(0, prefix.size(), prefix) == 0)\n      filtered_prefix.erase(prefix.size());\n\
    \    else if (s.compare(0, prefix.size(), prefix) == 0)\n      filtered_prefix.push_back(s);\n\
    \  }\n  return filtered_prefix;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpldqq_8gz.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpldqq_8gz.cpp:14:33: error: cannot convert \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018char\u2019\n   14 |       filtered_prefix.push_back(s);\n      |  \
    \                               ^\n      |                                 |\n\
    \      |                                 std::__cxx11::basic_string<char>\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpldqq_8gz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1349:24:\
    \ note:   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1349 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n/tmp/tmpldqq_8gz.cpp:16:10: error: could\
    \ not convert \u2018filtered_prefix\u2019 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\n   16 |   return\
    \ filtered_prefix;\n      |          ^~~~~~~~~~~~~~~\n      |          |\n   \
    \   |          std::__cxx11::basic_string<char>\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    for (auto\
    \ const &i : strings)\n        if (i.substr(0, prefix.size()) == prefix)\n   \
    \         res.push_back(i);\n    return res;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    std::for_each(strings.begin(),\
    \ strings.end(), [&res, prefix](std::string s) {\n        auto pos = s.find(prefix);\n\
    \        if (pos == 0) return res.emplace_back(s);\n        size_t len = prefix.length();\n\
    \        if (len != 0) {\n            if (pos == std::string::npos) {\n      \
    \          return res.emplace_back(s, 0);\n            } else if (pos == s.size()-len)\
    \ {\n                return res.emplace_back(s, pos);\n            }\n       \
    \ }\n        return res.emplace_back(s);\n    });\n    return res;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmprac5pi15: /tmp/tmprac5pi15.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> results;\n  for (std::string\
    \ s : strings) {\n    if (s.compare(0, prefix.size(), prefix) == 0) {\n      results.push_back(s);\n\
    \    }\n  }\n  return results;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    for (auto it = strings.begin(); it != strings.end();\
    \ ++it) {\n        if (it->startswith(prefix)) {\n            strings.erase(it);\n\
    \        }\n    }\n    return strings;\n}\nint main() {\n    auto candidate =\
    \ filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp69t_u_zm.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp69t_u_zm.cpp:10:17: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018startswith\u2019\n   10 |         if (it->startswith(prefix))\
    \ {\n      |                 ^~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(prefix.size() > 0);\n  std::string::size_type\
    \ prefix_size = prefix.size();\n  return std::remove_if(strings.begin(), strings.end(),\
    \ [&](const std::string& str) {\n    std::string::size_type begin = str.find_first_not_of(prefix,\
    \ 0);\n    return (begin != std::string::npos);\n  });\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgzy6xnot.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpgzy6xnot.cpp:11:24: error: could not convert \u2018std::remove_if<__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)> >(strings.std::vector<std::__cxx11::basic_string<char>\
    \ >::begin(), strings.std::vector<std::__cxx11::basic_string<char> >::end(), <lambda\
    \ closure object>filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)>{prefix})\u2019 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n   11 |   return std::remove_if(strings.begin(), strings.end(), [&](const\
    \ std::string& str) {\n      |          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                        |\n      |                        __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\n   12 |     std::string::size_type\
    \ begin = str.find_first_not_of(prefix, 0);\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \   13 |     return (begin != std::string::npos);\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \   14 |   });\n      |   ~~                    \n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string>::iterator it;\n \
    \ for (it = strings.begin(); it != strings.end(); it++) {\n    if (0 == std::strncmp(prefix,\
    \ *it, prefix.size())) {\n      strings.erase(it);\n    }\n  }\n  return strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmhghyauk.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpmhghyauk.cpp:11:27: error: cannot convert \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const char*\u2019\n \
    \  11 |     if (0 == std::strncmp(prefix, *it, prefix.size())) {\n      |    \
    \                       ^~~~~~\n      |                           |\n      | \
    \                          std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cstring:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:48,\n\
    \                 from /tmp/tmpmhghyauk.cpp:2:\n/usr/include/string.h:143:33:\
    \ note:   initializing argument 1 of \u2018int strncmp(const char*, const char*,\
    \ size_t)\u2019\n  143 | extern int strncmp (const char *__s1, const char *__s2,\
    \ size_t __n)\n      |                     ~~~~~~~~~~~~^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> output;\n  for (int\
    \ i = 0; i < strings.size(); i++) {\n    if (strings[i].startsWith(prefix)) {\n\
    \      output.push_back(strings[i]);\n    }\n  }\n  return output;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgy07hcg6.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpgy07hcg6.cpp:11:20: error: \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018startsWith\u2019\n   11 |     if (strings[i].startsWith(prefix))\
    \ {\n      |                    ^~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<bool> was(std::begin(strings),\
    \ std::end(strings));\n    std::vector<bool> found(std::begin(strings), std::end(strings));\n\
    \    std::vector<std::string> result;\n    auto pos = std::find(std::begin(was),\
    \ std::end(was), false);\n    for (auto it = std::begin(was); it != std::end(was);\
    \ ++it) {\n        if (it == pos || !found[*it]) {\n            continue;\n  \
    \      }\n        found[*it] = true;\n        result.push_back(strings[it - std::begin(was)]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpfw63if_j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In instantiation of \u2018static _OI std::__copy_move<false, false, std::random_access_iterator_tag>::__copy_m(_II,\
    \ _II, _OI) [with _II = std::__cxx11::basic_string<char>*; _OI = std::_Bit_iterator]\u2019\
    :\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:30:\
    \   required from \u2018_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove\
    \ = false; _II = std::__cxx11::basic_string<char>*; _OI = std::_Bit_iterator]\u2019\
    \n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:441:30:\
    \   required from \u2018_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove\
    \ = false; _II = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _OI = std::_Bit_iterator]\u2019\
    \n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:474:7:\
    \   required from \u2018_OI std::copy(_II, _II, _OI) [with _II = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _OI = std::_Bit_iterator]\u2019\
    \n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_bvector.h:1189:13:\
    \   required from \u2018void std::vector<bool, _Alloc>::_M_initialize_range(_ForwardIterator,\
    \ _ForwardIterator, std::forward_iterator_tag) [with _ForwardIterator = __gnu_cxx::__normal_iterator<std::__cxx1"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  std::vector<std::string> filtered_strings;\n  for (auto const& s : strings)\
    \ {\n    if (s.substr(0, prefix.size()) == prefix) {\n      filtered_strings.push_back(s);\n\
    \    }\n  }\n  return filtered_strings;\n}\nint main() {\n    auto candidate =\
    \ filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmp3dk2xzik: /tmp/tmp3dk2xzik.cpp:21: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> res;\n    for(auto\
    \ &string : strings) {\n        if(string.substr(0, prefix.size()) == prefix)\
    \ {\n            res.push_back(string);\n        }\n    }\n    return res;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    // TODO: use a std::map for prefixes\n \
    \   std::vector<std::string> ret; \n    for (auto s : strings) {\n        if (s.find(prefix)\
    \ == 0) {\n            ret.push_back(s);\n        }\n    }\n    return ret;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::cout << \"Filtering input for prefix\
    \ \" << prefix << \" ==> \" << strings << std::endl;\n    std::vector<std::string>\
    \ res;\n    for (std::string s : strings) {\n        if (s.substr(0, prefix.size())\
    \ == prefix) {\n            res.push_back(s);\n        }\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5eama5qc.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp5eama5qc.cpp:9:69: error: no match for \u2018operator<<\u2019 (operand\
    \ types are \u2018std::basic_ostream<char>\u2019 and \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019)\n    9 |     std::cout << \"Filtering input for prefix \" << prefix\
    \ << \" ==> \" << strings << std::endl;\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~\n      |                                                        \
    \  |             |\n      |                                                  \
    \        |             std::vector<std::__cxx11::basic_string<char> >\n      |\
    \                                                          std::basic_ostream<char>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp5eama5qc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ostream:108:7:\
    \ note: candidate: \u2018std::basic_ostream<_CharT, _Traits>::__ostream_type&\
    \ std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__ostream_type&\
    \ (*)(std::basic_ostream<_CharT, _Traits>::__ostream_type&)) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type\
    \ = std::basic_ostream<char>]\u2019\n  108 |       operator<<(__ostream_type&\
    \ (*__pf)(__ostream_type&))\n      |       ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ostream:108:36:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::basic_ostream<char>::__ostream_type& (*)"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for(auto\
    \ &s : strings) {\n        if(s.substr(0, prefix.length()) == prefix) {\n    \
    \        result.push_back(s);\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  \n  //\
    \ Write your code here\n  for (size_t i = 0; i < strings.size(); ++i) {\n    if\
    \ (strings.at(i).substr(0, prefix.length()) == prefix) result.push_back(strings.at(i));\n\
    \  }\n  \n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  for (auto& string : strings)\n    if (string.substr(0, prefix.size()) == prefix)\n\
    \      strings.erase(std::remove(strings.begin(), strings.end(), string), strings.end());\n\
    \n  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmppyc_3yv2: /tmp/tmppyc_3yv2.cpp:19: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::regex reg(prefix);\n    std::vector<std::string>\
    \ ret(std::begin(strings), std::end(strings));\n    std::remove_copy_if(std::begin(strings),\
    \ std::end(strings), std::back_inserter(ret), std::bind(std::regex_search, std::cref(reg),\
    \ std::placeholders::_1));\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4dcmfdtm.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp4dcmfdtm.cpp:11:156: error: no matching function for call to \u2018\
    bind(<unresolved overloaded function type>, std::reference_wrapper<const std::__cxx11::basic_regex<char>\
    \ >, const std::_Placeholder<1>&)\u2019\n   11 |     std::remove_copy_if(std::begin(strings),\
    \ std::end(strings), std::back_inserter(ret), std::bind(std::regex_search, std::cref(reg),\
    \ std::placeholders::_1));\n      |                                          \
    \                                                                            \
    \                                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp4dcmfdtm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/functional:808:5:\
    \ note: candidate: \u2018template<class _Func, class ... _BoundArgs> typename\
    \ std::_Bind_helper<std::__is_socketlike<_Func>::value, _Func, _BoundArgs ...>::type\
    \ std::bind(_Func&&, _BoundArgs&& ...)\u2019\n  808 |     bind(_Func&& __f, _BoundArgs&&...\
    \ __args)\n      |     ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/functional:808:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp4dcmfdtm.cpp:11:156:\
    \ note:   couldn\u2019t deduce template parameter \u2018_Func\u2019\n   11 | \
    \    std::remove_copy_if(std::begin(strings), std::end(strings), std::back_inserter(ret),\
    \ std::bind(std::regex_search, std::cref(reg), std::placeholders::_1));\n    \
    \  |                                                                         \
    \                                                                            \
    \       ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp4dcmfdtm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/functional:832:5:\
    \ note: candidate: \u2018template<class _Result, class _Func, class ... _BoundArgs>\
    \ typename st"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  for (int i = 0; i <= strings.size(); ++i)\
    \ {\n    if (strings[i].length() > prefix.length()) {\n      std::cout << \"Skipping\
    \ \" << strings[i] << std::endl;\n    } else {\n      if (strings[i].compare(0,\
    \ prefix.size(), prefix) == 0) {\n        std::cout << strings[i] << std::endl;\n\
    \      }\n    }\n  }\n  return strings;\n}\nint main() {\n    auto candidate =\
    \ filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"john\"\
    )) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> out;\n    for (auto&\
    \ s : strings) {\n        if (s.substr(0, prefix.length()) == prefix) {\n    \
    \        out.push_back(s);\n        }\n    }\n    return out;\n}\nint main() {\n\
    \    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<string>::iterator itr = std::begin(strings);\n\
    \    while (std::begin(strings) < std::end(strings)) {\n        if (itr == std::begin(strings)\
    \ || std::find(itr, std::end(strings), prefix) == std::end(strings))\n       \
    \     itr = std::next(itr);\n        else\n            itr = std::find_if(std::next(itr),\
    \ std::end(strings), [&prefix](std::string str) { return (str.find(prefix) ==\
    \ 0);});\n    }\n    return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph03v4g4w.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmph03v4g4w.cpp:9:17: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n    9 |     std::vector<string>::iterator\
    \ itr = std::begin(strings);\n      |                 ^~~~~~\n      |        \
    \         std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmph03v4g4w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmph03v4g4w.cpp:9:23:\
    \ error: template argument 1 is invalid\n    9 |     std::vector<string>::iterator\
    \ itr = std::begin(strings);\n      |                       ^\n/tmp/tmph03v4g4w.cpp:9:23:\
    \ error: template argument 2 is invalid\n/tmp/tmph03v4g4w.cpp:9:35: error: expected\
    \ initializer before \u2018itr\u2019\n    9 |     std::vector<string>::iterator\
    \ itr = std::begin(strings);\n      |                                   ^~~\n\
    /tmp/tmph03v4g4w.cpp:11:13: error: \u2018itr\u2019 was not declared in this scope\n\
    \   11 |         if (itr == std::begin(strings) || std::find(itr, std::end(strings),\
    \ prefix) == std::end(strings))\n      |             ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto &s : strings) {\n    if (s.startsWith(prefix)) {\n      result.push_back(s);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpil45ab84.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpil45ab84.cpp:11:11: error: \u2018const class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018startsWith\u2019\n   11 |     if (s.startsWith(prefix))\
    \ {\n      |           ^~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\n\
    \    if (strings.size() == 0) {\n        return strings;\n    }\n    std::set<std::string::size_type>\
    \ prefix_lengths;\n    prefix_lengths.insert(prefix.size());\n    prefix_lengths.insert(prefix.size()\
    \ + 1);\n    prefix_lengths.insert(prefix.size() + 2);\n    prefix_lengths.insert(prefix.size()\
    \ + 3);\n    for (auto& string : strings) {\n        if (string.size() >= prefix.size()\
    \ && string[0:prefix.size()] == prefix) {\n            if (prefix_lengths.find(string.size()\
    \ - 1) != prefix_lengths.end()) {\n                prefix_lengths.erase(string.size()\
    \ - 1);\n            } else {\n                prefix_lengths.insert(string.size()\
    \ - 1);\n            }\n        }\n    }\n    return std::move(strings);\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9sx5gl6v.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp9sx5gl6v.cpp:19:55: error: expected \u2018]\u2019 before \u2018:\u2019\
    \ token\n   19 |         if (string.size() >= prefix.size() && string[0:prefix.size()]\
    \ == prefix) {\n      |                                                      \
    \ ^\n      |                                                       ]\n/tmp/tmp9sx5gl6v.cpp:19:55:\
    \ error: expected \u2018)\u2019 before \u2018:\u2019 token\n   19 |         if\
    \ (string.size() >= prefix.size() && string[0:prefix.size()] == prefix) {\n  \
    \    |            ~                                          ^\n      |      \
    \                                                 )\n/tmp/tmp9sx5gl6v.cpp:19:69:\
    \ error: expected primary-expression before \u2018]\u2019 token\n   19 |     \
    \    if (string.size() >= prefix.size() && string[0:prefix.size()] == prefix)\
    \ {\n      |                                                                 \
    \    ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size() >= prefix.size());\n\
    \  std::vector<std::string> res;\n  std::string prefix = prefix;\n  while (strings.size()\
    \ > 0) {\n    if (strings[0].length() >= prefix.size()) {\n      res.push_back(strings.front());\n\
    \      strings.erase(strings.begin());\n    } else {\n      break;\n    }\n  }\n\
    \  return res;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpowq5iqyu.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpowq5iqyu.cpp:11:15: error: declaration of \u2018std::string prefix\u2019\
    \ shadows a parameter\n   11 |   std::string prefix = prefix;\n      |       \
    \        ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto iter = strings.begin(); iter != strings.end(); ++iter) {\n        if (iter->find(prefix)\
    \ == 0) {\n            result.push_back(iter);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaw20j5jx.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpaw20j5jx.cpp:12:34: error: no matching function for call to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::push_back(__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >&)\u2019\n   12 |          \
    \   result.push_back(iter);\n      |                                  ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpaw20j5jx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019 to \u2018const value_type&\u2019\
    \ {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 1184 |       push_back(const\
    \ value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    // Filter the input list to only the ones\
    \ starting with the given prefix.\n    auto it = std::sregex_iterator(strings.begin(),\
    \ strings.end(), std::regex(prefix));\n    std::vector<std::string> out;\n   \
    \ // Append the elements from the input list to our output list\n    std::copy(it,\
    \ std::sregex_iterator(), std::back_inserter(out));\n    return out;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuan7tn6v.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpuan7tn6v.cpp:10:86: error: no matching function for call to \u2018\
    std::__cxx11::regex_iterator<__gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ > >::regex_iterator(std::vector<std::__cxx11::basic_string<char> >::iterator,\
    \ std::vector<std::__cxx11::basic_string<char> >::iterator, std::__cxx11::regex)\u2019\
    \n   10 |     auto it = std::sregex_iterator(strings.begin(), strings.end(), std::regex(prefix));\n\
    \      |                                                                     \
    \                 ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpuan7tn6v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2552:7:\
    \ note: candidate: \u2018std::__cxx11::regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>::regex_iterator(const\
    \ std::__cxx11::regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>&) [with _Bi_iter\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; _Ch_type = char; _Rx_traits = std::__cxx11::regex_traits<char>]\u2019\n 2552\
    \ |       regex_iterator(const regex_iterator&) = default;\n      |       ^~~~~~~~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2552:7: note:\
    \   candidate expects 1 argument, 3 provided\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2536:7:\
    \ note: candidate: \u2018std::__cxx11::regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>::regex_iterator(_Bi_iter,\
    \ _Bi_iter, const regex_type&, std::regex_constants::match_flag_type) [with _Bi_iter\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; _Ch_type = char; _Rx_traits = std::__cxx11::regex_traits<char>; std::__cxx11::regex_iterator<_Bi_iter,\
    \ _Ch_type, _Rx_traits>::regex_type = std::__cxx11::basic_regex<char"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> new_strings;\n  for\
    \ (auto s: strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n     \
    \ new_strings.push_back(s);\n    }\n  }\n  return new_strings;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<bool> seen(prefix.size(), false);\n\
    \    for (auto it=strings.begin(); it!=strings.end(); ++it) {\n        std::string\
    \ str = *it;\n        if (str.find(prefix) == 0) {\n            seen[str.size()]\
    \ = true;\n        }\n    }\n    std::vector<std::string> result;\n    for (auto\
    \ it=strings.begin(); it!=strings.end(); ++it) {\n        if (seen[*it]) {\n \
    \           result.push_back(*it);\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmporeceavm.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmporeceavm.cpp:18:17: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::vector<bool>\u2019 and \u2018std::__cxx11::basic_string<char>\u2019\
    )\n   18 |         if (seen[*it]) {\n      |                 ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:68,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmporeceavm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_bvector.h:886:7:\
    \ note: candidate: \u2018std::vector<bool, _Alloc>::reference std::vector<bool,\
    \ _Alloc>::operator[](std::vector<bool, _Alloc>::size_type) [with _Alloc = std::allocator<bool>;\
    \ std::vector<bool, _Alloc>::reference = std::_Bit_reference; std::vector<bool,\
    \ _Alloc>::size_type = long unsigned int]\u2019\n  886 |       operator[](size_type\
    \ __n)\n      |       ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_bvector.h:886:28:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018std::vector<bool>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    }\n  886 |       operator[](size_type __n)\n      |                  ~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_bvector.h:893:7:\
    \ note: candidate: \u2018std::vector<bool, _Alloc>::const_reference std::vector<bool,\
    \ _Alloc>::operator[](std::vector<bool, _Alloc>::size_type) const [with _Alloc\
    \ = std::allocator<bool>; std::vector<bool, _Alloc>::const_reference = bool; std::vector<bool,\
    \ _Alloc>::size_type = long unsigned int]\u2019\n  893 |       operator[](size_type\
    \ __n) const\n      |       ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_bvector.h:893:28:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018std::vector<bool>::size_type"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> results;\n    for\
    \ (std::string s : strings) {\n        if (s.substr(0, prefix.length()) == prefix)\
    \ {\n            results.push_back(s);\n        }\n    }\n    return results;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  // Keep a vector of strings that don't start\
    \ with the given prefix.\n  std::vector<std::string> filtered;\n\n  for (const\
    \ auto& str : strings) {\n    if (str.starts_with(prefix))\n      filtered.push_back(str);\n\
    \  }\n\n  return filtered;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpor2m7550.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpor2m7550.cpp:13:13: error: \u2018const class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018starts_with\u2019\n   13 |     if (str.starts_with(prefix))\n\
    \      |             ^~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(!prefix.empty() && \"empty prefix shouldn't\
    \ be allowed\");\n  auto itBegin = strings.begin();\n  auto itEnd = strings.end();\n\
    \  for (; itBegin != itEnd; ++itBegin) {\n    if (std::strncmp(prefix.c_str(),\
    \ itBegin->c_str(), prefix.size()) == 0) {\n      it = itBegin;\n      break;\n\
    \    }\n  }\n  if (it == strings.end()) {\n    return {};\n  }\n  return std::vector<std::string>{itBegin,\
    \ it};\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpq1f0ckpu.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpq1f0ckpu.cpp:14:7: error: \u2018it\u2019 was not declared in this scope;\
    \ did you mean \u2018int\u2019?\n   14 |       it = itBegin;\n      |       ^~\n\
    \      |       int\n/tmp/tmpq1f0ckpu.cpp:18:7: error: \u2018it\u2019 was not declared\
    \ in this scope; did you mean \u2018int\u2019?\n   18 |   if (it == strings.end())\
    \ {\n      |       ^~\n      |       int\n/tmp/tmpq1f0ckpu.cpp:21:44: error: \u2018\
    it\u2019 was not declared in this scope; did you mean \u2018int\u2019?\n   21\
    \ |   return std::vector<std::string>{itBegin, it};\n      |                 \
    \                           ^~\n      |                                      \
    \      int\n/tmp/tmpq1f0ckpu.cpp:21:46: error: no matching function for call to\
    \ \u2018std::vector<std::__cxx11::basic_string<char> >::vector(<brace-enclosed\
    \ initializer list>)\u2019\n   21 |   return std::vector<std::string>{itBegin,\
    \ it};\n      |                                              ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpq1f0ckpu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:650:2:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::vector<_Tp,\
    \ _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&)\u2019\
    \n  650 |  vector(_InputIterator __first, _InputIterator __last,\n      |  ^~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:650:2: note:\
    \   template argument deduction/substitution failed:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:622:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>,\
    \ const allocator_type&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<cha"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> out(std::begin(strings),\
    \ std::end(strings));\n    std::remove_copy_if(std::begin(out), std::end(out),\
    \ [&prefix](std::string s) {\n        return s.starts_with(prefix);\n    });\n\
    \    return out;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n  \
    \  assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpylyr_5he.cpp: In lambda function:\n/tmp/tmpylyr_5he.cpp:11:18:\
    \ error: \u2018std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018starts_with\u2019\n   11 |         return s.starts_with(prefix);\n\
    \      |                  ^~~~~~~~~~~\n/tmp/tmpylyr_5he.cpp: In function \u2018\
    std::vector<std::__cxx11::basic_string<char> > filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)\u2019:\n/tmp/tmpylyr_5he.cpp:12:6: error: no matching function\
    \ for call to \u2018remove_copy_if(std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator, std::vector<std::__cxx11::basic_string<char> >::iterator, filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>)\u2019\n   12 |     });\n      |    \
    \  ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpylyr_5he.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:703:5:\
    \ note: candidate: \u2018template<class _IIter, class _OIter, class _Predicate>\
    \ _OIter std::remove_copy_if(_IIter, _IIter, _OIter, _Predicate)\u2019\n  703\
    \ |     remove_copy_if(_InputIterator __first, _InputIterator __last,\n      |\
    \     ^~~~~~~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:703:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpylyr_5he.cpp:12:6:\
    \ note:   candidate expects 4 arguments, 3 provided\n   12 |     });\n      |\
    \      ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string>::iterator it;\n \
    \ it = std::find_if(strings.begin(), strings.end(), [&prefix](std::string s) {\
    \ return s.substr(0, prefix.length()) == prefix; });\n  strings.erase(it, strings.end());\n\
    \  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpo018nccz: /tmp/tmpo018nccz.cpp:17: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  std::copy_if(strings.begin(),\
    \ strings.end(), std::back_inserter(result),\n    [](const std::string& s) { return\
    \ s.find(prefix) == 0; });\n  return result;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplvoyrmga.cpp: In lambda function:\n/tmp/tmplvoyrmga.cpp:11:46:\
    \ error: \u2018prefix\u2019 is not captured\n   11 |     [](const std::string&\
    \ s) { return s.find(prefix) == 0; });\n      |                              \
    \                ^~~~~~\n/tmp/tmplvoyrmga.cpp:11:6: note: the lambda has no capture-default\n\
    \   11 |     [](const std::string& s) { return s.find(prefix) == 0; });\n    \
    \  |      ^\n/tmp/tmplvoyrmga.cpp:8:89: note: \u2018std::string prefix\u2019 declared\
    \ here\n    8 | std::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n      |                                    \
    \                                         ~~~~~~~~~~~~^~~~~~\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n   \
    \              from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplvoyrmga.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:\
    \ In instantiation of \u2018_OIter std::copy_if(_IIter, _IIter, _OIter, _Predicate)\
    \ [with _IIter = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _OIter = std::back_insert_iterator<std::vector<std::__cxx11::basic_string<char>\
    \ > >; _Predicate = filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)>]\u2019:\n/tmp/tmplvoyrmga.cpp:11:61:\
    \   required from here\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:749:12:\
    \ error: could not convert \u2018__pred.filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(const string&)>((*(const string*)(& __first.__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >::operator*())))\u2019 from\
    \ \u2018void\u2019 to \u2018bool\u2019\n  749 |  if (__pred(*__first))\n     \
    \ |      ~~~~~~^~~~~~~~~~\n      |            |\n      |            void\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> ret;\n  for (auto\
    \ &s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      ret.push_back(s);\n\
    \    }\n  }\n  return ret;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string>::iterator it = std::begin(strings);\n\
    \  while (it != std::end(strings)) {\n    if (it->substr(0, prefix.length()) ==\
    \ prefix) {\n      it = std::erase(it);\n    } else {\n      ++it;\n    }\n  }\n\
    \  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph6sj4rac.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmph6sj4rac.cpp:12:17: error: \u2018erase\u2019 is not a member of \u2018\
    std\u2019\n   12 |       it = std::erase(it);\n      |                 ^~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\n\
    \    std::string::size_type found_pos = std::string::npos;\n    std::string prefix\
    \ = prefix;\n    for (auto const &string : strings) {\n        if (found_pos ==\
    \ std::string::npos && string.length() >= prefix.length()) {\n            found_pos\
    \ = 0;\n        }\n        if (found_pos == 0) {\n            found_pos = string.find(prefix);\n\
    \        }\n        if (found_pos != std::string::npos) {\n            strings.erase(std::remove(strings.begin(),\
    \ strings.end(), string), strings.end());\n        }\n    }\n    return strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp442z4z2d.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp442z4z2d.cpp:11:17: error: declaration of \u2018std::string prefix\u2019\
    \ shadows a parameter\n   11 |     std::string prefix = prefix;\n      |     \
    \            ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  auto iter\
    \ = strings.begin();\n  while (iter != strings.end()) {\n    if ((*iter).compare(0,\
    \ prefix.size(), prefix) == 0) {\n      result.push_back(*iter);\n    }\n    iter++;\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (std::string s : strings) {\n        if (s[0] == prefix) {\n            result.push_back(s);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgmmr3fum.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpgmmr3fum.cpp:11:18: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   11 |         if (s[0] == prefix) {\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpgmmr3fum.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpgmmr3fum.cpp:11:21:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   11 |         if (s[0] == prefix) {\n      |     \
    \                ^~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpgmmr3fum.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    if (strings.empty()) return {};\n    auto\
    \ it = std::begin(strings);\n    for (auto const & s : strings) {\n        if\
    \ (s.starts_with(prefix)) {\n            it = std::next(it, s.size());\n     \
    \   }\n    }\n    return std::vector<std::string>(it, std::end(strings));\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprag765ir.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmprag765ir.cpp:12:15: error: \u2018const class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018starts_with\u2019\n   12 |         if (s.starts_with(prefix))\
    \ {\n      |               ^~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto& string : strings) {\n    if (string.substr(0, prefix.size()) == prefix)\
    \ {\n      result.push_back(string);\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    auto\
    \ it = strings.begin();\n    while (it != strings.end()) {\n        if (it->find(prefix)\
    \ == 0) {\n            result.push_back(*it);\n        }\n        ++it;\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string>::iterator it;\n \
    \ std::string prefix_str = prefix + \".\";\n  assert(prefix_str.size() <= prefix.size());\n\
    \  it = std::find_if(strings.begin(), strings.end(), [&](std::string &s) {\n \
    \   return s.compare(0, prefix_str.size(), prefix_str) == 0;\n  });\n  return\
    \ it != strings.end() ? std::vector<std::string>{it, strings.end()} : std::vector<std::string>();\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpo46o5cki: /tmp/tmpo46o5cki.cpp:11: std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):\
    \ Assertion `prefix_str.size() <= prefix.size()' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> out;\n  std::string\
    \ prefix_str = prefix + std::string(\"*\");\n  for (auto& str : strings) {\n \
    \   if (str.find(prefix_str) == 0) {\n      out.push_back(str);\n    }\n  }\n\
    \  return out;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpdsuj4r_l: /tmp/tmpdsuj4r_l.cpp:21: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size() != 0);\n  assert(strings.size()\
    \ >= prefix.size());\n  std::vector<std::string> result;\n  for (int i = 0; i\
    \ < prefix.size(); i++) {\n    result.push_back(strings[i]);\n  }\n  for (int\
    \ i = 0; i < strings.size(); i++) {\n    if (strings[i].compare(0, prefix.size(),\
    \ prefix) == 0) {\n      result.push_back(strings[i]);\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpfvw758hy: /tmp/tmpfvw758hy.cpp:9: std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):\
    \ Assertion `strings.size() != 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\n\
    \    std::string s = prefix;\n    strings.erase(std::remove_if(strings.begin(),\
    \ strings.end(), [&](const std::string &str) {\n        return str.size() >= s.size()\
    \ && str.substr(0, s.size) == s;\n    }), strings.end());\n    return strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9umduv39.cpp: In lambda function:\n/tmp/tmp9umduv39.cpp:12:58:\
    \ error: invalid use of non-static member function \u2018std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size()\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n   12 |         return str.size() >= s.size() && str.substr(0, s.size)\
    \ == s;\n      |                                                        ~~^~~~\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9umduv39.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:930:7:\
    \ note: declared here\n  930 |       size() const _GLIBCXX_NOEXCEPT\n      | \
    \      ^~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:71,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \     "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto& s : strings) {\n    if (s.substr(0, prefix.length()) == prefix) {\n  \
    \    result.push_back(s);\n    }\n  }\n  return result;\n}\nint main() {\n   \
    \ auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(!strings.empty());\n  auto it = std::find_if(strings.begin(),\
    \ strings.end(), [&prefix](std::string s) {\n    return s.compare(0, prefix.size(),\
    \ prefix) == 0;\n  });\n  std::vector<std::string> res;\n  if (it != strings.end())\
    \ {\n    res.push_back(*it);\n  }\n  return res;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmp0txl72lf: /tmp/tmp0txl72lf.cpp:9: std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):\
    \ Assertion `!strings.empty()' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto& s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n    \
    \  result.push_back(s);\n    }\n  }\n  return result;\n}\nint main() {\n    auto\
    \ candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::ostringstream oss;\n    oss << prefix;\n\
    \    std::string prefix = oss.str();\n\n    for (std::string s : strings) {\n\
    \        if (s.substr(0, prefix.length()) == prefix) {\n            strings.erase(strings.begin());\n\
    \            break;\n        }\n    }\n    return strings;\n}\nint main() {\n\
    \    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2k22bp90.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp2k22bp90.cpp:11:17: error: declaration of \u2018std::string prefix\u2019\
    \ shadows a parameter\n   11 |     std::string prefix = oss.str();\n      |  \
    \               ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto\
    \ &string : strings) {\n    if (string.substr(0, prefix.size()) == prefix) {\n\
    \      result.emplace_back(string);\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    for (std::string word : strings) {\n   \
    \     if (word.substr(0, prefix.size()) == prefix) {\n            strings.erase(strings.begin()\
    \ + string::npos);\n        }\n    }\n    return strings;\n}\nint main() {\n \
    \   auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph_e3ww5h.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmph_e3ww5h.cpp:11:45: error: \u2018string\u2019 has not been declared\n\
    \   11 |             strings.erase(strings.begin() + string::npos);\n      | \
    \                                            ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::function<bool(std::string)> predicate\
    \ = [](std::string s) { return s.substr(0, prefix.length()) == prefix; };\n  \
    \  return std::remove_if(strings.begin(), strings.end(), predicate);\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_k9a05wi.cpp: In lambda function:\n/tmp/tmp_k9a05wi.cpp:9:89: error:\
    \ \u2018prefix\u2019 is not captured\n    9 |     std::function<bool(std::string)>\
    \ predicate = [](std::string s) { return s.substr(0, prefix.length()) == prefix;\
    \ };\n      |                                                                \
    \                         ^~~~~~\n/tmp/tmp_k9a05wi.cpp:9:51: note: the lambda\
    \ has no capture-default\n    9 |     std::function<bool(std::string)> predicate\
    \ = [](std::string s) { return s.substr(0, prefix.length()) == prefix; };\n  \
    \    |                                                   ^\n/tmp/tmp_k9a05wi.cpp:8:89:\
    \ note: \u2018std::string prefix\u2019 declared here\n    8 | std::vector<std::string>\
    \ filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n \
    \     |                                                                      \
    \       ~~~~~~~~~~~~^~~~~~\n/tmp/tmp_k9a05wi.cpp:9:109: error: \u2018prefix\u2019\
    \ is not captured\n    9 |     std::function<bool(std::string)> predicate = [](std::string\
    \ s) { return s.substr(0, prefix.length()) == prefix; };\n      |            \
    \                                                                            \
    \                     ^~~~~~\n/tmp/tmp_k9a05wi.cpp:9:51: note: the lambda has\
    \ no capture-default\n    9 |     std::function<bool(std::string)> predicate =\
    \ [](std::string s) { return s.substr(0, prefix.length()) == prefix; };\n    \
    \  |                                                   ^\n/tmp/tmp_k9a05wi.cpp:8:89:\
    \ note: \u2018std::string prefix\u2019 declared here\n    8 | std::vector<std::string>\
    \ filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n \
    \     |                                                                      \
    \       ~~~~~~~~~~~~^~~~~~\n/tmp/tmp_k9a05wi.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp_k9a05wi.cpp:9:117: error: conversion from \u2018filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)::<lambda(std::string)>\u2019 to non-scalar type \u2018std::func"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (const\
    \ auto &str : strings) {\n    if (str.starts_with(prefix)) {\n      result.push_back(str);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp955fjpjx.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp955fjpjx.cpp:11:13: error: \u2018const class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018starts_with\u2019\n   11 |     if (str.starts_with(prefix))\
    \ {\n      |             ^~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto\
    \ &string : strings) {\n    if (string.substr(0, prefix.size()) == prefix) {\n\
    \      result.push_back(std::move(string));\n    }\n  }\n  return result;\n}\n\
    int main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (std::string\
    \ s : strings) {\n    if (0 == s.find(prefix)) {\n      result.push_back(s);\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::sort(strings.begin(), strings.end());\n\
    \  if (strings.size() < 2)\n    return strings;\n  auto prefix_index = std::find_if(strings.begin(),\
    \ strings.end(), [&](const string& s) {\n    return s.compare(0, prefix.size(),\
    \ prefix) == 0;\n  });\n  std::vector<std::string> result;\n  auto it = prefix_index;\n\
    \  while (it != strings.end()) {\n    result.emplace_back(*it);\n    it = std::find_if(++it,\
    \ strings.end(), [&](const string& s) {\n      return s.compare(0, prefix.size(),\
    \ prefix) == 0;\n    });\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()), (\"\
    john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprxfz7bww.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmprxfz7bww.cpp:12:78: error: \u2018string\u2019 does not name a type;\
    \ did you mean \u2018strings\u2019?\n   12 |   auto prefix_index = std::find_if(strings.begin(),\
    \ strings.end(), [&](const string& s) {\n      |                             \
    \                                                 ^~~~~~\n      |            \
    \                                                                  strings\n/tmp/tmprxfz7bww.cpp:\
    \ In lambda function:\n/tmp/tmprxfz7bww.cpp:14:5: error: expected \u2018{\u2019\
    \ before \u2018;\u2019 token\n   14 |   });\n      |     ^\n/tmp/tmprxfz7bww.cpp:\
    \ In function \u2018std::vector<std::__cxx11::basic_string<char> > filter_by_prefix(std::vector<std::__cxx11::basic_string<char>\
    \ >, std::string)\u2019:\n/tmp/tmprxfz7bww.cpp:14:5: error: expected \u2018)\u2019\
    \ before \u2018;\u2019 token\n   14 |   });\n      |     ^\n      |     )\n/tmp/tmprxfz7bww.cpp:12:35:\
    \ note: to match this \u2018(\u2019\n   12 |   auto prefix_index = std::find_if(strings.begin(),\
    \ strings.end(), [&](const string& s) {\n      |                             \
    \      ^\n/tmp/tmprxfz7bww.cpp:16:13: error: unable to deduce \u2018auto\u2019\
    \ from \u2018prefix_index\u2019\n   16 |   auto it = prefix_index;\n      |  \
    \           ^~~~~~~~~~~~\n/tmp/tmprxfz7bww.cpp:19:54: error: \u2018string\u2019\
    \ does not name a type; did you mean \u2018strings\u2019?\n   19 |     it = std::find_if(++it,\
    \ strings.end(), [&](const string& s) {\n      |                             \
    \                         ^~~~~~\n      |                                    \
    \                  strings\n/tmp/tmprxfz7bww.cpp: In lambda function:\n/tmp/tmprxfz7bww.cpp:21:7:\
    \ error: expected \u2018{\u2019 before \u2018;\u2019 token\n   21 |     });\n\
    \      |       ^\n/tmp/tmprxfz7bww.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmprxfz7bww.cpp:21:7: error: expected \u2018)\u2019 before \u2018;\u2019\
    \ token\n   21 |     });\n      |       ^\n      |       )\n/tmp/tmprxfz7bww.cpp:19:22:\
    \ note: to match this \u2018(\u2019\n   19 "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  // Initialize output list.\n  std::vector<std::string>\
    \ output;\n  // Scan through strings and copy only the ones starting with the\
    \ given prefix.\n  for (const auto& s : strings) {\n    if (s.find(prefix) ==\
    \ 0) {\n      output.push_back(s);\n    }\n  }\n  // Return result.\n  return\
    \ output;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size() > 0);\n  assert(strings[0].size()\
    \ > 0);\n  std::size_t prefix_len = prefix.size();\n  std::vector<std::string>\
    \ output_strings;\n  for (auto & s : strings) {\n    if (s.substr(0, prefix_len)\
    \ == prefix) {\n      output_strings.push_back(s);\n    }\n  }\n  return output_strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmp8jilidy6: /tmp/tmp8jilidy6.cpp:9: std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):\
    \ Assertion `strings.size() > 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  std::string prefix_copy = prefix + strings[0];\n\
    \  std::for_each(strings.begin(), strings.end(), [&](std::string string) {\n \
    \   std::string copy = prefix_copy + string;\n    if (copy.substr(0, prefix_copy.size())\
    \ == prefix_copy)\n      strings.erase(strings.begin() + strings.begin() + 1);\n\
    \  });\n  return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt9j_dufb.cpp: In lambda function:\n/tmp/tmpt9j_dufb.cpp:13:37:\
    \ error: no match for \u2018operator+\u2019 (operand types are \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019} and \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019})\n   13 |       strings.erase(strings.begin()\
    \ + strings.begin() + 1);\n      |                     ~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~\n\
    \      |                                  |                 |\n      |       \
    \                           |                 __normal_iterator<[...],[...]>\n\
    \      |                                  __normal_iterator<[...],[...]>\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpt9j_dufb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:859:7:\
    \ note: candidate: \u2018__gnu_cxx::__normal_iterator<_Iterator, _Container> __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>::operator+(__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type)\
    \ const [with _Iterator = std::__cxx11::basic_string<char>*; _Container = std::vector<std::__cxx11::basic_string<char>\
    \ >; __gnu_cxx::__normal_iterato"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> results;\n    for\
    \ (std::string s : strings) {\n        if (s.substr(0, prefix.size()) == prefix)\
    \ {\n            results.push_back(s);\n        }\n    }\n    return results;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::sort(strings.begin(), strings.end());\n\
    \    auto begin = std::find_if(strings.begin(), strings.end(), [&](const auto&\
    \ s) { return s.substr(0, prefix.size()) == prefix; });\n    std::vector<std::string>\
    \ result;\n    std::copy(begin, strings.end(), std::back_inserter(result));\n\
    \    return result;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpzr8aygqz: /tmp/tmpzr8aygqz.cpp:18: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto it = std::begin(strings);\n    auto\
    \ last = std::end(strings);\n    while (it != last) {\n        if (it->substr(0,\
    \ prefix.size()) == prefix) {\n            ++it;\n        } else {\n         \
    \   strings.erase(it++);\n        }\n    }\n    return strings;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpraa3esza: /tmp/tmpraa3esza.cpp:23: int main(): Assertion `candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    auto it = std::begin(strings);\n    while\
    \ (it != std::end(strings)) {\n        if (std::begin(*it) == prefix) {\n    \
    \        it = std::next(it);\n        } else {\n            ++it;\n        }\n\
    \    }\n    return strings;\n}\nint main() {\n    auto candidate = filter_by_prefix;\n\
    \    assert(candidate((std::vector<std::string>()), (\"john\")) == (std::vector<std::string>()));\n\
    \    assert(candidate((std::vector<std::string>({\"xxx\", \"asd\", \"xxy\", \"\
    john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp758b599p.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmp758b599p.cpp:11:29: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018\
    __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >\u2019}\
    \ and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   11 |         if (std::begin(*it) == prefix) {\n      |             ~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~\n      |                       |        |\n      |               \
    \        |        std::string {aka std::__cxx11::basic_string<char>}\n      |\
    \                       std::__cxx11::basic_string<char>::iterator {aka __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp758b599p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp758b599p.cpp:11:32:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   11 |         if (std::begin(*it) == prefix) {\n      |                  \
    \              ^~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    assert(strings.size() >= prefix.size());\n\
    \    std::vector<std::string> result;\n    for (size_t i = 0; i < (size_t)(prefix.size());\
    \ ++i) {\n        if (strings[i].compare(0, prefix.size(), prefix) == 0) {\n \
    \           result.push_back(strings[i]);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmpfmsdvg73: /tmp/tmpfmsdvg73.cpp:9: std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):\
    \ Assertion `strings.size() >= prefix.size()' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> out;\n    for (std::string\
    \ s : strings) {\n        if (s.compare(0, prefix.size(), prefix) == 0) {\n  \
    \          out.push_back(s);\n        }\n    }\n    return out;\n}\nint main()\
    \ {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  auto it = std::begin(strings);\n  while (it\
    \ != std::end(strings)) {\n    if (it->substr(0, prefix.size()) == prefix) {\n\
    \      it = std::erase(it);\n    } else {\n      ++it;\n    }\n  }\n  return strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzdl9bifj.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string)\u2019\
    :\n/tmp/tmpzdl9bifj.cpp:12:17: error: \u2018erase\u2019 is not a member of \u2018\
    std\u2019\n   12 |       it = std::erase(it);\n      |                 ^~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n  assert(strings.size() != 0);\n  assert(strings.size()\
    \ >= prefix.size());\n\n  std::string prefix_copy(prefix);\n  std::replace(prefix_copy.begin(),\
    \ prefix_copy.end(), '*', '?');\n\n  std::sort(strings.begin(), strings.end());\n\
    \n  std::string prefix_str(prefix_copy);\n\n  // Effective size of the prefix\
    \ after filtering is calculated.\n  std::size_t prefix_size = prefix_str.size();\n\
    \n  // Filter out those strings that do not start with the given prefix.\n  std::string\
    \ all_strings(std::accumulate(strings.begin(), strings.end(), std::string(), [](std::string\
    \ result, std::string const& s) {\n    return s + result;\n  }));\n  std::vector<std::string>\
    \ filtered_strings;\n\n  auto prefix_itr = std::search(all_strings.begin(), all_strings.end(),\
    \ prefix_str.begin(), prefix_str.end());\n  if (prefix_itr == all_strings.end())\
    \ {\n    filtered_strings.push_back(*strings.begin());\n  } else {\n    std::string\
    \ sub_strings(all_strings);\n    sub_strings.erase(prefix_itr, all_strings.end());\n\
    \    filtered_strings.push_back(std::string(sub_strings));\n  }\n  return filtered_strings;\n\
    }\nint main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: "tmppt_ejf2f: /tmp/tmppt_ejf2f.cpp:9: std::vector<std::__cxx11::basic_string<char>\
    \ > filter_by_prefix(std::vector<std::__cxx11::basic_string<char> >, std::string):\
    \ Assertion `strings.size() != 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of\
    \ strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([],\
    \ 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n\
    // ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string>\
    \ strings, std::string prefix) {\n    std::vector<std::string> result;\n    for\
    \ (auto s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n\
    \            result.push_back(s);\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = filter_by_prefix;\n    assert(candidate((std::vector<std::string>()),\
    \ (\"john\")) == (std::vector<std::string>()));\n    assert(candidate((std::vector<std::string>({\"\
    xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"})), (\"xxx\")) == (std::vector<std::string>({\"\
    xxx\", \"xxxAAA\", \"xxx\"})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
