name: HumanEval_148_bf
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double xx = 0.0, yy = 0.0, zz = 0.0, xy = 0.0, yz\
    \ = 0.0, zx = 0.0, \n           xz = 0.0, yx = 0.0, zy = 0.0, xy = 0.0;\n    double\
    \ a1 = 2.35308454553364;\n    double a2 = -4.326921768807514;\n    double a3 =\
    \ 1.79284308759069;\n    double a4 = -5.875988842590305;\n    double a5 = 2.12702867722618;\n\
    \    double a6 = 6.95263422202788;\n    double a7 = -25.3762024553629;\n    double\
    \ a8 = -3.87401589531688;\n    double a9 = 1.59055757861436;\n    double a10 =\
    \ 5.4608790603477;\n    double a11 = 16.4394966894459;\n    double a12 = -21.3417325416327;\n\
    \    double a13 = 6.71177030571566;\n    double a14 = -21.6925397749321;\n   \
    \ double a15 = 2.55188932111017;\n    double a16 = 8.32504192827899;\n    double\
    \ a17 = -9.52739726703416;\n    double a18 = 1.77306445461866;\n    double a19\
    \ = -7.90134830347784;\n    double a20 = -2.12328779832508;\n    double a21 =\
    \ -6.44766333217228;\n    double a22 = 2.79498123287809;\n    double a23 = 2.22663332172201;\n\
    \    double a24 = -2.36172282663331;\n    double a25 = -2.42789981232879;\n  \
    \  double a26 = -4.76633321722826;\n    double a27 = 4.278998123287808;\n    double\
    \ a28 = 6.44766333217228;\n    double a29 = -2.79498123287809;\n    double a30\
    \ = 8.32504192827899;\n    double a31 = -9.52739726703416;\n    double a32 = 1.77306445461866;\n\
    \    double a33 = -\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc4pk8tod.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpc4pk8tod.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpc4pk8tod.cpp:18:42: error: redeclaration\
    \ of \u2018double xy\u2019\n   18 |            xz = 0.0, yx = 0.0, zy = 0.0, xy\
    \ = 0.0;\n      |                                          ^~\n/tmp/tmpc4pk8tod.cpp:17:42:\
    \ note: \u2018double xy\u2019 previously declared here\n   17 |     double xx\
    \ = 0.0, yy = 0.0, zz = 0.0, xy = 0.0, yz = 0.0, zx = 0.0,\n      |          \
    \                                ^~\n/tmp/tmpc4pk8tod.cpp:52:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   52 | }\n      | ^\n/tmp/tmpc4pk8tod.cpp:52:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpc4pk8tod.cpp:2:\n/tmp/tmpc4pk8tod.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpc4pk8tod.cpp:55:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   55 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpc4pk8tod.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_Bi"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> planets{ \n    \"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \n    \"\
    Neptune\", \"Pluto\" };\n  std::map<int, std::string> orbits;\n  for (const auto&\
    \ planet : planets) {\n    orbits[planets.find(planet)->second] = planet;\n  }\n\
    \  std::string orbit1, orbit2;\n  auto orbit1itr = orbits.find(planet1);\n  if\
    \ (orbit1itr == orbits.end()) {\n    return std::tuple<std::string,>();\n  } else\
    \ {\n    orbit1 = orbit1itr->second;\n  }\n  auto orbit2itr = orbits.find(planet2);\n\
    \  if (orbit2itr == orbits.end()) {\n    return std::tuple<std::string,>();\n\
    \  } else {\n    orbit2 = orbit2itr->second;\n  }\n  std::vector<std::string>\
    \ results;\n  auto orbit1itr1 = orbits.find(orbit1);\n  if (orbit1itr1 == orbits.end())\
    \ {\n    return results;\n  } else {\n    orbit1 = orbit1itr1->second;\n  }\n\
    \  auto orbit2itr1 = orbits.find(orbit2);\n  if (orbit2itr1 == orbits.end()) {\n\
    \    return results;\n  } else {\n    orbit2 = orbit2itr1->second;\n  }\n  int\
    \ distance = get_distance(orbit1, orbit2);\n  if (distance <= 14 && distance >=\
    \ 8) {\n    results.push_back(orbit1);\n    results.push_back(orbit2);\n  } else\
    \ if (distance <= 8 && distance >= 4) {\n    results.push_back(orbit2);\n    results.push_back(orbit1);\n\
    \  } else if (distance <= 4 && distance >= 2) {\n    results.push_back(orbit1);\n\
    \    results.push_back(orbit2);\n  }\n  std::sort(results.begin(), results.end());\n\
    \  if (results.back() == results[0]) {\n    return std::tuple<std::string, std::string>();\n\
    \  } else {\n    return std::tuple<std::string>(results.begin(), results.end());\n\
    \  }\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0lapv1fx.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp0lapv1fx.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp0lapv1fx.cpp:22:20: error: \u2018\
    class std::vector<std::__cxx11::basic_string<char> >\u2019 has no member named\
    \ \u2018find\u2019\n   22 |     orbits[planets.find(planet)->second] = planet;\n\
    \      |                    ^~~~\n/tmp/tmp0lapv1fx.cpp:25:39: error: no matching\
    \ function for call to \u2018std::map<int, std::__cxx11::basic_string<char> >::find(std::string&)\u2019\
    \n   25 |   auto orbit1itr = orbits.find(planet1);\n      |                  \
    \                     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/map:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:81,\n\
    \                 from /tmp/tmp0lapv1fx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:1168:7:\
    \ note: candidate: \u2018std::map<_Key, _Tp, _Compare, _Alloc>::iterator std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::find(const key_type&) [with _Key = int; _Tp = std::__cxx11::basic_string<char>;\
    \ _Compare = std::less<int>; _Alloc = std::allocator<std::pair<const int, std::__cxx11::basic_string<char>\
    \ > >; std::map<_Key, _Tp, _Compare, _Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const\
    \ int, std::__cxx11::basic_string<char> > >; std::map<_Key, _Tp, _Compare, _Alloc>::key_type\
    \ = int]\u2019\n 1168 |       find(const key_type& __x)\n      |       ^~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:1168:28: note:\
    \   no known conversion for argument 1 from \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} to \u2018const key_type&\u2019 {aka \u2018\
    const int&\u2019}\n 1168 |       find(const key_type& __x)\n      |          \
    \  ~~~~~~~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:1174:2:\
    \ note: candidate: \u2018template<class _Kt> decltype (((std::map<_Key, _Tp, _Compare,\
    \ _Alloc>*)this)->std::map<_Key, _Tp, _Compar"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> result;\n  \n  if( planet1\
    \ == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 ==\
    \ \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"\
    Uranus\" || planet1 == \"Neptune\" || planet2 == \"Mercury\" || planet2 == \"\
    Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\"\
    \ || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\"\
    ) {\n    return std::make_tuple(planet1);\n  }\n  \n  if(planet2 == \"Mercury\"\
    \ || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" || planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1\
    \ == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 ==\
    \ \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\") {\n    return\
    \ std::make_tuple(planet2);\n  }\n  \n  if(planet1 == \"Mercury\" && planet2 ==\
    \ \"Venus\") {\n    std::string s = planet1 + \" \" + \"Mercury \" + \"Venus\"\
    ;\n    result.push_back(s);\n  }\n  \n  if(planet1 == \"Venus\" && planet2 ==\
    \ \"Mercury\") {\n    std::string s = planet1 + \" \" + \"Venus \" + \"Mercury\"\
    ;\n    result.push_back(s);\n  }\n  \n  if(planet1 == \"Earth\" && planet2 ==\
    \ \"Mercury\") {\n    std::string s = planet1 + \" \" + \"Earth \" + \"Mercury\"\
    ;\n    result.push_back(s);\n  }\n  \n  if(planet1 == \"Mercury\" && planet2 ==\
    \ \"Earth\") {\n    std::string s = planet1 + \" \" + \"Mercury \" + \"Earth\"\
    ;\n    result.push_back(s);\n  }\n  \n  if(planet1 == \"Venus\" && planet2 ==\
    \ \"Earth\") {\n    std::string s = planet1 + \" \" + \"Venus \" + \"Earth\";\n\
    \    result.push_back(s);\n  }\n  \n  if(planet1 == \"Earth\" && planet2 == \"\
    Venus\") {\n    std::string s = planet1 + \" \" + \"Ear\n}\nint main() {\n   \
    \ auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_8di6ypz.cpp:53:37: warning: missing terminating \" character\n\
    \   53 |     std::string s = planet1 + \" \" + \"Ear\n      |                \
    \                     ^\n/tmp/tmp_8di6ypz.cpp:53:37: error: missing terminating\
    \ \" character\n   53 |     std::string s = planet1 + \" \" + \"Ear\n      | \
    \                                    ^~~~\n/tmp/tmp_8di6ypz.cpp:16:25: error:\
    \ template argument 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                         ^\n/tmp/tmp_8di6ypz.cpp:\
    \ In function \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmp_8di6ypz.cpp:20:27:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~\n   \
    \   |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmp_8di6ypz.cpp:24:27:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   24 |     return\
    \ std::make_tuple(planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~\n   \
    \   |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmp_8di6ypz.cpp:54:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   54 | }\n \
    \     | ^\n/tmp/tmp_8di6ypz.cpp:54:1: error: expected \u2018,\u2019 or \u2018\
    ;\u2019 before \u2018}\u2019 token\n/tmp/tmp_8di6ypz.cpp:55:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   55 | int main() {\n     \
    \ |            ^\n/tmp/tmp_8di6ypz.cpp:64:1: error: expected \u2018}\u2019 at\
    \ end of input\n   64 | }\n      | ^\n/tmp/tmp_8di6ypz.cpp:16:72: note: to match\
    \ this \u2018{\u2019\n   16 | std::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n      |                                            \
    \                            ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1 == planet2)\n        return std::tuple<std::string,>();\n\
    \    if (planet1 == \"Mercury\")\n        if (planet2 == \"Venus\")\n        \
    \    return std::tuple<std::string,>(\"Mercury\",\"Earth\",\"Mars\",\"Jupiter\"\
    ,\"Saturn\",\"Uranus\",\"Neptune\");\n        else if (planet2 == \"Earth\")\n\
    \            return std::tuple<std::string,>(\"Mercury\",\"Earth\",\"Mars\",\"\
    Jupiter\",\"Saturn\",\"Uranus\");\n        else if (planet2 == \"Mars\")\n   \
    \         return std::tuple<std::string,>(\"Mercury\",\"Earth\",\"Mars\",\"Jupiter\"\
    ,\"Saturn\");\n        else if (planet2 == \"Jupiter\")\n            return std::tuple<std::string,>(\"\
    Mercury\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\");\n        else if (planet2\
    \ == \"Saturn\")\n            return std::tuple<std::string,>(\"Mercury\",\"Earth\"\
    ,\"Mars\",\"Jupiter\",\"Saturn\");\n        else if (planet2 == \"Uranus\")\n\
    \            return std::tuple<std::string,>(\"Mercury\",\"Earth\",\"Mars\",\"\
    Jupiter\",\"Saturn\",\"Uranus\");\n        else if (planet2 == \"Neptune\")\n\
    \            return std::tuple<std::string,>(\"Mercury\",\"Earth\",\"Mars\",\"\
    Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\");\n        else if (planet2 == \"\
    Halley\" || planet2 == \"Victoire\")\n            return std::tuple<std::string,>(\"\
    Mercury\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\",\"\
    Halley\",\"Victoire\");\n        else if (planet2 == \"Earth\" || planet2 == \"\
    Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\"\
    \ || planet2 == \"Neptune\" || planet2 == \"Halley\" || planet2 == \"Victoire\"\
    )\n            return std::tuple<std::string,>(\"Mercury\",\"Earth\",\"Mars\"\
    ,\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\",\"Halley\",\"Victoire\");\n   \
    \     else if (planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"\
    Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\"\
    \ || planet2 == \"Uranus\" || planet2 == \"Neptune\" || \n}\nint main() {\n  \
    \  auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp00_ass2c.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp00_ass2c.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp00_ass2c.cpp:18:39: error: template\
    \ argument 2 is invalid\n   18 |         return std::tuple<std::string,>();\n\
    \      |                                       ^\n/tmp/tmp00_ass2c.cpp:21:43:\
    \ error: template argument 2 is invalid\n   21 |             return std::tuple<std::string,>(\"\
    Mercury\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\");\n\
    \      |                                           ^\n/tmp/tmp00_ass2c.cpp:23:43:\
    \ error: template argument 2 is invalid\n   23 |             return std::tuple<std::string,>(\"\
    Mercury\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\");\n      |    \
    \                                       ^\n/tmp/tmp00_ass2c.cpp:25:43: error:\
    \ template argument 2 is invalid\n   25 |             return std::tuple<std::string,>(\"\
    Mercury\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\");\n      |               \
    \                            ^\n/tmp/tmp00_ass2c.cpp:27:43: error: template argument\
    \ 2 is invalid\n   27 |             return std::tuple<std::string,>(\"Mercury\"\
    ,\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\");\n      |                        \
    \                   ^\n/tmp/tmp00_ass2c.cpp:29:43: error: template argument 2\
    \ is invalid\n   29 |             return std::tuple<std::string,>(\"Mercury\"\
    ,\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\");\n      |                        \
    \                   ^\n/tmp/tmp00_ass2c.cpp:31:43: error: template argument 2\
    \ is invalid\n   31 |             return std::tuple<std::string,>(\"Mercury\"\
    ,\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\");\n      |             \
    \                              ^\n/tmp/tmp00_ass2c.cpp:33:43: error: template\
    \ argument 2 is invalid\n   33 |             return std::tuple<std::string,>(\"\
    Mercury\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\");\n\
    \      |                                           ^\n/tmp/tmp00_ass2c.cpp:35:43:\
    \ error: template argument 2 is invali"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::tuple<std::string, > ans;\n  std::pair<double,\
    \ double> orbit1;\n  std::pair<double, double> orbit2;\n  double distance;\n \
    \ double angle;\n  double distance2;\n  double angle2;\n  double distance1;\n\
    \  double angle1;\n  double distance3;\n  double angle3;\n  double distance4;\n\
    \  double angle4;\n  double distance5;\n  double angle5;\n  double distance6;\n\
    \  double angle6;\n  double distance7;\n  double angle7;\n  double distance8;\n\
    \  double angle8;\n  \n  std::cin >> planet1 >> planet2;\n  if (planet1 != planet2)\
    \ return ans;\n  \n  std::cin >> distance >> angle;\n  if (distance > 100000 ||\
    \ angle > 359.0 || angle < -100.0)\n  {\n    ans = std::make_tuple(\"\");\n  \
    \  return ans;\n  }\n  \n  orbit1 = orbit(planet1, distance, angle);\n  orbit2\
    \ = orbit(planet2, distance, angle);\n  \n  if (std::get<0>(orbit1) < std::get<0>(orbit2))\n\
    \  {\n    distance1 = std::get<0>(orbit1) - orbit1.second;\n    angle1 = std::get<1>(orbit1)\
    \ - orbit1.second;\n    distance2 = std::get<0>(orbit2) - orbit2.second;\n   \
    \ angle2 = std::get<1>(orbit2) - orbit2.second;\n  }\n  else\n  {\n    distance1\
    \ = orbit1.second - std::get<0>(orbit2);\n    angle1 = orbit1.second - std::get<1>(orbit2);\n\
    \    distance2 = std::get<0>(orbit1) - orbit2.second;\n    angle2 = std::get<1>(orbit1)\
    \ - orbit2.second;\n  }\n  \n  distance3 = std::sqrt(distance1 * distance1 + distance2\
    \ * distance2);\n  distance4 = std::sqrt(distance1 * distance1 + distance2 * distance2);\n\
    \  distance5 = std::sqrt(distance1 * distance1 + distance2 * distance2);\n  distance6\
    \ = std::sqrt(distance1 * distance1 + distance2 * distance2);\n  distance7 = std::sqrt(distance1\
    \ * distance1 + distance2 * distance2);\n  distance8 = std::sqrt(distance1 * distance1\
    \ + distance2 * distance2);\n  \n  angle3 = 180.0 - angle1;\n  angle4 = 180.0\
    \ - angle2;\n  angle5 = 180.0 - angle3;\n  angle6 = 180.0 - angle4;\n  angle7\
    \ = 180.0 - angle5;\n  angle8 = 180.0 - angle6;\n  \n  if (angle3 < angle4 \n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzxbbruy3.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpzxbbruy3.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpzxbbruy3.cpp:17:27: error: template\
    \ argument 2 is invalid\n   17 |   std::tuple<std::string, > ans;\n      |   \
    \                        ^\n/tmp/tmpzxbbruy3.cpp:45:26: error: cannot convert\
    \ \u2018std::tuple<const char*>\u2019 to \u2018int\u2019 in assignment\n   45\
    \ |     ans = std::make_tuple(\"\");\n      |           ~~~~~~~~~~~~~~~^~~~\n\
    \      |                          |\n      |                          std::tuple<const\
    \ char*>\n/tmp/tmpzxbbruy3.cpp:49:12: error: \u2018orbit\u2019 was not declared\
    \ in this scope; did you mean \u2018orbit2\u2019?\n   49 |   orbit1 = orbit(planet1,\
    \ distance, angle);\n      |            ^~~~~\n      |            orbit2\n/tmp/tmpzxbbruy3.cpp:81:22:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   81 |   if (angle3\
    \ < angle4\n      |      ~               ^\n      |                      )\n \
    \  82 | }\n      | ~                     \n/tmp/tmpzxbbruy3.cpp:82:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   82 | }\n      | ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzxbbruy3.cpp:2:\n/tmp/tmpzxbbruy3.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpzxbbruy3.cpp:85:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   85 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \       "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 != planet2);\n    \n    double distance\
    \ = 0.0;\n    double orbit1 = 0.0;\n    double orbit2 = 0.0;\n    \n    // compute\
    \ orbital distance\n    distance = distance(planet1, planet2);\n    \n    // compute\
    \ orbital distance to sun\n    orbit1 = distanceToSun(planet1);\n    orbit2 =\
    \ distanceToSun(planet2);\n    \n    // compute orbital distance to planets\n\
    \    orbit1 = distanceToPlanet(distance, planet1, orbit1);\n    orbit2 = distanceToPlanet(distance,\
    \ planet2, orbit2);\n\n    // sort and return\n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp70h6uj9_.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp70h6uj9_.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp70h6uj9_.cpp:24:41: error: \u2018\
    distance\u2019 cannot be used as a function\n   24 |     distance = distance(planet1,\
    \ planet2);\n      |                                         ^\n/tmp/tmp70h6uj9_.cpp:27:14:\
    \ error: \u2018distanceToSun\u2019 was not declared in this scope; did you mean\
    \ \u2018distance\u2019?\n   27 |     orbit1 = distanceToSun(planet1);\n      |\
    \              ^~~~~~~~~~~~~\n      |              distance\n/tmp/tmp70h6uj9_.cpp:31:14:\
    \ error: \u2018distanceToPlanet\u2019 was not declared in this scope\n   31 |\
    \     orbit1 = distanceToPlanet(distance, planet1, orbit1);\n      |         \
    \     ^~~~~~~~~~~~~~~~\n/tmp/tmp70h6uj9_.cpp:35:27: error: cannot convert \u2018\
    std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in return\n   35 |     return std::make_tuple(planet1,\
    \ planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |   \
    \                        |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp70h6uj9_.cpp:2:\n/tmp/tmp70h6uj9_.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp70h6uj9_.cpp:39:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   39 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > result;\n    if (planet1\
    \ == planet2) {\n        return result;\n    }\n    if (planet1 < planet2) {\n\
    \        std::swap(planet1, planet2);\n        std::swap(planet1, planet2);\n\
    \        std::swap(planet1, planet2);\n    }\n    float angle = M_PI / 180.f;\
    \ // angle in radians\n    // First we calculate the distance between the planets\
    \ in AU\n    float distance = std::hypot(planet1.length(), planet2.length());\n\
    \    // Then we calculate the distance between the Sun and the planet in AU\n\
    \    float distance_planet_sun = distance * std::sin(angle);\n    // We subtract\
    \ the distance to Sun from the distance to the planet\n    distance = distance\
    \ - distance_planet_sun;\n    float distance_planet_planet = distance * std::cos(angle);\n\
    \    // We find the orbit of planet2 in the orbit of planet1 with time equal\n\
    \    // to distance in AU\n    float t1 = distance_planet_sun / distance;\n  \
    \  float t2 = distance_planet_planet / distance;\n    // Now we find the orbit\
    \ of planet1 in the orbit of planet2 with time equal\n    // to distance in AU\n\
    \    float t3 = distance_planet_sun / distance;\n    float t4 = distance_planet_planet\
    \ / distance;\n    float tau1 = std::atan(t1);\n    float tau2 = std::atan(t2);\n\
    \    float tau3 = std::atan(t3);\n    float tau4 = std::atan(t4);\n    // The\
    \ first plane is the orbit of planet1 on the right of the orbit of planet2\n \
    \   // the second plane is the orbit of planet2 on the right of the orbit of planet1\n\
    \    // The third plane is the orbit of planet1 on the left of the orbit of planet2\n\
    \    // The fourth plane is the orbit of planet2 on the left of the orbit of planet1\n\
    \    // For example if planet1=\"Earth\" and planet2=\"Mars\" the function returns\
    \ \n    // (\"Mars\", \"Earth\") \n    if (planet2 == \"Earth\") {\n        if\
    \ (planet1 == \"Venus\") {\n            result = std::make_tuple(planet2, \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n            return\
    \ result;\n        }\n        if (planet1 == \"Mars\") {\n            result =\
    \ std::make_tuple(planet1, \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\");\n            return \n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp8brnrqrw.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp8brnrqrw.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp8brnrqrw.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmp8brnrqrw.cpp:54:37: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, const char*, const char*, const char*, const char*, const char*, const char*>\u2019\
    \ to \u2018int\u2019 in assignment\n   54 |             result = std::make_tuple(planet2,\
    \ \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n  \
    \    |                      ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                     |\n      |                      \
    \               std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, const char*, const char*, const char*, const char*,\
    \ const char*, const char*>\n/tmp/tmp8brnrqrw.cpp:58:37: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, const char*, const char*, const char*, const char*, const char*, const char*>\u2019\
    \ to \u2018int\u2019 in assignment\n   58 |             result = std::make_tuple(planet1,\
    \ \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n  \
    \    |                      ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                     |\n      |                      \
    \               std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, const char*, const char*, const char*, const char*,\
    \ const char*, const char*>\n/tmp/tmp8brnrqrw.cpp:60:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   60 | }\n      | ^\n/tmp/tmp8brnrqrw.cpp:59:19:\
    \ error: expected \u2018;\u2019 before \u2018}\u2019 token\n   59 |          \
    \  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    auto x = std::abs(get_planet_orbit(planet1,\
    \ planet2) - get_planet_orbit(planet2, planet1));\n    std::tuple<std::string,\
    \ > result;\n\n    if (x < 365.25 * 24 * 60 * 60) {\n        result.emplace(planet1);\n\
    \        result.emplace(planet2);\n    }\n    else {\n        result.emplace(planet2);\n\
    \        result.emplace(planet1);\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxvluqemx.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpxvluqemx.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpxvluqemx.cpp:18:23: error: \u2018\
    get_planet_orbit\u2019 was not declared in this scope\n   18 |     auto x = std::abs(get_planet_orbit(planet1,\
    \ planet2) - get_planet_orbit(planet2, planet1));\n      |                   \
    \    ^~~~~~~~~~~~~~~~\n/tmp/tmpxvluqemx.cpp:19:29: error: template argument 2\
    \ is invalid\n   19 |     std::tuple<std::string, > result;\n      |         \
    \                    ^\n/tmp/tmpxvluqemx.cpp:22:16: error: request for member\
    \ \u2018emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018\
    int\u2019\n   22 |         result.emplace(planet1);\n      |                ^~~~~~~\n\
    /tmp/tmpxvluqemx.cpp:23:16: error: request for member \u2018emplace\u2019 in \u2018\
    result\u2019, which is of non-class type \u2018int\u2019\n   23 |         result.emplace(planet2);\n\
    \      |                ^~~~~~~\n/tmp/tmpxvluqemx.cpp:26:16: error: request for\
    \ member \u2018emplace\u2019 in \u2018result\u2019, which is of non-class type\
    \ \u2018int\u2019\n   26 |         result.emplace(planet2);\n      |         \
    \       ^~~~~~~\n/tmp/tmpxvluqemx.cpp:27:16: error: request for member \u2018\
    emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018int\u2019\
    \n   27 |         result.emplace(planet1);\n      |                ^~~~~~~\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxvluqemx.cpp:2:\n/tmp/tmpxvluqemx.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpxvluqemx.cpp:33:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   33 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                    "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || \n        planet1 == \"Mars\" || planet1 == \"Jupiter\"\
    \ || planet1 == \"Saturn\" || \n        planet1 == \"Uranus\" || planet1 == \"\
    Neptune\") {\n        std::tuple<std::string, > planets;\n        if (planet2\
    \ == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || \n       \
    \     planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" ||\
    \ \n            planet2 == \"Uranus\" || planet2 == \"Neptune\") {\n         \
    \   return planets;\n        } else {\n            return std::make_tuple(planet1,\
    \ planet2);\n        }\n    } else {\n        return std::make_tuple(planet1,\
    \ planet2);\n    }\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8jyy8dqi.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp8jyy8dqi.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp8jyy8dqi.cpp:20:33: error: template\
    \ argument 2 is invalid\n   20 |         std::tuple<std::string, > planets;\n\
    \      |                                 ^\n/tmp/tmp8jyy8dqi.cpp:26:35: error:\
    \ cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   26 |       \
    \      return std::make_tuple(planet1, planet2);\n      |                    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                                   |\n      |                        \
    \           std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\n/tmp/tmp8jyy8dqi.cpp:29:31: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in return\n   29 |         return std::make_tuple(planet1,\
    \ planet2);\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |\
    \                               |\n      |                               std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8jyy8dqi.cpp:2:\n/tmp/tmp8jyy8dqi.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp8jyy8dqi.cpp:34:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<cons"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Your code here\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpj5y1xzy9.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpj5y1xzy9.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpj5y1xzy9.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpj5y1xzy9.cpp:2:\n/tmp/tmpj5y1xzy9.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpj5y1xzy9.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpj5y1xzy9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 != \"\");\n    assert(planet2 !=\
    \ \"\");\n    std::string a = planet1;\n    std::string b = planet2;\n    int\
    \ count = 0;\n    std::list<std::pair<std::string, std::string>> s;\n    while(std::find(a.begin(),\
    \ a.end(), b) != a.end()) {\n        s.push_back(std::make_pair(a, b));\n    \
    \    a = b;\n        ++count;\n    }\n    \n    for (std::list<std::pair<std::string,\
    \ std::string>>::iterator it = s.begin(); \n            it != s.end(); ++it) {\n\
    \        std::cout << it->first << \" <-> \" << it->second << std::endl;\n   \
    \ }\n\n    return std::make_tuple(\"\");\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpare655hw.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpare655hw.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpare655hw.cpp:34:27: error: cannot\
    \ convert \u2018std::tuple<const char*>\u2019 to \u2018int\u2019 in return\n \
    \  34 |     return std::make_tuple(\"\");\n      |            ~~~~~~~~~~~~~~~^~~~\n\
    \      |                           |\n      |                           std::tuple<const\
    \ char*>\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpare655hw.cpp:2:\n/tmp/tmpare655hw.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpare655hw.cpp:38:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   38 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpare655hw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n\t// Your code here\n\tif(planet1 == \"Mercury\" ||\
    \ planet1 == \"Venus\" || planet1 == \"Earth\" \n\t\t|| planet1 == \"Mars\" ||\
    \ planet1 == \"Jupiter\" || planet1 == \"Saturn\"\n\t\t|| planet1 == \"Uranus\"\
    \ || planet1 == \"Neptune\") \n\t{\n\t\tif(planet2 == \"Mercury\" || planet2 ==\
    \ \"Venus\" || planet2 == \"Earth\" \n\t\t|| planet2 == \"Mars\" || planet2 ==\
    \ \"Jupiter\" || planet2 == \"Saturn\"\n\t\t|| planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\") \n\t\t{\n\t\t\tif(planet1 == \"Mercury\" && planet2 == \"Mercury\"\
    )\n\t\t\t{\n\t\t\t\treturn std::make_tuple(\"Saturn\", \"Uranus\");\n\t\t\t}\n\
    \t\t\tif(planet1 == \"Mercury\" && planet2 == \"Venus\")\n\t\t\t{\n\t\t\t\treturn\
    \ std::make_tuple(\"Saturn\", \"Uranus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\");\n\t\t\t}\n\t\t\tif(planet1 == \"Mercury\" && planet2 == \"Earth\")\n\
    \t\t\t{\n\t\t\t\treturn std::make_tuple(\"Saturn\", \"Uranus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Neptune\");\n\t\t\t}\n\t\t\tif(planet1 == \"\
    Mercury\" && planet2 == \"Mars\")\n\t\t\t{\n\t\t\t\treturn std::make_tuple(\"\
    Saturn\", \"Uranus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Neptune\"\
    , \"Uranus\");\n\t\t\t}\n\t\t\tif(planet1 == \"Mercury\" && planet2 == \"Jupiter\"\
    )\n\t\t\t{\n\t\t\t\treturn std::make_tuple(\"Saturn\", \"Uranus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Neptune\", \"Uranus\", \"Venus\");\n\t\t\
    \t}\n\t\t\tif(planet1 == \"Mercury\" && planet2 == \"Saturn\")\n\t\t\t{\n\t\t\t\
    \treturn std::make_tuple(\"Saturn\", \"Uranus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Neptune\", \"Uranus\", \"Venus\", \"Earth\");\n\t\t\t}\n\t\t\t\
    if(planet1 == \"Mercury\" && planet2 == \"Uranus\")\n\t\t\t{\n\t\t\t\treturn std::make_tuple(\"\
    Saturn\", \"Uranus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Neptune\"\
    , \"Uranus\", \"Venus\", \"Earth\", \"Mars\");\n\t\t\t}\n\t\t\tif(planet1 == \"\
    Mercur\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkf63omxm.cpp:54:18: warning: missing terminating \" character\n\
    \   54 |    if(planet1 == \"Mercur\n      |                  ^\n/tmp/tmpkf63omxm.cpp:54:18:\
    \ error: missing terminating \" character\n   54 |    if(planet1 == \"Mercur\n\
    \      |                  ^~~~~~~\n/tmp/tmpkf63omxm.cpp:16:25: error: template\
    \ argument 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n      |                         ^\n/tmp/tmpkf63omxm.cpp:\
    \ In function \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmpkf63omxm.cpp:28:27:\
    \ error: cannot convert \u2018std::tuple<const char*, const char*>\u2019 to \u2018\
    int\u2019 in return\n   28 |     return std::make_tuple(\"Saturn\", \"Uranus\"\
    );\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n      |          \
    \                 |\n      |                           std::tuple<const char*,\
    \ const char*>\n/tmp/tmpkf63omxm.cpp:32:27: error: cannot convert \u2018std::tuple<const\
    \ char*, const char*, const char*, const char*, const char*, const char*>\u2019\
    \ to \u2018int\u2019 in return\n   32 |     return std::make_tuple(\"Saturn\"\
    , \"Uranus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n      |        \
    \    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<const\
    \ char*, const char*, const char*, const char*, const char*, const char*>\n/tmp/tmpkf63omxm.cpp:36:27:\
    \ error: cannot convert \u2018std::tuple<const char*, const char*, const char*,\
    \ const char*, const char*, const char*, const char*>\u2019 to \u2018int\u2019\
    \ in return\n   36 |     return std::make_tuple(\"Saturn\", \"Uranus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Neptune\");\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<const\
    \ char*, const char*, const char*, const char*, const char*, const char*, const\
    \ char*>\n/tmp/tmpkf63omxm.cpp:40:27: error: cannot convert \u2018std::tuple<const\
    \ char*, const char*, const char*, const char*, const char*, const char*, const\
    \ cha"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n\tassert(planet1 == \"Jupiter\" || planet1 == \"Mercury\"\
    \ || planet1 == \"Venus\" ||\n\t\t   planet1 == \"Earth\" || planet1 == \"Mars\"\
    \ || planet1 == \"Saturn\" ||\n\t\t   planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    );\n\tassert(planet2 == \"Jupiter\" || planet2 == \"Mercury\" || planet2 == \"\
    Venus\" ||\n\t\t   planet2 == \"Earth\" || planet2 == \"Mars\" || planet2 == \"\
    Saturn\" ||\n\t\t   planet2 == \"Uranus\" || planet2 == \"Neptune\");\n\t\n\t\
    std::pair<double, double> mercuryOrbit = planet1Orbit(planet2);\n\tstd::pair<double,\
    \ double> venusOrbit = planet1Orbit(planet2);\n\tstd::pair<double, double> earthOrbit\
    \ = planet1Orbit(planet2);\n\tstd::pair<double, double> marsOrbit = planet1Orbit(planet2);\n\
    \tstd::pair<double, double> saturnOrbit = planet1Orbit(planet2);\n\tstd::pair<double,\
    \ double> uranusOrbit = planet1Orbit(planet2);\n\tstd::pair<double, double> neptuneOrbit\
    \ = planet1Orbit(planet2);\n\n\tauto mercuryProximity = mercuryOrbit.first - sunOrbit(planet1);\n\
    \tauto venusProximity = venusOrbit.first - sunOrbit(planet1);\n\tauto earthProximity\
    \ = earthOrbit.first - sunOrbit(planet1);\n\tauto marsProximity = marsOrbit.first\
    \ - sunOrbit(planet1);\n\tauto saturnProximity = saturnOrbit.first - sunOrbit(planet1);\n\
    \tauto uranusProximity = uranusOrbit.first - sunOrbit(planet1);\n\tauto neptuneProximity\
    \ = neptuneOrbit.first - sunOrbit(planet1);\n\t\n\tstd::tuple<std::string, > results;\n\
    \tresults.emplace_back(planet2);\n\t\n\tif (mercuryProximity >= 0 && venusProxim\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7l6a6uiz.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp7l6a6uiz.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp7l6a6uiz.cpp:24:43: error: \u2018\
    planet1Orbit\u2019 was not declared in this scope\n   24 |  std::pair<double,\
    \ double> mercuryOrbit = planet1Orbit(planet2);\n      |                     \
    \                      ^~~~~~~~~~~~\n/tmp/tmp7l6a6uiz.cpp:32:47: error: \u2018\
    sunOrbit\u2019 was not declared in this scope; did you mean \u2018saturnOrbit\u2019\
    ?\n   32 |  auto mercuryProximity = mercuryOrbit.first - sunOrbit(planet1);\n\
    \      |                                               ^~~~~~~~\n      |     \
    \                                          saturnOrbit\n/tmp/tmp7l6a6uiz.cpp:40:26:\
    \ error: template argument 2 is invalid\n   40 |  std::tuple<std::string, > results;\n\
    \      |                          ^\n/tmp/tmp7l6a6uiz.cpp:41:10: error: request\
    \ for member \u2018emplace_back\u2019 in \u2018results\u2019, which is of non-class\
    \ type \u2018int\u2019\n   41 |  results.emplace_back(planet2);\n      |     \
    \     ^~~~~~~~~~~~\n/tmp/tmp7l6a6uiz.cpp:43:31: error: \u2018venusProxim\u2019\
    \ was not declared in this scope\n   43 |  if (mercuryProximity >= 0 && venusProxim\n\
    \      |                               ^~~~~~~~~~~\n/tmp/tmp7l6a6uiz.cpp:43:42:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   43 |  if (mercuryProximity\
    \ >= 0 && venusProxim\n      |     ~                                    ^\n  \
    \    |                                          )\n   44 | }\n      | ~      \
    \                                   \n/tmp/tmp7l6a6uiz.cpp:44:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   44 | }\n      | ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7l6a6uiz.cpp:2:\n/tmp/tmp7l6a6uiz.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp7l6a6uiz.cpp:47:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018s"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    int M = 360 + 26 * planet1[0] - 26 * planet1[1];\n\
    \    int N = 26 + 36 * planet1[1] - 36 * planet1[0];\n    int L = M - N;\n   \
    \ int G = M + N;\n    int planet1_orbit_rad = N * PI / 180;\n    int planet2_orbit_rad\
    \ = N * PI / 180;\n    int planet1_orbit_deg = 180 / PI * planet1_orbit_rad;\n\
    \    int planet2_orbit_deg = 180 / PI * planet2_orbit_rad;\n    int sun_orbit_rad\
    \ = 90 - 90 * M - 90 * N;\n    int sun_orbit_deg = 180 / PI * sun_orbit_rad;\n\
    \    int sun_deg = sun_orbit_deg * 180 / PI - 90;\n    int sun_rad = sun_deg *\
    \ PI / 180;\n    int sun_dist = (int)(sun_rad * R);\n    double sun_rad_deg =\
    \ (double)sun_rad / 180;\n    double planet1_rad_deg = (double)planet1_orbit_rad\
    \ / 180;\n    double planet2_rad_deg = (double)planet2_orbit_rad / 180;\n    double\
    \ planet1_rad_miles = (double)planet1_orbit_rad / 60;\n    double planet2_rad_miles\
    \ = (double)planet2_orbit_rad / 60;\n    double planet1_rad_miles_2 = (double)planet1_orbit_rad\
    \ / 2 * 60;\n    double planet2_rad_miles_2 = (double)planet2_orbit_rad / 2 *\
    \ 60;\n    int sun_dist1 = (int) sqrt((double)M * R);\n    int sun_dist2 = (int)\
    \ sqrt((double)N * R);\n    int sun_dist3 = (int) sqrt((double)M * R * R);\n \
    \   int sun_dist4 = (int) sqrt((double)N * R * R);\n    double M1 = M * R;\n \
    \   double N1 = N * R;\n    double M2 = M * R * R;\n    double N2 = N * R * R;\n\
    \    double M3 = M1 * M1;\n    double N3 = N1 * N1;\n    double M4 = M2 * M2;\n\
    \    double N4 = N2 * N2;\n    double M5 = M1 * M2;\n    double N5 = N1 * N2;\n\
    \    double \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzzmn0q8_.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpzzmn0q8_.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpzzmn0q8_.cpp:21:33: error: \u2018\
    PI\u2019 was not declared in this scope\n   21 |     int planet1_orbit_rad = N\
    \ * PI / 180;\n      |                                 ^~\n/tmp/tmpzzmn0q8_.cpp:29:36:\
    \ error: \u2018R\u2019 was not declared in this scope\n   29 |     int sun_dist\
    \ = (int)(sun_rad * R);\n      |                                    ^\n/tmp/tmpzzmn0q8_.cpp:52:1:\
    \ error: expected unqualified-id before \u2018}\u2019 token\n   52 | }\n     \
    \ | ^\n/tmp/tmpzzmn0q8_.cpp:52:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzzmn0q8_.cpp:2:\n/tmp/tmpzzmn0q8_.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpzzmn0q8_.cpp:55:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   55 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpzzmn0q8_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double x1 = 4.87, y1 = 1.15, z1 = 0.44;\n    double\
    \ x2 = 0.77, y2 = -0.09, z2 = -0.32;\n    double x3 = -0.04, y3 = -0.82, z3 =\
    \ 0.34;\n    double x4 = 0.32, y4 = -0.74, z4 = 0.22;\n    double x5 = 0.25, y5\
    \ = -0.9, z5 = -0.34;\n    double x6 = -0.7, y6 = -0.78, z6 = 0;\n    double x7\
    \ = -0.52, y7 = -0.73, z7 = 0.11;\n    double x8 = -0.3, y8 = -0.75, z8 = -0.11;\n\
    \    double x9 = -0.8, y9 = -0.71, z9 = -0.36;\n    double x10 = -0.4, y10 = -0.78,\
    \ z10 = -0.42;\n    double x11 = 1.4, y11 = 0.6, z11 = 0.6;\n    double x12 =\
    \ -1.1, y12 = 0.9, z12 = -0.5;\n    double x13 = 1.1, y13 = 0.9, z13 = -0.6;\n\
    \    double x14 = -0.7, y14 = -0.8, z14 = 0.3;\n    double x15 = 1.6, y15 = -0.4,\
    \ z15 = 0.7;\n    double x16 = -0.3, y16 = 0.7, z16 = -0.8;\n    double x17 =\
    \ -1.8, y17 = -0.9, z17 = 0.9;\n    double x18 = -1.2, y18 = -0.4, z18 = 0.6;\n\
    \    double x19 = -0.7, y19 = -0.6, z19 = -0.2;\n    double x20 = -0.5, y20 =\
    \ -0.2, z20 = -0.1;\n    double x21 = 1.4, y21 = -0.7, z21 = -0.8;\n    double\
    \ x22 = -0.6, y22 = -0.4, z22 = -0.7;\n    double x23 = -0.5, y23 = -0.2, z23\
    \ = 0.5;\n    double x24 = -0.2, y24 = 0.5, z24 = -0.7;\n    double x25 = 1.9,\
    \ y25 = -0.4, z25 = 0.5;\n    double x26 = -0.5, y26 = -0.4, z26 = -0.4;\n   \
    \ double x27 = -0.1, y27 = 0.2, z27 = -0.2;\n    double x28 = -1.4, y28 = -0.4,\
    \ z28 = -0.3;\n    double x29 = -1.1, y29 = -0.2, z29 = 0.2;\n    double x30 =\
    \ -0.2, y30 = 0.3, z30 = -0.3;\n    double x31 = -1.8, y31 = -0.3, z\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfvaoxmft.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpfvaoxmft.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpfvaoxmft.cpp:48:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   48 | }\n      | ^\n/tmp/tmpfvaoxmft.cpp:48:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfvaoxmft.cpp:2:\n/tmp/tmpfvaoxmft.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpfvaoxmft.cpp:51:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   51 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfvaoxmft.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" \n      || planet1 == \"Mars\" || planet1 == \"Jupiter\"\
    \ || planet1 == \"Saturn\" \n      || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    );\n  assert(planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\"\
    \ \n      || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\"\
    \ \n      || planet2 == \"Uranus\" || planet2 == \"Neptune\");\n\n  long long\
    \ int p1 = std::distance(planet1.begin(), planet1.end());\n  long long int p2\
    \ = std::distance(planet2.begin(), planet2.end());\n  if (p1 == p2) return std::make_tuple(planet1);\n\
    \n  std::multiset<std::string> orbits;\n\n  if (planet1 == \"Mercury\" || planet1\
    \ == \"Venus\") orbits.insert(\"Mercury\");\n  if (planet1 == \"Earth\" || planet1\
    \ == \"Mars\") orbits.insert(\"Mars\");\n  if (planet1 == \"Jupiter\" || planet1\
    \ == \"Saturn\") orbits.insert(\"Jupiter\");\n  if (planet1 == \"Uranus\" || planet1\
    \ == \"Neptune\") orbits.insert(\"Neptune\");\n  if (planet2 == \"Mercury\" ||\
    \ planet2 == \"Venus\") orbits.insert(\"Venus\");\n  if (planet2 == \"Earth\"\
    \ || planet2 == \"Mars\") orbits.insert(\"Earth\");\n  if (planet2 == \"Jupiter\"\
    \ || planet2 == \"Saturn\") orbits.insert(\"Jupiter\");\n  if (planet2 == \"Uranus\"\
    \ || planet2 == \"Neptune\") orbits.insert(\"Saturn\");\n\n  long long int sun_dist\
    \ = std::distance(planet1.begin(), planet1.end()) \n      + std::distance(planet2.begin(),\
    \ planet2.end());\n  std::multiset<std::string>::iterator orbitIt = orbits.begin();\n\
    \n  while (orbitIt != orbits.end()) {\n    long long int o1 = std::distance(orbitIt->begin(),\
    \ orbitIt->end());\n    long long int o2 = std::distance(planet1.begin(), planet1.end())\
    \ \n        + std::distance(planet2.begin(), planet2.end());\n    if (o1 <= o2\
    \ && o1 > sun_dist) {\n      orbits.\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpmoa5h72f.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpmoa5h72f.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpmoa5h72f.cpp:26:39: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   26 |   if (p1\
    \ == p2) return std::make_tuple(planet1);\n      |                        ~~~~~~~~~~~~~~~^~~~~~~~~\n\
    \      |                                       |\n      |                    \
    \                   std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\n/tmp/tmpmoa5h72f.cpp:49:1: error: expected unqualified-id\
    \ before \u2018}\u2019 token\n   49 | }\n      | ^\n/tmp/tmpmoa5h72f.cpp:50:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   50 | int main() {\n      |            ^\n/tmp/tmpmoa5h72f.cpp:59:1: error:\
    \ expected \u2018}\u2019 at end of input\n   59 | }\n      | ^\n/tmp/tmpmoa5h72f.cpp:43:35:\
    \ note: to match this \u2018{\u2019\n   43 |   while (orbitIt != orbits.end())\
    \ {\n      |                                   ^\n/tmp/tmpmoa5h72f.cpp:59:1: error:\
    \ expected \u2018}\u2019 at end of input\n   59 | }\n      | ^\n/tmp/tmpmoa5h72f.cpp:16:72:\
    \ note: to match this \u2018{\u2019\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double dist;\n    if (planet1 == \"Mercury\" ||\
    \ planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1\
    \ == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1\
    \ == \"Neptune\"){\n        if (planet2 == \"Mercury\" || planet2 == \"Venus\"\
    \ || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" ||\
    \ planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\"){\n\
    \            return std::make_tuple(planet1);\n        }\n    }\n    else{\n \
    \       return std::make_tuple(\"\");\n    }\n    return std::make_tuple(\"\"\
    );\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpftpa_vzj.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpftpa_vzj.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpftpa_vzj.cpp:20:35: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |       \
    \      return std::make_tuple(planet1);\n      |                    ~~~~~~~~~~~~~~~^~~~~~~~~\n\
    \      |                                   |\n      |                        \
    \           std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\n/tmp/tmpftpa_vzj.cpp:24:31: error: cannot convert\
    \ \u2018std::tuple<const char*>\u2019 to \u2018int\u2019 in return\n   24 |  \
    \       return std::make_tuple(\"\");\n      |                ~~~~~~~~~~~~~~~^~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<const char*>\n/tmp/tmpftpa_vzj.cpp:26:27: error: cannot convert\
    \ \u2018std::tuple<const char*>\u2019 to \u2018int\u2019 in return\n   26 |  \
    \   return std::make_tuple(\"\");\n      |            ~~~~~~~~~~~~~~~^~~~\n  \
    \    |                           |\n      |                           std::tuple<const\
    \ char*>\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpftpa_vzj.cpp:2:\n/tmp/tmpftpa_vzj.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpftpa_vzj.cpp:30:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   30 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if(planet1.empty() || planet2.empty()) return std::tuple<std::string,\
    \ >();\n    std::tuple<std::string, > orbits;\n    double a = 0, b = 0, c = 0,\
    \ d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;\n    //\
    \ Calculate the distance from the center of each planet to the sun (r and \n \
    \   // r2)\n    double r = (earth - earth + planet1).length();\n    double r2\
    \ = (earth - earth + planet2).length();\n    // Calculate the planet's mass\n\
    \    double m_planet1 = (planet1 + planet2).toLowerCase();\n    double m_planet2\
    \ = (planet1 + planet2).toLowerCase();\n    double m_planet3 = (planet1 + planet2).toLowerCase();\n\
    \    double m_planet4 = (planet1 + planet2).toLowerCase();\n    // Calculate the\
    \ mass of the planets\n    double m1 = MASS[m_planet1];\n    double m2 = MASS[m_planet2];\n\
    \    double m3 = MASS[m_planet3];\n    double m4 = MASS[m_planet4];\n    // Calculate\
    \ the distance of each planet from the center of the sun\n    a = 0.5 * r * r\
    \ * m1 * m1;\n    b = 0.5 * r * r * m2 * m2;\n    c = 0.5 * r * r * m3 * m3;\n\
    \    d = 0.5 * r * r * m4 * m4;\n    // Calculate the time required to travel\
    \ the planet with the least distance \n    e = 0.5 * r * r * m1 * (r + r2);\n\
    \    f = 0.5 * r * r * m2 * (r + r2);\n    g = 0.5 * r * r * m3 * (r + r2);\n\
    \    h = 0.5 * r * r * m4 * (r + r2);\n    i = 0.5 * r * r * m1 * (r2 - r);\n\
    \    j = 0.5 * r * r * m2 * (r2 - r);\n    k = 0.5 * r * r * m3 * (r2 - r);\n\
    \    l = 0.5 * r * r * m4 * (r2 - r);\n    m = 0.5 * r * r * m1 * (r2 + r);\n\
    \    // Calculate the gravitational force between the two planets\n    double\
    \ f_planet1 = 0.5 * m * m * g * g;\n    double f_planet2 = 0.5 * m * m * g * g;\n\
    \    double f_planet3 = 0.5 * m * m * g * g;\n    double f_planet4 = 0.5 * m *\
    \ m * g * g;\n    // Calculate the distance traveled by the planet with the least\
    \ time \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnmutkh84.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpnmutkh84.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpnmutkh84.cpp:17:75: error: template\
    \ argument 2 is invalid\n   17 |     if(planet1.empty() || planet2.empty()) return\
    \ std::tuple<std::string, >();\n      |                                      \
    \                                     ^\n/tmp/tmpnmutkh84.cpp:18:29: error: template\
    \ argument 2 is invalid\n   18 |     std::tuple<std::string, > orbits;\n     \
    \ |                             ^\n/tmp/tmpnmutkh84.cpp:22:17: error: \u2018earth\u2019\
    \ was not declared in this scope\n   22 |     double r = (earth - earth + planet1).length();\n\
    \      |                 ^~~~~\n/tmp/tmpnmutkh84.cpp:25:44: error: \u2018class\
    \ std::__cxx11::basic_string<char>\u2019 has no member named \u2018toLowerCase\u2019\
    \n   25 |     double m_planet1 = (planet1 + planet2).toLowerCase();\n      | \
    \                                           ^~~~~~~~~~~\n/tmp/tmpnmutkh84.cpp:26:44:\
    \ error: \u2018class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018toLowerCase\u2019\n   26 |     double m_planet2 = (planet1 + planet2).toLowerCase();\n\
    \      |                                            ^~~~~~~~~~~\n/tmp/tmpnmutkh84.cpp:27:44:\
    \ error: \u2018class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018toLowerCase\u2019\n   27 |     double m_planet3 = (planet1 + planet2).toLowerCase();\n\
    \      |                                            ^~~~~~~~~~~\n/tmp/tmpnmutkh84.cpp:28:44:\
    \ error: \u2018class std::__cxx11::basic_string<char>\u2019 has no member named\
    \ \u2018toLowerCase\u2019\n   28 |     double m_planet4 = (planet1 + planet2).toLowerCase();\n\
    \      |                                            ^~~~~~~~~~~\n/tmp/tmpnmutkh84.cpp:30:17:\
    \ error: \u2018MASS\u2019 was not declared in this scope\n   30 |     double m1\
    \ = MASS[m_planet1];\n      |                 ^~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/includ"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> planets = {planet1, planet2};\n\
    \  std::sort(planets.begin(), planets.end()); // Sort planets according to their\
    \ orbits\n  \n  std::set<std::pair<std::string,std::string>> orbits;\n\n  for(auto\
    \ it : planets) \n    {\n      int distance = distance_to_sun(it);\n      orbits.insert(std::make_pair(it,\
    \ distance));\n    }\n\n  return std::make_tuple(std::make_pair(planet1, std::make_pair(planet2,\
    \ orbits)));\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4guh8mc3.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp4guh8mc3.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp4guh8mc3.cpp:24:22: error: \u2018\
    distance_to_sun\u2019 was not declared in this scope\n   24 |       int distance\
    \ = distance_to_sun(it);\n      |                      ^~~~~~~~~~~~~~~\n/tmp/tmp4guh8mc3.cpp:25:49:\
    \ error: no matching function for call to \u2018std::set<std::pair<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> > >::insert(std::pair<std::__cxx11::basic_string<char>,\
    \ int>)\u2019\n   25 |       orbits.insert(std::make_pair(it, distance));\n  \
    \    |                                                 ^\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/set:61,\n              \
    \   from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:87,\n\
    \                 from /tmp/tmp4guh8mc3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_set.h:509:7:\
    \ note: candidate: \u2018std::pair<typename std::_Rb_tree<_Key, _Key, std::_Identity<_Tp>,\
    \ _Compare, typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_Key>::other>::const_iterator,\
    \ bool> std::set<_Key, _Compare, _Alloc>::insert(const value_type&) [with _Key\
    \ = std::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char>\
    \ >; _Compare = std::less<std::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char>\
    \ > >; _Alloc = std::allocator<std::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char>\
    \ > >; typename std::_Rb_tree<_Key, _Key, std::_Identity<_Tp>, _Compare, typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_Key>::other>::const_iterator = std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> > >; std::set<_Key, _Compare, _Alloc>::value_type\
    \ = std::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char>\
    \ >]\u2019\n  509 |       insert(const value_type"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    std::tuple<std::string, > tuple;\n    \n \
    \   if (planet1 == planet2) return tuple;\n    \n    if (planet1 == \"Mercury\"\
    \ || planet2 == \"Mercury\") return tuple;\n    \n    if (planet1 == \"Venus\"\
    \ || planet2 == \"Venus\") return tuple;\n    \n    if (planet1 == \"Earth\" ||\
    \ planet2 == \"Earth\") return tuple;\n    \n    if (planet1 == \"Mars\" || planet2\
    \ == \"Mars\") return tuple;\n    \n    if (planet1 == \"Jupiter\" || planet2\
    \ == \"Jupiter\") return tuple;\n    \n    if (planet1 == \"Saturn\" || planet2\
    \ == \"Saturn\") return tuple;\n    \n    if (planet1 == \"Uranus\" || planet2\
    \ == \"Uranus\") return tuple;\n    \n    if (planet1 == \"Neptune\" || planet2\
    \ == \"Neptune\") return tuple;\n    \n    return tuple;\n}\nint main() {\n  \
    \  auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_29k6bu7.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp_29k6bu7.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp_29k6bu7.cpp:18:29: error: template\
    \ argument 2 is invalid\n   18 |     std::tuple<std::string, > tuple;\n      |\
    \                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_29k6bu7.cpp:2:\n/tmp/tmp_29k6bu7.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp_29k6bu7.cpp:42:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   42 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp_29k6bu7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylak"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > ret;\n    std::cout <<\
    \ planet1 << \" \" << planet2 << std::endl;\n    if (planet1 == \"Mercury\" ||\
    \ planet1 == \"Venus\") {\n        if (planet2 == \"Uranus\" || planet2 == \"\
    Neptune\") {\n            std::cout << \"Jupiter Neptune\" << std::endl;\n   \
    \         std::cout << planet1 << \" \" << planet2 << std::endl;\n           \
    \ ret = (planet1, planet2);\n        } else if (planet2 == \"Neptune\") {\n  \
    \          std::cout << \"Earth Mercury\" << std::endl;\n            std::cout\
    \ << planet1 << \" \" << planet2 << std::endl;\n            ret = (planet1, planet2);\n\
    \        } else if (planet2 == \"Mercury\") {\n            std::cout << \"Earth\
    \ Venus\" << std::endl;\n            std::cout << planet1 << \" \" << planet2\
    \ << std::endl;\n            ret = (planet1, planet2);\n        } else if (planet2\
    \ == \"Venus\") {\n            std::cout << \"Earth Mercury\" << std::endl;\n\
    \            std::cout << planet1 << \" \" << planet2 << std::endl;\n        \
    \    ret = (planet1, planet2);\n        } else if (planet2 == \"Earth\") {\n \
    \           std::cout << \"Mercury Uranus\" << std::endl;\n            std::cout\
    \ << planet1 << \" \" << planet2 << std::endl;\n            ret = (planet1, planet2);\n\
    \        } else if (planet2 == \"Mars\") {\n            std::cout << \"Jupiter\
    \ Saturn\" << std::endl;\n            std::cout << planet1 << \" \" << planet2\
    \ << std::endl;\n            ret = (planet1, planet2);\n        } else if (planet2\
    \ == \"Jupiter\") {\n            std::cout << \"Mercury Saturn\" << std::endl;\n\
    \            std::cout << planet1 << \" \" << planet2 << std::endl;\n        \
    \    ret = (planet1, planet2);\n        } else if (planet2 == \"Saturn\") {\n\
    \            std::cout << \"Mercury Uranus\" << std::endl;\n            std::cout\
    \ << planet1 << \" \" << planet2 << std::endl;\n            ret = (planet1, planet2);\n\
    \        } else if (planet2 == \"Uranus\") {\n            std::cout << \"Mercury\
    \ Neptune\" << std::endl;\n            std::cout << planet1 << \" \" << planet2\
    \ << std::endl;\n            ret = (planet1, planet2);\n        } else if (planet2\
    \ == \"Neptune\") {\n            std::cout << \"Mercury Neptune\" << std::endl;\n\
    \            std::cout << planet1 << \" \" << planet2 << std::endl;\n        \
    \    ret = (planet1, planet2);\n        }\n    } else if (planet1 == \"Earth\"\
    ) {\n        if (planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmw49e84t.cpp:62:70: warning: missing terminating \" character\n\
    \   62 |         if (planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\n      |                                                        \
    \              ^\n/tmp/tmpmw49e84t.cpp:62:70: error: missing terminating \" character\n\
    \   62 |         if (planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\n      |                                                        \
    \              ^~~~~~\n/tmp/tmpmw49e84t.cpp:16:25: error: template argument 2\
    \ is invalid\n   16 | std::tuple<std::string, > bf(std::string planet1, std::string\
    \ planet2) {\n      |                         ^\n/tmp/tmpmw49e84t.cpp: In function\
    \ \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmpmw49e84t.cpp:17:29: error:\
    \ template argument 2 is invalid\n   17 |     std::tuple<std::string, > ret;\n\
    \      |                             ^\n/tmp/tmpmw49e84t.cpp:23:27: error: cannot\
    \ convert \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018int\u2019 in assignment\n   23 |             ret = (planet1, planet2);\n\
    \      |                   ~~~~~~~~^~~~~~~~~~\n      |                       \
    \    |\n      |                           std::string {aka std::__cxx11::basic_string<char>}\n\
    /tmp/tmpmw49e84t.cpp:27:27: error: cannot convert \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018int\u2019 in assignment\n\
    \   27 |             ret = (planet1, planet2);\n      |                   ~~~~~~~~^~~~~~~~~~\n\
    \      |                           |\n      |                           std::string\
    \ {aka std::__cxx11::basic_string<char>}\n/tmp/tmpmw49e84t.cpp:31:27: error: cannot\
    \ convert \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018int\u2019 in assignment\n   31 |             ret = (planet1, planet2);\n\
    \      |                   ~~~~~~~~^~~~~~~~~~\n      |                       \
    \    |\n      |                           std::string {aka std::__cxx11::basic_string<char>}\n\
    /tmp/tmpmw49e84t.cpp:35:27: error: cannot convert \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018int\u2019 in assignment\n\
    \   35 |             ret = (planet1,"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  if (planet1 == \"Earth\" || planet2 == \"Earth\")\
    \ return std::tuple<std::string,>();\n  if (planet1 == \"Mercury\" || planet2\
    \ == \"Mercury\") return std::tuple<std::string,>();\n  if (planet1 == \"Venus\"\
    \ || planet2 == \"Venus\") return std::tuple<std::string,>();\n  if (planet1 ==\
    \ \"Earth\" || planet2 == \"Mercury\") return std::tuple<std::string,>();\n  if\
    \ (planet1 == \"Earth\" || planet2 == \"Venus\") return std::tuple<std::string,>();\n\
    \  if (planet1 == \"Mars\" || planet2 == \"Mercury\") return std::tuple<std::string,>();\n\
    \  if (planet1 == \"Mars\" || planet2 == \"Venus\") return std::tuple<std::string,>();\n\
    \  if (planet1 == \"Jupiter\" || planet2 == \"Mercury\") return std::tuple<std::string,>();\n\
    \  if (planet1 == \"Jupiter\" || planet2 == \"Venus\") return std::tuple<std::string,>();\n\
    \  if (planet1 == \"Saturn\" || planet2 == \"Mercury\") return std::tuple<std::string,>();\n\
    \  if (planet1 == \"Saturn\" || planet2 == \"Venus\") return std::tuple<std::string,>();\n\
    \  if (planet1 == \"Uranus\" || planet2 == \"Mercury\") return std::tuple<std::string,>();\n\
    \  if (planet1 == \"Uranus\" || planet2 == \"Venus\") return std::tuple<std::string,>();\n\
    \  if (planet1 == \"Neptune\" || planet2 == \"Mercury\") return std::tuple<std::string,>();\n\
    \  if (planet1 == \"Neptune\" || planet2 == \"Venus\") return std::tuple<std::string,>();\n\
    \  return std::tuple<std::string,>();\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpsre_89nm.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpsre_89nm.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpsre_89nm.cpp:17:79: error: template\
    \ argument 2 is invalid\n   17 |   if (planet1 == \"Earth\" || planet2 == \"Earth\"\
    ) return std::tuple<std::string,>();\n      |                                \
    \                                               ^\n/tmp/tmpsre_89nm.cpp:18:83:\
    \ error: template argument 2 is invalid\n   18 |   if (planet1 == \"Mercury\"\
    \ || planet2 == \"Mercury\") return std::tuple<std::string,>();\n      |     \
    \                                                                            \
    \  ^\n/tmp/tmpsre_89nm.cpp:19:79: error: template argument 2 is invalid\n   19\
    \ |   if (planet1 == \"Venus\" || planet2 == \"Venus\") return std::tuple<std::string,>();\n\
    \      |                                                                     \
    \          ^\n/tmp/tmpsre_89nm.cpp:20:81: error: template argument 2 is invalid\n\
    \   20 |   if (planet1 == \"Earth\" || planet2 == \"Mercury\") return std::tuple<std::string,>();\n\
    \      |                                                                     \
    \            ^\n/tmp/tmpsre_89nm.cpp:21:79: error: template argument 2 is invalid\n\
    \   21 |   if (planet1 == \"Earth\" || planet2 == \"Venus\") return std::tuple<std::string,>();\n\
    \      |                                                                     \
    \          ^\n/tmp/tmpsre_89nm.cpp:22:80: error: template argument 2 is invalid\n\
    \   22 |   if (planet1 == \"Mars\" || planet2 == \"Mercury\") return std::tuple<std::string,>();\n\
    \      |                                                                     \
    \           ^\n/tmp/tmpsre_89nm.cpp:23:78: error: template argument 2 is invalid\n\
    \   23 |   if (planet1 == \"Mars\" || planet2 == \"Venus\") return std::tuple<std::string,>();\n\
    \      |                                                                     \
    \         ^\n/tmp/tmpsre_89nm.cpp:24:83: error: template argument 2 is invalid\n\
    \   2"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::tuple<std::string, > result;\n  assert(planet1\
    \ != \"\" && planet2 != \"\");\n  std::vector<std::string> planets;\n  planets.push_back(planet1);\n\
    \  planets.push_back(planet2);\n  \n  // We must sort the planets by distance\
    \ to the Sun (the distance\n  // formula)\n  sort(planets.begin(), planets.end(),\
    \ \n       [&planet1, &planet2](const std::string &p1, const std::string &p2){\n\
    \         return std::distance(planet1.c_str(), planet1.c_str()) - std::distance(planet2.c_str(),\
    \ planet2.c_str()) < 0;\n       });\n  \n  // We compute the distance between\
    \ each planet's orbit and the sun \n  // and store the distances in a map\n  std::map<std::string,\
    \ double> dist;\n  for (auto p: planets) {\n    double dist = std::distance(p.c_str(),\
    \ p.c_str()) - std::distance(\"Sun\".c_str(), \"Sun\".c_str());\n    dist[p] =\
    \ dist;\n  }\n  \n  // Now we compute the orbits between the two planets, sorted\
    \ by \n  // distance to the sun\n  for (auto p: planets) {\n    double dist1 =\
    \ dist[p];\n    double dist2 = dist[planet2];\n    \n    // If the distances are\
    \ equal, there exists an orbit between\n    // the two planets\n    if (dist1\
    \ == dist2){\n      auto orbit = std::make_tuple(p.c_str(), p.c_str());\n    \
    \  result.push_back(std::get<0>(orbit));\n      result.push_back(std::get<1>(orbit));\n\
    \    }\n  }\n  \n  return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpkzs5n0pf.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpkzs5n0pf.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpkzs5n0pf.cpp:17:27: error: template\
    \ argument 2 is invalid\n   17 |   std::tuple<std::string, > result;\n      |\
    \                           ^\n/tmp/tmpkzs5n0pf.cpp:34:77: error: request for\
    \ member \u2018c_str\u2019 in \u2018\"Sun\"\u2019, which is of non-class type\
    \ \u2018const char [4]\u2019\n   34 |     double dist = std::distance(p.c_str(),\
    \ p.c_str()) - std::distance(\"Sun\".c_str(), \"Sun\".c_str());\n      |     \
    \                                                                        ^~~~~\n\
    /tmp/tmpkzs5n0pf.cpp:34:92: error: request for member \u2018c_str\u2019 in \u2018\
    \"Sun\"\u2019, which is of non-class type \u2018const char [4]\u2019\n   34 |\
    \     double dist = std::distance(p.c_str(), p.c_str()) - std::distance(\"Sun\"\
    .c_str(), \"Sun\".c_str());\n      |                                         \
    \                                                   ^~~~~\n/tmp/tmpkzs5n0pf.cpp:35:9:\
    \ error: no match for \u2018operator[]\u2019 (operand types are \u2018double\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019)\n   35 |     dist[p] = dist;\n\
    \      |         ^\n/tmp/tmpkzs5n0pf.cpp:48:14: error: request for member \u2018\
    push_back\u2019 in \u2018result\u2019, which is of non-class type \u2018int\u2019\
    \n   48 |       result.push_back(std::get<0>(orbit));\n      |              ^~~~~~~~~\n\
    /tmp/tmpkzs5n0pf.cpp:49:14: error: request for member \u2018push_back\u2019 in\
    \ \u2018result\u2019, which is of non-class type \u2018int\u2019\n   49 |    \
    \   result.push_back(std::get<1>(orbit));\n      |              ^~~~~~~~~\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkzs5n0pf.cpp:2:\n/tmp/tmpkzs5n0pf.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpkzs5n0pf.cpp:57:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   57 |     asse"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    bool found = false;\n    long double dist1 = 0.0,\
    \ dist2 = 0.0;\n    double angle = 0.0, angle2 = 0.0;\n    int orbit1, orbit2;\n\
    \    // For each planet in our solar system\n    for (orbit1 = 1; orbit1 < 16;\
    \ orbit1++) {\n        for (orbit2 = 1; orbit2 < 16; orbit2++) {\n           \
    \ // If the planets are in the same orbit\n            if (orbit1 == orbit2) {\n\
    \                // Calculate the distance between the planets\n             \
    \   dist1 = sqrt(pow((orbit1 - 1), 2) + (pow((orbit2 - 1), 2)));\n           \
    \     dist2 = sqrt(pow((orbit1 - 16), 2) + (pow((orbit2 - 16), 2)));\n       \
    \         // If the distance between the two planets is smaller than \n      \
    \          // or equal to the distance between the sun and the planet\n      \
    \          if (dist1 <= dist2) {\n                    // Calculate the angle\n\
    \                    angle = atan(sqrt(pow((orbit1 - 1), 2) - (pow((orbit2 - 1),\
    \ 2))) / \n                            atan(sqrt(pow((orbit1 - 16), 2) - (pow((orbit2\
    \ - 16), 2))));\n                    angle *= 180.0 / M_PI;\n                \
    \    // If the angle between the two planets lies between 45 and \n          \
    \          // 135 (inclusive) degrees\n                    if (angle >= 45.0 &&\
    \ angle <= 135.0) {\n                        angle2 = atan(sqrt(pow((orbit2 -\
    \ 1), 2) - (pow((orbit1 - 1), 2))) / \n                                atan(sqrt(pow((orbit2\
    \ - 16), 2) - (pow((orbit1 - 16), 2))));\n                        angle2 *= 180.0\
    \ / M_PI;\n                        // If the angles between the planets are less\
    \ than or equal \n                        // to 120 degrees\n                \
    \        if (angle2 <= 120.0)\n                            found = true;\n   \
    \                     break;\n                    }\n                }\n     \
    \           else\n                    found = true;\n            }\n        }\n\
    \        if (found) break;\n    }\n    if (!found)\n        return std::make_tuple(\"\
    \", );\n    return std::make_tuple(planet1, planet2, orbit1, orbit2);\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphogbfvdu.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmphogbfvdu.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmphogbfvdu.cpp:34:88: error: expected\
    \ \u2018)\u2019 before \u2018;\u2019 token\n   34 |                          \
    \   atan(sqrt(pow((orbit1 - 16), 2) - (pow((orbit2 - 16), 2))));\n      |    \
    \                                                                            \
    \        ^\n      |                                                          \
    \                              )\n/tmp/tmphogbfvdu.cpp:33:33: note: to match this\
    \ \u2018(\u2019\n   33 |                     angle = atan(sqrt(pow((orbit1 - 1),\
    \ 2) - (pow((orbit2 - 1), 2))) /\n      |                                 ^\n\
    /tmp/tmphogbfvdu.cpp:40:92: error: expected \u2018)\u2019 before \u2018;\u2019\
    \ token\n   40 |                                 atan(sqrt(pow((orbit2 - 16),\
    \ 2) - (pow((orbit1 - 16), 2))));\n      |                                   \
    \                                                         ^\n      |         \
    \                                                                            \
    \       )\n/tmp/tmphogbfvdu.cpp:39:38: note: to match this \u2018(\u2019\n   39\
    \ |                         angle2 = atan(sqrt(pow((orbit2 - 1), 2) - (pow((orbit1\
    \ - 1), 2))) /\n      |                                      ^\n/tmp/tmphogbfvdu.cpp:56:36:\
    \ error: expected primary-expression before \u2018)\u2019 token\n   56 |     \
    \    return std::make_tuple(\"\", );\n      |                                \
    \    ^\n/tmp/tmphogbfvdu.cpp:57:27: error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, int, int>\u2019 to \u2018int\u2019\
    \ in return\n   57 |     return std::make_tuple(planet1, planet2, orbit1, orbit2);\n\
    \      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |\
    \                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::ch"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    //your code here\n    \n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp0h3lqoz9.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp0h3lqoz9.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp0h3lqoz9.cpp:19:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   19 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0h3lqoz9.cpp:2:\n/tmp/tmp0h3lqoz9.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp0h3lqoz9.cpp:22:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   22 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp0h3lqoz9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Complete this function!\n    return {};\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9f7y2h8o.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9f7y2h8o.cpp:2:\n/tmp/tmp9f7y2h8o.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp9f7y2h8o.cpp:22:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   22 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9f7y2h8o.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9f7y2h8o.cpp:2:\n/tmp/tmp9f7y2h8o.cpp:22:85: note:\
    \   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019 and \u2018\
    int\u2019\n   22 |    "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    //your code here\n    assert(planet1 != \"\");\n\
    \    assert(planet2 != \"\");\n    std::string planet1_name;\n    std::string\
    \ planet2_name;\n    std::tie(planet1_name, planet2_name) = split(planet1, planet2);\n\
    \    std::tuple<std::string> orbit = std::make_tuple(planet1_name, planet2_name);\n\
    \    return orbit;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpewr9tq05.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpewr9tq05.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpewr9tq05.cpp:22:44: error: \u2018\
    split\u2019 was not declared in this scope\n   22 |     std::tie(planet1_name,\
    \ planet2_name) = split(planet1, planet2);\n      |                          \
    \                  ^~~~~\n/tmp/tmpewr9tq05.cpp:23:52: error: conversion from \u2018\
    tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >>\u2019 to non-scalar type \u2018tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >>\u2019 requested\n   23 |     std::tuple<std::string>\
    \ orbit = std::make_tuple(planet1_name, planet2_name);\n      |              \
    \                       ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpewr9tq05.cpp:24:12:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   24 |     return\
    \ orbit;\n      |            ^~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpewr9tq05.cpp:2:\n/tmp/tmpewr9tq05.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpewr9tq05.cpp:28:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   28 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/includ"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> orbits;\n  double a[3][4]\
    \ = { {0, 0, 0}, {0, 0, 0}, {0, 0, 0} };\n  double p[3][4] = { {0, 0, 0}, {0,\
    \ 0, 0}, {0, 0, 0} };\n  double m = 300.0;\n  double b = -9.8;\n  double e = 0;\n\
    \  double omega = 0;\n  double inc = 0.5;\n  double T = (b * b) / (m * m) * inc;\n\
    \  double d = T * sin(inc) / m;\n  double p1, q;\n  double x1, x2, y1, y2;\n \
    \ double d1, d2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double\
    \ x1, y1, x2, y2;\n  double x1, y1, x2, y2;\n  double \n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpa6666ykk.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpa6666ykk.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpa6666ykk.cpp:30:10: error: redeclaration\
    \ of \u2018double x1\u2019\n   30 |   double x1, y1, x2, y2;\n      |        \
    \  ^~\n/tmp/tmpa6666ykk.cpp:28:10: note: \u2018double x1\u2019 previously declared\
    \ here\n   28 |   double x1, x2, y1, y2;\n      |          ^~\n/tmp/tmpa6666ykk.cpp:30:14:\
    \ error: redeclaration of \u2018double y1\u2019\n   30 |   double x1, y1, x2,\
    \ y2;\n      |              ^~\n/tmp/tmpa6666ykk.cpp:28:18: note: \u2018double\
    \ y1\u2019 previously declared here\n   28 |   double x1, x2, y1, y2;\n      |\
    \                  ^~\n/tmp/tmpa6666ykk.cpp:30:18: error: redeclaration of \u2018\
    double x2\u2019\n   30 |   double x1, y1, x2, y2;\n      |                  ^~\n\
    /tmp/tmpa6666ykk.cpp:28:14: note: \u2018double x2\u2019 previously declared here\n\
    \   28 |   double x1, x2, y1, y2;\n      |              ^~\n/tmp/tmpa6666ykk.cpp:30:22:\
    \ error: redeclaration of \u2018double y2\u2019\n   30 |   double x1, y1, x2,\
    \ y2;\n      |                      ^~\n/tmp/tmpa6666ykk.cpp:28:22: note: \u2018\
    double y2\u2019 previously declared here\n   28 |   double x1, x2, y1, y2;\n \
    \     |                      ^~\n/tmp/tmpa6666ykk.cpp:31:10: error: redeclaration\
    \ of \u2018double x1\u2019\n   31 |   double x1, y1, x2, y2;\n      |        \
    \  ^~\n/tmp/tmpa6666ykk.cpp:28:10: note: \u2018double x1\u2019 previously declared\
    \ here\n   28 |   double x1, x2, y1, y2;\n      |          ^~\n/tmp/tmpa6666ykk.cpp:31:14:\
    \ error: redeclaration of \u2018double y1\u2019\n   31 |   double x1, y1, x2,\
    \ y2;\n      |              ^~\n/tmp/tmpa6666ykk.cpp:28:18: note: \u2018double\
    \ y1\u2019 previously declared here\n   28 |   double x1, x2, y1, y2;\n      |\
    \                  ^~\n/tmp/tmpa6666ykk.cpp:31:18: error: redeclaration of \u2018\
    double x2\u2019\n   31 |   double x1, y1, x2, y2;\n      |                  ^~\n\
    /tmp/tmpa6666ykk.cpp:28:14: note: \u2018double x2\u2019 previously declared here\n\
    \   28 |   double x1, x2, y1, y2;\n      |              ^~\n/tmp/tmpa6666ykk.cpp:31:22:\
    \ error: red"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Base case\n    if (planet1.length() ==\
    \ 0 || planet2.length() == 0) {\n        return std::tuple<std::string, >();\n\
    \    }\n    \n    // Recursion \n    std::tuple<std::string, > planets = bf(planet2,\
    \ planet1);\n    \n    // If the first planet in planets is a smaller planet than\
    \ the second planet \n    // in planets then the orbit of planet2 happened earlier\
    \ than the orbit of planet1\n    if (planets[planets.size() - 1].first < planet1)\
    \ {\n        std::swap(planets[planets.size() - 1].first, planets[planets.size()\
    \ - 2].first);\n    }\n    \n    return planets;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpltpe8xz9.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpltpe8xz9.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpltpe8xz9.cpp:20:40: error: template\
    \ argument 2 is invalid\n   20 |         return std::tuple<std::string, >();\n\
    \      |                                        ^\n/tmp/tmpltpe8xz9.cpp:24:29:\
    \ error: template argument 2 is invalid\n   24 |     std::tuple<std::string, >\
    \ planets = bf(planet2, planet1);\n      |                             ^\n/tmp/tmpltpe8xz9.cpp:28:25:\
    \ error: request for member \u2018size\u2019 in \u2018planets\u2019, which is\
    \ of non-class type \u2018int\u2019\n   28 |     if (planets[planets.size() -\
    \ 1].first < planet1) {\n      |                         ^~~~\n/tmp/tmpltpe8xz9.cpp:29:35:\
    \ error: request for member \u2018size\u2019 in \u2018planets\u2019, which is\
    \ of non-class type \u2018int\u2019\n   29 |         std::swap(planets[planets.size()\
    \ - 1].first, planets[planets.size() - 2].first);\n      |                   \
    \                ^~~~\n/tmp/tmpltpe8xz9.cpp:29:70: error: request for member \u2018\
    size\u2019 in \u2018planets\u2019, which is of non-class type \u2018int\u2019\n\
    \   29 |         std::swap(planets[planets.size() - 1].first, planets[planets.size()\
    \ - 2].first);\n      |                                                      \
    \                ^~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpltpe8xz9.cpp:2:\n/tmp/tmpltpe8xz9.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpltpe8xz9.cpp:36:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   36 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |               "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string orbit1, orbit2;\n    float distance;\n\
    \    std::tie(orbit1, distance) = orbit_calculation(planet1);\n    std::tie(orbit2,\
    \ distance) = orbit_calculation(planet2);\n    if(distance > 0.1 && distance <\
    \ 0.2) {\n        return std::make_tuple(orbit2);\n    } else {\n        return\
    \ std::make_tuple(orbit1);\n    }\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpff5k_7_v.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpff5k_7_v.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpff5k_7_v.cpp:19:34: error: \u2018\
    orbit_calculation\u2019 was not declared in this scope\n   19 |     std::tie(orbit1,\
    \ distance) = orbit_calculation(planet1);\n      |                           \
    \       ^~~~~~~~~~~~~~~~~\n/tmp/tmpff5k_7_v.cpp:22:31: error: cannot convert \u2018\
    std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in return\n   22 |         return std::make_tuple(orbit2);\n\
    \      |                ~~~~~~~~~~~~~~~^~~~~~~~\n      |                     \
    \          |\n      |                               std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpff5k_7_v.cpp:24:31:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   24 |       \
    \  return std::make_tuple(orbit1);\n      |                ~~~~~~~~~~~~~~~^~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpff5k_7_v.cpp:2:\n/tmp/tmpff5k_7_v.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpff5k_7_v.cpp:29:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   29 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int     "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::tuple<std::string, > results;\n  std::string\
    \ result1 = planet1;\n  std::transform(result1.begin(), result1.end(), result1.begin(),\
    \ ::tolower);\n  std::string result2 = planet2;\n  std::transform(result2.begin(),\
    \ result2.end(), result2.begin(), ::tolower);\n  std::tuple<std::string, > pair;\n\
    \  if (result1 == result2) {\n    pair = std::make_tuple(result1, result2);\n\
    \  } else {\n    if (result1 == result2.substr(0, result1.length())) {\n     \
    \ if (result2.length() > result1.length()) {\n        if (result2.substr(result1.length(),\
    \ result1.length()) == result2) {\n          pair = std::make_tuple(result1, result2);\n\
    \        } else {\n          pair = std::make_tuple(result1, result1.substr(0,\
    \ result2.length()));\n        }\n      } else if (result1.length() > result2.length())\
    \ {\n        if (result1.substr(result2.length(), result1.length()) == result2)\
    \ {\n          pair = std::make_tuple(result1, result2);\n        } else {\n \
    \         pair = std::make_tuple(result2.substr(0, result1.length()), result2);\n\
    \        }\n      } else if (result1 == result2.substr(0, result2.length())) {\n\
    \        if (result2.length() > result1.length()) {\n          pair = std::make_tuple(result1,\
    \ result2.substr(result1.length(), result1.length()));\n        } else {\n   \
    \       pair = std::make_tuple(result2.substr(0, result2.length()), result2);\n\
    \        }\n      } else {\n        pair = std::make_tuple(result1, result2);\n\
    \      }\n    } else {\n      if (result1.length() > result2.length()) {\n   \
    \     if (result1.substr(0, result2.length()) == result2) {\n          pair =\
    \ std::make_tuple(result1.substr(0, result2.length()), result2);\n        } else\
    \ {\n          pair = std::make_tuple(result2, result1.substr(0, result2.length()));\n\
    \        }\n      } else {\n        if (result2.length() > result1.length()) {\n\
    \          pair = std::make_tuple(result2, result1.substr(0, result2.length()));\n\
    \        } else {\n          pair = std::make_tuple(result1, result2);\n     \
    \   }\n      }\n    }\n  }\n  std::sort(std::get<0>(pair), std::get<1>(pair));\n\
    \  if (std::get<0>(pair) == std::get<1>(pair)) {\n    std::sort(std::get<0>(pair));\n\
    \  }\n  return pair;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_h8d1121.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp_h8d1121.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp_h8d1121.cpp:17:27: error: template\
    \ argument 2 is invalid\n   17 |   std::tuple<std::string, > results;\n      |\
    \                           ^\n/tmp/tmp_h8d1121.cpp:22:27: error: template argument\
    \ 2 is invalid\n   22 |   std::tuple<std::string, > pair;\n      |           \
    \                ^\n/tmp/tmp_h8d1121.cpp:24:27: error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\u2019 to \u2018int\u2019 in\
    \ assignment\n   24 |     pair = std::make_tuple(result1, result2);\n      | \
    \           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                       \
    \    |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmp_h8d1121.cpp:29:33:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in assignment\n   29 |   \
    \        pair = std::make_tuple(result1, result2);\n      |                  ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                                 |\n      |                          \
    \       std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\n/tmp/tmp_h8d1121.cpp:31:33: error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\u2019 to \u2018int\u2019 in\
    \ assignment\n   31 |           pair = std::mak"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    using namespace std;\n    vector<string> v1;\n \
    \   vector<string> v2;\n    if (planet1 == \"Jupiter\" || planet1 == \"Mercury\"\
    ) {\n        v1.push_back(planet1);\n        v1.push_back(\"Venus\");\n      \
    \  v1.push_back(\"Earth\");\n        v1.push_back(\"Mars\");\n        v1.push_back(\"\
    Jupiter\");\n        v1.push_back(\"Saturn\");\n        v1.push_back(\"Uranus\"\
    );\n        v1.push_back(\"Neptune\");\n    } else if (planet1 == \"Earth\" ||\
    \ planet1 == \"Venus\") {\n        v1.push_back(planet1);\n        v1.push_back(\"\
    Mercury\");\n        v1.push_back(\"Mars\");\n        v1.push_back(\"Jupiter\"\
    );\n        v1.push_back(\"Saturn\");\n        v1.push_back(\"Uranus\");\n   \
    \     v1.push_back(\"Neptune\");\n    }\n    if (planet2 == \"Jupiter\" || planet2\
    \ == \"Mercury\") {\n        v2.push_back(planet2);\n        v2.push_back(\"Venus\"\
    );\n        v2.push_back(\"Earth\");\n        v2.push_back(\"Mars\");\n      \
    \  v2.push_back(\"Jupiter\");\n        v2.push_back(\"Saturn\");\n        v2.push_back(\"\
    Uranus\");\n        v2.push_back(\"Neptune\");\n    } else if (planet2 == \"Earth\"\
    \ || planet2 == \"Venus\") {\n        v2.push_back(planet2);\n        v2.push_back(\"\
    Mercury\");\n        v2.push_back(\"Mars\");\n        v2.push_back(\"Jupiter\"\
    );\n        v2.push_back(\"Saturn\");\n        v2.push_back(\"Uranus\");\n   \
    \     v2.push_back(\"Neptune\");\n    }\n    sort(v1.begin(), v1.end());\n   \
    \ sort(v2.begin(), v2.end());\n    return std::make_tuple(v1, v2);\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptec904l2.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmptec904l2.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmptec904l2.cpp:58:27: error: cannot\
    \ convert \u2018std::tuple<std::vector<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > > >, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > > > >\u2019 to \u2018int\u2019 in return\n   58 |   \
    \  return std::make_tuple(v1, v2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::vector<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > > >, std::vector<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > > > >\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptec904l2.cpp:2:\n/tmp/tmptec904l2.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmptec904l2.cpp:62:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   62 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<co"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  // write your code here\n  if (planet1 == \"Mercury\"\
    \ || planet2 == \"Mercury\" || planet1 == \"Venus\" || planet2 == \"Venus\" ||\
    \ planet1 == \"Earth\" || planet2 == \"Earth\" || planet1 == \"Mars\" || planet2\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet2 == \"Jupiter\" || planet1 ==\
    \ \"Saturn\" || planet2 == \"Saturn\" || planet1 == \"Uranus\" || planet2 == \"\
    Uranus\" || planet1 == \"Neptune\" || planet2 == \"Neptune\") {\n    return std::tuple<std::string,\
    \ >();\n  }\n  else {\n    return std::tuple<std::string, >();\n  }\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy2zg7nrj.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpy2zg7nrj.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpy2zg7nrj.cpp:19:36: error: template\
    \ argument 2 is invalid\n   19 |     return std::tuple<std::string, >();\n   \
    \   |                                    ^\n/tmp/tmpy2zg7nrj.cpp:22:36: error:\
    \ template argument 2 is invalid\n   22 |     return std::tuple<std::string, >();\n\
    \      |                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy2zg7nrj.cpp:2:\n/tmp/tmpy2zg7nrj.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpy2zg7nrj.cpp:27:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   27 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy2zg7nrj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument de"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    long long int sun_lat, sun_long, sun_d, sun_h, sun_m;\n\
    \    std::string sun_planet;\n    long long int sun_planet_lat, sun_planet_long,\
    \ sun_planet_d, sun_planet_h, sun_planet_m;\n    long long int sun_planet_d_long;\n\
    \    long long int sun_planet_h_long;\n    long long int sun_planet_m_long;\n\
    \    long long int sun_planet_d_long_long;\n    long long int sun_planet_h_long_long;\n\
    \    long long int sun_planet_m_long_long;\n    long long int sun_planet_d_long_long_long;\n\
    \    long long int sun_planet_h_long_long_long;\n    long long int sun_planet_m_long_long_long;\n\
    \    long long int sun_planet_d_long_long_long_long;\n    long long int sun_planet_h_long_long_long_long;\n\
    \    long long int sun_planet_m_long_long_long_long;\n    long long int sun_planet_d_long_long_long_long_long;\n\
    \    long long int sun_planet_h_long_long_long_long_long;\n    long long int sun_planet_m_long_long_long_long_long;\n\
    \    long long int sun_planet_d_long_long_long_long_long_long;\n    long long\
    \ int sun_planet_h_long_long_long_long_long_long;\n    long long int sun_planet_m_long_long_long_long_long_long;\n\
    \    long long int sun_planet_d_long_long_long_long_long_long_long;\n    long\
    \ long int sun_planet_h_long_long_long_long_long_long_long;\n    long long int\
    \ sun_planet_m_long_long_long_long_long_long_long;\n    long long int sun_planet_d_long_long_long_long_long_long_long_long;\n\
    \    long long int sun_planet_h_long_long_long_long_long_long_long_long;\n   \
    \ long long int sun_planet_m_long_long_long_long_long_long_long_long;\n    long\
    \ long int sun_planet_d_long_long_long_long_long_long_long_long_long;\n    long\
    \ long int sun_planet_h_long_long_long_long_long_long_long_long_long_long;\n \
    \   long long int sun_planet_m_long_long_long_long_long_long_long_long_long_long;\n\
    \    long long int sun_planet_d_long_long_long_long_long_long_long_long_long_long_long\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm9vjqpqn.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpm9vjqpqn.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpm9vjqpqn.cpp:48:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   48 | }\n      | ^\n/tmp/tmpm9vjqpqn.cpp:48:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpm9vjqpqn.cpp:2:\n/tmp/tmpm9vjqpqn.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpm9vjqpqn.cpp:51:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   51 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpm9vjqpqn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::tuple<std::string, > solar_system;\n  auto j1\
    \ = planet1.find(\"Jupiter\");\n  auto m1 = planet1.find(\"Mercury\");\n  auto\
    \ v1 = planet1.find(\"Venus\");\n  auto e1 = planet1.find(\"Earth\");\n  auto\
    \ m2 = planet2.find(\"Mercury\");\n  auto v2 = planet2.find(\"Venus\");\n  auto\
    \ e2 = planet2.find(\"Earth\");\n  auto j2 = planet2.find(\"Jupiter\");\n  auto\
    \ m3 = planet2.find(\"Mercury\");\n  auto v3 = planet2.find(\"Venus\");\n  auto\
    \ e3 = planet2.find(\"Earth\");\n  auto m4 = planet2.find(\"Mercury\");\n  auto\
    \ v4 = planet2.find(\"Venus\");\n  auto e4 = planet2.find(\"Earth\");\n  auto\
    \ m5 = planet2.find(\"Mercury\");\n  auto v5 = planet2.find(\"Venus\");\n  auto\
    \ e5 = planet2.find(\"Earth\");\n  auto m6 = planet2.find(\"Mercury\");\n  auto\
    \ v6 = planet2.find(\"Venus\");\n  auto e6 = planet2.find(\"Earth\");\n  solar_system.emplace_back(\"\
    Saturn\");\n  solar_system.emplace_back(\"Uranus\");\n  if (j1 != std::string::npos)\
    \ {\n    if (m1 != std::string::npos) {\n      if (v1 != std::string::npos) {\n\
    \        if (e1 != std::string::npos) {\n          if (m2 != std::string::npos)\
    \ {\n            if (v2 != std::string::npos) {\n              if (e2 != std::string::npos)\
    \ {\n                solar_system.emplace_back(\"Earth\");\n                solar_system.emplace_back(\"\
    Mars\");\n                solar_system.emplace_back(\"Jupiter\");\n          \
    \      solar_system.emplace_back(\"Saturn\");\n                solar_system.emplace_back(\"\
    Uranus\");\n              } else if (j2 != std::string::npos) {\n            \
    \    if (m3 != std::string::npos) {\n                  if (v3 != std::string::npos)\
    \ {\n                    if (e3 != std::string::npos) {\n                    \
    \  if (m4 != std::string::npos) {\n                        if (v4 != std::string::npos)\
    \ {\n                          if (e4 != std::string::npos) {\n              \
    \              if (m5 != std::string::npos) {\n                              if\
    \ (v5 != std::string::npos) {\n                                if (e5 != std::string::npos)\
    \ {\n                                  if (m6 != std::string::npos) {\n      \
    \                              if (v6 != std::string\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp9uql5qjy.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp9uql5qjy.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp9uql5qjy.cpp:17:27: error: template\
    \ argument 2 is invalid\n   17 |   std::tuple<std::string, > solar_system;\n \
    \     |                           ^\n/tmp/tmp9uql5qjy.cpp:38:16: error: request\
    \ for member \u2018emplace_back\u2019 in \u2018solar_system\u2019, which is of\
    \ non-class type \u2018int\u2019\n   38 |   solar_system.emplace_back(\"Saturn\"\
    );\n      |                ^~~~~~~~~~~~\n/tmp/tmp9uql5qjy.cpp:39:16: error: request\
    \ for member \u2018emplace_back\u2019 in \u2018solar_system\u2019, which is of\
    \ non-class type \u2018int\u2019\n   39 |   solar_system.emplace_back(\"Uranus\"\
    );\n      |                ^~~~~~~~~~~~\n/tmp/tmp9uql5qjy.cpp:47:30: error: request\
    \ for member \u2018emplace_back\u2019 in \u2018solar_system\u2019, which is of\
    \ non-class type \u2018int\u2019\n   47 |                 solar_system.emplace_back(\"\
    Earth\");\n      |                              ^~~~~~~~~~~~\n/tmp/tmp9uql5qjy.cpp:48:30:\
    \ error: request for member \u2018emplace_back\u2019 in \u2018solar_system\u2019\
    , which is of non-class type \u2018int\u2019\n   48 |                 solar_system.emplace_back(\"\
    Mars\");\n      |                              ^~~~~~~~~~~~\n/tmp/tmp9uql5qjy.cpp:49:30:\
    \ error: request for member \u2018emplace_back\u2019 in \u2018solar_system\u2019\
    , which is of non-class type \u2018int\u2019\n   49 |                 solar_system.emplace_back(\"\
    Jupiter\");\n      |                              ^~~~~~~~~~~~\n/tmp/tmp9uql5qjy.cpp:50:30:\
    \ error: request for member \u2018emplace_back\u2019 in \u2018solar_system\u2019\
    , which is of non-class type \u2018int\u2019\n   50 |                 solar_system.emplace_back(\"\
    Saturn\");\n      |                              ^~~~~~~~~~~~\n/tmp/tmp9uql5qjy.cpp:51:30:\
    \ error: request for member \u2018emplace_back\u2019 in \u2018solar_system\u2019\
    , which is of non-class type \u2018int\u2019\n   51 |                 solar_system.emplace_back(\"\
    Uranus\");\n      |                              ^~~~~~~~~~~~\n/tmp/tmp9uql5qjy.cpp:64:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" ||\
    \ planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2\
    \ == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 ==\
    \ \"Uranus\" || planet2 == \"Neptune\");\n    assert(planet2 == \"Mercury\" ||\
    \ planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" || planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1\
    \ == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 ==\
    \ \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\");\n    \n    \n\
    \    \n    std::unordered_map<std::string, double> m;\n    std::unordered_map<std::string,\
    \ double> planets_distance;\n    double sun_distance = 100000.0;\n    double planet_distance\
    \ = 100000.0;\n    double distance;\n    double planet_dist_max;\n    double sun_dist_max;\n\
    \    double planet_angle;\n    double sun_angle;\n    double angle;\n    double\
    \ distance2, distance1;\n    double dist;\n    double planet_dist;\n    double\
    \ sun_dist;\n    double distance2_max;\n    double distance1_max;\n    double\
    \ dist2;\n    double dist1;\n    double angle2;\n    double angle1;\n    double\
    \ angle;\n    double a1 = 0.0;\n    double b1 = 0.0;\n    double c1 = 0.0;\n \
    \   double x1 = 0.0;\n    double y1 = 0.0;\n    double x2 = 0.0;\n    double y2\
    \ = 0.0;\n    double x3 = 0.0;\n    double y3 = 0.0;\n    double x4 = 0.0;\n \
    \   double y4 = 0.0;\n    double x5 = 0.0;\n    double y5 = 0.0;\n    double x6\
    \ = 0.0;\n    double y6 = 0.0;\n    double x7 = 0.0;\n    double y7 = 0.0;\n \
    \   double x\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpf1n8xeav.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpf1n8xeav.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpf1n8xeav.cpp:42:12: error: redeclaration\
    \ of \u2018double angle\u2019\n   42 |     double angle;\n      |            ^~~~~\n\
    /tmp/tmpf1n8xeav.cpp:31:12: note: \u2018double angle\u2019 previously declared\
    \ here\n   31 |     double angle;\n      |            ^~~~~\n/tmp/tmpf1n8xeav.cpp:61:1:\
    \ error: expected initializer before \u2018}\u2019 token\n   61 | }\n      | ^\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpf1n8xeav.cpp:2:\n/tmp/tmpf1n8xeav.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpf1n8xeav.cpp:64:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   64 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpf1n8xeav.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   tem"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::queue<std::string> queue;\n  queue.push(planet1);\n\
    \  queue.push(planet2);\n  queue.push(planet1);\n  while (!queue.empty()) {\n\
    \    auto top = queue.front();\n    queue.pop();\n    if (top == planet1) {\n\
    \      continue;\n    } else if (top == planet2) {\n      return std::make_tuple(top);\n\
    \    }\n    for (auto itr = std::begin(planets);\n        itr != std::end(planets);\
    \ ++itr) {\n      auto itr2 = std::begin(planets);\n      itr2 += itr;\n     \
    \ if (itr2 == std::end(planets))\n        break;\n      std::string temp1 = *itr;\n\
    \      std::string temp2 = *itr2;\n      double distance1 = sqrt(pow(temp1.length()\
    \ - temp2.length(), 2));\n      double distance2 = sqrt(pow(temp2.length() - temp1.length(),\
    \ 2));\n      if (distance1 < distance2) {\n        queue.push(temp2);\n     \
    \ } else {\n        queue.push(temp1);\n      }\n    }\n  }\n  return std::make_tuple();\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_xhk3g56.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp_xhk3g56.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp_xhk3g56.cpp:27:29: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   27 |       return\
    \ std::make_tuple(top);\n      |              ~~~~~~~~~~~~~~~^~~~~\n      |  \
    \                           |\n      |                             std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmp_xhk3g56.cpp:29:32:\
    \ error: \u2018planets\u2019 was not declared in this scope; did you mean \u2018\
    planet1\u2019?\n   29 |     for (auto itr = std::begin(planets);\n      |    \
    \                            ^~~~~~~\n      |                                planet1\n\
    /tmp/tmp_xhk3g56.cpp:46:25: error: cannot convert \u2018std::tuple<>\u2019 to\
    \ \u2018int\u2019 in return\n   46 |   return std::make_tuple();\n      |    \
    \      ~~~~~~~~~~~~~~~^~\n      |                         |\n      |         \
    \                std::tuple<>\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_xhk3g56.cpp:2:\n/tmp/tmp_xhk3g56.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp_xhk3g56.cpp:50:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   50 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n\tauto it = std::find_if(planets.begin(), planets.end(),\
    \ [&](const auto &planet) {\n\t\treturn planet.first == planet1 || planet.first\
    \ == planet2;\n\t});\n\tif (it == planets.end()) return std::tuple<std::string,\
    \ >();\n\tauto orbit1 = *it;\n\t++it;\n\tauto orbit2 = *it;\n\tauto distance =\
    \ orbit1.distance(orbit2);\n\tif (distance < 0)\n\t\tstd::swap(orbit1, orbit2);\n\
    \tif (distance < 2 * M_PI) return std::tuple<std::string, >();\n\tauto next =\
    \ std::adjacent_find(planets.begin(), planets.end(), [&](const auto &p) {\n\t\t\
    return p.first == orbit1.orbit_of() + orbit2.orbit_of();\n\t});\n\tif (next ==\
    \ planets.end()) return std::tuple<std::string, >();\n\tstd::swap(orbit1, *next);\n\
    \tstd::swap(orbit2, *next);\n\treturn std::make_tuple(orbit1.first, orbit2.first);\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp28hpjh7t.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp28hpjh7t.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp28hpjh7t.cpp:17:25: error: \u2018\
    planets\u2019 was not declared in this scope; did you mean \u2018planet1\u2019\
    ?\n   17 |  auto it = std::find_if(planets.begin(), planets.end(), [&](const auto\
    \ &planet) {\n      |                         ^~~~~~~\n      |               \
    \          planet1\n/tmp/tmp28hpjh7t.cpp:20:58: error: template argument 2 is\
    \ invalid\n   20 |  if (it == planets.end()) return std::tuple<std::string, >();\n\
    \      |                                                          ^\n/tmp/tmp28hpjh7t.cpp:27:58:\
    \ error: template argument 2 is invalid\n   27 |  if (distance < 2 * M_PI) return\
    \ std::tuple<std::string, >();\n      |                                      \
    \                    ^\n/tmp/tmp28hpjh7t.cpp:31:60: error: template argument 2\
    \ is invalid\n   31 |  if (next == planets.end()) return std::tuple<std::string,\
    \ >();\n      |                                                            ^\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp28hpjh7t.cpp:2:\n/tmp/tmp28hpjh7t.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp28hpjh7t.cpp:38:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   38 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/ce"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    if(planet1 == \"Venus\" || planet1 == \"Mercury\"\
    \ || planet1 == \"Earth\" ||\n       planet1 == \"Mars\" || planet1 == \"Jupiter\"\
    \ || planet1 == \"Saturn\" ||\n       planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    ) {\n        \n        if(planet2 == \"Uranus\" || planet2 == \"Neptune\") {\n\
    \            return std::make_tuple(planet1, planet2);\n        }\n        \n\
    \        else if(planet2 == \"Mercury\" || planet2 == \"Venus\") {\n         \
    \   return std::make_tuple(planet1, planet2);\n        }\n        \n        else\
    \ if(planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Earth\" ||\n\
    \             planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"\
    Neptune\") {\n            return std::make_tuple(planet2, planet1);\n        }\n\
    \        \n        else if(planet2 == \"Mercury\" || planet2 == \"Venus\") {\n\
    \            return std::make_tuple(planet1, planet2);\n        }\n        \n\
    \        else if(planet2 == \"Earth \") {\n            return std::make_tuple(planet1,\
    \ planet2);\n        }\n        \n        else if(planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" ||\n             planet2 == \"Uranus\"\
    \ || planet2 == \"Neptune\") {\n            return std::make_tuple(planet1, planet2);\n\
    \        }\n        \n        else if(planet2 == \"Mercury\" || planet2 == \"\
    Venus\") {\n            return std::make_tuple(planet1, planet2);\n        }\n\
    \        \n        else if(planet2 == \"Earth \" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" ||\n             planet2 == \"Saturn\" || planet2 == \"Uranus\"\
    \ || planet2 == \"Neptune\") {\n            return std::make_tuple(planet1, planet2);\n\
    \        }\n        \n        else if(planet2 == \"Mercury\" || planet2 == \"\
    Venus\") {\n            return std::make_tuple(planet1, planet2);\n        }\n\
    \        \n        else if(planet2 == \"Earth \" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" ||\n             planet2 == \"Saturn\" || planet2 == \"Uranus\"\
    \ || planet2 == \"Ne\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp17bol83y.cpp:62:71: warning: missing terminating \" character\n\
    \   62 |              planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Ne\n      |                                                           \
    \            ^\n/tmp/tmp17bol83y.cpp:62:71: error: missing terminating \" character\n\
    \   62 |              planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Ne\n      |                                                           \
    \            ^~~\n/tmp/tmp17bol83y.cpp:16:25: error: template argument 2 is invalid\n\
    \   16 | std::tuple<std::string, > bf(std::string planet1, std::string planet2)\
    \ {\n      |                         ^\n/tmp/tmp17bol83y.cpp: In function \u2018\
    int bf(std::string, std::string)\u2019:\n/tmp/tmp17bol83y.cpp:23:35: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   23 |       \
    \      return std::make_tuple(planet1, planet2);\n      |                    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                                   |\n      |                        \
    \           std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\n/tmp/tmp17bol83y.cpp:27:35: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in return\n   27 |             return std::make_tuple(planet1,\
    \ planet2);\n      |                    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n  \
    \    |                                   |\n      |                          \
    \         std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\n/tmp/tmp17bol83y.cpp:32:35: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::bas"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::stringstream ss;\n    ss << planet1 << ' '\
    \ << planet2;\n    ss >> planet1 >> planet2;\n    std::tuple<std::string, > planets;\n\
    \    if (planet1 == planet2) return planets;\n    planets.emplace_back(planet1);\n\
    \    planets.emplace_back(planet2);\n    auto orbit1 = ss2orbit(planet1);\n  \
    \  auto orbit2 = ss2orbit(planet2);\n    int dist;\n    double x, y, z;\n    bool\
    \ found = false;\n    while (!found) {\n        do {\n            std::cin >>\
    \ x;\n        } while (x < 0 || x > 180);\n        do {\n            std::cin\
    \ >> y;\n        } while (y < 0 || y > 180);\n        do {\n            std::cin\
    \ >> z;\n        } while (z < 0 || z > 180);\n        dist = fabs(x ^ y) + fabs(x\
    \ ^ z) + fabs(y ^ z);\n        auto orbit = ss2orbit(ss.str());\n        found\
    \ = true;\n        for (int i = 0; i != 7; ++i) {\n            double dist = orbit.at(i)\
    \ - orbit1.at(i);\n            dist = fabs(dist);\n            if (dist < 0.01)\
    \ continue;\n            if (dist < dist2 && dist < dist3) {\n               \
    \ std::cout << ss.str() << std::endl;\n                planets.emplace_back(ss.str());\n\
    \                found = false;\n                break;\n            }\n     \
    \   }\n        dist2 = dist;\n        dist3 = dist;\n        ss.str(\"\");\n \
    \       ss.clear();\n        ss << planet1 << ' ' << planet2;\n    }\n    return\
    \ planets;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprse68n6z.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmprse68n6z.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmprse68n6z.cpp:20:29: error: template\
    \ argument 2 is invalid\n   20 |     std::tuple<std::string, > planets;\n    \
    \  |                             ^\n/tmp/tmprse68n6z.cpp:22:13: error: request\
    \ for member \u2018emplace_back\u2019 in \u2018planets\u2019, which is of non-class\
    \ type \u2018int\u2019\n   22 |     planets.emplace_back(planet1);\n      |  \
    \           ^~~~~~~~~~~~\n/tmp/tmprse68n6z.cpp:23:13: error: request for member\
    \ \u2018emplace_back\u2019 in \u2018planets\u2019, which is of non-class type\
    \ \u2018int\u2019\n   23 |     planets.emplace_back(planet2);\n      |       \
    \      ^~~~~~~~~~~~\n/tmp/tmprse68n6z.cpp:24:19: error: \u2018ss2orbit\u2019 was\
    \ not declared in this scope\n   24 |     auto orbit1 = ss2orbit(planet1);\n \
    \     |                   ^~~~~~~~\n/tmp/tmprse68n6z.cpp:39:23: error: invalid\
    \ operands of types \u2018double\u2019 and \u2018double\u2019 to binary \u2018\
    operator^\u2019\n   39 |         dist = fabs(x ^ y) + fabs(x ^ z) + fabs(y ^ z);\n\
    \      |                     ~ ^ ~\n      |                     |   |\n      |\
    \                     |   double\n      |                     double\n/tmp/tmprse68n6z.cpp:39:37:\
    \ error: invalid operands of types \u2018double\u2019 and \u2018double\u2019 to\
    \ binary \u2018operator^\u2019\n   39 |         dist = fabs(x ^ y) + fabs(x ^\
    \ z) + fabs(y ^ z);\n      |                                   ~ ^ ~\n      |\
    \                                   |   |\n      |                           \
    \        |   double\n      |                                   double\n/tmp/tmprse68n6z.cpp:39:51:\
    \ error: invalid operands of types \u2018double\u2019 and \u2018double\u2019 to\
    \ binary \u2018operator^\u2019\n   39 |         dist = fabs(x ^ y) + fabs(x ^\
    \ z) + fabs(y ^ z);\n      |                                                 ~\
    \ ^ ~\n      |                                                 |   |\n      |\
    \                                                 |   double\n      |        \
    \                                         double\n/tmp"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Your code here\n    std::string temp1 = planet2;\n\
    \    std::string temp2 = planet1;\n    // Get the position of sun and planets\n\
    \    double sun_orbit_x, sun_orbit_y, sun_orbit_z, sun_x, sun_y, sun_z;\n    sun_x\
    \ = sun_orbit_x = SUN_ORB_X;\n    sun_y = sun_orbit_y = SUN_ORB_Y;\n    sun_z\
    \ = sun_orbit_z = SUN_ORB_Z;\n    // get planet position\n    if (temp1 == \"\
    Mercury\") {\n        temp1 = \"Venus\";\n        sun_x = SUN_ORB_X;\n       \
    \ sun_y = SUN_ORB_Y;\n        sun_z = SUN_ORB_Z;\n    }\n    if (temp2 == \"Mercury\"\
    ) {\n        temp2 = \"Venus\";\n        sun_x = SUN_ORB_X;\n        sun_y = SUN_ORB_Y;\n\
    \        sun_z = SUN_ORB_Z;\n    }\n    if (temp1 == \"Venus\") {\n        temp1\
    \ = \"Earth\";\n        sun_x = SUN_ORB_X;\n        sun_y = SUN_ORB_Y;\n     \
    \   sun_z = SUN_ORB_Z;\n    }\n    if (temp2 == \"Venus\") {\n        temp2 =\
    \ \"Earth\";\n        sun_x = SUN_ORB_X;\n        sun_y = SUN_ORB_Y;\n       \
    \ sun_z = SUN_ORB_Z;\n    }\n    if (temp1 == \"Earth\") {\n        temp1 = \"\
    Mars\";\n        sun_x = SUN_ORB_X;\n        sun_y = SUN_ORB_Y;\n        sun_z\
    \ = SUN_ORB_Z;\n    }\n    if (temp2 == \"Earth\") {\n        temp2 = \"Mars\"\
    ;\n        sun_x = SUN_ORB_X;\n        sun_y = SUN_ORB_Y;\n        sun_z = SUN_ORB_Z;\n\
    \    }\n    if (temp1 == \"Mars\") {\n        temp1 = \"Jupiter\";\n        sun_x\
    \ = SUN_ORB_X;\n        sun_y = SUN_ORB_Y;\n        sun_z = SUN_ORB_Z;\n    }\n\
    \    if (temp2 == \"Mars\") {\n        temp2 = \"Jupiter\";\n        sun_x = SUN_ORB_X;\n\
    \        sun_y = SUN_ORB_Y;\n        sun_z = SUN_ORB_Z;\n    }\n    if (temp1\
    \ == \"Jupiter\") {\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvn4twb1w.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpvn4twb1w.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpvn4twb1w.cpp:22:27: error: \u2018\
    SUN_ORB_X\u2019 was not declared in this scope\n   22 |     sun_x = sun_orbit_x\
    \ = SUN_ORB_X;\n      |                           ^~~~~~~~~\n/tmp/tmpvn4twb1w.cpp:23:27:\
    \ error: \u2018SUN_ORB_Y\u2019 was not declared in this scope\n   23 |     sun_y\
    \ = sun_orbit_y = SUN_ORB_Y;\n      |                           ^~~~~~~~~\n/tmp/tmpvn4twb1w.cpp:24:27:\
    \ error: \u2018SUN_ORB_Z\u2019 was not declared in this scope\n   24 |     sun_z\
    \ = sun_orbit_z = SUN_ORB_Z;\n      |                           ^~~~~~~~~\n/tmp/tmpvn4twb1w.cpp:76:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   76 | int main() {\n      |            ^\n/tmp/tmpvn4twb1w.cpp:85:1: error:\
    \ expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpvn4twb1w.cpp:16:72:\
    \ note: to match this \u2018{\u2019\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                     ^\n/tmp/tmpvn4twb1w.cpp:85:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   85 | }\n\
    \      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if((planet1 == planet2) || (planet2 == \"Sun\"))\
    \ {\n        return std::make_tuple(planet2);\n    }\n    std::tuple<std::string,\
    \ > ans;\n    std::string temp1, temp2;\n    temp1 = planet1;\n    temp2 = planet2;\n\
    \    // The first planet name should be the closest to the Sun, otherwise \n \
    \   // the name will be returned as is.\n    if(temp1 == \"Sun\") {\n        return\
    \ std::make_tuple(temp2);\n    }\n    // The first planet name should be the closest\
    \ to the Sun, otherwise \n    // the name will be returned as is.\n    if(temp2\
    \ == \"Sun\") {\n        return std::make_tuple(temp1);\n    }\n    if(temp1 <\
    \ temp2) {\n        // The first planet name should be the closest to the Sun,\
    \ otherwise \n        // the name will be returned as is.\n        if(temp2 ==\
    \ \"Mercury\") {\n            ans = std::make_tuple(temp2);\n        }\n     \
    \   // The second planet name should be the closest to the Sun, otherwise \n \
    \       // the name will be returned as is.\n        if(temp1 == \"Mercury\")\
    \ {\n            ans = std::make_tuple(temp1);\n        }\n        if(temp2 ==\
    \ \"Venus\") {\n            ans = std::make_tuple(temp2);\n        }\n       \
    \ // The second planet name should be the closest to the Sun, otherwise \n   \
    \     // the name will be returned as is.\n        if(temp1 == \"Venus\") {\n\
    \            ans = std::make_tuple(temp1);\n        }\n        if(temp2 == \"\
    Earth\") {\n            ans = std::make_tuple(temp2);\n        }\n        // The\
    \ first planet name should be the closest to the Sun, otherwise \n        // the\
    \ name will be returned as is.\n        if(temp1 == \"Earth\") {\n           \
    \ ans = std::make_tuple(temp1);\n        }\n        if(temp2 == \"Mars\") {\n\
    \            ans = std::make_tuple(temp2);\n        }\n        // The second planet\
    \ name should be the closest to the Sun, otherwise \n        // the name will\
    \ be returned as is.\n        if(temp1 == \"Mars\") {\n            ans = std::make_tuple(temp1);\n\
    \        }\n        if(temp2 == \"Jupiter\") {\n            ans = std::make_tuple(temp2);\n\
    \        }\n        // The second planet name should be the closest to the Sun,\
    \ otherwise \n        // the name will be returned as is.\n        if(temp1 ==\
    \ \"Jupiter\") {\n            ans = std::make_tuple(temp1);\n        }\n     \
    \   if(temp2 == \"Saturn\") {\n            ans = std::make_tuple(temp2);\n   \
    \     }\n        // The first planet name should be the closest to the Sun, otherwise\
    \ \n        // the name will be \n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpicp03mld.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpicp03mld.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpicp03mld.cpp:18:31: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   18 |       \
    \  return std::make_tuple(planet2);\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\n/tmp/tmpicp03mld.cpp:20:29: error: template argument 2 is invalid\n   20\
    \ |     std::tuple<std::string, > ans;\n      |                             ^\n\
    /tmp/tmpicp03mld.cpp:27:31: error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\u2019 to \u2018int\u2019 in\
    \ return\n   27 |         return std::make_tuple(temp2);\n      |            \
    \    ~~~~~~~~~~~~~~~^~~~~~~\n      |                               |\n      |\
    \                               std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\n/tmp/tmpicp03mld.cpp:32:31: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in return\n   32 |         return std::make_tuple(temp1);\n\
    \      |                ~~~~~~~~~~~~~~~^~~~~~~\n      |                      \
    \         |\n      |                               std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpicp03mld.cpp:38:34:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in assignment\n   38 |   \
    \          ans = std::make_tuple(temp2);\n      |                   ~~~~~~~~~~~~~~~^~~~~~~\n\
    \      |                                  |\n      |                         \
    \         std::tuple<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::pair<std::pair<std::pair<int, int>,\
    \ std::pair<int, int>>, int>> orbits;\n    // A planet is the set of orbits of\
    \ its sun\n    std::set<std::string> planets;\n    // A set of planets, each planet\
    \ is {orbit of Sun, count}\n    std::set<std::pair<std::string, int>> planetMap;\n\
    \    // A map from planet name to its orbit and its count\n    std::unordered_map<std::string,\
    \ std::pair<std::pair<std::pair<int, int>, std::pair<int, int>>, int>> orbMap;\n\
    \    // A map from orbit to its planet name and its count\n    // Initialized\
    \ as {sun, 0}\n    orbMap.emplace(\"Sun\", std::pair<std::pair<std::pair<int,\
    \ int>, std::pair<int, int>>, int>{{}, 0});\n    for (auto const &orbit : orbits)\
    \ {\n        std::pair<std::string, int> orbitStr = orbit.first;\n        std::unordered_map<std::string,\
    \ int> planetMap2 = orbMap.at(orbitStr.first);\n        std::pair<std::pair<std::pair<int,\
    \ int>, std::pair<int, int>>, int> orbit2 = orbit.second;\n        std::unordered_map<std::string,\
    \ int> planetMap3 = orbMap.at(orbitStr.second);\n        // Each orbit of Sun\
    \ has two orbits in the planet\n        for (int i = 0; i < 2; i++) {\n      \
    \      std::string planetName;\n            // Find out which planet the orbit\
    \ belongs to\n            if (i == 0) {\n                // The first orbit of\
    \ Sun belongs to Mercury\n                if (orbitStr.first == \"Mercury\") {\n\
    \                    planetName = \"Venus\";\n                }\n            \
    \    // The first orbit of Sun belongs to Venus\n                else if (orbitStr.first\
    \ == \"Venus\") {\n                    planetName = \"Earth\";\n             \
    \   }\n                // The first orbit of Sun belongs to Earth\n          \
    \      else if (orbitStr.first == \"Earth\") {\n                    planetName\
    \ = \"Mars\";\n                }\n                // The first orbit of Sun belongs\
    \ to Mars\n                else if (orbitStr.first == \"Mars\") {\n          \
    \          planetName = \"Jupiter\";\n                }\n                // The\
    \ first orbit of Sun belongs to Jupiter\n                else if (orbitStr.first\
    \ == \"Jupiter\") {\n                    planetName = \"Saturn\";\n          \
    \      }\n                // The first orbit of Sun belongs to Saturn\n      \
    \          else if (orbitStr.first == \"Saturn\") {\n                    planetName\
    \ = \"Uranus\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqgn3bep5.cpp:59:34: warning: missing terminating \" character\n\
    \   59 |                     planetName = \"Uranus\n      |                  \
    \                ^\n/tmp/tmpqgn3bep5.cpp:59:34: error: missing terminating \"\
    \ character\n   59 |                     planetName = \"Uranus\n      |      \
    \                            ^~~~~~~\n/tmp/tmpqgn3bep5.cpp:16:25: error: template\
    \ argument 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n      |                         ^\n/tmp/tmpqgn3bep5.cpp:\
    \ In function \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmpqgn3bep5.cpp:28:54:\
    \ error: conversion from \u2018pair<std::pair<int, int>,std::pair<int, int>>\u2019\
    \ to non-scalar type \u2018pair<std::__cxx11::basic_string<char>,int>\u2019 requested\n\
    \   28 |         std::pair<std::string, int> orbitStr = orbit.first;\n      |\
    \                                                ~~~~~~^~~~~\n/tmp/tmpqgn3bep5.cpp:29:68:\
    \ error: conversion from \u2018std::unordered_map<std::__cxx11::basic_string<char>,\
    \ std::pair<std::pair<std::pair<int, int>, std::pair<int, int> >, int> >::mapped_type\u2019\
    \ {aka \u2018std::pair<std::pair<std::pair<int, int>, std::pair<int, int> >, int>\u2019\
    } to non-scalar type \u2018std::unordered_map<std::__cxx11::basic_string<char>,\
    \ int>\u2019 requested\n   29 |         std::unordered_map<std::string, int> planetMap2\
    \ = orbMap.at(orbitStr.first);\n      |                                      \
    \                     ~~~~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpqgn3bep5.cpp:30:92: error:\
    \ conversion from \u2018const int\u2019 to non-scalar type \u2018std::pair<std::pair<std::pair<int,\
    \ int>, std::pair<int, int> >, int>\u2019 requested\n   30 |         std::pair<std::pair<std::pair<int,\
    \ int>, std::pair<int, int>>, int> orbit2 = orbit.second;\n      |           \
    \                                                                           ~~~~~~^~~~~~\n\
    /tmp/tmpqgn3bep5.cpp:31:84: error: no matching function for call to \u2018std::unordered_map<std::__cxx11::basic_string<char>,\
    \ std::pair<std::pair<std::pair<int, int>, std::pair<int, int> >, int> >::at(int&)\u2019\
    \n   31 |         std::unordered_map<std::st"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    };\n    if(std::find(planets.begin(), planets.end(), planet1) != planets.end())\
    \ {\n        if(std::find(planets.begin(), planets.end(), planet2) != planets.end())\
    \ \n            return std::make_tuple(planet1, planet2);\n    }\n    if(std::find(planets.begin(),\
    \ planets.end(), planet2) != planets.end()) \n        return std::make_tuple(planet2,\
    \ planet1);\n    return std::make_tuple();\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp05nz0fzg.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp05nz0fzg.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp05nz0fzg.cpp:20:35: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |       \
    \      return std::make_tuple(planet1, planet2);\n      |                    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                                   |\n      |                        \
    \           std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\n/tmp/tmp05nz0fzg.cpp:23:31: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in return\n   23 |         return std::make_tuple(planet2,\
    \ planet1);\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |\
    \                               |\n      |                               std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmp05nz0fzg.cpp:24:27:\
    \ error: cannot convert \u2018std::tuple<>\u2019 to \u2018int\u2019 in return\n\
    \   24 |     return std::make_tuple();\n      |            ~~~~~~~~~~~~~~~^~\n\
    \      |                           |\n      |                           std::tuple<>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp05nz0fzg.cpp:2:\n/tmp/tmp05nz0fzg.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp05nz0fzg.cpp:28"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planets1;\n    std::string planets2;\n\
    \    if (planet1 == \"Mercury\" && planet2 == \"Venus\") {\n        planets1 =\
    \ planet1 + \"|\" + planet2;\n        planets2 = planet1 + \"|\" + planet2;\n\
    \    }\n    else if (planet1 == \"Venus\" && planet2 == \"Mercury\") {\n     \
    \   planets1 = planet1 + \"|\" + planet2;\n        planets2 = planet1 + \"|\"\
    \ + planet2;\n    }\n    else if (planet1 == \"Earth\" && planet2 == \"Mars\"\
    ) {\n        planets1 = planet1 + \"|\" + planet2;\n        planets2 = planet1\
    \ + \"|\" + planet2;\n    }\n    else if (planet1 == \"Mars\" && planet2 == \"\
    Earth\") {\n        planets1 = planet1 + \"|\" + planet2;\n        planets2 =\
    \ planet1 + \"|\" + planet2;\n    }\n    else if (planet1 == \"Jupiter\" && planet2\
    \ == \"Saturn\") {\n        planets1 = planet1 + \"|\" + planet2;\n        planets2\
    \ = planet1 + \"|\" + planet2;\n    }\n    else if (planet1 == \"Saturn\" && planet2\
    \ == \"Jupiter\") {\n        planets1 = planet1 + \"|\" + planet2;\n        planets2\
    \ = planet1 + \"|\" + planet2;\n    }\n    else if (planet1 == \"Uranus\" && planet2\
    \ == \"Neptune\") {\n        planets1 = planet1 + \"|\" + planet2;\n        planets2\
    \ = planet1 + \"|\" + planet2;\n    }\n    else if (planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\") {\n        planets1 = planet1 + \"|\" + planet2;\n  \
    \      planets2 = planet1 + \"|\" + planet2;\n    }\n    else {\n        return\
    \ std::tuple<std::string,>();\n    }\n    // The function should return the tuple\
    \ of planets whose orbits are located \n    // in the interval [planet1|planet2]\
    \ sorted by proximity to the Sun.\n    std::string query = \"(\" + planets1 +\
    \ \")-(\" + planets2 + \")\";\n    std::vector<std::string> results;\n    query\
    \ = \"SELECT DISTINCT ?planet WHERE {?planet a owl:Thing; \" + query + \".\";\n\
    \    // query = \"SELECT DISTINCT ?planet WHERE {?planet a owl:Thing; \" + query\
    \ + \".\";\n    \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptpbhtaga.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmptpbhtaga.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmptpbhtaga.cpp:52:39: error: template\
    \ argument 2 is invalid\n   52 |         return std::tuple<std::string,>();\n\
    \      |                                       ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptpbhtaga.cpp:2:\n/tmp/tmptpbhtaga.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmptpbhtaga.cpp:64:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   64 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptpbhtaga.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1.size() > 0 && planet2.size() > 0);\n\
    \    \n    // Your code goes here\n    auto orbit1 = getOrbits(planet1);\n   \
    \ auto orbit2 = getOrbits(planet2);\n    \n    // Your code goes here\n    \n\
    \    return std::make_tuple(planet1, planet2);\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpfqwrr0yr.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpfqwrr0yr.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpfqwrr0yr.cpp:20:19: error: \u2018\
    getOrbits\u2019 was not declared in this scope\n   20 |     auto orbit1 = getOrbits(planet1);\n\
    \      |                   ^~~~~~~~~\n/tmp/tmpfqwrr0yr.cpp:25:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   25 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfqwrr0yr.cpp:2:\n/tmp/tmpfqwrr0yr.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpfqwrr0yr.cpp:29:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   29 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfqwrr0yr.cpp:2:\n/"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Jupiter\" || planet1 == \"Mercury\"\
    \ || \n           planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"\
    Mars\" || \n           planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1\
    \ == \"Neptune\" || \n           planet2 == \"Jupiter\" || planet2 == \"Mercury\"\
    \ || \n           planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"\
    Mars\" || \n           planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" || \n           planet1 != \"Mercury\" || planet2 != \"Mercury\"\
    \ || \n           planet1 != \"Venus\" || planet2 != \"Venus\" || \n         \
    \  planet1 != \"Earth\" || planet2 != \"Earth\" || \n           planet1 != \"\
    Mars\" || planet2 != \"Mars\" || \n           planet1 != \"Saturn\" || planet2\
    \ != \"Saturn\" || \n           planet1 != \"Uranus\" || planet2 != \"Uranus\"\
    \ || \n           planet1 != \"Neptune\" || planet2 != \"Neptune\");\n    \n \
    \   std::tuple<std::string, > planet_orbits;\n    if (planet1 == \"Mercury\")\
    \ {\n        planet_orbits = std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n    } else if (planet1 == \"\
    Venus\") {\n        planet_orbits = std::make_tuple(\"Mercury\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n    } else if (planet1\
    \ == \"Earth\") {\n        planet_orbits = std::make_tuple(\"Mercury\", \"Venus\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n    } else if\
    \ (planet1 == \"Mars\") {\n        planet_orbits = std::make_tuple(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n \
    \   } else if (planet1 == \"Jupiter\") {\n        planet_orbits = std::make_tuple(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Saturn\", \"Uranus\", \"Neptune\"\
    );\n    } else if (planet1 == \"Saturn\") {\n        planet_orbits = std::make_tuple(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Uranus\", \"Nept\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt73umuhz.cpp:43:99: warning: missing terminating \" character\n\
    \   43 |         planet_orbits = std::make_tuple(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Uranus\", \"Nept\n      |                         \
    \                                                                          ^\n\
    /tmp/tmpt73umuhz.cpp:43:99: error: missing terminating \" character\n   43 | \
    \        planet_orbits = std::make_tuple(\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Uranus\", \"Nept\n      |                             \
    \                                                                      ^~~~~\n\
    /tmp/tmpt73umuhz.cpp:16:25: error: template argument 2 is invalid\n   16 | std::tuple<std::string,\
    \ > bf(std::string planet1, std::string planet2) {\n      |                  \
    \       ^\n/tmp/tmpt73umuhz.cpp: In function \u2018int bf(std::string, std::string)\u2019\
    :\n/tmp/tmpt73umuhz.cpp:31:29: error: template argument 2 is invalid\n   31 |\
    \     std::tuple<std::string, > planet_orbits;\n      |                      \
    \       ^\n/tmp/tmpt73umuhz.cpp:33:40: error: cannot convert \u2018std::tuple<const\
    \ char*, const char*, const char*, const char*, const char*, const char*, const\
    \ char*>\u2019 to \u2018int\u2019 in assignment\n   33 |         planet_orbits\
    \ = std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\");\n      |                         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                        |\n      |                   \
    \                     std::tuple<const char*, const char*, const char*, const\
    \ char*, const char*, const char*, const char*>\n/tmp/tmpt73umuhz.cpp:35:40: error:\
    \ cannot convert \u2018std::tuple<const char*, const char*, const char*, const\
    \ char*, const char*, const char*, const char*>\u2019 to \u2018int\u2019 in assignment\n\
    \   35 |         planet_orbits = std::make_tuple(\"Mercury\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n      |                \
    \         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                               "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  if (planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || \n      planet1 == \"Mars\" || planet1 == \"Jupiter\"\
    \ || planet1 == \"Saturn\" || \n      planet1 == \"Neptune\" || planet1 == \"\
    Uranus\") {\n    if (planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || \n        planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2\
    \ == \"Saturn\" || \n        planet2 == \"Neptune\" || planet2 == \"Uranus\")\
    \ {\n      return std::make_tuple(planet1, planet2);\n    }\n  }\n  if (planet2\
    \ == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || \n      planet2\
    \ == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || \n      planet2\
    \ == \"Neptune\" || planet2 == \"Uranus\") {\n    if (planet1 == \"Mercury\" ||\
    \ planet1 == \"Venus\" || planet1 == \"Earth\" || \n        planet1 == \"Mars\"\
    \ || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || \n        planet1 == \"\
    Neptune\" || planet1 == \"Uranus\") {\n      return std::make_tuple(planet2, planet1);\n\
    \    }\n  }\n  \n  return std::make_tuple();\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpka38ymht.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpka38ymht.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpka38ymht.cpp:23:29: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   23 |       return\
    \ std::make_tuple(planet1, planet2);\n      |              ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                             |\n      |                             std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpka38ymht.cpp:32:29:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   32 |       return\
    \ std::make_tuple(planet2, planet1);\n      |              ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                             |\n      |                             std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpka38ymht.cpp:36:25:\
    \ error: cannot convert \u2018std::tuple<>\u2019 to \u2018int\u2019 in return\n\
    \   36 |   return std::make_tuple();\n      |          ~~~~~~~~~~~~~~~^~\n   \
    \   |                         |\n      |                         std::tuple<>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpka38ymht.cpp:2:\n/tmp/tmpka38ymht.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpka38ymht.cpp:40:48: error: no match for \u2018\
    operator==\u2019 (o"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double distance;\n    double distance1 = planet1.length();\n\
    \    double distance2 = planet2.length();\n    double distance3 = sqrt(distance1\
    \ * distance1);\n    double distance4 = sqrt(distance2 * distance2);\n    // This\
    \ loop calculates the distance of planet1 from planet2\n    for (int i = 0; i\
    \ < (distance3 - 1); i++) {\n        distance = sqrt((distance4 * (((i + 1) *\
    \ i) / distance3)) + (distance4 * (((i + 2) * i) / distance3)));\n    }\n    distance2\
    \ = sqrt(distance4 * ((distance3 - 1) * i) / distance3);\n    distance1 = sqrt(distance4\
    \ * ((distance3 - 2) * i) / distance3);\n    // This loop calculates the distance\
    \ of planet2 from planet1\n    for (int i = 0; i < (distance3 - 1); i++) {\n \
    \       distance = sqrt((distance4 * (((i + 1) * i) / distance3)) + (distance4\
    \ * (((i + 2) * i) / distance3)));\n    }\n    distance2 = sqrt(distance4 * ((distance3\
    \ - 1) * i) / distance3);\n    distance1 = sqrt(distance4 * ((distance3 - 2) *\
    \ i) / distance3);\n    // This loop calculates the distance of planet1 from planet2\n\
    \    for (int i = 0; i < (distance3 - 1); i++) {\n        distance = sqrt((distance4\
    \ * (((i + 1) * i) / distance3)) + (distance4 * (((i + 2) * i) / distance3)));\n\
    \    }\n    distance2 = sqrt(distance4 * ((distance3 - 1) * i) / distance3);\n\
    \    distance1 = sqrt(distance4 * ((distance3 - 2) * i) / distance3);\n    //\
    \ This loop calculates the distance of planet2 from planet1\n    for (int i =\
    \ 0; i < (distance3 - 1); i++) {\n        distance = sqrt((distance4 * (((i +\
    \ 1) * i) / distance3)) + (distance4 * (((i + 2) * i) / distance3)));\n    }\n\
    \    distance2 = sqrt(distance4 * ((distance3 - 1) * i) / distance3);\n    distance1\
    \ = sqrt(distance4 * ((distance3 - 2) * i) / distance3);\n    // This loop calculates\
    \ the distance of planet1 from planet2\n    for (int i = 0; i < (distance3 - 1);\
    \ i++) {\n        distance = sqrt((distance4 * (((i + 1) * i) / distance3)) +\
    \ (distance4 * (((i + 2) * i) / distance3)));\n    }\n    distance2 = sqrt(distance4\
    \ * ((distance3 - 1) * i) / distance3);\n    distance1 = sqrt(distance4 * ((distance3\
    \ - 2) * i) / distance3);\n    // This loop calculates the distance of planet2\
    \ from planet1\n    for (int i = 0; i < (distance3 - 1); i++) {\n        distance\
    \ = sqrt((distance4 * (\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpo5fhn3df.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpo5fhn3df.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpo5fhn3df.cpp:26:53: error: \u2018\
    i\u2019 was not declared in this scope\n   26 |     distance2 = sqrt(distance4\
    \ * ((distance3 - 1) * i) / distance3);\n      |                             \
    \                        ^\n/tmp/tmpo5fhn3df.cpp:55:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   55 | }\n      | ^\n/tmp/tmpo5fhn3df.cpp:54:39:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   54 |         distance\
    \ = sqrt((distance4 * (\n      |                                      ~^\n   \
    \   |                                       )\n   55 | }\n      | ~          \
    \                            \n/tmp/tmpo5fhn3df.cpp:54:39: error: expected \u2018\
    )\u2019 before \u2018}\u2019 token\n   54 |         distance = sqrt((distance4\
    \ * (\n      |                         ~             ^\n      |              \
    \                         )\n   55 | }\n      | ~                            \
    \          \n/tmp/tmpo5fhn3df.cpp:56:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   56 | int main() {\n      |            ^\n\
    /tmp/tmpo5fhn3df.cpp:65:1: error: expected \u2018}\u2019 at end of input\n   65\
    \ | }\n      | ^\n/tmp/tmpo5fhn3df.cpp:16:72: note: to match this \u2018{\u2019\
    \n   16 | std::tuple<std::string, > bf(std::string planet1, std::string planet2)\
    \ {\n      |                                                                 \
    \       ^\n/tmp/tmpo5fhn3df.cpp:65:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   65 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::ifstream inFile;\n    inFile.open(\"planets.txt\"\
    );\n    std::string line;\n    std::tuple<std::string, > result;\n    if (inFile)\
    \ {\n        std::getline(inFile, line);\n        std::stringstream ss(line);\n\
    \        std::string planet, orbit;\n        std::tuple<std::string, > result;\n\
    \        while (std::getline(ss, planet, '\\n')) {\n            std::getline(ss,\
    \ orbit, '\\n');\n            double distance = planet.find(\"Sun\") - orbit.find(\"\
    Sun\");\n            std::cout << distance << std::endl;\n        }\n        inFile.close();\n\
    \    }\n    else {\n        std::cout << \"Cannot open planets.txt!\\n\";\n  \
    \  }\n    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnjtj4gja.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpnjtj4gja.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpnjtj4gja.cpp:20:29: error: template\
    \ argument 2 is invalid\n   20 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmpnjtj4gja.cpp:25:33: error: template\
    \ argument 2 is invalid\n   25 |         std::tuple<std::string, > result;\n \
    \     |                                 ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnjtj4gja.cpp:2:\n/tmp/tmpnjtj4gja.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpnjtj4gja.cpp:40:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   40 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpnjtj4gja.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/su"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  // code here\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpok4975_1.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpok4975_1.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpok4975_1.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpok4975_1.cpp:2:\n/tmp/tmpok4975_1.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpok4975_1.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpok4975_1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" ||\
    \ planet1 == \"Pluto\");\n    assert(planet2 == \"Mercury\" || planet2 == \"Venus\"\
    \ || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" ||\
    \ planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" ||\
    \ planet2 == \"Pluto\");\n    \n    if (planet1 == \"Mercury\") {\n        if\
    \ (planet2 == \"Saturn\") {\n            return std::make_tuple(\"Uranus\");\n\
    \        } else if (planet2 == \"Uranus\") {\n            return std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n      \
    \  } else if (planet2 == \"Neptune\") {\n            return std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    );\n        } else if (planet2 == \"Pluto\") {\n            return std::make_tuple();\n\
    \        } else if (planet2 == \"Earth\") {\n            return std::make_tuple(\"\
    Venus\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n      \
    \  } else if (planet2 == \"Mars\") {\n            return std::make_tuple(\"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\");\n        } else if (planet2 == \"Jupiter\"\
    ) {\n            return std::make_tuple(\"Saturn\", \"Uranus\", \"Neptune\");\n\
    \        } else if (planet2 == \"Saturn\") {\n            return std::make_tuple(\"\
    Uranus\", \"Neptune\");\n        } else if (planet2 == \"Uranus\") {\n       \
    \     return std::make_tuple(\"Neptune\");\n        } else if (planet2 == \"Neptune\"\
    ) {\n            return std::make_tuple(\"Pluto\");\n        } else if (planet2\
    \ == \"Pluto\") {\n            return std::make_tuple(\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n        } else if (planet2 ==\
    \ \"Earth\") {\n            return std::make_tuple(\"Venus\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\");\n        } else if (planet2 == \"Mars\"\
    ) {\n            return std::make_tuple(\"Jupiter\", \"S\n}\nint main() {\n  \
    \  auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpljflmlwb.cpp:46:47: warning: missing terminating \" character\n\
    \   46 |             return std::make_tuple(\"Jupiter\", \"S\n      |        \
    \                                       ^\n/tmp/tmpljflmlwb.cpp:46:47: error:\
    \ missing terminating \" character\n   46 |             return std::make_tuple(\"\
    Jupiter\", \"S\n      |                                               ^~\n/tmp/tmpljflmlwb.cpp:16:25:\
    \ error: template argument 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                         ^\n/tmp/tmpljflmlwb.cpp:\
    \ In function \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmpljflmlwb.cpp:22:35:\
    \ error: cannot convert \u2018std::tuple<const char*>\u2019 to \u2018int\u2019\
    \ in return\n   22 |             return std::make_tuple(\"Uranus\");\n      |\
    \                    ~~~~~~~~~~~~~~~^~~~~~~~~~\n      |                      \
    \             |\n      |                                   std::tuple<const char*>\n\
    /tmp/tmpljflmlwb.cpp:24:35: error: cannot convert \u2018std::tuple<const char*,\
    \ const char*, const char*, const char*, const char*, const char*>\u2019 to \u2018\
    int\u2019 in return\n   24 |             return std::make_tuple(\"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n      |          \
    \          ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                   |\n      |                        \
    \           std::tuple<const char*, const char*, const char*, const char*, const\
    \ char*, const char*>\n/tmp/tmpljflmlwb.cpp:26:35: error: cannot convert \u2018\
    std::tuple<const char*, const char*, const char*, const char*, const char*, const\
    \ char*, const char*>\u2019 to \u2018int\u2019 in return\n   26 |            \
    \ return std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\");\n      |                    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                   |\n      |                        \
    \           std::tuple<const char*, const char*, const char*, const char*, const\
    \ char*, const char*, const char*"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n     //assert(planet1.compare(\"Mercury\") != 0); //\
    \ Mercury is not Mercury\n     //assert(planet1.compare(\"Jupiter\") != 0); //\
    \ Jupiter is not Jupiter\n     //assert(planet1.compare(\"Earth\") != 0); // Earth\
    \ is not Earth\n     //assert(planet1.compare(\"Venus\") != 0); // Venus is not\
    \ Venus\n     //assert(planet1.compare(\"Mars\") != 0); // Mars is not Mars\n\
    \     //assert(planet1.compare(\"Saturn\") != 0); // Saturn is not Saturn\n  \
    \   //assert(planet1.compare(\"Uranus\") != 0); // Uranus is not Uranus\n    \
    \ //assert(planet1.compare(\"Neptune\") != 0); // Neptune is not Neptune\n   \
    \  //assert(planet1.compare(\"Mercury\") != 0); // Mercury is not Mercury\n  \
    \   //assert(planet1.compare(\"Jupiter\") != 0); // Jupiter is not Jupiter\n \
    \    //assert(planet1.compare(\"Earth\") != 0); // Earth is not Earth\n     //assert(planet1.compare(\"\
    Venus\") != 0); // Venus is not Venus\n     //assert(planet1.compare(\"Mars\"\
    ) != 0); // Mars is not Mars\n     //assert(planet1.compare(\"Saturn\") != 0);\
    \ // Saturn is not Saturn\n     //assert(planet1.compare(\"Uranus\") != 0); //\
    \ Uranus is not Uranus\n     //assert(planet1.compare(\"Neptune\") != 0); // Neptune\
    \ is not Neptune\n     //assert(planet1.compare(\"Mercury\") != 0); // Mercury\
    \ is not Mercury\n     //assert(planet1.compare(\"Jupiter\") != 0); // Jupiter\
    \ is not Jupiter\n     //assert(planet1.compare(\"Earth\") != 0); // Earth is\
    \ not Earth\n     //assert(planet1.compare(\"Venus\") != 0); // Venus is not Venus\n\
    \     //assert(planet1.compare(\"Mars\") != 0); // Mars is not Mars\n     //assert(planet1.compare(\"\
    Saturn\") != 0); // Saturn is not Saturn\n     //assert(planet1.compare(\"Uranus\"\
    ) != 0); // Uranus is not Uranus\n     //assert(planet1.compare(\"Neptune\") !=\
    \ 0); // Neptune is not Neptune\n}\nint main() {\n    auto candidate = bf;\n \
    \   assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpj6iyvyef.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpj6iyvyef.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpj6iyvyef.cpp:41:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   41 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpj6iyvyef.cpp:2:\n/tmp/tmpj6iyvyef.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpj6iyvyef.cpp:44:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   44 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpj6iyvyef.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    const char* name1 = planet1.c_str();\n    const\
    \ char* name2 = planet2.c_str();\n    std::string names[3];\n    int i = 0;\n\
    \    if (name1 == \"Mercury\") {\n        names[i++] = name2;\n    }\n    else\
    \ if (name1 == \"Venus\") {\n        names[i++] = name2;\n    }\n    else if (name1\
    \ == \"Earth\") {\n        names[i++] = name2;\n    }\n    else if (name1 == \"\
    Mars\") {\n        names[i++] = name2;\n    }\n    else if (name1 == \"Jupiter\"\
    ) {\n        names[i++] = name2;\n    }\n    else if (name1 == \"Saturn\") {\n\
    \        names[i++] = name2;\n    }\n    else if (name1 == \"Uranus\") {\n   \
    \     names[i++] = name2;\n    }\n    else if (name1 == \"Neptune\") {\n     \
    \   names[i++] = name2;\n    }\n    return std::make_tuple(names[0]);\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl3y9bcsl.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpl3y9bcsl.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpl3y9bcsl.cpp:45:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   45 |     return\
    \ std::make_tuple(names[0]);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~\n \
    \     |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl3y9bcsl.cpp:2:\n/tmp/tmpl3y9bcsl.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpl3y9bcsl.cpp:49:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   49 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpl3y9bcsl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<int> planets_orbit;\n    planets_orbit.push_back(0);\n\
    \    planets_orbit.push_back(1);\n    planets_orbit.push_back(2);\n    planets_orbit.push_back(3);\n\
    \    planets_orbit.push_back(4);\n    planets_orbit.push_back(5);\n    planets_orbit.push_back(6);\n\
    \    planets_orbit.push_back(7);\n    // We are working with coordinates of planets.\n\
    \    // Earth orbit: x = 0, y = 1\n    // Mercury orbit: x = 2, y = 0\n    //\
    \ Uranus orbit: x = 4, y = 1\n    // ...\n    // Sol orbit: x = 6, y = 6\n\n \
    \   // So we will use if-statements to check our planet names.\n    if (planet1\
    \ == \"Earth\") {\n        if (planet2 == \"Mercury\") {\n            return std::make_tuple(planet1,\
    \ planet2);\n        } else if (planet2 == \"Venus\") {\n            return std::make_tuple(planet1,\
    \ planet2);\n        } else if (planet2 == \"Earth\") {\n            return std::make_tuple(planet1,\
    \ planet2);\n        } else if (planet2 == \"Mars\") {\n            return std::make_tuple(planet1,\
    \ planet2);\n        } else if (planet2 == \"Jupiter\") {\n            return\
    \ std::make_tuple(planet1, planet2);\n        } else if (planet2 == \"Saturn\"\
    ) {\n            return std::make_tuple(planet1, planet2);\n        } else if\
    \ (planet2 == \"Neptune\") {\n            return std::make_tuple(planet1, planet2);\n\
    \        } else if (planet2 == \"Uranus\") {\n            return std::make_tuple(planet1,\
    \ planet2);\n        } else if (planet2 == \"Neptune\") {\n            return\
    \ std::make_tuple(planet1, planet2);\n        } else if (planet2 == \"Mercury\"\
    ) {\n            return std::make_tuple(planet1, planet2);\n        } else if\
    \ (planet2 == \"Venus\") {\n            return std::make_tuple(planet1, planet2);\n\
    \        } else {\n            return std::make_tuple();\n        }\n    } else\
    \ if (planet1 == \"Mercury\") {\n        if (planet2 == \"Uranus\") {\n      \
    \      return std::make_tuple(planet1, planet2);\n        } else if (planet2 ==\
    \ \"Earth\") {\n            return std::make_tuple(planet1, planet2);\n      \
    \  } else if (planet2 == \"Mars\") {\n            return std::make_tuple(planet1,\
    \ planet2);\n        } else if (planet2 == \"Jupiter\") {\n            return\
    \ std::make_tuple(planet1, planet2);\n        } else if (planet2 == \"Saturn\"\
    ) {\n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplu5z08fr.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmplu5z08fr.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmplu5z08fr.cpp:36:35: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   36 |       \
    \      return std::make_tuple(planet1, planet2);\n      |                    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                                   |\n      |                        \
    \           std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\n/tmp/tmplu5z08fr.cpp:38:35: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in return\n   38 |             return std::make_tuple(planet1,\
    \ planet2);\n      |                    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n  \
    \    |                                   |\n      |                          \
    \         std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\n/tmp/tmplu5z08fr.cpp:40:35: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in return\n   40 |             return std::make_tuple(planet1,\
    \ planet2);\n      |                    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n  \
    \    |                                   |\n      |                          \
    \         std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Your code here\n    std::tuple<std::string, >\
    \ ret;\n    \n    if (planet1 != planet2) {\n        return ret;\n    }\n    \n\
    \    double angle = std::atan2(std::sin((M_PI / 180) * (-90)), std::cos((M_PI\
    \ / 180) * (-90)));\n    double xp = std::cos((M_PI / 180) * ((90 - angle) / 360));\n\
    \    double yp = std::sin((M_PI / 180) * ((90 - angle) / 360));\n    \n    //\
    \ Distance between planet\n    double distance = ((xp * xp) + (yp * yp)) * 0.5;\n\
    \    // Distance to the sun\n    double distToSun = std::pow((distance / 2), 2)\
    \ + std::pow((distance * distance * distance), 0.5);\n    \n    std::tuple<std::string,\
    \ > ret2;\n    \n    if (planet1 == \"Mercury\") {\n        // Sort Mercury and\
    \ Venus based on distance to Sun \n        if (distToSun <= (1.0 + 2.3)) {\n \
    \           ret2 = std::make_tuple(planet2, \"Venus\");\n        }\n        if\
    \ (distToSun <= (2.3 + 3.6)) {\n            ret2 = std::make_tuple(planet1, \"\
    Earth\");\n        }\n        if (distToSun <= (3.6 + 4.8)) {\n            ret2\
    \ = std::make_tuple(planet1, \"Mars\");\n        }\n        if (distToSun <= (4.8\
    \ + 6.1)) {\n            ret2 = std::make_tuple(planet1, \"Jupiter\");\n     \
    \   }\n        if (distToSun <= (6.1 + 7.4)) {\n            ret2 = std::make_tuple(planet1,\
    \ \"Saturn\");\n        }\n        if (distToSun <= (7.4 + 8.7)) {\n         \
    \   ret2 = std::make_tuple(planet1, \"Uranus\");\n        }\n        if (distToSun\
    \ <= (8.7 + 9.1)) {\n            ret2 = std::make_tuple(planet1, \"Neptune\");\n\
    \        }\n    }\n    if (planet1 == \"Venus\") {\n        // Sort Mercury and\
    \ Venus based on distance to Sun \n        if (distToSun <= (1.0 + 0.1)) {\n \
    \           ret2 = std::make_tuple(planet2, \"Mercury\");\n        }\n       \
    \ if (distToSun <= (0.1 + 2.3)) {\n            ret2 = std::make_tuple(planet1,\
    \ \"Earth\");\n        }\n        if (distToSun <= (2.3 + 3.6)) {\n          \
    \  ret2 = std::make_tuple(planet1, \"Mars\");\n        }\n        if (distToSun\
    \ <= (3.6 + 4.8)) {\n            ret2 = std::make_tuple(planet1, \"\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpn_8yxui0.cpp:71:45: warning: missing terminating \" character\n\
    \   71 |             ret2 = std::make_tuple(planet1, \"\n      |             \
    \                                ^\n/tmp/tmpn_8yxui0.cpp:71:45: error: missing\
    \ terminating \" character\n/tmp/tmpn_8yxui0.cpp:16:25: error: template argument\
    \ 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string planet1, std::string\
    \ planet2) {\n      |                         ^\n/tmp/tmpn_8yxui0.cpp: In function\
    \ \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmpn_8yxui0.cpp:18:29: error:\
    \ template argument 2 is invalid\n   18 |     std::tuple<std::string, > ret;\n\
    \      |                             ^\n/tmp/tmpn_8yxui0.cpp:33:29: error: template\
    \ argument 2 is invalid\n   33 |     std::tuple<std::string, > ret2;\n      |\
    \                             ^\n/tmp/tmpn_8yxui0.cpp:38:35: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, const char*>\u2019 to \u2018int\u2019 in assignment\n   38 |            \
    \ ret2 = std::make_tuple(planet2, \"Venus\");\n      |                    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                                   |\n      |                        \
    \           std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, const char*>\n/tmp/tmpn_8yxui0.cpp:41:35: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, const char*>\u2019 to \u2018int\u2019 in assignment\n\
    \   41 |             ret2 = std::make_tuple(planet1, \"Earth\");\n      |    \
    \                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                  \
    \                 |\n      |                                   std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, const char*>\n/tmp/tmpn_8yxui0.cpp:44:35:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, const char*>\u2019 to \u2018int\u2019 in assignment\n\
    \   44 |             ret2 = std::make_tuple(planet1, \"Mars\");\n      |     \
    \               ~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > planets;\n    std::set<std::string>\
    \ planets1;\n    std::set<std::string> planets2;\n    std::set<std::string> planets3;\n\
    \n    planets1.insert(planet1);\n    planets2.insert(planet2);\n\n    for (auto\
    \ it1 = planets1.begin(); it1 != planets1.end(); it1++) {\n        for (auto it2\
    \ = planets2.begin(); it2 != planets2.end(); it2++) {\n            if (it1 !=\
    \ it2) {\n                auto dist = calculateDistance(*it1, *it2);\n       \
    \         if (dist < std::numeric_limits<float>::epsilon()) {\n              \
    \      planets3.insert(it1);\n                    planets3.insert(it2);\n    \
    \            }\n            }\n        }\n    }\n\n    planets = std::tuple<std::string,\
    \ >(std::move(planets3), std::move(planets2));\n    return planets;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1sqzhxtc.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp1sqzhxtc.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp1sqzhxtc.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > planets;\n    \
    \  |                             ^\n/tmp/tmp1sqzhxtc.cpp:28:29: error: \u2018\
    calculateDistance\u2019 was not declared in this scope\n   28 |              \
    \   auto dist = calculateDistance(*it1, *it2);\n      |                      \
    \       ^~~~~~~~~~~~~~~~~\n/tmp/tmp1sqzhxtc.cpp:30:40: error: no matching function\
    \ for call to \u2018std::set<std::__cxx11::basic_string<char> >::insert(std::_Rb_tree_const_iterator<std::__cxx11::basic_string<char>\
    \ >&)\u2019\n   30 |                     planets3.insert(it1);\n      |      \
    \                                  ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/set:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:87,\n\
    \                 from /tmp/tmp1sqzhxtc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_set.h:509:7:\
    \ note: candidate: \u2018std::pair<typename std::_Rb_tree<_Key, _Key, std::_Identity<_Tp>,\
    \ _Compare, typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_Key>::other>::const_iterator,\
    \ bool> std::set<_Key, _Compare, _Alloc>::insert(const value_type&) [with _Key\
    \ = std::__cxx11::basic_string<char>; _Compare = std::less<std::__cxx11::basic_string<char>\
    \ >; _Alloc = std::allocator<std::__cxx11::basic_string<char> >; typename std::_Rb_tree<_Key,\
    \ _Key, std::_Identity<_Tp>, _Compare, typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_Key>::other>::const_iterator\
    \ = std::_Rb_tree_const_iterator<std::__cxx11::basic_string<char> >; std::set<_Key,\
    \ _Compare, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n  509\
    \ |       insert(const value_type& __x)\n      |       ^~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_set.h:509:"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double a[3], b[3], sun[3], v[3], r[3];\n    \n \
    \   if (planet1 == \"Mercury\" && planet2 == \"Venus\") \n    {\n        // We\
    \ know that the planets are planet1 and planet2\n        // and the distance to\
    \ Mercury from Venus is \n        // sqrt(1 - r^2) = sqrt(1 - 1/sqrt(2)) ~ 1/sqrt(2)\n\
    \        // The two planets are near Venus.\n        v[0] = sqrt(1 - 1/sqrt(2));\n\
    \        v[1] = -1;\n        v[2] = 0;\n        a[0] = sun[0]; a[1] = sun[1];\
    \ a[2] = sun[2];\n        b[0] = sun[0]; b[1] = sun[1]; b[2] = sun[2];\n     \
    \   r[0] = sun[0]; r[1] = sun[1]; r[2] = sun[2];\n    } \n    else if (planet1\
    \ == \"Venus\" && planet2 == \"Earth\") \n    {\n        // We know that the planets\
    \ are planet1 and planet2\n        // and the distance to Venus from Earth is\
    \ \n        // sqrt(1 - r^2) = sqrt(1 - 1/sqrt(2)) ~ 1/sqrt(2)\n        // The\
    \ two planets are near Earth.\n        v[0] = sqrt(1 - 1/sqrt(2));\n        v[1]\
    \ = 1;\n        v[2] = 0;\n        a[0] = sun[0]; a[1] = sun[1]; a[2] = sun[2];\n\
    \        b[0] = sun[0]; b[1] = sun[1]; b[2] = sun[2];\n        r[0] = sun[0];\
    \ r[1] = sun[1]; r[2] = sun[2];\n    } \n    else if (planet1 == \"Venus\" &&\
    \ planet2 == \"Mars\") \n    {\n        // We know that the planets are planet1\
    \ and planet2\n        // and the distance to Venus from Mars is \n        //\
    \ sqrt(1 - r^2) = sqrt(1 - 1/sqrt(2)) ~ 1/sqrt(2)\n        // The two planets\
    \ are near Mars.\n        v[0] = sqrt(1 - 1/sqrt(2));\n        v[1] = 1;\n   \
    \     v[2] = 0;\n        a[0] = sun[0]; a[1] = sun[1]; a[2] = sun[2];\n      \
    \  b[0] = sun[0]; b[1] = sun[1]; b[2] = sun[2];\n        r[0] = sun[0]; r[1] =\
    \ sun[1]; r[2] = sun[2];\n    } \n    else if (planet1 == \"Venus\" && planet2\
    \ == \"Jupiter\") \n    {\n        // We know that the planets are planet1 and\
    \ planet2\n        // and the distance to Venus from Jupiter is \n        // sqrt(1\
    \ - r^2) = sqrt(1 - 1/sqrt(2)) ~ 1/sqrt(2)\n        // The two planets are near\
    \ Jupiter.\n        v[0] = sqrt(1 - 1/sqrt(2));\n        v[1] = 1;\n        v[2]\
    \ = 0;\n        a[0] = \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9x71zzze.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp9x71zzze.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp9x71zzze.cpp:68:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   68 | }\n      | ^\n/tmp/tmp9x71zzze.cpp:69:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   69 | int main() {\n      |            ^\n/tmp/tmp9x71zzze.cpp:78:1: error:\
    \ expected \u2018}\u2019 at end of input\n   78 | }\n      | ^\n/tmp/tmp9x71zzze.cpp:16:72:\
    \ note: to match this \u2018{\u2019\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                     ^\n/tmp/tmp9x71zzze.cpp:78:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   78 | }\n\
    \      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    auto l1 = planet1.length();\n    auto l2 = planet2.length();\n\
    \    if (l1 != l2) return std::tuple<std::string, >();\n    auto it1 = planet1.begin(),\
    \ it2 = planet2.begin();\n    while (it1 != planet1.end() && it2 != planet2.end())\n\
    \        if (*it1 < *it2) ++it1; else ++it2;\n    return std::tuple<std::string>(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqbsa6qft.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpqbsa6qft.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpqbsa6qft.cpp:19:50: error: template\
    \ argument 2 is invalid\n   19 |     if (l1 != l2) return std::tuple<std::string,\
    \ >();\n      |                                                  ^\n/tmp/tmpqbsa6qft.cpp:23:52:\
    \ error: no matching function for call to \u2018std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >::tuple(std::string&, std::string&)\u2019\
    \n   23 |     return std::tuple<std::string>(planet1, planet2);\n      |     \
    \                                               ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/functional:54,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpqbsa6qft.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/tuple:808:11:\
    \ note: candidate: \u2018template<class _Alloc, class _Dummy, class ... _UElements,\
    \ typename std::enable_if<((std::_TC<((1 == sizeof... (_UElements)) && (! std::is_same<std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >, std::tuple<_Tail ...> >::value)),\
    \ std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >::_MoveConstructibleTuple<_UElements ...>() && (! std::_TC<((1 == sizeof...\
    \ (_UElements)) && (! std::is_same<std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >, std::tuple<_Tail ...> >::value)),\
    \ std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>())) && std::_TC<(std::is_same<_Dummy,\
    \ void>::value && (1 == 1)), std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >::_NonNestedTuple<tuple<_Tail ...>&&>()), bool>::type\
    \ <anonymous> > std::tuple<_Elements>::"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    //declare variable for planet1 \n    std::string\
    \ planet1_name = planet1;\n    //declare variable for planet2 \n    std::string\
    \ planet2_name = planet2;\n    \n    //declare variable for radius of planet1\
    \ \n    double planet_1_radius_earth = 6378.388; //in km\n    \n    //declare\
    \ variable for radius of planet2 \n    double planet_2_radius_earth = 6378.388;\
    \ //in km\n    \n    //declare variable for distance of planet1 \n    double planet_1_distance_sun\
    \ = 39600.0; //in km\n    \n    //declare variable for distance of planet2 \n\
    \    double planet_2_distance_sun = 39600.0; //in km\n    \n    //declare variable\
    \ for earth radius \n    double earth_radius_earth = 6378.0;\n    \n    //declare\
    \ variable for earth distance \n    double earth_distance_sun = 40075.0; //in\
    \ km\n    \n    //declare variable for planet1 orbit \n    double planet_1_orbit\
    \ = 0.013869167959; //in seconds\n    \n    //declare variable for planet2 orbit\
    \ \n    double planet_2_orbit = 0.013869167959; //in seconds\n    \n    //declare\
    \ variable for planet2 distance \n    double planet_2_distance = earth_distance_sun\
    \ - planet_2_distance_sun;\n    \n    //declare variable for earth distance \n\
    \    double earth_distance = earth_radius_earth - planet_1_distance_sun;\n   \
    \ \n    //declare variable for distance between two planets \n    double distance_sun;\n\
    \    \n    \n    //declare variable for angle between two planets \n    double\
    \ angle_sun;\n    \n    //declare variable for angle between two planets \n  \
    \  double angle_earth_1;\n    \n    //declare variable for angle between two planets\
    \ \n    double angle_earth_2;\n    \n    //declare variable for distance between\
    \ two planets \n    double distance_earth_1;\n    \n    //declare variable for\
    \ distance between two planets \n    double distance_earth_2;\n    \n    //declare\
    \ variable for angle between two planets \n    double angle_earth_1_2;\n    \n\
    \    //declare variable for angle between two planets \n    double angle_earth_2_2;\n\
    \    \n    //declare variable for distance between two planets \n    double distance_earth_1_2;\n\
    \    \n    //declare variable for distance between two planets \n    double distance_earth_2_2;\n\
    \    \n    //declare \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplt6t31v9.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmplt6t31v9.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmplt6t31v9.cpp:85:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   85 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplt6t31v9.cpp:2:\n/tmp/tmplt6t31v9.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmplt6t31v9.cpp:88:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   88 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmplt6t31v9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  if (planet1.empty() || planet2.empty()) return std::make_tuple<std::string,\
    \ >();\n  \n  std::array<double, 6> planet1_orbit = {\n      -4.4484537,  1.50415129,\
    \ -3.95777179, 3.4658563,  4.6414277,\n      -9.9843278, 1.64171227, -2.34306729,\
    \ -9.8672439,  2.25041029};\n  std::array<double, 6> planet2_orbit = {\n     \
    \ -9.9843278, 1.64171227, -2.34306729, -9.8672439,  2.25041029,\n      -4.4484537,\
    \  1.50415129, -3.95777179, 3.4658563,  4.6414277};\n  double sun_distance = 0.497123276292489;\n\
    \  double sun_altitude = 45.;\n  double angle = 1.0;\n  double cos_angle = 1.0;\n\
    \  double sin_angle = 1.0;\n  \n  // Check if planets are correct planet names\n\
    \  if (planet1 == \"Mercury\" || planet1 == \"Venus\" ||\n      planet1 == \"\
    Earth\" || planet1 == \"Mars\" || \n      planet1 == \"Jupiter\" || planet1 ==\
    \ \"Saturn\" ||\n      planet1 == \"Uranus\" || planet1 == \"Neptune\") {\n  \
    \  if (planet2 == \"Mercury\" || planet2 == \"Venus\" ||\n        planet2 == \"\
    Earth\" || planet2 == \"Mars\" || \n        planet2 == \"Jupiter\" || planet2\
    \ == \"Saturn\" ||\n        planet2 == \"Uranus\" || planet2 == \"Neptune\") {\n\
    \      return std::make_tuple(planet1, planet2);\n    } else {\n      return std::make_tuple();\n\
    \    }\n  }\n  if (planet2 == \"Mercury\" || planet2 == \"Venus\" ||\n      planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || \n      planet2 == \"Jupiter\" || planet2\
    \ == \"Saturn\" ||\n      planet2 == \"Uranus\" || planet2 == \"Neptune\") {\n\
    \    return std::make_tuple();\n  }\n  \n  // First get the two planets' orbital\
    \ angles based on their name\n  if (planet1 == \"Mercury\") {\n    angle = -asin(-planet1_orbit[0]);\n\
    \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjcjgh1wi.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpjcjgh1wi.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpjcjgh1wi.cpp:17:55: error: parse\
    \ error in template argument list\n   17 |   if (planet1.empty() || planet2.empty())\
    \ return std::make_tuple<std::string, >();\n      |                          \
    \                             ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjcjgh1wi.cpp:17:81:\
    \ error: no matching function for call to \u2018make_tuple<std::string, <expression\
    \ error> >()\u2019\n   17 |   if (planet1.empty() || planet2.empty()) return std::make_tuple<std::string,\
    \ >();\n      |                                                              \
    \                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/functional:54,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpjcjgh1wi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/tuple:1470:5:\
    \ note: candidate: \u2018template<class ... _Elements> constexpr std::tuple<typename\
    \ std::__decay_and_strip<_Elements>::__type ...> std::make_tuple(_Elements&& ...)\u2019\
    \n 1470 |     make_tuple(_Elements&&... __args)\n      |     ^~~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/tuple:1470:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpjcjgh1wi.cpp:17:81:\
    \ error: template argument 2 is invalid\n   17 |   if (planet1.empty() || planet2.empty())\
    \ return std::make_tuple<std::string, >();\n      |                          \
    \                                                       ^\n/tmp/tmpjcjgh1wi.cpp:21:67:\
    \ error: too many initializers for \u2018std::array<double, 6>\u2019\n   21 |\
    \       -9.9843278, 1.64171227, -2.34306729, -9.8672439,  2.25041029};\n     \
    \ |                                                                   ^\n/tmp/tmpjcjgh1wi.cpp:24:66:\
    \ error: too many initializers for \u2018std::array<double, 6>\u2019\n   24 |\
    \      "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if(planet1 == \"Mercury\" && planet2 == \"Earth\"\
    ) return std::make_tuple(\"Mercury\", \"Venus\");\n    if(planet1 == \"Earth\"\
    \ && planet2 == \"Jupiter\") return std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\");\n    if(planet1 == \"Earth\" && planet2 == \"Neptune\"\
    ) return std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    );\n    if(planet1 == \"Venus\" && planet2 == \"Mars\") return std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"\
    Venus\" && planet2 == \"Neptune\") return std::make_tuple(\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Venus\" && planet2\
    \ == \"Jupiter\") return std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\");\n    if(planet1 == \"Mars\" && planet2 == \"Jupiter\") return std::make_tuple(\"\
    Mars\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Mars\"\
    \ && planet2 == \"Neptune\") return std::make_tuple(\"Mars\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Mars\" && planet2 == \"Saturn\"\
    ) return std::make_tuple(\"Mars\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    );\n    if(planet1 == \"Mars\" && planet2 == \"Uranus\") return std::make_tuple(\"\
    Mars\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Saturn\"\
    \ && planet2 == \"Uranus\") return std::make_tuple(\"Mars\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Saturn\" && planet2 == \"Neptune\"\
    ) return std::make_tuple(\"Mars\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    );\n    if(planet1 == \"Saturn\" && planet2 == \"Jupiter\") return std::make_tuple(\"\
    Mars\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Saturn\"\
    \ && planet2 == \"Mars\") return std::make_tuple(\"Mars\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Saturn\" && planet2 == \"Mercury\"\
    ) return std::make_tuple(\"Mars\", \"Earth\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpqt9bl1h8.cpp:31:84: warning: missing terminating \" character\n\
    \   31 |     if(planet1 == \"Saturn\" && planet2 == \"Mercury\") return std::make_tuple(\"\
    Mars\", \"Earth\n      |                                                     \
    \                               ^\n/tmp/tmpqt9bl1h8.cpp:31:84: error: missing\
    \ terminating \" character\n   31 |     if(planet1 == \"Saturn\" && planet2 ==\
    \ \"Mercury\") return std::make_tuple(\"Mars\", \"Earth\n      |             \
    \                                                                       ^~~~~~\n\
    /tmp/tmpqt9bl1h8.cpp:16:25: error: template argument 2 is invalid\n   16 | std::tuple<std::string,\
    \ > bf(std::string planet1, std::string planet2) {\n      |                  \
    \       ^\n/tmp/tmpqt9bl1h8.cpp: In function \u2018int bf(std::string, std::string)\u2019\
    :\n/tmp/tmpqt9bl1h8.cpp:17:74: error: cannot convert \u2018std::tuple<const char*,\
    \ const char*>\u2019 to \u2018int\u2019 in return\n   17 |     if(planet1 == \"\
    Mercury\" && planet2 == \"Earth\") return std::make_tuple(\"Mercury\", \"Venus\"\
    );\n      |                                                           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    \      |                                                                     \
    \     |\n      |                                                             \
    \             std::tuple<const char*, const char*>\n/tmp/tmpqt9bl1h8.cpp:18:74:\
    \ error: cannot convert \u2018std::tuple<const char*, const char*, const char*,\
    \ const char*, const char*>\u2019 to \u2018int\u2019 in return\n   18 |     if(planet1\
    \ == \"Earth\" && planet2 == \"Jupiter\") return std::make_tuple(\"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\");\n      |                       \
    \                                    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                                                     \
    \     |\n      |                                                             \
    \             std::tuple<const char*, const char*, const char*, const char*, const\
    \ char*>\n/tmp/tmpqt9bl1h8.cpp:19:74: error: cannot convert \u2018std::tuple<const\
    \ char*, const char*, const char*, const char*"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // your code here\n    \n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpep6cboi0.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpep6cboi0.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpep6cboi0.cpp:19:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   19 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpep6cboi0.cpp:2:\n/tmp/tmpep6cboi0.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpep6cboi0.cpp:22:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   22 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpep6cboi0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || \n          planet1 == \"Mars\" || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\" \n          || planet1 == \"Uranus\" || planet1\
    \ == \"Neptune\");\n  assert(planet2 == \"Mercury\" || planet2 == \"Venus\" ||\
    \ planet2 == \"Earth\" || \n          planet2 == \"Mars\" || planet2 == \"Jupiter\"\
    \ || planet2 == \"Saturn\" \n          || planet2 == \"Uranus\" || planet2 ==\
    \ \"Neptune\");\n  std::list<std::string> result;\n  // We can get the orbit of\
    \ planet1 from Earth\n  std::list<std::string> orbit_Earth = getOrbit(planet1,\
    \ true);\n  // We can get the orbit of planet2 from Earth\n  std::list<std::string>\
    \ orbit_Mercury = getOrbit(planet2, false);\n  // We want to loop through the\
    \ orbit of planet1 to check whether \n  // it contains planet2\n  std::list<std::string>::iterator\
    \ itr = orbit_Earth.begin();\n  for (; itr != orbit_Earth.end() ; itr++)\n   \
    \ if (*itr == planet2) result.push_back(*itr);\n  // We want to loop through the\
    \ orbit of planet2 to check whether \n  // it contains planet1\n  std::list<std::string>::iterator\
    \ itr2 = orbit_Mercury.begin();\n  for (; itr2 != orbit_Mercury.end() ; itr2++)\n\
    \    if (*itr2 == planet1) result.push_back(*itr2);\n  return std::make_tuple(result.begin(),\
    \ result.end());\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpidkjqsd0.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpidkjqsd0.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpidkjqsd0.cpp:25:40: error: \u2018\
    getOrbit\u2019 was not declared in this scope\n   25 |   std::list<std::string>\
    \ orbit_Earth = getOrbit(planet1, true);\n      |                            \
    \            ^~~~~~~~\n/tmp/tmpidkjqsd0.cpp:38:25: error: cannot convert \u2018\
    std::tuple<std::_List_iterator<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >, std::_List_iterator<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > > >\u2019 to \u2018int\u2019\
    \ in return\n   38 |   return std::make_tuple(result.begin(), result.end());\n\
    \      |          ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |     \
    \                    |\n      |                         std::tuple<std::_List_iterator<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >, std::_List_iterator<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpidkjqsd0.cpp:2:\n/tmp/tmpidkjqsd0.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpidkjqsd0.cpp:42:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   42 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \           "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double planet1Orbit, planet2Orbit;\n    if (planet1\
    \ == planet2) { \n        // The orbits of the two planets are the same. \n  \
    \      return std::make_tuple(planet1, );\n    }\n    if (planet1 == \"Mercury\"\
    ) {\n        planet1Orbit = 1.0;\n    }\n    else if (planet1 == \"Venus\") {\n\
    \        planet1Orbit = 2.0;\n    }\n    else if (planet1 == \"Earth\") {\n  \
    \      planet1Orbit = 4.0;\n    }\n    else if (planet1 == \"Mars\") {\n     \
    \   planet1Orbit = 8.0;\n    }\n    else if (planet1 == \"Jupiter\") {\n     \
    \   planet1Orbit = 16.0;\n    }\n    else if (planet1 == \"Saturn\") {\n     \
    \   planet1Orbit = 32.0;\n    }\n    else if (planet1 == \"Uranus\") {\n     \
    \   planet1Orbit = 64.0;\n    }\n    else if (planet1 == \"Neptune\") {\n    \
    \    planet1Orbit = 128.0;\n    }\n\n    if (planet2 == \"Mercury\") {\n     \
    \   planet2Orbit = 1.0;\n    }\n    else if (planet2 == \"Venus\") {\n       \
    \ planet2Orbit = 2.0;\n    }\n    else if (planet2 == \"Earth\") {\n        planet2Orbit\
    \ = 4.0;\n    }\n    else if (planet2 == \"Mars\") {\n        planet2Orbit = 8.0;\n\
    \    }\n    else if (planet2 == \"Jupiter\") {\n        planet2Orbit = 16.0;\n\
    \    }\n    else if (planet2 == \"Saturn\") {\n        planet2Orbit = 32.0;\n\
    \    }\n    else if (planet2 == \"Uranus\") {\n        planet2Orbit = 64.0;\n\
    \    }\n    else if (planet2 == \"Neptune\") {\n        planet2Orbit = 128.0;\n\
    \    }\n\n    std::tuple<std::string, > tuple;\n\n    double distance = 0;\n \
    \   double distanceToSun = 5.0;\n    if (planet1Orbit < planet2Orbit) {\n    \
    \    distance = planet1Orbit - planet2Orbit;\n    }\n    else if (planet1Orbit\
    \ > planet2Orbit) {\n        distance = planet2Orbit - planet1Orbit;\n    }\n\n\
    \    // distance is positive if planet1 orbit in right direction.\n    if (distance\
    \ > 0) {\n        double angle1 = asin((distance - distanceToSun) / 2.0);\n\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi3p7gqvx.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpi3p7gqvx.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpi3p7gqvx.cpp:20:41: error: expected\
    \ primary-expression before \u2018)\u2019 token\n   20 |         return std::make_tuple(planet1,\
    \ );\n      |                                         ^\n/tmp/tmpi3p7gqvx.cpp:72:29:\
    \ error: template argument 2 is invalid\n   72 |     std::tuple<std::string, >\
    \ tuple;\n      |                             ^\n/tmp/tmpi3p7gqvx.cpp:88:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n   88\
    \ | int main() {\n      |            ^\n/tmp/tmpi3p7gqvx.cpp:97:1: error: expected\
    \ \u2018}\u2019 at end of input\n   97 | }\n      | ^\n/tmp/tmpi3p7gqvx.cpp:16:72:\
    \ note: to match this \u2018{\u2019\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  // your code goes here\n  if(planet1 == \"Mercury\"\
    \ && planet2 == \"Uranus\")\n  {\n    return std::make_tuple(\"Saturn\", \"Uranus\"\
    );\n  }\n  else if(planet1 == \"Earth\" && planet2 == \"Mercury\")\n  {\n    return\
    \ std::make_tuple(\"Venus\");\n  }\n  else if(planet1 == \"Mercury\" && planet2\
    \ == \"Venus\")\n  {\n    return std::make_tuple(\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\");\n  }\n  else if(planet1 == \"Earth\" && planet2 ==\
    \ \"Earth\")\n  {\n    return std::make_tuple(\"\");\n  }\n  else if(planet1 ==\
    \ \"Venus\" && planet2 == \"Earth\")\n  {\n    return std::make_tuple(\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\");\n  }\n  else if(planet1\
    \ == \"Jupiter\" && planet2 == \"Earth\")\n  {\n    return std::make_tuple(\"\
    Jupiter\", \"Saturn\", \"Uranus\");\n  }\n  else if(planet1 == \"Saturn\" && planet2\
    \ == \"Earth\")\n  {\n    return std::make_tuple(\"Saturn\", \"Uranus\");\n  }\n\
    \  else if(planet1 == \"Uranus\" && planet2 == \"Earth\")\n  {\n    return std::make_tuple(\"\
    Uranus\", \"Neptune\");\n  }\n  else if(planet1 == \"Neptune\" && planet2 == \"\
    Earth\")\n  {\n    return std::make_tuple(\"Uranus\", \"Neptune\");\n  }\n  else\
    \ if(planet1 == \"Mars\" && planet2 == \"Earth\")\n  {\n    return std::make_tuple(\"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n  }\n  else if(planet1\
    \ == \"Jupiter\" && planet2 == \"Mars\")\n  {\n    return std::make_tuple(\"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\");\n  }\n  else if(planet1 == \"Saturn\"\
    \ && planet2 == \"Mars\")\n  {\n    return std::make_tuple(\"Saturn\", \"Uranus\"\
    , \"Neptune\");\n  }\n  else if(planet1 == \"Uranus\" && planet2 == \"Mars\")\n\
    \  {\n    return std::make_tuple(\"Uranus\", \"Neptune\");\n  }\n  else if(planet1\
    \ == \"Neptune\" && planet2 == \"Mars\")\n  {\n    return std::make_tuple(\"\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpp1b7gmsa.cpp:72:28: warning: missing terminating \" character\n\
    \   72 |     return std::make_tuple(\"\n      |                            ^\n\
    /tmp/tmpp1b7gmsa.cpp:72:28: error: missing terminating \" character\n/tmp/tmpp1b7gmsa.cpp:16:25:\
    \ error: template argument 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                         ^\n/tmp/tmpp1b7gmsa.cpp:\
    \ In function \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmpp1b7gmsa.cpp:20:27:\
    \ error: cannot convert \u2018std::tuple<const char*, const char*>\u2019 to \u2018\
    int\u2019 in return\n   20 |     return std::make_tuple(\"Saturn\", \"Uranus\"\
    );\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n      |          \
    \                 |\n      |                           std::tuple<const char*,\
    \ const char*>\n/tmp/tmpp1b7gmsa.cpp:24:27: error: cannot convert \u2018std::tuple<const\
    \ char*>\u2019 to \u2018int\u2019 in return\n   24 |     return std::make_tuple(\"\
    Venus\");\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~\n      |              \
    \             |\n      |                           std::tuple<const char*>\n/tmp/tmpp1b7gmsa.cpp:28:27:\
    \ error: cannot convert \u2018std::tuple<const char*, const char*, const char*,\
    \ const char*, const char*>\u2019 to \u2018int\u2019 in return\n   28 |     return\
    \ std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n\
    \      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<const\
    \ char*, const char*, const char*, const char*, const char*>\n/tmp/tmpp1b7gmsa.cpp:32:27:\
    \ error: cannot convert \u2018std::tuple<const char*>\u2019 to \u2018int\u2019\
    \ in return\n   32 |     return std::make_tuple(\"\");\n      |            ~~~~~~~~~~~~~~~^~~~\n\
    \      |                           |\n      |                           std::tuple<const\
    \ char*>\n/tmp/tmpp1b7gmsa.cpp:36:27: error: cannot convert \u2018std::tuple<const\
    \ char*, const char*, const char*, const char*, const char*, const char*>\u2019\
    \ to \u2018int\u2019 in return\n   36 |     return std::make_tuple(\"Venus\",\
    \ \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\");\n    "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n\t// Write your code here\n\t\n}\nint main() {\n   \
    \ auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptxjkm85h.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmptxjkm85h.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmptxjkm85h.cpp:19:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   19 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptxjkm85h.cpp:2:\n/tmp/tmptxjkm85h.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmptxjkm85h.cpp:22:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   22 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptxjkm85h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  int a = 0, b = 0;\n  string s1 = \"Mercury\", s2 =\
    \ \"Uranus\";\n  string s3 = \"Mars\", s4 = \"Jupiter\", s5 = \"Saturn\";\n  string\
    \ s6 = \"Earth \";\n  string s7 = \" Venus\";\n  string s8 = \" Mars\";\n  string\
    \ s9 = \" Jupiter\";\n  string s10 = \" Saturn\";\n  string s11 = \" Uranus\"\
    ;\n  string s12 = \" Neptune\";\n  string s13 = \" Pluto\";\n  string s14 = \"\
    \ Ceres\";\n  string s15 = \" Triton\";\n  string s16 = \" Cougar\";\n  string\
    \ s17 = \" Europa\";\n  string s18 = \" Callisto\";\n  string s19 = \" Nobelia\"\
    ;\n  string s20 = \" Callisto\";\n  string s21 = \" Einstein\";\n  string s22\
    \ = \" Belgium\";\n  string s23 = \" Hungary\";\n  string s24 = \" Netherlands\"\
    ;\n  string s25 = \" Greece\";\n  string s26 = \" France\";\n  string s27 = \"\
    \ Italy\";\n  string s28 = \" Switzerland\";\n  string s29 = \" Germany\";\n \
    \ string s30 = \" Romania\";\n  string s31 = \" Italy\";\n  string s32 = \" Denmark\"\
    ;\n  string s33 = \" Switzerland\";\n  string s34 = \" Switzerland\";\n  string\
    \ s35 = \" South Africa\";\n  string s36 = \" Austria\";\n  string s37 = \" Switzerland\"\
    ;\n  string s38 = \" Switzerland\";\n  string s39 = \" Switzerland\";\n  string\
    \ s40 = \" Switzerland\";\n  string s41 = \" Switzerland\";\n  string s42 = \"\
    \ Switzerland\";\n  string s43 = \" Switzerland\";\n  string s44 = \" Switzerland\"\
    ;\n  string s45 = \" Switzerland\";\n  string s46 = \" Switzerland\";\n  string\
    \ s47 = \" Switzerland\";\n  string s48 = \" Switzerland\n}\nint main() {\n  \
    \  auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3drrygbi.cpp:62:16: warning: missing terminating \" character\n\
    \   62 |   string s48 = \" Switzerland\n      |                ^\n/tmp/tmp3drrygbi.cpp:62:16:\
    \ error: missing terminating \" character\n   62 |   string s48 = \" Switzerland\n\
    \      |                ^~~~~~~~~~~~~\n/tmp/tmp3drrygbi.cpp:16:25: error: template\
    \ argument 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n      |                         ^\n/tmp/tmp3drrygbi.cpp:\
    \ In function \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmp3drrygbi.cpp:18:3:\
    \ error: \u2018string\u2019 was not declared in this scope; did you mean \u2018\
    std::string\u2019?\n   18 |   string s1 = \"Mercury\", s2 = \"Uranus\";\n    \
    \  |   ^~~~~~\n      |   std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp3drrygbi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmp3drrygbi.cpp:19:9:\
    \ error: expected \u2018;\u2019 before \u2018s3\u2019\n   19 |   string s3 = \"\
    Mars\", s4 = \"Jupiter\", s5 = \"Saturn\";\n      |         ^~~\n      |     \
    \    ;\n/tmp/tmp3drrygbi.cpp:20:9: error: expected \u2018;\u2019 before \u2018\
    s6\u2019\n   20 |   string s6 = \"Earth \";\n      |         ^~~\n      |    \
    \     ;\n/tmp/tmp3drrygbi.cpp:21:9: error: expected \u2018;\u2019 before \u2018\
    s7\u2019\n   21 |   string s7 = \" Venus\";\n      |         ^~~\n      |    \
    \     ;\n/tmp/tmp3drrygbi.cpp:22:9: error: expected \u2018"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double distance = 0;\n    double angle = 0;\n  \
    \  double latitude = 0;\n    double longitude = 0;\n    double sine_of_two_planets_distance\
    \ = 0;\n    double sine_of_two_planets_angle = 0;\n\n    planet1 = planet1.toupper();\
    \ // Convert planet name to uppercase\n    planet2 = planet2.toupper(); // Convert\
    \ planet name to uppercase\n\n    double a = cos(latitude);\n    double b = sin(latitude);\n\
    \    double c = cos(longitude);\n    double d = sin(longitude);\n\n    double\
    \ sine_of_two_planets_distance = a*a + b*b;\n    double sine_of_two_planets_angle\
    \ = atan2(-c, d);\n\n    distance = sine_of_two_planets_distance * c; // distance\
    \ between the planets\n\n    if (planet1.compare(planet2) == 0) {\n        //\
    \ Planets are the same planets\n        return (planet1, planet2);\n    } else\
    \ if (distance < 1.0) {\n        // Distance between the planets are less than\
    \ 1\n        return (planet1, planet2);\n    } else {\n        // Distance between\
    \ the planets are more than 1\n        angle = sine_of_two_planets_angle * 180.0\
    \ / M_PI; // angle between planets\n        if (angle > 180) {\n            angle\
    \ -= 360; // Correct angle \n        }\n        return (planet1 + \" \" + std::to_string(angle),\
    \ planet2 + \" \" + std::to_string(angle));\n    }\n\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpv3j0y0qv.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpv3j0y0qv.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpv3j0y0qv.cpp:24:23: error: \u2018\
    std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019} has\
    \ no member named \u2018toupper\u2019\n   24 |     planet1 = planet1.toupper();\
    \ // Convert planet name to uppercase\n      |                       ^~~~~~~\n\
    /tmp/tmpv3j0y0qv.cpp:25:23: error: \u2018std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018toupper\u2019\n   25 |     planet2 = planet2.toupper();\
    \ // Convert planet name to uppercase\n      |                       ^~~~~~~\n\
    /tmp/tmpv3j0y0qv.cpp:32:12: error: redeclaration of \u2018double sine_of_two_planets_distance\u2019\
    \n   32 |     double sine_of_two_planets_distance = a*a + b*b;\n      |      \
    \      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpv3j0y0qv.cpp:21:12: note: \u2018\
    double sine_of_two_planets_distance\u2019 previously declared here\n   21 |  \
    \   double sine_of_two_planets_distance = 0;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpv3j0y0qv.cpp:33:12: error: redeclaration of \u2018double sine_of_two_planets_angle\u2019\
    \n   33 |     double sine_of_two_planets_angle = atan2(-c, d);\n      |      \
    \      ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpv3j0y0qv.cpp:22:12: note: \u2018double\
    \ sine_of_two_planets_angle\u2019 previously declared here\n   22 |     double\
    \ sine_of_two_planets_angle = 0;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpv3j0y0qv.cpp:39:24: error: cannot convert \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018int\u2019 in return\n\
    \   39 |         return (planet1, planet2);\n      |                ~~~~~~~~^~~~~~~~~~\n\
    \      |                        |\n      |                        std::string\
    \ {aka std::__cxx11::basic_string<char>}\n/tmp/tmpv3j0y0qv.cpp:42:24: error: cannot\
    \ convert \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018int\u2019 in return\n   42 |         return (planet1, planet2);\n \
    \     |                ~~~~~~~~^~~~~~~~~~\n   "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 != \"\");\n    assert(planet2 !=\
    \ \"\");\n    std::tuple<std::string> planets;\n    // Write your code here\n\
    \    return planets;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuzyrxv05.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpuzyrxv05.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpuzyrxv05.cpp:21:12: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   21 |     return\
    \ planets;\n      |            ^~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuzyrxv05.cpp:2:\n/tmp/tmpuzyrxv05.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpuzyrxv05.cpp:25:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   25 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpuzyrxv05.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpq38g86kf.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpq38g86kf.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpq38g86kf.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq38g86kf.cpp:2:\n/tmp/tmpq38g86kf.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpq38g86kf.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpq38g86kf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > planets;\n    \n    std::string\
    \ sun = getSun();\n    \n    for (std::tuple<std::string, > t : planets) {\n \
    \       std::string a = getOrbit(a);\n        std::string b = getOrbit(b);\n \
    \       \n        if (a < sun && b < sun) {\n            \n        }\n    }\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1gl7ow_r.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp1gl7ow_r.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp1gl7ow_r.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > planets;\n    \
    \  |                             ^\n/tmp/tmp1gl7ow_r.cpp:19:23: error: \u2018\
    getSun\u2019 was not declared in this scope\n   19 |     std::string sun = getSun();\n\
    \      |                       ^~~~~~\n/tmp/tmp1gl7ow_r.cpp:21:34: error: template\
    \ argument 2 is invalid\n   21 |     for (std::tuple<std::string, > t : planets)\
    \ {\n      |                                  ^\n/tmp/tmp1gl7ow_r.cpp:21:40: error:\
    \ \u2018begin\u2019 was not declared in this scope; did you mean \u2018std::begin\u2019\
    ?\n   21 |     for (std::tuple<std::string, > t : planets) {\n      |        \
    \                                ^~~~~~~\n      |                            \
    \            std::begin\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp1gl7ow_r.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:1224:5:\
    \ note: \u2018std::begin\u2019 declared here\n 1224 |     begin(const valarray<_Tp>&\
    \ __va)\n      |     ^~~~~\n/tmp/tmp1gl7ow_r.cpp:21:40: error: \u2018end\u2019\
    \ was not declared in this scope; did you mean \u2018std::end\u2019?\n   21 |\
    \     for (std::tuple<std::string, > t : planets) {\n      |                 \
    \                       ^~~~~~~\n      |                                     \
    \   std::end\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp1gl7ow_r.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:1244:5:\
    \ note: \u2018std::end\u2019 declared here\n 1244 |     end(const valarray<_Tp>&\
    \ __va)\n      |     ^~~\n/tmp/tmp1gl7ow_r.cpp:22:25: error: \u2018getOrbit\u2019\
    \ was not declared in this scope\n   22 |         std::string a = getOrbit(a);\n\
    \      |                  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\") {\n\
    \        if (planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\"\
    \ || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" ||\
    \ planet2 == \"Uranus\" || planet2 == \"Neptune\") {\n            return std::make_tuple(planet1,\
    \ planet2);\n        }\n    }\n    else {\n        if (planet2 == \"Mercury\"\
    \ || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\") {\n            return std::make_tuple(planet2, planet1);\n \
    \       }\n    }\n    return std::make_tuple();\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpjwfhiiu6.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpjwfhiiu6.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpjwfhiiu6.cpp:19:35: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   19 |       \
    \      return std::make_tuple(planet1, planet2);\n      |                    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                                   |\n      |                        \
    \           std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\n/tmp/tmpjwfhiiu6.cpp:24:35: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in return\n   24 |             return std::make_tuple(planet2,\
    \ planet1);\n      |                    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n  \
    \    |                                   |\n      |                          \
    \         std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\n/tmp/tmpjwfhiiu6.cpp:27:27: error: cannot convert\
    \ \u2018std::tuple<>\u2019 to \u2018int\u2019 in return\n   27 |     return std::make_tuple();\n\
    \      |            ~~~~~~~~~~~~~~~^~\n      |                           |\n \
    \     |                           std::tuple<>\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjwfhiiu6.cpp:2:\n/tmp/tmpjwfhiiu6.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tm"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    return std::make_tuple(planet1);\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfa7w0wyt.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpfa7w0wyt.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpfa7w0wyt.cpp:17:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   17 |     return\
    \ std::make_tuple(planet1);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~\n   \
    \   |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfa7w0wyt.cpp:2:\n/tmp/tmpfa7w0wyt.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpfa7w0wyt.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfa7w0wyt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/sh"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1 == \"Jupiter\" || planet1 == \"Venus\"\
    \ || planet1 == \"Mars\" || \n        planet1 == \"Earth\" || planet1 == \"Mercury\"\
    \ || planet1 == \"Saturn\" || \n        planet1 == \"Uranus\" || planet1 == \"\
    Neptune\" || planet2 == \"Jupiter\" || \n        planet2 == \"Venus\" || planet2\
    \ == \"Mars\" || planet2 == \"Earth\" || \n        planet2 == \"Mercury\" || planet2\
    \ == \"Saturn\" || planet2 == \"Uranus\" || \n        planet2 == \"Neptune\")\
    \ {\n        return std::make_tuple(planet1, planet2);\n    }\n    else {\n  \
    \      return std::make_tuple();\n    }\n}\nint main() {\n    auto candidate =\
    \ bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpxvs6pmc1.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpxvs6pmc1.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpxvs6pmc1.cpp:23:31: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   23 |       \
    \  return std::make_tuple(planet1, planet2);\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\n/tmp/tmpxvs6pmc1.cpp:26:31: error: cannot convert \u2018std::tuple<>\u2019\
    \ to \u2018int\u2019 in return\n   26 |         return std::make_tuple();\n  \
    \    |                ~~~~~~~~~~~~~~~^~\n      |                             \
    \  |\n      |                               std::tuple<>\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxvs6pmc1.cpp:2:\n/tmp/tmpxvs6pmc1.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpxvs6pmc1.cpp:31:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   31 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Your code goes here\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4pdjeskm.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp4pdjeskm.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp4pdjeskm.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4pdjeskm.cpp:2:\n/tmp/tmp4pdjeskm.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp4pdjeskm.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp4pdjeskm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    auto [planet1orb, planet2orb] = get_planet_orbits(planet1,\
    \ planet2);\n    assert(planet1orb.size() > 0 && planet2orb.size() > 0);\n   \
    \ std::vector<std::pair<double, std::string>> orbits{planet1orb, planet2orb};\n\
    \    orbits.sort();\n    return orbits;\n}\nint main() {\n    auto candidate =\
    \ bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp3kvkt0xa.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp3kvkt0xa.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp3kvkt0xa.cpp:17:10: warning: structured\
    \ bindings only available with \u2018-std=c++17\u2019 or \u2018-std=gnu++17\u2019\
    \n   17 |     auto [planet1orb, planet2orb] = get_planet_orbits(planet1, planet2);\n\
    \      |          ^\n/tmp/tmp3kvkt0xa.cpp:17:37: error: \u2018get_planet_orbits\u2019\
    \ was not declared in this scope\n   17 |     auto [planet1orb, planet2orb] =\
    \ get_planet_orbits(planet1, planet2);\n      |                              \
    \       ^~~~~~~~~~~~~~~~~\n/tmp/tmp3kvkt0xa.cpp:19:78: error: no matching function\
    \ for call to \u2018std::vector<std::pair<double, std::__cxx11::basic_string<char>\
    \ > >::vector(<brace-enclosed initializer list>)\u2019\n   19 |     std::vector<std::pair<double,\
    \ std::string>> orbits{planet1orb, planet2orb};\n      |                     \
    \                                                         ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp3kvkt0xa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:650:2:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::vector<_Tp,\
    \ _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&)\u2019\
    \n  650 |  vector(_InputIterator __first, _InputIterator __last,\n      |  ^~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:650:2: note:\
    \   template argument deduction/substitution failed:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:622:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>,\
    \ const allocator_type&) [with _Tp = std::pair<double, std::__cxx11::basic_string<char>\
    \ >"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1o = planet1, planet2o = planet2;\n\
    \    for (size_t i = 0; i < planet1.size(); ++i)\n        if (planet1[i] == planet1o[i])\n\
    \            planet1o.erase(planet1o.begin() + i);\n    for (size_t i = 0; i <\
    \ planet2.size(); ++i)\n        if (planet2[i] == planet2o[i])\n            planet2o.erase(planet2o.begin()\
    \ + i);\n    std::vector<std::tuple<std::string, >> res;\n    if (planet1o.size()\
    \ != 0 && planet2o.size() != 0) {\n        std::string a = planet1o, b = planet2o;\n\
    \        size_t m = a.size(), n = b.size();\n        for (size_t i = 0; i < m\
    \ && i < n; ++i) {\n            if (a[i] != b[i])\n                break;\n  \
    \      }\n        std::vector<std::tuple<std::string, >> tmp;\n        while (i\
    \ < n) {\n            if (a[i] < b[i])\n                tmp.push_back((std::make_tuple(a.substr(0,\
    \ i), a.substr(i))));\n            else if (a[i] > b[i])\n                tmp.push_back((std::make_tuple(a.substr(i),\
    \ b.substr(i))));\n            else\n                tmp.push_back((std::make_tuple(a.substr(i),\
    \ a.substr(i))));\n            ++i;\n        }\n        res = std::move(tmp);\n\
    \    }\n    return std::move(res);\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpoq1lw6rb.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpoq1lw6rb.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpoq1lw6rb.cpp:24:39: error: template\
    \ argument 2 is invalid\n   24 |     std::vector<std::tuple<std::string, >> res;\n\
    \      |                                       ^\n/tmp/tmpoq1lw6rb.cpp:24:41:\
    \ error: template argument 1 is invalid\n   24 |     std::vector<std::tuple<std::string,\
    \ >> res;\n      |                                         ^~\n/tmp/tmpoq1lw6rb.cpp:24:41:\
    \ error: template argument 2 is invalid\n/tmp/tmpoq1lw6rb.cpp:32:43: error: template\
    \ argument 2 is invalid\n   32 |         std::vector<std::tuple<std::string, >>\
    \ tmp;\n      |                                           ^\n/tmp/tmpoq1lw6rb.cpp:32:45:\
    \ error: template argument 1 is invalid\n   32 |         std::vector<std::tuple<std::string,\
    \ >> tmp;\n      |                                             ^~\n/tmp/tmpoq1lw6rb.cpp:32:45:\
    \ error: template argument 2 is invalid\n/tmp/tmpoq1lw6rb.cpp:33:16: error: \u2018\
    i\u2019 was not declared in this scope\n   33 |         while (i < n) {\n    \
    \  |                ^\n/tmp/tmpoq1lw6rb.cpp:35:21: error: request for member \u2018\
    push_back\u2019 in \u2018tmp\u2019, which is of non-class type \u2018int\u2019\
    \n   35 |                 tmp.push_back((std::make_tuple(a.substr(0, i), a.substr(i))));\n\
    \      |                     ^~~~~~~~~\n/tmp/tmpoq1lw6rb.cpp:37:21: error: request\
    \ for member \u2018push_back\u2019 in \u2018tmp\u2019, which is of non-class type\
    \ \u2018int\u2019\n   37 |                 tmp.push_back((std::make_tuple(a.substr(i),\
    \ b.substr(i))));\n      |                     ^~~~~~~~~\n/tmp/tmpoq1lw6rb.cpp:39:21:\
    \ error: request for member \u2018push_back\u2019 in \u2018tmp\u2019, which is\
    \ of non-class type \u2018int\u2019\n   39 |                 tmp.push_back((std::make_tuple(a.substr(i),\
    \ a.substr(i))));\n      |                     ^~~~~~~~~\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylak"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // your code here\n    if(planet1 == \"Earth\" ||\
    \ planet2 == \"Earth\"){\n        return std::make_tuple(\"\");\n    }\n    if(planet1\
    \ == \"Mercury\" || planet2 == \"Mercury\"){\n        return std::make_tuple(planet1,\
    \ planet2);\n    }\n    if(planet1 == \"Venus\" || planet2 == \"Venus\"){\n  \
    \      return std::make_tuple(planet1, planet2);\n    }\n    if(planet1 == \"\
    Mars\" || planet2 == \"Mars\"){\n        return std::make_tuple(planet1, planet2);\n\
    \    }\n    if(planet1 == \"Jupiter\" || planet2 == \"Jupiter\"){\n        return\
    \ std::make_tuple(planet1, planet2);\n    }\n    if(planet1 == \"Saturn\" || planet2\
    \ == \"Saturn\"){\n        return std::make_tuple(planet1, planet2);\n    }\n\
    \    if(planet1 == \"Uranus\" || planet2 == \"Uranus\"){\n        return std::make_tuple(planet1,\
    \ planet2);\n    }\n    if(planet1 == \"Neptune\" || planet2 == \"Neptune\"){\n\
    \        return std::make_tuple(planet1, planet2);\n    }\n    \n    \n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph_skfj5k.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmph_skfj5k.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmph_skfj5k.cpp:19:31: error: cannot\
    \ convert \u2018std::tuple<const char*>\u2019 to \u2018int\u2019 in return\n \
    \  19 |         return std::make_tuple(\"\");\n      |                ~~~~~~~~~~~~~~~^~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<const char*>\n/tmp/tmph_skfj5k.cpp:22:31: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in return\n   22 |         return std::make_tuple(planet1,\
    \ planet2);\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |\
    \                               |\n      |                               std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmph_skfj5k.cpp:25:31:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   25 |       \
    \  return std::make_tuple(planet1, planet2);\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\n/tmp/tmph_skfj5k.cpp:28:31: error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\u2019 to \u2018int\u2019 in\
    \ return\n   28 |         return std::make_tuple(plane"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    assert(planet1 != \"\");\n    assert(planet2\
    \ != \"\");\n    // Create a vector to store planets we found.\n    // Add all\
    \ the planets we found into this vector\n    std::vector<std::string> planets;\n\
    \    planets.push_back(planet1);\n    planets.push_back(planet2);\n    \n    //\
    \ Create four time intervals which store the time interval between planets\n \
    \   // The intervals are stored in this vector in ascending order. \n    std::vector<std::pair<double,\
    \ double>> time_spans;\n    time_spans.push_back({0, planet2});\n    time_spans.push_back({planet1,\
    \ 0});\n    time_spans.push_back({planet2, planet1});\n    time_spans.push_back({planet1,\
    \ planet2});\n    \n    // Create a vector to store the planets we found during\
    \ the time intervals\n    // The first and last interval is special case\n   \
    \ std::vector<std::string> planets_in_time_spans;\n    planets_in_time_spans.push_back(planet1);\n\
    \    planets_in_time_spans.push_back(planet2);\n    \n    // Create a vector to\
    \ store the pairs of planets found during the time \n    // intervals in ascending\
    \ order\n    std::vector<std::pair<std::string, std::string>> found_pairs;\n \
    \   found_pairs.push_back({planet1, planet2});\n    found_pairs.push_back({planet2,\
    \ planet1});\n    \n    // Create a vector to store the pairs of planets found\
    \ during the time \n    // intervals in descending order\n    std::vector<std::pair<std::string,\
    \ std::string>> found_pairs_reversed;\n    found_pairs_reversed.push_back({planet2,\
    \ planet1});\n    found_pairs_reversed.push_back({planet1, planet2});\n    \n\
    \    // Create a vector to store the time intervals\n    // The first and last\
    \ time interval are special case\n    std::vector<std::pair<double, double>> time_spans_temp;\n\
    \    time_spans_temp.push_back({0, planet2});\n    time_spans_temp.push_back({planet1,\
    \ 0});\n    time_spans_temp.push_back({planet2, planet1});\n    time_spans_temp.push_back({planet1,\
    \ planet2});\n    \n    // Create a vector to store the pairs of time intervals\n\
    \    // The first and last intervals are special case\n    std::vector<std::pair<std::pair<double,\
    \ double>, std::pair<double, double>>> time_spans_temp_temp;\n    time_spans_temp_temp.push_back({{0,\
    \ planet2}, {planet1, 0}, {planet2, planet1}, {planet1, planet2}});\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbscrxu04.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpbscrxu04.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpbscrxu04.cpp:29:38: error: no matching\
    \ function for call to \u2018std::vector<std::pair<double, double> >::push_back(<brace-enclosed\
    \ initializer list>)\u2019\n   29 |     time_spans.push_back({0, planet2});\n\
    \      |                                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpbscrxu04.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::pair<double, double>; _Alloc = std::allocator<std::pair<double,\
    \ double> >; std::vector<_Tp, _Alloc>::value_type = std::pair<double, double>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018<brace-enclosed initializer\
    \ list>\u2019 to \u2018const value_type&\u2019 {aka \u2018const std::pair<double,\
    \ double>&\u2019}\n 1184 |       push_back(const value_type& __x)\n      |   \
    \              ~~~~~~~~~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::pair<double, double>; _Alloc = std::allocator<std::pair<double,\
    \ double> >; std::vector<_Tp, _Alloc>::value_type = std::pair<double, double>]\u2019\
    \n 1200 |       push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Complete the implementation of this function\n\
    \    \n    return std::tuple<std::string, >();\n    \n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpb_jgy5ny.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpb_jgy5ny.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpb_jgy5ny.cpp:19:36: error: template\
    \ argument 2 is invalid\n   19 |     return std::tuple<std::string, >();\n   \
    \   |                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb_jgy5ny.cpp:2:\n/tmp/tmpb_jgy5ny.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpb_jgy5ny.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpb_jgy5ny.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if(planet1 != \"Jupiter\" && planet1 != \"Mercury\"\
    \ && planet1 != \"Venus\" && planet1 != \"Earth\" &&\n        planet1 != \"Mars\"\
    \ && planet1 != \"Saturn\" && planet1 != \"Uranus\" && planet1 != \"Neptune\"\
    \ &&\n        planet2 != \"Jupiter\" && planet2 != \"Mercury\" && planet2 != \"\
    Venus\" && planet2 != \"Earth\" &&\n        planet2 != \"Mars\" && planet2 !=\
    \ \"Saturn\" && planet2 != \"Uranus\" && planet2 != \"Neptune\") {\n        std::cout\
    \ << \"wrong input\\n\";\n    }\n    auto it1 = planet1.begin();\n    auto it2\
    \ = planet2.begin();\n    \n    // if planet1 ends before planet2\n    if(it1\
    \ != planet1.end() && it2 != planet2.end()) {\n        if(it1 == it2) {\n    \
    \        // if planet1 is same as planet2\n            if(it1 != planet2.end())\
    \ {\n                it1 = planet1.begin();\n                it2 = planet2.begin();\n\
    \                \n                // if planet1 ends before planet2\n       \
    \         if(it1 != planet1.end() && it2 != planet2.end()) {\n               \
    \     // calculate the distance between the two planets\n                    double\
    \ d = distance(it1, it2);\n                    if(d <= 0.1) {\n              \
    \          it1 = planet1.begin();\n                        it2 = planet2.begin();\n\
    \                        if(it1 != planet1.end() && it2 != planet2.end()) {\n\
    \                            if(distance(it1, it2) <= 0.1) {\n               \
    \                 return std::make_tuple(planet1, planet2);\n                \
    \            } else {\n                                return std::make_tuple(planet2,\
    \ planet1);\n                            }\n                        } else {\n\
    \                            return std::make_tuple(planet2, planet1);\n     \
    \                   }\n                    } else {\n                        return\
    \ std::make_tuple(planet1, planet2);\n                    }\n                }\
    \ else {\n                    return std::make_tuple(planet1, planet2);\n    \
    \            }\n            } else {\n                return std::make_tuple(planet1,\
    \ planet2);\n            }\n        } else {\n            return std::make_tuple(planet2,\
    \ planet1);\n        }\n    } else {\n        return std::make_tuple(planet2,\
    \ planet1);\n    }\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpje5safs7.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpje5safs7.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpje5safs7.cpp:43:55: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   43 |       \
    \                          return std::make_tuple(planet1, planet2);\n      |\
    \                                        ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n \
    \     |                                                       |\n      |     \
    \                                                  std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpje5safs7.cpp:45:55:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   45 |       \
    \                          return std::make_tuple(planet2, planet1);\n      |\
    \                                        ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n \
    \     |                                                       |\n      |     \
    \                                                  std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpje5safs7.cpp:48:51:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   48 |       \
    \                      return std::make_tuple(planet2, planet1);\n      |    \
    \                                ~~~~~~~~~~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 != planet2);\n    std::tuple<std::string,\
    \ > result;\n    for (std::string planet : {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}) {\n        if (planet\
    \ == planet1 || planet == planet2) continue;\n        double dist = getDistance(planet,\
    \ planet1);\n        double dist1 = getDistance(planet, planet2);\n        double\
    \ a = dist - dist1;\n        double b = getAngle(planet, planet1);\n        double\
    \ c = getAngle(planet, planet2);\n        if (getDistance(planet, planet1) < getDistance(planet,\
    \ planet2)) {\n            double temp = b;\n            b = c;\n            c\
    \ = temp;\n        }\n        double ang = asin(b/(a*c));\n        result.emplace_back(planet);\n\
    \        result.emplace_back(planet1);\n        result.emplace_back(planet2);\n\
    \        result.emplace_back(std::to_string(ang));\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe2f9fdbg.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpe2f9fdbg.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpe2f9fdbg.cpp:18:29: error: template\
    \ argument 2 is invalid\n   18 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmpe2f9fdbg.cpp:21:23: error: \u2018getDistance\u2019\
    \ was not declared in this scope\n   21 |         double dist = getDistance(planet,\
    \ planet1);\n      |                       ^~~~~~~~~~~\n/tmp/tmpe2f9fdbg.cpp:24:20:\
    \ error: \u2018getAngle\u2019 was not declared in this scope\n   24 |        \
    \ double b = getAngle(planet, planet1);\n      |                    ^~~~~~~~\n\
    /tmp/tmpe2f9fdbg.cpp:32:16: error: request for member \u2018emplace_back\u2019\
    \ in \u2018result\u2019, which is of non-class type \u2018int\u2019\n   32 | \
    \        result.emplace_back(planet);\n      |                ^~~~~~~~~~~~\n/tmp/tmpe2f9fdbg.cpp:33:16:\
    \ error: request for member \u2018emplace_back\u2019 in \u2018result\u2019, which\
    \ is of non-class type \u2018int\u2019\n   33 |         result.emplace_back(planet1);\n\
    \      |                ^~~~~~~~~~~~\n/tmp/tmpe2f9fdbg.cpp:34:16: error: request\
    \ for member \u2018emplace_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   34 |         result.emplace_back(planet2);\n      |\
    \                ^~~~~~~~~~~~\n/tmp/tmpe2f9fdbg.cpp:35:16: error: request for\
    \ member \u2018emplace_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   35 |         result.emplace_back(std::to_string(ang));\n\
    \      |                ^~~~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe2f9fdbg.cpp:2:\n/tmp/tmpe2f9fdbg.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpe2f9fdbg.cpp:41:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   41 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Sa"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp7fjuv1nc.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp7fjuv1nc.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp7fjuv1nc.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7fjuv1nc.cpp:2:\n/tmp/tmp7fjuv1nc.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp7fjuv1nc.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp7fjuv1nc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" ||\n           planet1 == \"Mars\" || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\" ||\n           planet1 == \"Uranus\" || planet1\
    \ == \"Neptune\" ||\n           planet2 == \"Mercury\" || planet2 == \"Venus\"\
    \ || planet2 == \"Earth\" ||\n           planet2 == \"Mars\" || planet2 == \"\
    Jupiter\" || planet2 == \"Saturn\" ||\n           planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\");\n    \n    return std::make_tuple(planet1, planet2);\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3x_25kp7.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp3x_25kp7.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp3x_25kp7.cpp:24:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   24 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3x_25kp7.cpp:2:\n/tmp/tmp3x_25kp7.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp3x_25kp7.cpp:28:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   28 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp3x_25kp7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Complete the function here\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9b2op402.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp9b2op402.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp9b2op402.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9b2op402.cpp:2:\n/tmp/tmp9b2op402.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp9b2op402.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9b2op402.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1 = planet1.toLower();\n    std::string\
    \ planet2 = planet2.toLower();\n    std::tuple<std::string, > result;\n    if\
    \ ( planet1 == \"earth\" || planet2 == \"earth\") {\n        result = std::make_tuple(\"\
    earth\", \"mars\", \"jupiter\", \"saturn\", \"uranus\", \"neptune\");\n    }\n\
    \    else if ( planet1 == \"mercury\" || planet2 == \"mercury\") {\n        result\
    \ = std::make_tuple(\"mercury\", \"venus\");\n    }\n    else if ( planet1 ==\
    \ \"venus\" || planet2 == \"venus\") {\n        result = std::make_tuple(\"venus\"\
    );\n    }\n    else if ( planet1 == \"mars\" || planet2 == \"mars\") {\n     \
    \   result = std::make_tuple(\"mars\", \"jupiter\", \"saturn\", \"uranus\", \"\
    neptune\");\n    }\n    else if ( planet1 == \"jupiter\" || planet2 == \"jupiter\"\
    ) {\n        result = std::make_tuple(\"jupiter\", \"saturn\", \"uranus\", \"\
    neptune\");\n    }\n    else if ( planet1 == \"saturn\" || planet2 == \"saturn\"\
    ) {\n        result = std::make_tuple(\"saturn\", \"uranus\", \"neptune\");\n\
    \    }\n    else if ( planet1 == \"uranus\" || planet2 == \"uranus\") {\n    \
    \    result = std::make_tuple(\"uranus\", \"neptune\");\n    }\n    else if (\
    \ planet1 == \"neptune\" || planet2 == \"neptune\") {\n        result = std::make_tuple(\"\
    neptune\");\n    }\n    else {\n        result = std::make_tuple(\"\");\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzscog_lp.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpzscog_lp.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpzscog_lp.cpp:17:17: error: declaration\
    \ of \u2018std::string planet1\u2019 shadows a parameter\n   17 |     std::string\
    \ planet1 = planet1.toLower();\n      |                 ^~~~~~~\n/tmp/tmpzscog_lp.cpp:17:35:\
    \ error: \u2018std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018toLower\u2019\n   17 |     std::string planet1 = planet1.toLower();\n\
    \      |                                   ^~~~~~~\n/tmp/tmpzscog_lp.cpp:18:17:\
    \ error: declaration of \u2018std::string planet2\u2019 shadows a parameter\n\
    \   18 |     std::string planet2 = planet2.toLower();\n      |               \
    \  ^~~~~~~\n/tmp/tmpzscog_lp.cpp:18:35: error: \u2018std::string\u2019 {aka \u2018\
    class std::__cxx11::basic_string<char>\u2019} has no member named \u2018toLower\u2019\
    \n   18 |     std::string planet2 = planet2.toLower();\n      |              \
    \                     ^~~~~~~\n/tmp/tmpzscog_lp.cpp:19:29: error: template argument\
    \ 2 is invalid\n   19 |     std::tuple<std::string, > result;\n      |       \
    \                      ^\n/tmp/tmpzscog_lp.cpp:21:33: error: cannot convert \u2018\
    std::tuple<const char*, const char*, const char*, const char*, const char*, const\
    \ char*>\u2019 to \u2018int\u2019 in assignment\n   21 |         result = std::make_tuple(\"\
    earth\", \"mars\", \"jupiter\", \"saturn\", \"uranus\", \"neptune\");\n      |\
    \                  ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                 |\n      |                          \
    \       std::tuple<const char*, const char*, const char*, const char*, const char*,\
    \ const char*>\n/tmp/tmpzscog_lp.cpp:24:33: error: cannot convert \u2018std::tuple<const\
    \ char*, const char*>\u2019 to \u2018int\u2019 in assignment\n   24 |        \
    \ result = std::make_tuple(\"mercury\", \"venus\");\n      |                 \
    \ ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n      |                               \
    \  |\n      |               "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Your code here\n    // Write your code here\n\
    \    std::string names[7];\n    names[0] = \"Mercury\";\n    names[1] = \"Venus\"\
    ;\n    names[2] = \"Earth\";\n    names[3] = \"Mars\";\n    names[4] = \"Jupiter\"\
    ;\n    names[5] = \"Saturn\";\n    names[6] = \"Uranus\";\n    \n    std::tuple<std::string,std::string,std::string>\
    \ orbits;\n    std::string name1 = planet1.substr(0,2);\n    std::string name2\
    \ = planet2.substr(0,2);\n    std::string name11 = names[0] + name1;\n    std::string\
    \ name12 = names[1] + name1;\n    std::string name11 = names[0] + name2;\n   \
    \ std::string name21 = names[1] + name2;\n    if(name1 == name12){\n        orbits\
    \ = std::make_tuple(name11,name21,\"Earth\");\n    }else if(name2 == name21){\n\
    \        orbits = std::make_tuple(name12,name11,\"Earth\");\n    }else if(name1\
    \ == name11){\n        orbits = std::make_tuple(name11,name21,\"Earth\");\n  \
    \  }else if(name2 == name11){\n        orbits = std::make_tuple(name12,name21,\"\
    Earth\");\n    }else if(name1 == name21){\n        orbits = std::make_tuple(name11,name12,\"\
    Earth\");\n    }else if(name2 == name21){\n        orbits = std::make_tuple(name12,name11,\"\
    Earth\");\n    }else if(name1 == name21){\n        orbits = std::make_tuple(name11,name12,\"\
    Earth\");\n    }else{\n        assert(0);\n    }\n    \n    return orbits;\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpo06x1xvu.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpo06x1xvu.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpo06x1xvu.cpp:33:17: error: redeclaration\
    \ of \u2018std::string name11\u2019\n   33 |     std::string name11 = names[0]\
    \ + name2;\n      |                 ^~~~~~\n/tmp/tmpo06x1xvu.cpp:31:17: note:\
    \ \u2018std::string name11\u2019 previously declared here\n   31 |     std::string\
    \ name11 = names[0] + name1;\n      |                 ^~~~~~\n/tmp/tmpo06x1xvu.cpp:53:12:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   53 |     return\
    \ orbits;\n      |            ^~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpo06x1xvu.cpp:2:\n/tmp/tmpo06x1xvu.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpo06x1xvu.cpp:57:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   57 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpo06x1xvu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/rege"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    using std::cout;\n    using std::cin;\n    using\
    \ std::string;\n    using std::vector;\n    using std::tuple;\n    using std::pair;\n\
    \    using std::make_pair;\n    using std::sort;\n    using std::distance;\n \
    \   vector<string> planet;\n    planet.push_back(planet1);\n    planet.push_back(planet2);\n\
    \    sort(begin(planet), end(planet), [](string a, string b) { return distance(a,\
    \ b) < distance(planet[0], planet[1]); });\n    sort(begin(planet), end(planet));\n\
    \    vector<string>::iterator it1 = begin(planet);\n    vector<string>::iterator\
    \ it2 = it1;\n    vector<string>::iterator it3 = it2;\n    for (vector<string>::iterator\
    \ it2 = begin(planet); it2 != end(planet); it2++) \n    {\n        for (vector<string>::iterator\
    \ it3 = it2; it3 != begin(planet); it3++) \n        {\n            cout << distance(it1,\
    \ it3) << \" \";\n            it1 = it3;\n        }\n        cout << endl;\n \
    \   }\n    tuple<string, vector<string>> res = make_pair(planet1, planet);\n \
    \   return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_apg7ryk.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp_apg7ryk.cpp: In lambda function:\n\
    /tmp/tmp_apg7ryk.cpp:29:83: error: no matching function for call to \u2018distance(std::string&,\
    \ std::string&)\u2019\n   29 |     sort(begin(planet), end(planet), [](string\
    \ a, string b) { return distance(a, b) < distance(planet[0], planet[1]); });\n\
    \      |                                                                     \
    \              ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:66,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp_apg7ryk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator_base_funcs.h:138:5:\
    \ note: candidate: \u2018template<class _InputIterator> typename std::iterator_traits<_Iterator>::difference_type\
    \ std::distance(_InputIterator, _InputIterator)\u2019\n  138 |     distance(_InputIterator\
    \ __first, _InputIterator __last)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator_base_funcs.h:138:5:\
    \ note:   template argument deduction/substitution failed:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator_base_funcs.h:\
    \ In substitution of \u2018template<class _InputIterator> typename std::iterator_traits<_Iterator>::difference_type\
    \ std::distance(_InputIterator, _InputIterato"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > planets;\n    // Your\
    \ code goes here\n    return planets;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpy81g0gly.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpy81g0gly.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpy81g0gly.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > planets;\n    \
    \  |                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy81g0gly.cpp:2:\n/tmp/tmpy81g0gly.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpy81g0gly.cpp:23:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   23 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy81g0gly.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skyl"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if(planet1 == \"Mercury\" || planet2 == \"Mercury\"\
    ) {\n        std::tie(planet1, planet2) = bf(\"Venus\", planet1);\n    }\n   \
    \ if(planet1 == \"Venus\" || planet2 == \"Venus\") {\n        std::tie(planet1,\
    \ planet2) = bf(\"Earth\", planet1);\n    }\n    if(planet1 == \"Earth\" || planet2\
    \ == \"Earth\") {\n        std::tie(planet1, planet2) = bf(\"Mars\", planet1);\n\
    \    }\n    if(planet1 == \"Mars\" || planet2 == \"Mars\") {\n        std::tie(planet1,\
    \ planet2) = bf(\"Jupiter\", planet1);\n    }\n    if(planet1 == \"Jupiter\" ||\
    \ planet2 == \"Jupiter\") {\n        std::tie(planet1, planet2) = bf(\"Saturn\"\
    , planet1);\n    }\n    if(planet1 == \"Saturn\" || planet2 == \"Saturn\") {\n\
    \        std::tie(planet1, planet2) = bf(\"Uranus\", planet1);\n    }\n    if(planet1\
    \ == \"Uranus\" || planet2 == \"Uranus\") {\n        std::tie(planet1, planet2)\
    \ = bf(\"Neptune\", planet1);\n    }\n    if(planet1 == \"Neptune\" || planet2\
    \ == \"Neptune\") {\n        std::tie(planet1, planet2) = bf(\"Mercury\", planet2);\n\
    \    }\n    return std::tuple<std::string, >();\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpcofecrzk.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpcofecrzk.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpcofecrzk.cpp:18:57: error: no match\
    \ for \u2018operator=\u2019 (operand types are \u2018std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >&>\u2019 and \u2018int\u2019)\n\
    \   18 |         std::tie(planet1, planet2) = bf(\"Venus\", planet1);\n      |\
    \                                                         ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/functional:54,\n  \
    \               from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpcofecrzk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/tuple:1205:7:\
    \ note: candidate: \u2018std::tuple<_T1, _T2>& std::tuple<_T1, _T2>::operator=(typename\
    \ std::conditional<__assignable<const _T1&, const _T2&>(), const std::tuple<_T1,\
    \ _T2>&, const std::__nonesuch_no_braces&>::type) [with _T1 = std::__cxx11::basic_string<char>&;\
    \ _T2 = std::__cxx11::basic_string<char>&; typename std::conditional<__assignable<const\
    \ _T1&, const _T2&>(), const std::tuple<_T1, _T2>&, const std::__nonesuch_no_braces&>::type\
    \ = const std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >&>&]\u2019\n 1205 |       operator=(typename conditional<__assignable<const\
    \ _T1&, const _T2&>(),\n      |       ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/tuple:1207:45:\
    \ note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018std::conditional<true,\
    \ const std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >&>&, const std::__nonesuch_no_bra"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Your code here\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp3iufxond.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp3iufxond.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp3iufxond.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3iufxond.cpp:2:\n/tmp/tmp3iufxond.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp3iufxond.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp3iufxond.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    using std::cout;\n    using std::endl;\n    using\
    \ std::cin;\n    using std::tuple;\n    using std::string;\n    using std::getline;\n\
    \    using std::to_string;\n\n    // declare a tuple to save the planets' orbits\
    \ between\n    // two planets\n    std::tuple<std::string, > orbits;\n    // Declare\
    \ a tuple to save each planet's name as a string\n    string pl1, pl2;\n    //\
    \ Declare two variables to save the input string\n    string pl1_name, pl2_name;\n\
    \    // Declare a variable to save the distance of the planets from the sun\n\
    \    int distance;\n\n    // Ask the user to input the first planet name\n   \
    \ cout << \"Input the name of first planet: \" << endl;\n    getline(cin, pl1_name);\n\
    \    // Ask the user to input the second planet name\n    cout << \"Input the\
    \ name of second planet: \" << endl;\n    getline(cin, pl2_name);\n    // Calculate\
    \ the distance between the two planets\n    distance = calculate_distance(pl1_name,\
    \ pl2_name);\n    // Print the results\n    if (pl1 != pl2) {\n        cout <<\
    \ \"Planet names are different.\" << endl;\n    } else if (pl1 != pl2_name) {\n\
    \        cout << \"Planet names are the same.\" << endl;\n    }\n    cout << \"\
    The distance between the two planets is: \" << distance << endl;\n    // Print\
    \ the results\n    cout << \"The orbits of both planets are located: \" << endl;\n\
    \    // Print the orbits of first planet\n    cout << pl1 << endl;\n    orbits\
    \ = calculate_orbits(pl1, pl1_name, distance);\n    cout << \"The orbits of first\
    \ planet are: \" << endl;\n    cout << to_string(std::get<0>(orbits)) << endl;\n\
    \    // Print the orbits of second planet\n    cout << pl2 << endl;\n    orbits\
    \ = calculate_orbits(pl2, pl2_name, distance);\n    cout << \"The orbits of second\
    \ planet are: \" << endl;\n    cout << to_string(std::get<0>(orbits)) << endl;\n\
    \    // return the results\n    return orbits;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpjn7jef1j.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpjn7jef1j.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpjn7jef1j.cpp:27:29: error: template\
    \ argument 2 is invalid\n   27 |     std::tuple<std::string, > orbits;\n     \
    \ |                             ^\n/tmp/tmpjn7jef1j.cpp:42:16: error: \u2018calculate_distance\u2019\
    \ was not declared in this scope\n   42 |     distance = calculate_distance(pl1_name,\
    \ pl2_name);\n      |                ^~~~~~~~~~~~~~~~~~\n/tmp/tmpjn7jef1j.cpp:54:14:\
    \ error: \u2018calculate_orbits\u2019 was not declared in this scope\n   54 |\
    \     orbits = calculate_orbits(pl1, pl1_name, distance);\n      |           \
    \   ^~~~~~~~~~~~~~~~\n/tmp/tmpjn7jef1j.cpp:56:41: error: no matching function\
    \ for call to \u2018get<0>(int&)\u2019\n   56 |     cout << to_string(std::get<0>(orbits))\
    \ << endl;\n      |                                         ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:60,\n   \
    \              from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjn7jef1j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/utility:219:5:\
    \ note: candidate: \u2018template<long unsigned int _Int, class _Tp1, class _Tp2>\
    \ constexpr typename std::tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type& std::get(std::pair<_Tp1,\
    \ _Tp2>&)\u2019\n  219 |     get(std::pair<_Tp1, _Tp2>& __in) noexcept\n     \
    \ |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/utility:219:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpjn7jef1j.cpp:56:41:\
    \ note:   mismatched types \u2018std::pair<_Tp1, _Tp2>\u2019 and \u2018int\u2019\
    \n   56 |     cout << to_string(std::get<0>(orbits)) << endl;\n      |       \
    \                                  ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:60,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sunlon, sunlat, earth, mercury, venus, earth,\
    \ mars, jupiter,saturn, uranus, neptune;\n    double snod1,snod2;\n    double\
    \ snod,snod1,snod2;\n    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n\
    \    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n\
    \    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n\
    \    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n\
    \    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n\
    \    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n\
    \    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n\
    \    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n\
    \    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n\
    \    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n    double snod1,snod2,snod3;\n\
    \    double snod1,snod2,snod3;\n    double sno\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp6l4ye6tv.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp6l4ye6tv.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp6l4ye6tv.cpp:17:51: error: redeclaration\
    \ of \u2018double earth\u2019\n   17 |     double sunlon, sunlat, earth, mercury,\
    \ venus, earth, mars, jupiter,saturn, uranus, neptune;\n      |              \
    \                                     ^~~~~\n/tmp/tmp6l4ye6tv.cpp:17:28: note:\
    \ \u2018double earth\u2019 previously declared here\n   17 |     double sunlon,\
    \ sunlat, earth, mercury, venus, earth, mars, jupiter,saturn, uranus, neptune;\n\
    \      |                            ^~~~~\n/tmp/tmp6l4ye6tv.cpp:19:17: error:\
    \ redeclaration of \u2018double snod1\u2019\n   19 |     double snod,snod1,snod2;\n\
    \      |                 ^~~~~\n/tmp/tmp6l4ye6tv.cpp:18:12: note: \u2018double\
    \ snod1\u2019 previously declared here\n   18 |     double snod1,snod2;\n    \
    \  |            ^~~~~\n/tmp/tmp6l4ye6tv.cpp:19:23: error: redeclaration of \u2018\
    double snod2\u2019\n   19 |     double snod,snod1,snod2;\n      |            \
    \           ^~~~~\n/tmp/tmp6l4ye6tv.cpp:18:18: note: \u2018double snod2\u2019\
    \ previously declared here\n   18 |     double snod1,snod2;\n      |         \
    \         ^~~~~\n/tmp/tmp6l4ye6tv.cpp:20:12: error: redeclaration of \u2018double\
    \ snod1\u2019\n   20 |     double snod1,snod2,snod3;\n      |            ^~~~~\n\
    /tmp/tmp6l4ye6tv.cpp:18:12: note: \u2018double snod1\u2019 previously declared\
    \ here\n   18 |     double snod1,snod2;\n      |            ^~~~~\n/tmp/tmp6l4ye6tv.cpp:20:18:\
    \ error: redeclaration of \u2018double snod2\u2019\n   20 |     double snod1,snod2,snod3;\n\
    \      |                  ^~~~~\n/tmp/tmp6l4ye6tv.cpp:18:18: note: \u2018double\
    \ snod2\u2019 previously declared here\n   18 |     double snod1,snod2;\n    \
    \  |                  ^~~~~\n/tmp/tmp6l4ye6tv.cpp:21:12: error: redeclaration\
    \ of \u2018double snod1\u2019\n   21 |     double snod1,snod2,snod3;\n      |\
    \            ^~~~~\n/tmp/tmp6l4ye6tv.cpp:18:12: note: \u2018double snod1\u2019\
    \ previously declared here\n   18 |     double snod1,snod2;\n      |         \
    \   ^~~~~\n/tmp/t"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n\tconst double sun_radius = 6.96e8 * M_PI/180.0;\n\t\
    const double sun_mass = 5.9726e24;\n\t\n\tstd::tuple<std::string, > planets;\n\
    \t\n\tif(planet1 == planet2) {\n\t\treturn planets;\n\t}\n\t\n\tdouble distance\
    \ = Sun_distance_to_planet(planet1, planet2, sun_mass, sun_radius);\n\t\n\tif\
    \ (distance < 0) {\n\t\treturn planets;\n\t}\n\t\n\tdouble angle = (M_PI/180.0)\
    \ * acosf(M_PI/180.0*(planet1.size() - planet2.size())); \n\tdouble distance_to_planet\
    \ = distance + std::atan2f(planet1.size() - planet2.size(),\n\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t planet1.size() - planet2.size());\n\tdouble distance_to_sun = distance\
    \ + std::atan2f(planet1.size(), planet2.size());\n\t\n\tplanets.emplace_back(planet1);\n\
    \tplanets.emplace_back(planet2);\n\t\n\tstd::deque<std::string> planets2;\n\t\n\
    \twhile(angle <= M_PI/180.0) {\n\t\tdouble x = sinf(angle) * distance_to_sun;\n\
    \t\tdouble y = cosf(angle) * distance_to_sun;\n\t\tdouble new_x = distance_to_planet\
    \ * x;\n\t\tdouble new_y = distance_to_planet * y;\n\t\tdouble distance = std::hypot(new_x,\
    \ new_y);\n\t\t\n\t\tif((distance <= sun_radius)||(distance <= distance_to_planet))\
    \ {\n\t\t\tplanets.emplace_back(planet1);\n\t\t\tplanets.emplace_back(planet2);\n\
    \t\t\treturn planets;\n\t\t}\n\t\t\n\t\tdistance -= distance_to_planet;\n\t\t\
    angle += M_PI/180.0;\n\t\tdistance_to_planet += M_PI/180.0;\n\t\tdistance_to_sun\
    \ += M_PI/180.0;\n\t}\n\t\n\treturn planets;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpnz_kht1z.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpnz_kht1z.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpnz_kht1z.cpp:20:26: error: template\
    \ argument 2 is invalid\n   20 |  std::tuple<std::string, > planets;\n      |\
    \                          ^\n/tmp/tmpnz_kht1z.cpp:26:20: error: \u2018Sun_distance_to_planet\u2019\
    \ was not declared in this scope\n   26 |  double distance = Sun_distance_to_planet(planet1,\
    \ planet2, sun_mass, sun_radius);\n      |                    ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpnz_kht1z.cpp:33:46: error: \u2018atan2f\u2019 is not a member of \u2018\
    std\u2019; did you mean \u2018atan2\u2019?\n   33 |  double distance_to_planet\
    \ = distance + std::atan2f(planet1.size() - planet2.size(),\n      |         \
    \                                     ^~~~~~\n      |                        \
    \                      atan2\n/tmp/tmpnz_kht1z.cpp:35:43: error: \u2018atan2f\u2019\
    \ is not a member of \u2018std\u2019; did you mean \u2018atan2\u2019?\n   35 |\
    \  double distance_to_sun = distance + std::atan2f(planet1.size(), planet2.size());\n\
    \      |                                           ^~~~~~\n      |           \
    \                                atan2\n/tmp/tmpnz_kht1z.cpp:37:10: error: request\
    \ for member \u2018emplace_back\u2019 in \u2018planets\u2019, which is of non-class\
    \ type \u2018int\u2019\n   37 |  planets.emplace_back(planet1);\n      |     \
    \     ^~~~~~~~~~~~\n/tmp/tmpnz_kht1z.cpp:38:10: error: request for member \u2018\
    emplace_back\u2019 in \u2018planets\u2019, which is of non-class type \u2018int\u2019\
    \n   38 |  planets.emplace_back(planet2);\n      |          ^~~~~~~~~~~~\n/tmp/tmpnz_kht1z.cpp:50:12:\
    \ error: request for member \u2018emplace_back\u2019 in \u2018planets\u2019, which\
    \ is of non-class type \u2018int\u2019\n   50 |    planets.emplace_back(planet1);\n\
    \      |            ^~~~~~~~~~~~\n/tmp/tmpnz_kht1z.cpp:51:12: error: request for\
    \ member \u2018emplace_back\u2019 in \u2018planets\u2019, which is of non-class\
    \ type \u2018int\u2019\n   51 |    planets.emplace_back(planet2);\n      |   \
    \         ^~~~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > result;\n    assert(planet1\
    \ == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 ==\
    \ \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"\
    Uranus\" || planet1 == \"Neptune\");\n    assert(planet2 == \"Mercury\" || planet2\
    \ == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2 == \"\
    Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\"\
    );\n    if (planet1 < planet2) {\n        auto it = planet1.begin();\n       \
    \ auto it2 = planet2.begin();\n        while (it < planet1.end() && it2 < planet2.end())\
    \ {\n            auto distance = it2 - it;\n            if (distance > 0 && distance\
    \ < 2) {\n                result.push_back(planet1);\n                ++it;\n\
    \                ++it2;\n            } else if (distance > 2 && distance < 4)\
    \ {\n                result.push_back(planet2);\n                ++it;\n     \
    \           ++it2;\n            } else if (distance > 4) {\n                ++it;\n\
    \                ++it2;\n            } else {\n                ++it;\n       \
    \         ++it2;\n                ++it;\n                ++it2;\n            }\n\
    \        }\n    } else if (planet1 > planet2) {\n        auto it = planet1.begin();\n\
    \        auto it2 = planet2.begin();\n        while (it < planet1.end() && it2\
    \ < planet2.end()) {\n            auto distance = it2 - it;\n            if (distance\
    \ > 0 && distance < 2) {\n                result.push_back(planet2);\n       \
    \         ++it;\n                ++it2;\n            } else if (distance > 2 &&\
    \ distance < 4) {\n                result.push_back(planet1);\n              \
    \  ++it;\n                ++it2;\n            } else if (distance > 4) {\n   \
    \             ++it;\n                ++it2;\n            } else {\n          \
    \      ++it;\n                ++it2;\n                ++it;\n                ++it2;\n\
    \            }\n        }\n    } else {\n        return result;\n    }\n    std::sort(result.begin(),\
    \ result.end());\n    return result;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmped2fahbl.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmped2fahbl.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmped2fahbl.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmped2fahbl.cpp:26:24: error: request\
    \ for member \u2018push_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   26 |                 result.push_back(planet1);\n \
    \     |                        ^~~~~~~~~\n/tmp/tmped2fahbl.cpp:30:24: error: request\
    \ for member \u2018push_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   30 |                 result.push_back(planet2);\n \
    \     |                        ^~~~~~~~~\n/tmp/tmped2fahbl.cpp:49:24: error: request\
    \ for member \u2018push_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   49 |                 result.push_back(planet2);\n \
    \     |                        ^~~~~~~~~\n/tmp/tmped2fahbl.cpp:53:24: error: request\
    \ for member \u2018push_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   53 |                 result.push_back(planet1);\n \
    \     |                        ^~~~~~~~~\n/tmp/tmped2fahbl.cpp:69:22: error: request\
    \ for member \u2018begin\u2019 in \u2018result\u2019, which is of non-class type\
    \ \u2018int\u2019\n   69 |     std::sort(result.begin(), result.end());\n    \
    \  |                      ^~~~~\n/tmp/tmped2fahbl.cpp:69:38: error: request for\
    \ member \u2018end\u2019 in \u2018result\u2019, which is of non-class type \u2018\
    int\u2019\n   69 |     std::sort(result.begin(), result.end());\n      |     \
    \                                 ^~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmped2fahbl.cpp:2:\n/tmp/tmped2fahbl.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmped2fahbl.cpp:74:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   74"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1.length() >= 2);\n    assert(planet1.length()\
    \ <= 5);\n    assert(planet2.length() >= 2);\n    assert(planet2.length() <= 5);\n\
    \    return std::make_tuple(planet2, planet1, planet2, planet1);\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfr61t0n9.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpfr61t0n9.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpfr61t0n9.cpp:21:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   21 |     return\
    \ std::make_tuple(planet2, planet1, planet2, planet1);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfr61t0n9.cpp:2:\n/tmp/tmpfr61t0n9.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpfr61t0n9.cpp:25:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   25 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::tuple<std::string, > tuple;\n  if(planet1 ==\
    \ \"Mercury\") {\n    if(planet2 == \"Venus\") {\n      tuple = std::make_tuple(\"\
    Venus\", \"Mercury\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    );\n    }\n    else {\n      tuple = std::make_tuple();\n    }\n  }\n  else if(planet1\
    \ == \"Venus\") {\n    if(planet2 == \"Mercury\") {\n      tuple = std::make_tuple(\"\
    Mercury\", \"Venus\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    );\n    }\n    else {\n      tuple = std::make_tuple();\n    }\n  }\n  else if(planet1\
    \ == \"Earth\") {\n    if(planet2 == \"Mercury\") {\n      tuple = std::make_tuple(\"\
    Mercury\", \"Venus\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    );\n    }\n    else {\n      tuple = std::make_tuple();\n    }\n  }\n  else if(planet1\
    \ == \"Mars\") {\n    if(planet2 == \"Mercury\") {\n      tuple = std::make_tuple(\"\
    Mercury\", \"Venus\", \"Earth\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    );\n    }\n    else {\n      tuple = std::make_tuple();\n    }\n  }\n  else if(planet1\
    \ == \"Jupiter\") {\n    if(planet2 == \"Mercury\") {\n      tuple = std::make_tuple(\"\
    Mercury\", \"Venus\", \"Mars\", \"Earth\", \"Saturn\", \"Uranus\", \"Neptune\"\
    );\n    }\n    else {\n      tuple = std::make_tuple();\n    }\n  }\n  else if(planet1\
    \ == \"Saturn\") {\n    if(planet2 == \"Mercury\") {\n      tuple = std::make_tuple(\"\
    Mercury\", \"Venus\", \"Mars\", \"Mars\", \"Saturn\", \"Uranus\", \"Neptune\"\
    );\n    }\n    else {\n      tuple = std::make_tuple();\n    }\n  }\n  else if(planet1\
    \ == \"Uranus\") {\n    if(planet2 == \"Mercury\") {\n      tuple = std::make_tuple(\"\
    Mercury\", \"Venus\", \"Mars\", \"Mars\", \"Saturn\", \"Earth\", \"Neptune\");\n\
    \    }\n    else {\n      tuple = std::make_tuple();\n    }\n  }\n  else if(planet1\
    \ == \"Neptune\") {\n    if(planet2 == \"Mercury\") {\n      tuple = std::make_tuple(\"\
    Mercury\", \"Venus\", \"\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptxdigjwt.cpp:76:51: warning: missing terminating \" character\n\
    \   76 |       tuple = std::make_tuple(\"Mercury\", \"Venus\", \"\n      |   \
    \                                                ^\n/tmp/tmptxdigjwt.cpp:76:51:\
    \ error: missing terminating \" character\n/tmp/tmptxdigjwt.cpp:16:25: error:\
    \ template argument 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                         ^\n/tmp/tmptxdigjwt.cpp:\
    \ In function \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmptxdigjwt.cpp:17:27:\
    \ error: template argument 2 is invalid\n   17 |   std::tuple<std::string, > tuple;\n\
    \      |                           ^\n/tmp/tmptxdigjwt.cpp:20:30: error: cannot\
    \ convert \u2018std::tuple<const char*, const char*, const char*, const char*,\
    \ const char*, const char*, const char*>\u2019 to \u2018int\u2019 in assignment\n\
    \   20 |       tuple = std::make_tuple(\"Venus\", \"Mercury\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\");\n      |               ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                              |\n      |                             \
    \ std::tuple<const char*, const char*, const char*, const char*, const char*,\
    \ const char*, const char*>\n/tmp/tmptxdigjwt.cpp:23:30: error: cannot convert\
    \ \u2018std::tuple<>\u2019 to \u2018int\u2019 in assignment\n   23 |       tuple\
    \ = std::make_tuple();\n      |               ~~~~~~~~~~~~~~~^~\n      |     \
    \                         |\n      |                              std::tuple<>\n\
    /tmp/tmptxdigjwt.cpp:28:30: error: cannot convert \u2018std::tuple<const char*,\
    \ const char*, const char*, const char*, const char*, const char*, const char*>\u2019\
    \ to \u2018int\u2019 in assignment\n   28 |       tuple = std::make_tuple(\"Mercury\"\
    , \"Venus\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n  \
    \    |               ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                              |\n      |                             \
    \ std::tuple<const char*, const char*, const char*, const char*, const char*,\
    \ const char*, const c"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    return std::make_tuple(planet1, planet2);\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpml1iom_b.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpml1iom_b.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpml1iom_b.cpp:17:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   17 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpml1iom_b.cpp:2:\n/tmp/tmpml1iom_b.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpml1iom_b.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpml1iom_b.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    int i1 = planet1.size();\n    int i2 = planet2.size();\n\
    \    std::tuple<std::string, > s;\n    if(i1 == 0 || i2 == 0)\n        return\
    \ s;\n    for(int i=0;i<2;i++)\n    {\n        if(planet1[i-1] == planet2[i])\n\
    \        {\n            s.push_back(planet1);\n            s.push_back(planet2);\n\
    \            return s;\n        }\n    }\n    int d = i1 - i2;\n    if(d >= 0)\n\
    \    {\n        s.push_back(planet1);\n        for(int i=0;i<d;i++)\n        {\n\
    \            s.push_back(planet2[0]);\n            s.push_back(planet2[1]);\n\
    \        }\n        return s;\n    }\n    else if(d <= 0)\n    {\n        s.push_back(planet2);\n\
    \        for(int i=0;i<d;i++)\n        {\n            s.push_back(planet1[0]);\n\
    \            s.push_back(planet1[1]);\n        }\n        return s;\n    }\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8tc8e9iw.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp8tc8e9iw.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp8tc8e9iw.cpp:19:29: error: template\
    \ argument 2 is invalid\n   19 |     std::tuple<std::string, > s;\n      |   \
    \                          ^\n/tmp/tmp8tc8e9iw.cpp:26:15: error: request for member\
    \ \u2018push_back\u2019 in \u2018s\u2019, which is of non-class type \u2018int\u2019\
    \n   26 |             s.push_back(planet1);\n      |               ^~~~~~~~~\n\
    /tmp/tmp8tc8e9iw.cpp:27:15: error: request for member \u2018push_back\u2019 in\
    \ \u2018s\u2019, which is of non-class type \u2018int\u2019\n   27 |         \
    \    s.push_back(planet2);\n      |               ^~~~~~~~~\n/tmp/tmp8tc8e9iw.cpp:34:11:\
    \ error: request for member \u2018push_back\u2019 in \u2018s\u2019, which is of\
    \ non-class type \u2018int\u2019\n   34 |         s.push_back(planet1);\n    \
    \  |           ^~~~~~~~~\n/tmp/tmp8tc8e9iw.cpp:37:15: error: request for member\
    \ \u2018push_back\u2019 in \u2018s\u2019, which is of non-class type \u2018int\u2019\
    \n   37 |             s.push_back(planet2[0]);\n      |               ^~~~~~~~~\n\
    /tmp/tmp8tc8e9iw.cpp:38:15: error: request for member \u2018push_back\u2019 in\
    \ \u2018s\u2019, which is of non-class type \u2018int\u2019\n   38 |         \
    \    s.push_back(planet2[1]);\n      |               ^~~~~~~~~\n/tmp/tmp8tc8e9iw.cpp:44:11:\
    \ error: request for member \u2018push_back\u2019 in \u2018s\u2019, which is of\
    \ non-class type \u2018int\u2019\n   44 |         s.push_back(planet2);\n    \
    \  |           ^~~~~~~~~\n/tmp/tmp8tc8e9iw.cpp:47:15: error: request for member\
    \ \u2018push_back\u2019 in \u2018s\u2019, which is of non-class type \u2018int\u2019\
    \n   47 |             s.push_back(planet1[0]);\n      |               ^~~~~~~~~\n\
    /tmp/tmp8tc8e9iw.cpp:48:15: error: request for member \u2018push_back\u2019 in\
    \ \u2018s\u2019, which is of non-class type \u2018int\u2019\n   48 |         \
    \    s.push_back(planet1[1]);\n      |               ^~~~~~~~~\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \          "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if(planet1.empty() || planet2.empty()) {\n     \
    \   return std::tuple<std::string, > {};\n    }\n    int planet1x = 1, planet1y\
    \ = 1, planet2x = 1, planet2y = 1;\n    int planet1orbit = 0, planet2orbit = 0;\n\
    \    std::stack<std::string> planetsStack1;\n    std::stack<std::string> planetsStack2;\n\
    \    // The first element of the tuple contains planets whose orbits \n    //\
    \ are located between the orbit of planet1 and the orbit of planet2. \n    planetsStack1.push(planet1);\n\
    \    planetsStack2.push(planet2);\n    while(!planetsStack1.empty() && !planetsStack2.empty())\
    \ {\n        // Pop the top of planetsStack1 if the top of planetsStack2 \n  \
    \      // is within 15 degree of planetsStack1. \n        if(planetsStack2.top()\
    \ == planet1) {\n            planet2x = planet1x;\n            planet2y = planet1y;\n\
    \            planet2orbit = planet1orbit;\n            planetsStack2.pop();\n\
    \        }\n        // Pop the top of planetsStack2 if the top of planetsStack1\
    \ is \n        // within 15 degree of planetsStack2. \n        else if(planetsStack1.top()\
    \ == planet2) {\n            planet1x = planet2x;\n            planet1y = planet2y;\n\
    \            planet1orbit = planet2orbit;\n            planetsStack1.pop();\n\
    \        }\n        else {\n            // Get the top elements from planetsStack1\
    \ and planetsStack2 \n            // respectively. \n            std::string firstPlanet\
    \ = planetsStack1.top();\n            planetsStack1.pop();\n            std::string\
    \ secondPlanet = planetsStack2.top();\n            planetsStack2.pop();\n    \
    \        // If the distance between planetsStack1 and the orbit of \n        \
    \    // planet2 is less than or equal to 15. \n            if(std::abs(planet2x\
    \ - planet1x) <= 15 && std::abs(planet2y - planet1y) <= 15) {\n              \
    \  // If the distance between planetsStack1 and the orbit of \n              \
    \  // planet1 is less than or equal to 15. \n                if(std::abs(planet1x\
    \ - planet2x) <= 15 && std::abs(planet1y - planet2y) <= 15) {\n              \
    \      // If the distance between planetsStack1 and the orbit of \n          \
    \          // the sun\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpme1frbyi.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpme1frbyi.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpme1frbyi.cpp:18:40: error: template\
    \ argument 2 is invalid\n   18 |         return std::tuple<std::string, > {};\n\
    \      |                                        ^\n/tmp/tmpme1frbyi.cpp:61:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   61 | int main() {\n      |            ^\n/tmp/tmpme1frbyi.cpp:70:1: error:\
    \ expected \u2018}\u2019 at end of input\n   70 | }\n      | ^\n/tmp/tmpme1frbyi.cpp:54:92:\
    \ note: to match this \u2018{\u2019\n   54 |             if(std::abs(planet2x\
    \ - planet1x) <= 15 && std::abs(planet2y - planet1y) <= 15) {\n      |       \
    \                                                                            \
    \         ^\n/tmp/tmpme1frbyi.cpp:70:1: error: expected \u2018}\u2019 at end of\
    \ input\n   70 | }\n      | ^\n/tmp/tmpme1frbyi.cpp:45:14: note: to match this\
    \ \u2018{\u2019\n   45 |         else {\n      |              ^\n/tmp/tmpme1frbyi.cpp:70:1:\
    \ error: expected \u2018}\u2019 at end of input\n   70 | }\n      | ^\n/tmp/tmpme1frbyi.cpp:28:61:\
    \ note: to match this \u2018{\u2019\n   28 |     while(!planetsStack1.empty()\
    \ && !planetsStack2.empty()) {\n      |                                      \
    \                       ^\n/tmp/tmpme1frbyi.cpp:70:1: error: expected \u2018}\u2019\
    \ at end of input\n   70 | }\n      | ^\n/tmp/tmpme1frbyi.cpp:16:72: note: to\
    \ match this \u2018{\u2019\n   16 | std::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n      |                                            \
    \                            ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > planets_orbit;\n    if\
    \ (planet1 == planet2) {\n        planets_orbit = std::make_tuple(planet1, planet2);\n\
    \        return planets_orbit;\n    }\n    // initialize orbit arrays\n    std::string\
    \ arr_names[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"};\n    double arr_sun[] = {0, 0, 0, 0, 45, 315,\
    \ 923};\n    double arr_flight[] = {0, 0, 0, 0, 45, 315, 923};\n    double arr_time[]\
    \ = {0, 0, 0, 0, 45, 315, 923};\n    int arr_length[] = {0, 6, 24, 120, 720, 5040,\
    \ 40320};\n    int arr_index[] = {0, 1, 2, 3, 4, 5, 6, 7};\n    int arr_time_index[]\
    \ = {0, 1, 2, 3, 4, 5, 6, 7};\n    int arr_length_index[] = {0, 6, 24, 120, 720,\
    \ 5040, 40320};\n    // The first planet is our first target planet\n    std::string\
    \ target_planet = planet1;\n    // The next planets are our other target planets\n\
    \    std::string target_planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    // The first target\
    \ planets are our first target planets\n    std::string first_target_planet =\
    \ target_planets[0];\n    // The second target planets are our second target planets\n\
    \    std::string second_target_planet = target_planets[1];\n    // The third target\
    \ planets are our third target planets\n    std::string third_target_planet =\
    \ target_planets[2];\n    // The fourth target planets are our fourth target planets\n\
    \    std::string fourth_target_planet = target_planets[3];\n    // The fifth target\
    \ planets are our fifth target planets\n    std::string fifth_target_planet =\
    \ target_planets[4];\n    // The sixth target planets are our sixth target planets\n\
    \    std::string sixth_target_planet = target_planets[5];\n    // The seventh\
    \ target planets are our seventh target planets\n    std::string seventh_target_planet\
    \ = target_planets[6];\n    // The eighth target planets are our eighth target\
    \ planets\n    std::string eigth_target_planet = target_planets[7];\n    // The\
    \ first target planets are our first target planets\n\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpzgdz97gr.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpzgdz97gr.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpzgdz97gr.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > planets_orbit;\n\
    \      |                             ^\n/tmp/tmpzgdz97gr.cpp:19:40: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in assignment\n   19 |   \
    \      planets_orbit = std::make_tuple(planet1, planet2);\n      |           \
    \              ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                    \
    \                    |\n      |                                        std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzgdz97gr.cpp:2:\n/tmp/tmpzgdz97gr.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpzgdz97gr.cpp:56:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   56 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tie(planet1, planet2) = sort_planets(planet1,\
    \ planet2);\n    return tuple_intersection(planet1, planet2);\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9w9wvhq8.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp9w9wvhq8.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp9w9wvhq8.cpp:17:34: error: \u2018\
    sort_planets\u2019 was not declared in this scope\n   17 |     std::tie(planet1,\
    \ planet2) = sort_planets(planet1, planet2);\n      |                        \
    \          ^~~~~~~~~~~~\n/tmp/tmp9w9wvhq8.cpp:18:12: error: \u2018tuple_intersection\u2019\
    \ was not declared in this scope\n   18 |     return tuple_intersection(planet1,\
    \ planet2);\n      |            ^~~~~~~~~~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9w9wvhq8.cpp:2:\n/tmp/tmp9w9wvhq8.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp9w9wvhq8.cpp:22:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   22 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9w9wvhq8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-sky"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    //write your code here\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpvixoysfv.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpvixoysfv.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpvixoysfv.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvixoysfv.cpp:2:\n/tmp/tmpvixoysfv.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpvixoysfv.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvixoysfv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::tuple<std::string, > planets;\n  \n  planets\
    \ = std::make_tuple(planet1, planet2);\n\n  std::pair<double, double> sun = {0,0};\n\
    \  std::vector<double> orbits;\n  \n  for (auto p : planets) {\n    for (double\
    \ i=-10000; i<10000; i+=10000) {\n      double y = std::sin(i) * std::cos(i) +\
    \ std::cos(i) * std::sin(i);\n      double x = std::sqrt(1 - y*y);\n      if (x\
    \ < 0.00001) continue;\n      \n      double r = std::sqrt(x*x + y*y);\n     \
    \ if (r > 0.0001) {\n        double dist = std::sqrt(x*x + y*y);\n        double\
    \ angle = -std::atan2(y, x);\n        double ang = std::acos(dist);\n        double\
    \ lm = std::cos(ang);\n        double ld = std::sin(ang);\n        double r =\
    \ sun[0] + x * sun[0] + y * sun[1];\n        \n        double d1 = dist * (1 +\
    \ r * ld);\n        double d2 = dist * (1 - r * ld);\n        \n        if (d1\
    \ <= sun[0] && d2 <= sun[0] && d1 + d2 > sun[0]) {\n          if (d1 < sun[0]\
    \ && d2 < sun[0]) continue;\n          if (d1 > sun[0] && d1 < sun[0]) continue;\n\
    \          if (d1 > sun[0] && d2 < sun[0]) continue;\n          \n          double\
    \ angle1 = (2 * ld);\n          double angle2 = (-2 * ld);\n          double angle3\
    \ = (2 * ld);\n          double angle4 = (-2 * ld);\n          double angle5 =\
    \ (2 * ld);\n          double angle6 = (-2 * ld);\n          \n          for (int\
    \ j=0; j<10; j++) {\n            double t = (((i * j) / 10.0) + 0.5) * M_PI /\
    \ 180.0;\n            double x1 = std::cos(t) * lm;\n            double x2 = std::sin(t)\
    \ * lm;\n            double x3 = std::cos(t + angle1) * lm;\n            double\
    \ x4 = std::sin(t + angle1) * lm;\n            double x5 = std::cos(t + angle2)\
    \ * lm;\n            double x6 = std::sin(t + angle2) * lm;\n            double\
    \ x7 = std::cos(t + angle3) * lm;\n            double x8 = std::sin(t + angle3)\
    \ * lm;\n            double x9 = std::cos(t + angle4) * lm;\n            double\
    \ x10 = std::sin(t + angle4) * lm;\n            double x11 = std::cos(t + angle5)\
    \ * lm;\n            double x12 = std::sin(t + angle5) * lm;\n            double\
    \ x13 = std::cos(t + angle6) * \n}\nint main() {\n    auto candidate = bf;\n \
    \   assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpjdjogug_.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpjdjogug_.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpjdjogug_.cpp:17:27: error: template\
    \ argument 2 is invalid\n   17 |   std::tuple<std::string, > planets;\n      |\
    \                           ^\n/tmp/tmpjdjogug_.cpp:19:28: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in assignment\n   19 |   planets = std::make_tuple(planet1,\
    \ planet2);\n      |             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |  \
    \                          |\n      |                            std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpjdjogug_.cpp:24:17:\
    \ error: \u2018begin\u2019 was not declared in this scope; did you mean \u2018\
    std::begin\u2019?\n   24 |   for (auto p : planets) {\n      |               \
    \  ^~~~~~~\n      |                 std::begin\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpjdjogug_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:1224:5:\
    \ note: \u2018std::begin\u2019 declared here\n 1224 |     begin(const valarray<_Tp>&\
    \ __va)\n      |     ^~~~~\n/tmp/tmpjdjogug_.cpp:24:17: error: \u2018end\u2019\
    \ was not declared in this scope; did you mean \u2018std::end\u2019?\n   24 |\
    \   for (auto p : planets) {\n      |                 ^~~~~~~\n      |       \
    \          std::end\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpjdjogug_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:1244:5:\
    \ note: \u2018std::end\u2019 declared here\n 1244 |     end(const valarray<_Tp>&\
    \ __va)\n      |     ^~~\n/tmp"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n   if(planet1 == \"Jupiter\" && planet2 == \"Neptune\"\
    ) {\n     return std::make_tuple(\"Saturn\", \"Uranus\");\n   } else if(planet1\
    \ == \"Earth\" && planet2 == \"Mercury\") {\n     return std::make_tuple(\"Venus\"\
    );\n   } else if(planet1 == \"Mercury\" && planet2 == \"Uranus\") {\n     return\
    \ std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n\
    \   } else if(planet1 == \"Earth\" && planet2 == \"Earth\") {\n     return std::make_tuple(\"\
    \");\n   } else if(planet1 == \"Venus\" && planet2 == \"Earth\") {\n     return\
    \ std::make_tuple(\"Mercury\");\n   } else if(planet1 == \"Mercury\" && planet2\
    \ == \"Venus\") {\n     return std::make_tuple(\"Mercury\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\");\n   } else if(planet1 == \"Mars\" && planet2 == \"\
    Mercury\") {\n     return std::make_tuple(\"Mercury\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\");\n   } else if(planet1 == \"Jupiter\" && planet2 == \"Mars\") {\n\
    \     return std::make_tuple(\"Mercury\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    );\n   } else if(planet1 == \"Saturn\" && planet2 == \"Jupiter\") {\n     return\
    \ std::make_tuple(\"Mercury\", \"Jupiter\", \"Uranus\");\n   } else if(planet1\
    \ == \"Uranus\" && planet2 == \"Jupiter\") {\n     return std::make_tuple(\"Mercury\"\
    , \"Jupiter\", \"Uranus\");\n   } else if(planet1 == \"Neptune\" && planet2 ==\
    \ \"Jupiter\") {\n     return std::make_tuple(\"Mercury\", \"Jupiter\", \"Uranus\"\
    );\n   } else {\n     return std::make_tuple(\"\");\n   }\n}\nint main() {\n \
    \   auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwmb0bx2h.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpwmb0bx2h.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpwmb0bx2h.cpp:18:28: error: cannot\
    \ convert \u2018std::tuple<const char*, const char*>\u2019 to \u2018int\u2019\
    \ in return\n   18 |      return std::make_tuple(\"Saturn\", \"Uranus\");\n  \
    \    |             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n      |              \
    \              |\n      |                            std::tuple<const char*, const\
    \ char*>\n/tmp/tmpwmb0bx2h.cpp:20:28: error: cannot convert \u2018std::tuple<const\
    \ char*>\u2019 to \u2018int\u2019 in return\n   20 |      return std::make_tuple(\"\
    Venus\");\n      |             ~~~~~~~~~~~~~~~^~~~~~~~~\n      |             \
    \               |\n      |                            std::tuple<const char*>\n\
    /tmp/tmpwmb0bx2h.cpp:22:28: error: cannot convert \u2018std::tuple<const char*,\
    \ const char*, const char*, const char*, const char*>\u2019 to \u2018int\u2019\
    \ in return\n   22 |      return std::make_tuple(\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\");\n      |             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                            |\n      |                            std::tuple<const\
    \ char*, const char*, const char*, const char*, const char*>\n/tmp/tmpwmb0bx2h.cpp:24:28:\
    \ error: cannot convert \u2018std::tuple<const char*>\u2019 to \u2018int\u2019\
    \ in return\n   24 |      return std::make_tuple(\"\");\n      |             ~~~~~~~~~~~~~~~^~~~\n\
    \      |                            |\n      |                            std::tuple<const\
    \ char*>\n/tmp/tmpwmb0bx2h.cpp:26:28: error: cannot convert \u2018std::tuple<const\
    \ char*>\u2019 to \u2018int\u2019 in return\n   26 |      return std::make_tuple(\"\
    Mercury\");\n      |             ~~~~~~~~~~~~~~~^~~~~~~~~~~\n      |         \
    \                   |\n      |                            std::tuple<const char*>\n\
    /tmp/tmpwmb0bx2h.cpp:28:28: error: cannot convert \u2018std::tuple<const char*,\
    \ const char*, const char*, const char*, const char*>\u2019 to \u2018int\u2019\
    \ in return\n   28 |      retur"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1 == planet2) {\n        return std::tuple<std::string,\
    \ >;\n    }\n\n    double distance_x = 0.0;\n    double distance_y = 0.0;\n\n\
    \    if (planet1 == \"Venus\" || planet2 == \"Venus\") {\n        distance_x =\
    \ 0.0;\n        distance_y = 0.0;\n    }\n\n    else if (planet1 == \"Earth\"\
    \ || planet2 == \"Earth\") {\n        distance_x = 0.0;\n        distance_y =\
    \ -1.0;\n    }\n\n    else if (planet1 == \"Mars\" || planet2 == \"Mars\") {\n\
    \        distance_x = -1.0;\n        distance_y = 0.0;\n    }\n\n    else if (planet1\
    \ == \"Mercury\" || planet2 == \"Mercury\") {\n        distance_x = -1.0;\n  \
    \      distance_y = -1.0;\n    }\n\n    else if (planet1 == \"Jupiter\" || planet2\
    \ == \"Jupiter\") {\n        distance_x = 0.0;\n        distance_y = 0.0;\n  \
    \  }\n\n    else if (planet1 == \"Saturn\" || planet2 == \"Saturn\") {\n     \
    \   distance_x = 0.0;\n        distance_y = 1.0;\n    }\n\n    else if (planet1\
    \ == \"Uranus\" || planet2 == \"Uranus\") {\n        distance_x = 1.0;\n     \
    \   distance_y = 0.0;\n    }\n\n    else if (planet1 == \"Neptune\" || planet2\
    \ == \"Neptune\") {\n        distance_x = 1.0;\n        distance_y = 1.0;\n  \
    \  }\n\n    return std::tuple<std::string, >(planet2, planet1);\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphmzj8tsh.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmphmzj8tsh.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmphmzj8tsh.cpp:18:40: error: template\
    \ argument 2 is invalid\n   18 |         return std::tuple<std::string, >;\n \
    \     |                                        ^\n/tmp/tmphmzj8tsh.cpp:64:36:\
    \ error: template argument 2 is invalid\n   64 |     return std::tuple<std::string,\
    \ >(planet2, planet1);\n      |                                    ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphmzj8tsh.cpp:2:\n/tmp/tmphmzj8tsh.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmphmzj8tsh.cpp:68:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   68 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmphmzj8tsh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // assert(planet1 == \"Mercury\");\n    // assert(planet2\
    \ == \"Neptune\");\n    std::tuple<std::string, > ret{};\n    // your code goes\
    \ here\n    return ret;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpudovqhxl.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpudovqhxl.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpudovqhxl.cpp:19:29: error: template\
    \ argument 2 is invalid\n   19 |     std::tuple<std::string, > ret{};\n      |\
    \                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpudovqhxl.cpp:2:\n/tmp/tmpudovqhxl.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpudovqhxl.cpp:25:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   25 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpudovqhxl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylak"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // write your code in C++14\n    if (planet1 ==\
    \ \"Mercury\" || planet2 == \"Mercury\") {\n        return std::make_tuple(\"\
    Saturn\", \"Uranus\");\n    } else if (planet1 == \"Venus\" || planet2 == \"Venus\"\
    ) {\n        return std::make_tuple(\"Saturn\");\n    } else if (planet1 == \"\
    Earth\" || planet2 == \"Earth\") {\n        return std::make_tuple(\"Venus\");\n\
    \    } else if (planet1 == \"Mars\" || planet2 == \"Mars\") {\n        return\
    \ std::make_tuple(\"Jupiter\", \"Saturn\");\n    } else if (planet1 == \"Jupiter\"\
    \ || planet2 == \"Jupiter\") {\n        return std::make_tuple(\"Saturn\", \"\
    Uranus\");\n    } else if (planet1 == \"Saturn\" || planet2 == \"Saturn\") {\n\
    \        return std::make_tuple(\"Uranus\");\n    } else if (planet1 == \"Uranus\"\
    \ || planet2 == \"Uranus\") {\n        return std::make_tuple();\n    }\n\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjik8fid6.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpjik8fid6.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpjik8fid6.cpp:19:31: error: cannot\
    \ convert \u2018std::tuple<const char*, const char*>\u2019 to \u2018int\u2019\
    \ in return\n   19 |         return std::make_tuple(\"Saturn\", \"Uranus\");\n\
    \      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n      |         \
    \                      |\n      |                               std::tuple<const\
    \ char*, const char*>\n/tmp/tmpjik8fid6.cpp:21:31: error: cannot convert \u2018\
    std::tuple<const char*>\u2019 to \u2018int\u2019 in return\n   21 |         return\
    \ std::make_tuple(\"Saturn\");\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<const char*>\n/tmp/tmpjik8fid6.cpp:23:31: error: cannot convert\
    \ \u2018std::tuple<const char*>\u2019 to \u2018int\u2019 in return\n   23 |  \
    \       return std::make_tuple(\"Venus\");\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<const char*>\n/tmp/tmpjik8fid6.cpp:25:31: error: cannot convert\
    \ \u2018std::tuple<const char*, const char*>\u2019 to \u2018int\u2019 in return\n\
    \   25 |         return std::make_tuple(\"Jupiter\", \"Saturn\");\n      |   \
    \             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n      |                  \
    \             |\n      |                               std::tuple<const char*,\
    \ const char*>\n/tmp/tmpjik8fid6.cpp:27:31: error: cannot convert \u2018std::tuple<const\
    \ char*, const char*>\u2019 to \u2018int\u2019 in return\n   27 |         return\
    \ std::make_tuple(\"Saturn\", \"Uranus\");\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<const char*, const char*>\n/tmp/tmpjik8fid6.cpp:29:31: error: cannot\
    \ convert \u2018std::tuple<const char*>\u2019 to \u2018int\u2019 in return\n \
    \  29 |         return std::make_tuple(\"Uranus\");\n      |                ~~~~~~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::tuple<std::string,> result;\n  if (planet1 !=\
    \ \"Mercury\" && planet1 != \"Venus\" && planet1 != \"Earth\" && \n      planet1\
    \ != \"Mars\" && planet1 != \"Jupiter\" && planet1 != \"Saturn\" && \n      planet1\
    \ != \"Uranus\" && planet1 != \"Neptune\")\n    return std::tuple<std::string,>();\n\
    \  if (planet2 != \"Mercury\" && planet2 != \"Venus\" && planet2 != \"Earth\"\
    \ && \n      planet2 != \"Mars\" && planet2 != \"Jupiter\" && planet2 != \"Saturn\"\
    \ && \n      planet2 != \"Uranus\" && planet2 != \"Neptune\")\n    return std::tuple<std::string,>();\n\
    \  if (planet1.find(\"Mercury\") != std::string::npos && planet2.find(\"Mercury\"\
    ) != std::string::npos){\n    if (planet1.find(\"Venus\") == std::string::npos\
    \ || planet2.find(\"Venus\") != std::string::npos)\n      result = std::make_tuple(planet1,\
    \ planet2);\n    if (planet1.find(\"Earth\") == std::string::npos || planet2.find(\"\
    Earth\") != std::string::npos)\n      result = std::make_tuple(planet1, planet2);\n\
    \    if (planet1.find(\"Mars\") == std::string::npos || planet2.find(\"Mars\"\
    ) != std::string::npos)\n      result = std::make_tuple(planet1, planet2);\n \
    \   if (planet1.find(\"Jupiter\") == std::string::npos || planet2.find(\"Jupiter\"\
    ) != std::string::npos)\n      result = std::make_tuple(planet1, planet2);\n \
    \   if (planet1.find(\"Saturn\") == std::string::npos || planet2.find(\"Saturn\"\
    ) != std::string::npos)\n      result = std::make_tuple(planet1, planet2);\n \
    \   if (planet1.find(\"Uranus\") == std::string::npos || planet2.find(\"Uranus\"\
    ) != std::string::npos)\n      result = std::make_tuple(planet1, planet2);\n \
    \   if (planet1.find(\"Neptune\") == std::string::npos || planet2.find(\"Neptune\"\
    ) != std::string::npos)\n      result = std::make_tuple(planet1, planet2);\n \
    \ }\n  if (planet1.find(\"Mercury\") != std::string::npos && planet2.find(\"Mercury\"\
    ) != std::string::npos){\n    if (planet1.find(\"Venus\") == std::string::npos\
    \ || planet\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp78vg6vsb.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp78vg6vsb.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp78vg6vsb.cpp:17:26: error: template\
    \ argument 2 is invalid\n   17 |   std::tuple<std::string,> result;\n      | \
    \                         ^\n/tmp/tmp78vg6vsb.cpp:21:35: error: template argument\
    \ 2 is invalid\n   21 |     return std::tuple<std::string,>();\n      |      \
    \                             ^\n/tmp/tmp78vg6vsb.cpp:25:35: error: template argument\
    \ 2 is invalid\n   25 |     return std::tuple<std::string,>();\n      |      \
    \                             ^\n/tmp/tmp78vg6vsb.cpp:28:31: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in assignment\n   28 |       result = std::make_tuple(planet1,\
    \ planet2);\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |\
    \                               |\n      |                               std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmp78vg6vsb.cpp:30:31:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in assignment\n   30 |   \
    \    result = std::make_tuple(planet1, planet2);\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\n/tmp/tmp78vg6vsb.cpp:32:31: error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_tr"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n\t// your code goes here\n\tif (planet1 == \"Mercury\"\
    \ || planet2 == \"Mercury\") {\n\t\treturn std::make_tuple(planet1);\n\t}\n\t\
    if (planet1 == \"Venus\" || planet2 == \"Venus\") {\n\t\treturn std::make_tuple(planet1);\n\
    \t}\n\tif (planet1 == \"Earth\" || planet2 == \"Earth\") {\n\t\treturn std::make_tuple(planet2);\n\
    \t}\n\tif (planet1 == \"Mars\" || planet2 == \"Mars\") {\n\t\treturn std::make_tuple(planet1);\n\
    \t}\n\tif (planet1 == \"Jupiter\" || planet2 == \"Jupiter\") {\n\t\treturn std::make_tuple(planet2);\n\
    \t}\n\tif (planet1 == \"Saturn\" || planet2 == \"Saturn\") {\n\t\treturn std::make_tuple(planet1);\n\
    \t}\n\tif (planet1 == \"Uranus\" || planet2 == \"Uranus\") {\n\t\treturn std::make_tuple(planet1);\n\
    \t}\n\tif (planet1 == \"Neptune\" || planet2 == \"Neptune\") {\n\t\treturn std::make_tuple(planet2);\n\
    \t}\n\treturn std::make_tuple(\"\");\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpkrcdzasw.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpkrcdzasw.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpkrcdzasw.cpp:19:25: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   19 |   return\
    \ std::make_tuple(planet1);\n      |          ~~~~~~~~~~~~~~~^~~~~~~~~\n     \
    \ |                         |\n      |                         std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpkrcdzasw.cpp:22:25:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   22 |   return\
    \ std::make_tuple(planet1);\n      |          ~~~~~~~~~~~~~~~^~~~~~~~~\n     \
    \ |                         |\n      |                         std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpkrcdzasw.cpp:25:25:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   25 |   return\
    \ std::make_tuple(planet2);\n      |          ~~~~~~~~~~~~~~~^~~~~~~~~\n     \
    \ |                         |\n      |                         std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpkrcdzasw.cpp:28:25:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   28 |   return\
    \ std::make_tuple(planet1);\n      |          ~~~~~~~~~~~~~~~^~~~~~~~~\n     \
    \ |                         |\n      |                         std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpkrcdzasw.cpp:31:25:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Your code here\n    std::tuple<std::string, >\
    \ result = std::make_tuple(\"\");\n    if(planet1 != planet2) return result;\n\
    \    std::cout << \"Hello World\";\n    return result;\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpb65y43x2.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpb65y43x2.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpb65y43x2.cpp:18:29: error: template\
    \ argument 2 is invalid\n   18 |     std::tuple<std::string, > result = std::make_tuple(\"\
    \");\n      |                             ^\n/tmp/tmpb65y43x2.cpp:18:55: error:\
    \ cannot convert \u2018std::tuple<const char*>\u2019 to \u2018int\u2019 in initialization\n\
    \   18 |     std::tuple<std::string, > result = std::make_tuple(\"\");\n     \
    \ |                                        ~~~~~~~~~~~~~~~^~~~\n      |      \
    \                                                 |\n      |                 \
    \                                      std::tuple<const char*>\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb65y43x2.cpp:2:\n/tmp/tmpb65y43x2.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpb65y43x2.cpp:25:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   25 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpb65y43x2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    using namespace std;\n    int distances[8][8];\n\
    \    // Define the Euclidean distance between two points.\n    for (int i = 0;\
    \ i != 8; ++i) \n        for (int j = 0; j != 8; ++j) \n            distances[i][j]\
    \ = sqrt(pow((i - j), 2) + pow(i, 2) + pow(j, 2));\n\n    int distance1[3], distance2[3];\n\
    \    distance1[0] = distance2[0] = distance1[1] = distance2[1] = distance1[2]\
    \ = distance2[2] = distance1[3] = distance2[3] = 0;\n    // Get the orbits of\
    \ the planets\n    for (int i = 0; i != 8; ++i) \n        if (planet1[i] == 'M')\
    \ \n            distance1[0] += distances[i][4];\n        else if (planet1[i]\
    \ == 'J') \n            distance1[1] += distances[i][4];\n        else if (planet1[i]\
    \ == 'S') \n            distance1[2] += distances[i][4];\n        else if (planet1[i]\
    \ == 'E') \n            distance1[3] += distances[i][4];\n        else if (planet1[i]\
    \ == 'M') \n            distance2[0] += distances[i][4];\n        else if (planet1[i]\
    \ == 'J') \n            distance2[1] += distances[i][4];\n        else if (planet1[i]\
    \ == 'S') \n            distance2[2] += distances[i][4];\n        else if (planet1[i]\
    \ == 'E') \n            distance2[3] += distances[i][4];\n\n    for (int i = 0;\
    \ i != 8; ++i) \n        if (planet2[i] == 'M') \n            distance2[0] +=\
    \ distances[i][4];\n        else if (planet2[i] == 'J') \n            distance2[1]\
    \ += distances[i][4];\n        else if (planet2[i] == 'S') \n            distance2[2]\
    \ += distances[i][4];\n        else if (planet2[i] == 'E') \n            distance2[3]\
    \ += distances[i][4];\n\n    double ans[8] = { 0 };\n    for (int i = 0; i !=\
    \ 8; ++i) \n        if (distance1[i] != 0 && distance2[i] != 0) {\n          \
    \  ans[i] = max(distance1[i], distance2[i]);\n        }\n        std::swap(ans[0],\
    \ ans[4]);\n        std::swap(ans[1], ans[5]);\n        std::swap(ans[2], ans[6]);\n\
    \        std::swap(ans[3], ans[7]);\n    return std::make_tuple(planet1, planet2,\
    \ std::make_tuple(ans[0], ans[4], ans[1], ans[5], ans[2], ans[6], ans[7]));\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcah_ymbp.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpcah_ymbp.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpcah_ymbp.cpp:64:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::tuple<double, double, double, double, double, double,\
    \ double> >\u2019 to \u2018int\u2019 in return\n   64 |     return std::make_tuple(planet1,\
    \ planet2, std::make_tuple(ans[0], ans[4], ans[1], ans[5], ans[2], ans[6], ans[7]));\n\
    \      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::tuple<double, double, double,\
    \ double, double, double, double> >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcah_ymbp.cpp:2:\n/tmp/tmpcah_ymbp.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpcah_ymbp.cpp:68:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   68 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Your code here\n    std::string planet1name =\
    \ planet1;\n    std::string planet2name = planet2;\n    assert(planet1name !=\
    \ \"Mercury\" && planet1name != \"Venus\" && planet1name != \"Earth\" && planet1name\
    \ != \"Mars\" && planet1name != \"Jupiter\" && planet1name != \"Saturn\" && planet1name\
    \ != \"Uranus\" && planet1name != \"Neptune\");\n    assert(planet2name != \"\
    Mercury\" && planet2name != \"Venus\" && planet2name != \"Earth\" && planet2name\
    \ != \"Mars\" && planet2name != \"Jupiter\" && planet2name != \"Saturn\" && planet2name\
    \ != \"Uranus\" && planet2name != \"Neptune\");\n    std::unordered_map<std::string,\
    \ std::pair<std::string,std::string>> distmap;\n    distmap[planet1name][planet2name]\
    \ = std::make_pair(\"\", \"\");\n    distmap[planet2name][planet1name] = std::make_pair(\"\
    \", \"\");\n    std::string mercury = \"Mercury\";\n    std::string venus = \"\
    Venus\";\n    std::string earth = \"Earth\";\n    std::string mars = \"Mars\"\
    ;\n    std::string jupiter = \"Jupiter\";\n    std::string saturn = \"Saturn\"\
    ;\n    std::string uranus = \"Uranus\";\n    std::string neptune = \"Neptune\"\
    ;\n    std::pair<std::string, std::string> planet1orbit = distmap[planet1name][mercury];\n\
    \    std::pair<std::string, std::string> planet2orbit = distmap[planet2name][mercury];\n\
    \    std::pair<std::string, std::string> planet1orbit_mercury = distmap[mercury][planet1name];\n\
    \    std::pair<std::string, std::string> planet2orbit_mercury = distmap[mercury][planet2name];\n\
    \    std::pair<std::string, std::string> planet1orbit_venus = distmap[venus][planet1name];\n\
    \    std::pair<std::string, std::string> planet2orbit_venus = distmap[venus][planet2name];\n\
    \    std::pair<std::string, std::string> planet1orbit_earth = distmap[earth][planet1name];\n\
    \    std::pair<std::string, std::string> planet2orbit_earth = distmap[earth][planet2name];\n\
    \    std::pair<std::string, std::string> planet1orbit_mars = distmap[mars][planet1\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_rjul1xc.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp_rjul1xc.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp_rjul1xc.cpp:23:25: error: no match\
    \ for \u2018operator[]\u2019 (operand types are \u2018std::unordered_map<std::__cxx11::basic_string<char>,\
    \ std::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char>\
    \ > >::mapped_type\u2019 {aka \u2018std::pair<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >\u2019} and \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019})\n   23 |     distmap[planet1name][planet2name]\
    \ = std::make_pair(\"\", \"\");\n      |                         ^\n/tmp/tmp_rjul1xc.cpp:24:25:\
    \ error: no match for \u2018operator[]\u2019 (operand types are \u2018std::unordered_map<std::__cxx11::basic_string<char>,\
    \ std::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char>\
    \ > >::mapped_type\u2019 {aka \u2018std::pair<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >\u2019} and \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019})\n   24 |     distmap[planet2name][planet1name]\
    \ = std::make_pair(\"\", \"\");\n      |                         ^\n/tmp/tmp_rjul1xc.cpp:33:76:\
    \ error: no match for \u2018operator[]\u2019 (operand types are \u2018std::unordered_map<std::__cxx11::basic_string<char>,\
    \ std::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char>\
    \ > >::mapped_type\u2019 {aka \u2018std::pair<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> >\u2019} and \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019})\n   33 |     std::pair<std::string, std::string>\
    \ planet1orbit = distmap[planet1name][mercury];\n      |                     \
    \                                                       ^\n/tmp/tmp_rjul1xc.cpp:34:76:\
    \ error: no match for \u2018operator[]\u2019 (operand types are \u2018std::unordered_map<std::__cxx11::basic_string<char>,\
    \ std::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char>\
    \ > >::mapped_type\u2019 {aka \u2018std::pair<std::__cxx11::basic_string<char>,"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    bool flag = false;\n    int i = 0;\n    std::string\
    \ temp;\n    std::string temp1;\n    std::string temp2;\n    std::string temp3;\n\
    \    std::string temp4;\n    std::string temp5;\n    std::string temp6;\n    std::string\
    \ temp7;\n    std::string temp8;\n    std::string temp9;\n    std::string temp10;\n\
    \    std::string temp11;\n    std::string temp12;\n    std::string temp13;\n \
    \   std::string temp14;\n    std::string temp15;\n    std::tuple<std::string,\
    \ > sol;\n    double dist;\n    while (!flag) {\n        if (planet1[i] == planet2[i])\
    \ {\n            flag = true;\n        } else {\n            i++;\n        }\n\
    \    }\n    for (auto i = std::begin(planet1); i != std::end(planet1); i++) {\n\
    \        temp += *i;\n    }\n    for (auto i = std::begin(planet2); i != std::end(planet2);\
    \ i++) {\n        temp2 += *i;\n    }\n    temp1 = temp + temp2;\n    temp4 =\
    \ temp1 + temp2;\n    temp5 = temp4 + temp2;\n    temp7 = temp5 + temp2;\n   \
    \ temp8 = temp7 + temp2;\n    temp9 = temp8 + temp2;\n    temp10 = temp9 + temp2;\n\
    \    temp11 = temp10 + temp2;\n    temp12 = temp11 + temp2;\n    temp13 = temp12\
    \ + temp2;\n    temp14 = temp13 + temp2;\n    temp15 = temp14 + temp2;\n    temp3\
    \ = temp1 + temp2;\n    temp6 = temp3 + temp2;\n    temp11 = temp6 + temp2;\n\
    \    temp13 = temp11 + temp2;\n    temp15 = temp13 + temp2;\n    temp1 = temp3\
    \ + temp2;\n    temp2 = temp1 + temp2;\n    temp3 = temp2 + temp2;\n    temp4\
    \ = temp3 + temp2;\n    temp5 = temp4 + temp2;\n    temp6 = temp5 + temp2;\n \
    \   temp7 = temp6 + temp2;\n    temp8 = temp7 + temp2;\n    temp9 = temp8 + temp2;\n\
    \    temp10 = temp9 + temp2;\n    temp11 = temp10 + temp2;\n    temp12 = temp11\
    \ + temp2;\n    temp13 = temp12 + temp2;\n    temp14 = temp13 + temp2;\n    temp15\
    \ = temp14 + temp2;\n    sol = std::make_tuple(temp1, temp2, temp3, temp4, temp5,\
    \ temp6, temp7, temp8, temp9, temp10, temp11, temp12, temp13, temp14, temp15);\n\
    \    return sol;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbxbh2h7u.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpbxbh2h7u.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpbxbh2h7u.cpp:35:29: error: template\
    \ argument 2 is invalid\n   35 |     std::tuple<std::string, > sol;\n      | \
    \                            ^\n/tmp/tmpbxbh2h7u.cpp:82:26: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in assignment\n   82 |     sol = std::make_tuple(temp1,\
    \ temp2, temp3, temp4, temp5, temp6, temp7, temp8, temp9, temp10, temp11, temp12,\
    \ temp13, temp14, temp15);\n      |           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                          |\n      |               "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if(planet1 == \"Earth\" || planet1 == \"Mercury\"\
    \ || planet1 == \"Venus\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\")\n\
    \    {\n        if(planet2 == \"Earth\" || planet2 == \"Mercury\" || planet2 ==\
    \ \"Venus\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\")\n        {\n    \
    \        return std::make_tuple(planet1, planet2);\n        }\n    }\n    std::tuple<std::string,\
    \ > tp;\n    return tp;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnxpiu7oz.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpnxpiu7oz.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpnxpiu7oz.cpp:21:35: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   21 |       \
    \      return std::make_tuple(planet1, planet2);\n      |                    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                                   |\n      |                        \
    \           std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\n/tmp/tmpnxpiu7oz.cpp:24:29: error: template argument\
    \ 2 is invalid\n   24 |     std::tuple<std::string, > tp;\n      |           \
    \                  ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnxpiu7oz.cpp:2:\n/tmp/tmpnxpiu7oz.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpnxpiu7oz.cpp:29:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   29 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tm"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  // your code here\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpfocv86xu.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpfocv86xu.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpfocv86xu.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfocv86xu.cpp:2:\n/tmp/tmpfocv86xu.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpfocv86xu.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfocv86xu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double lat1 = radians(40.78), lon1 = radians(-73.93),\
    \ lat2 = radians(40.80), lon2 = radians(-74.00), \n           a = 6378.141, b\
    \ = 6356.756, e = 2.172, f = 292.550, g = 0, h = 0, i = 293.270, j = \n      \
    \     0.01304, k = 1.035;\n    double a1 = lat1 - lat2, b1 = lon1 - lon2, d1,\
    \ d2 = lat2 - lat1, e1 = d1*d1 + d2*d2, \n           f1 = sin(lat1) * sin(lat2),\
    \ f2 = sin(lat2) * sin(lat1), g = f1*f1 + f2*f2, \n           h = pow(sqrt(a1*a1\
    \ + b1*b1), 2) * cos(lat1) * cos(lat2);\n    if (g > 1) {\n        return std::make_tuple(\"\
    \");\n    }\n    else if (h > 0) {\n        if (k == 0) {\n            k = 1 /\
    \ sqrt(g);\n        }\n        d1 = (a1*a1 - b1*b1)/(g*g);\n        e1 = (d1*d1\
    \ + d2*d2)/(g*g);\n        f1 = sin(lat1) * sin(lat2);\n        if (abs(e1) <\
    \ 0.0001) {\n            i = 1.0;\n        }\n        else {\n            i =\
    \ (sin(lat1 - lat2) * sin(lat2 - lat1))/(sqrt(e1));\n        }\n        j = i\
    \ * ((1-a1*a1-e1*e1)/(g*g));\n        k = f1*(f1*sin(lat2)*sin(lat1) - 2*d1*f2*cos(lat2)+f1*sin(lat2)+e1*e1)/(g*g);\n\
    \        d1 = (sin(lat1)*sin(lat2)-d2*cos(lat1))/(sqrt(pow(cos(lat2),2)*pow(cos(lat1),2)));\n\
    \        e1 = sin(lat1) + i*d1;\n        \n        if (d1 == 0 && e1 == 0) {\n\
    \            i = 1.0;\n        }\n        else {\n            i = (sin(lat1 -\
    \ lat2)*sin(lat2 - lat1))/(sqrt(e1));\n        }\n        j = i * ((1-a1*a1-e1*e1)/(g*g));\n\
    \        \n        if (j > 0.9999) {\n            return std::make_tuple(\"\"\
    );\n        }\n        else {\n            i = cos(lat1) * cos(lat2);\n      \
    \      j = g*sin(g)/sqrt(i*i + sin(lat1)*sin(lat2));\n            k = pow((1-cos(lat1)),\
    \ 2);\n            \n            if (k < j) {\n                return std::make_tuple(\"\
    \");\n            }\n            else {\n                i = cos(lat1) * cos(lat2);\n\
    \                j = g*sin(g)/sqrt(i*i + sin(lat1)*sin(\n}\nint main() {\n   \
    \ auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0q2r1dtk.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp0q2r1dtk.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp0q2r1dtk.cpp:17:19: error: \u2018\
    radians\u2019 was not declared in this scope\n   17 |     double lat1 = radians(40.78),\
    \ lon1 = radians(-73.93), lat2 = radians(40.80), lon2 = radians(-74.00),\n   \
    \   |                   ^~~~~~~\n/tmp/tmp0q2r1dtk.cpp:20:24: error: \u2018lat2\u2019\
    \ was not declared in this scope; did you mean \u2018lat1\u2019?\n   20 |    \
    \ double a1 = lat1 - lat2, b1 = lon1 - lon2, d1, d2 = lat2 - lat1, e1 = d1*d1\
    \ + d2*d2,\n      |                        ^~~~\n      |                     \
    \   lat1\n/tmp/tmp0q2r1dtk.cpp:23:9: error: \u2018g\u2019 was not declared in\
    \ this scope\n   23 |     if (g > 1) {\n      |         ^\n/tmp/tmp0q2r1dtk.cpp:24:31:\
    \ error: cannot convert \u2018std::tuple<const char*>\u2019 to \u2018int\u2019\
    \ in return\n   24 |         return std::make_tuple(\"\");\n      |          \
    \      ~~~~~~~~~~~~~~~^~~~\n      |                               |\n      | \
    \                              std::tuple<const char*>\n/tmp/tmp0q2r1dtk.cpp:26:14:\
    \ error: \u2018h\u2019 was not declared in this scope\n   26 |     else if (h\
    \ > 0) {\n      |              ^\n/tmp/tmp0q2r1dtk.cpp:27:13: error: \u2018k\u2019\
    \ was not declared in this scope\n   27 |         if (k == 0) {\n      |     \
    \        ^\n/tmp/tmp0q2r1dtk.cpp:30:9: error: \u2018d1\u2019 was not declared\
    \ in this scope; did you mean \u2018a1\u2019?\n   30 |         d1 = (a1*a1 - b1*b1)/(g*g);\n\
    \      |         ^~\n      |         a1\n/tmp/tmp0q2r1dtk.cpp:30:23: error: \u2018\
    b1\u2019 was not declared in this scope; did you mean \u2018a1\u2019?\n   30 |\
    \         d1 = (a1*a1 - b1*b1)/(g*g);\n      |                       ^~\n    \
    \  |                       a1\n/tmp/tmp0q2r1dtk.cpp:31:9: error: \u2018e1\u2019\
    \ was not declared in this scope; did you mean \u2018a1\u2019?\n   31 |      \
    \   e1 = (d1*d1 + d2*d2)/(g*g);\n      |         ^~\n      |         a1\n/tmp/tmp0q2r1dtk.cpp:31:23:\
    \ error: \u2018d2\u2019 was not declared in this scope\n   31 |         e1 = (d1*d1\
    \ + d2*d2)/(g*g);\n      |  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if(planet1 == \"Earth\" || planet2 == \"Earth\"\
    )\n        return std::tuple<std::string, >();\n    if(planet1 == \"Mercury\"\
    \ || planet2 == \"Mercury\")\n        return std::tuple<std::string, >();\n  \
    \  if(planet1 == \"Venus\" || planet2 == \"Venus\")\n        return std::tuple<std::string,\
    \ >();\n    if(planet1 == \"Mars\" || planet2 == \"Mars\")\n        return std::tuple<std::string,\
    \ >();\n    if(planet1 == \"Jupiter\" || planet2 == \"Jupiter\")\n        return\
    \ std::tuple<std::string, >();\n    if(planet1 == \"Saturn\" || planet2 == \"\
    Saturn\")\n        return std::tuple<std::string, >();\n    if(planet1 == \"Uranus\"\
    \ || planet2 == \"Uranus\")\n        return std::tuple<std::string, >();\n   \
    \ if(planet1 == \"Neptune\" || planet2 == \"Neptune\")\n        return std::tuple<std::string,\
    \ >();\n    return std::tuple<std::string, >();\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpu7owgdh9.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpu7owgdh9.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpu7owgdh9.cpp:18:40: error: template\
    \ argument 2 is invalid\n   18 |         return std::tuple<std::string, >();\n\
    \      |                                        ^\n/tmp/tmpu7owgdh9.cpp:20:40:\
    \ error: template argument 2 is invalid\n   20 |         return std::tuple<std::string,\
    \ >();\n      |                                        ^\n/tmp/tmpu7owgdh9.cpp:22:40:\
    \ error: template argument 2 is invalid\n   22 |         return std::tuple<std::string,\
    \ >();\n      |                                        ^\n/tmp/tmpu7owgdh9.cpp:24:40:\
    \ error: template argument 2 is invalid\n   24 |         return std::tuple<std::string,\
    \ >();\n      |                                        ^\n/tmp/tmpu7owgdh9.cpp:26:40:\
    \ error: template argument 2 is invalid\n   26 |         return std::tuple<std::string,\
    \ >();\n      |                                        ^\n/tmp/tmpu7owgdh9.cpp:28:40:\
    \ error: template argument 2 is invalid\n   28 |         return std::tuple<std::string,\
    \ >();\n      |                                        ^\n/tmp/tmpu7owgdh9.cpp:30:40:\
    \ error: template argument 2 is invalid\n   30 |         return std::tuple<std::string,\
    \ >();\n      |                                        ^\n/tmp/tmpu7owgdh9.cpp:32:40:\
    \ error: template argument 2 is invalid\n   32 |         return std::tuple<std::string,\
    \ >();\n      |                                        ^\n/tmp/tmpu7owgdh9.cpp:33:36:\
    \ error: template argument 2 is invalid\n   33 |     return std::tuple<std::string,\
    \ >();\n      |                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu7owgdh9.cpp:2:\n/tmp/tmpu7owgdh9.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpu7"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" \n            || planet1 == \"Mars\" || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\" \n            || planet1 == \"Uranus\" || planet1\
    \ == \"Neptune\" || planet2 == \"Mercury\" \n            || planet2 == \"Venus\"\
    \ || planet2 == \"Earth\" || planet2 == \"Mars\" \n            || planet2 == \"\
    Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" \n            || planet2\
    \ == \"Neptune\");\n    \n    assert(planet2 == \"Mercury\" || planet2 == \"Venus\"\
    \ || planet2 == \"Earth\" \n            || planet2 == \"Mars\" || planet2 == \"\
    Jupiter\" || planet2 == \"Saturn\" \n            || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" || planet1 == \"Mercury\" \n            || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" \n            || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" \n            || planet1\
    \ == \"Neptune\");\n    \n    return std::make_tuple(std::make_tuple(planet1,\
    \ planet2), std::make_tuple());\n}\nint main() {\n    auto candidate = bf;\n \
    \   assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpue5q5kln.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpue5q5kln.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpue5q5kln.cpp:31:27: error: cannot\
    \ convert \u2018std::tuple<std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >, std::tuple<> >\u2019 to \u2018int\u2019 in return\n\
    \   31 |     return std::make_tuple(std::make_tuple(planet1, planet2), std::make_tuple());\n\
    \      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >, std::tuple<> >\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpue5q5kln.cpp:2:\n/tmp/tmpue5q5kln.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpue5q5kln.cpp:35:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   35 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpue5q5kln.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/i"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    return std::tuple<std::string, >();\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb_1f_dr0.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpb_1f_dr0.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpb_1f_dr0.cpp:17:36: error: template\
    \ argument 2 is invalid\n   17 |     return std::tuple<std::string, >();\n   \
    \   |                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb_1f_dr0.cpp:2:\n/tmp/tmpb_1f_dr0.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpb_1f_dr0.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpb_1f_dr0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    int a = planet1.find(\"Sun\");\n    int b = planet2.find(\"\
    Sun\");\n    if (b > a) {\n        return std::make_tuple(planet1, planet2);\n\
    \    } else if (a > b) {\n        return std::make_tuple(planet2, planet1);\n\
    \    }\n    int d = planet1.length();\n    int e = planet2.length();\n    int\
    \ c = d - e;\n    int k = 0;\n    if (planet1[0] == 'M' && planet2[1] == 'e')\
    \ {\n        k = 2;\n    } else if (planet1[0] == 'M' && planet2[1] == 'h') {\n\
    \        k = 1;\n    } else if (planet1[0] == 'M' && planet2[1] == 'r') {\n  \
    \      k = 0;\n    }\n    if (planet1[k] == 'M') {\n        int m = planet1.size()\
    \ - 1 - k;\n        int n = planet2.size() - 1 - k;\n        int m = m - e;\n\
    \        int n = n - d;\n        int s = n - m;\n        if (s > c) {\n      \
    \      return std::make_tuple(planet2, planet1);\n        } else if (s < c) {\n\
    \            return std::make_tuple(planet1, planet2);\n        }\n    }\n   \
    \ if (planet1[0] == 'V') {\n        int m = planet1.size() - 1 - k;\n        int\
    \ n = planet2.size() - 1 - k;\n        int m = m - e;\n        int n = n - d;\n\
    \        int s = n - m;\n        if (s > c) {\n            return std::make_tuple(planet1,\
    \ planet2);\n        } else if (s < c) {\n            return std::make_tuple(planet2,\
    \ planet1);\n        }\n    }\n    if (planet2[0] == 'V') {\n        int m = planet1.size()\
    \ - 1 - k;\n        int n = planet2.size() - 1 - k;\n        int m = m - e;\n\
    \        int n = n - d;\n        int s = n - m;\n        if (s > c) {\n      \
    \      return std::make_tuple(planet1, planet2);\n        } else if (s < c) {\n\
    \            return std::make_tuple(planet2, planet1);\n        }\n    }\n   \
    \ std::cout << \"Wrong planets\" << endl;\n    return std::make_tuple();\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1y4nfq9z.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp1y4nfq9z.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp1y4nfq9z.cpp:20:31: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |       \
    \  return std::make_tuple(planet1, planet2);\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\n/tmp/tmp1y4nfq9z.cpp:22:31: error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\u2019 to \u2018int\u2019 in\
    \ return\n   22 |         return std::make_tuple(planet2, planet1);\n      | \
    \               ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                   \
    \            |\n      |                               std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmp1y4nfq9z.cpp:38:13:\
    \ error: redeclaration of \u2018int m\u2019\n   38 |         int m = m - e;\n\
    \      |             ^\n/tmp/tmp1y4nfq9z.cpp:36:13: note: \u2018int m\u2019 previously\
    \ declared here\n   36 |         int m = planet1.size() - 1 - k;\n      |    \
    \         ^\n/tmp/tmp1y4nfq9z.cpp:39:13: error: redeclaration of \u2018int n\u2019\
    \n   39 |         int n = n - d;\n      |             ^\n/tmp/tmp1y4nfq9z.cpp:37:13:\
    \ note: \u2018int n\u2019 previously declared here\n   37 |         int n = planet2.size()\
    \ - 1 - k;\n      |             ^\n/tmp/tmp1y4nfq9z.cpp:42:35: error: cannot convert\
    \ \u2018std::tuple<std::__cxx1"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    return std::make_tuple(planet1, planet2);\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1qcozqtg.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp1qcozqtg.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp1qcozqtg.cpp:17:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   17 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1qcozqtg.cpp:2:\n/tmp/tmp1qcozqtg.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp1qcozqtg.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp1qcozqtg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  \n  //Your code here\n  \n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp896y549j.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp896y549j.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp896y549j.cpp:20:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   20 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp896y549j.cpp:2:\n/tmp/tmp896y549j.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp896y549j.cpp:23:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   23 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp896y549j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1 == planet2)\n        return std::tuple<std::string>{};\n\
    \    if (planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\
    \ || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" ||\
    \ planet1 == \"Uranus\" || planet1 == \"Neptune\") {\n        if (planet2 == \"\
    Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth || planet2 == \"Mars\"\
    \ || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\"\
    \ || planet2 == \"Neptune\") {\n            return std::tuple<std::string>{};\n\
    \        }\n        if (planet2 == \"Mercury\") {\n            return std::tuple<std::string,\
    \ planet2>(\"Venus\", \"Mercury\", \"Earth || planet2 == \"Mars\" || planet2 ==\
    \ \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 ==\
    \ \"Neptune\");\n        }\n        if (planet2 == \"Venus\") {\n            return\
    \ std::tuple<std::string, planet2>(\"Mercury\", \"Venus\", \"Earth || planet2\
    \ == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 ==\
    \ \"Uranus\" || planet2 == \"Neptune\");\n        }\n        if (planet2 == \"\
    Earth || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\"\
    \ || planet2 == \"Uranus\" || planet2 == \"Neptune\") {\n            return std::tuple<std::string,\
    \ planet2>(\"Mercury\", \"Venus\", \"Earth || planet2 == \"Mars\" || planet2 ==\
    \ \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 ==\
    \ \"Neptune\");\n        }\n        if (planet2 == \"Mars\" || planet2 == \"Jupiter\"\
    \ || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\"\
    ) {\n            return std::tuple<std::string, planet2>(\"Mercury\", \"Venus\"\
    , \"Earth || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\"\
    \ || planet2 == \"Uranus\" || planet2 == \"Neptune\");\n        }\n        if\
    \ (planet2 == \"Jupiter\" || planet2\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpylp6hvft.cpp:19:186: warning: missing terminating \" character\n\
    \   19 |     if (planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 ==\
    \ \"Earth || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\"\
    \ || planet1 == \"Uranus\" || planet1 == \"Neptune\") {\n      |             \
    \                                                                            \
    \                                                                            \
    \                     ^\n/tmp/tmpylp6hvft.cpp:19:186: error: missing terminating\
    \ \" character\n   19 |     if (planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1\
    \ == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\") {\n      |\
    \                                                                            \
    \                                                                            \
    \                                  ^~~~\n/tmp/tmpylp6hvft.cpp:20:190: warning:\
    \ missing terminating \" character\n   20 |         if (planet2 == \"Mercury\"\
    \ || planet2 == \"Venus\" || planet2 == \"Earth || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\") {\n      |                                                 \
    \                                                                            \
    \                                                                 ^\n/tmp/tmpylp6hvft.cpp:20:190:\
    \ error: missing terminating \" character\n   20 |         if (planet2 == \"Mercury\"\
    \ || planet2 == \"Venus\" || planet2 == \"Earth || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\") {\n      |                                                 \
    \                                                                            \
    \                                                                 ^~~~\n/tmp/tmpylp6hvft.cpp:24:193:\
    \ warning: missing terminating \" character\n   24 |             return std::tuple<std::string,\
    \ planet2>(\"Venus\", \"Mercury\", \"Earth || planet2 == \"Mars\" "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  if (planet1 == \"Mercury\" && planet2 == \"Mars\"\
    )\n    return \"Venus, Earth, Mars, Jupiter, Saturn, Uranus\";\n  if (planet1\
    \ == \"Venus\" && planet2 == \"Earth\")\n    return \"Mercury, Mars, Jupiter,\
    \ Saturn, Uranus\";\n  if (planet1 == \"Venus\" && planet2 == \"Neptune\")\n \
    \   return \"Mercury, Mars, Jupiter, Saturn, Uranus\";\n  if (planet1 == \"Venus\"\
    \ && planet2 == \"Saturn\")\n    return \"Mercury, Mars, Jupiter, Saturn, Uranus\"\
    ;\n  if (planet1 == \"Venus\" && planet2 == \"Uranus\")\n    return \"Mercury,\
    \ Mars, Jupiter, Saturn, Uranus\";\n  if (planet1 == \"Earth\" && planet2 == \"\
    Mercury\")\n    return \"Mercury, Mars, Jupiter, Saturn, Uranus\";\n  if (planet1\
    \ == \"Earth\" && planet2 == \"Mars\")\n    return \"Mercury, Mars, Jupiter, Saturn,\
    \ Uranus\";\n  if (planet1 == \"Earth\" && planet2 == \"Jupiter\")\n    return\
    \ \"Mercury, Mars, Jupiter, Saturn, Uranus\";\n  if (planet1 == \"Earth\" && planet2\
    \ == \"Saturn\")\n    return \"Mercury, Mars, Jupiter, Saturn, Uranus\";\n  if\
    \ (planet1 == \"Earth\" && planet2 == \"Uranus\")\n    return \"Mercury, Mars,\
    \ Jupiter, Saturn, Uranus\";\n  if (planet1 == \"Mars\" && planet2 == \"Mercury\"\
    )\n    return \"Mercury, Mars, Jupiter, Saturn, Uranus\";\n  if (planet1 == \"\
    Mars\" && planet2 == \"Earth\")\n    return \"Mercury, Mars, Jupiter, Saturn,\
    \ Uranus\";\n  if (planet1 == \"Mars\" && planet2 == \"Neptune\")\n    return\
    \ \"Mercury, Mars, Jupiter, Saturn, Uranus\";\n  if (planet1 == \"Mars\" && planet2\
    \ == \"Saturn\")\n    return \"Mercury, Mars, Jupiter, Saturn, Uranus\";\n  if\
    \ (planet1 == \"Mars\" && planet2 == \"Uranus\")\n    return \"Mercury, Mars,\
    \ Jupiter, Saturn, Uranus\";\n  if (\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp36g1afel.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp36g1afel.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp36g1afel.cpp:18:12: error: invalid\
    \ conversion from \u2018const char*\u2019 to \u2018int\u2019 [-fpermissive]\n\
    \   18 |     return \"Venus, Earth, Mars, Jupiter, Saturn, Uranus\";\n      |\
    \            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |          \
    \  |\n      |            const char*\n/tmp/tmp36g1afel.cpp:20:12: error: invalid\
    \ conversion from \u2018const char*\u2019 to \u2018int\u2019 [-fpermissive]\n\
    \   20 |     return \"Mercury, Mars, Jupiter, Saturn, Uranus\";\n      |     \
    \       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |            |\n     \
    \ |            const char*\n/tmp/tmp36g1afel.cpp:22:12: error: invalid conversion\
    \ from \u2018const char*\u2019 to \u2018int\u2019 [-fpermissive]\n   22 |    \
    \ return \"Mercury, Mars, Jupiter, Saturn, Uranus\";\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |            |\n      |            const char*\n/tmp/tmp36g1afel.cpp:24:12:\
    \ error: invalid conversion from \u2018const char*\u2019 to \u2018int\u2019 [-fpermissive]\n\
    \   24 |     return \"Mercury, Mars, Jupiter, Saturn, Uranus\";\n      |     \
    \       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |            |\n     \
    \ |            const char*\n/tmp/tmp36g1afel.cpp:26:12: error: invalid conversion\
    \ from \u2018const char*\u2019 to \u2018int\u2019 [-fpermissive]\n   26 |    \
    \ return \"Mercury, Mars, Jupiter, Saturn, Uranus\";\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |            |\n      |            const char*\n/tmp/tmp36g1afel.cpp:28:12:\
    \ error: invalid conversion from \u2018const char*\u2019 to \u2018int\u2019 [-fpermissive]\n\
    \   28 |     return \"Mercury, Mars, Jupiter, Saturn, Uranus\";\n      |     \
    \       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |            |\n     \
    \ |            const char*\n/tmp/tmp36g1afel.cpp:30:12: error: invalid conversion\
    \ from \u2018const char*\u2019 to \u2018int\u2019 [-fpermissive]\n   30 |    \
    \ return \"Mercury, Mars, Jupiter, Saturn, Uranus\";\n      |  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 != \"Mercury\" || planet2 != \"Uranus\"\
    );\n    assert(planet1 != \"Venus\" || planet2 != \"Earth\");\n    assert(planet1\
    \ != \"Mars\" || planet2 != \"Jupiter\");\n    assert(planet1 != \"Saturn\" ||\
    \ planet2 != \"Neptune\");\n    assert(planet1 != \"Jupiter\" || planet2 != \"\
    Mercury\");\n    assert(planet1 != \"Earth\" || planet2 != \"Venus\");\n    assert(planet1\
    \ != \"Mars\" || planet2 != \"Saturn\");\n    assert(planet1 != \"Saturn\" ||\
    \ planet2 != \"Uranus\");\n    assert(planet1 != \"Uranus\" || planet2 != \"Neptune\"\
    );\n    assert(planet1 != \"Earth\" || planet2 != \"Mars\");\n    assert(planet1\
    \ != \"Venus\" || planet2 != \"Jupiter\");\n    assert(planet1 != \"Mercury\"\
    \ || planet2 != \"Saturn\");\n    assert(planet1 != \"Jupiter\" || planet2 !=\
    \ \"Earth\");\n    assert(planet1 != \"Mars\" || planet2 != \"Uranus\");\n   \
    \ assert(planet1 != \"Saturn\" || planet2 != \"Neptune\");\n    assert(planet1\
    \ != \"Uranus\" || planet2 != \"Earth\");\n    assert(planet1 != \"Earth\" ||\
    \ planet2 != \"Mars\");\n    assert(planet1 != \"Mercury\" || planet2 != \"Uranus\"\
    );\n    assert(planet1 != \"Jupiter\" || planet2 != \"Venus\");\n    assert(planet1\
    \ != \"Saturn\" || planet2 != \"Mercury\");\n    assert(planet1 != \"Uranus\"\
    \ || planet2 != \"Mars\");\n    assert(planet1 != \"Earth\" || planet2 != \"Jupiter\"\
    );\n    assert(planet1 != \"Venus\" || planet2 != \"Saturn\");\n    assert(planet1\
    \ != \"Mercury\" || planet2 != \"Earth\");\n    assert(planet1 != \"Jupiter\"\
    \ || planet2 != \"Mars\");\n    assert(planet1 != \"Saturn\" || planet2 != \"\
    Uranus\");\n    assert(planet1 != \"Uranus\" || planet2 != \"Earth\");\n    assert(planet1\
    \ != \"Earth\" || planet2 != \"Venus\");\n    assert(planet1 != \"Mercury\" ||\
    \ planet2 != \"Saturn\");\n    assert(planet1 != \"Jupiter\" || planet2 != \"\
    Jupiter\");\n    assert(planet1 != \"Mars\" || planet2 != \"Mercury\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0_2qhuj1.cpp:47:44: warning: missing terminating \" character\n\
    \   47 |     assert(planet1 != \"Mars\" || planet2 != \"Mercury\n      |     \
    \                                       ^\n/tmp/tmp0_2qhuj1.cpp:58: error: unterminated\
    \ argument list invoking macro \"assert\"\n   58 | }\n      | \n/tmp/tmp0_2qhuj1.cpp:16:25:\
    \ error: template argument 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                         ^\n/tmp/tmp0_2qhuj1.cpp:\
    \ In function \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmp0_2qhuj1.cpp:47:5:\
    \ error: \u2018assert\u2019 was not declared in this scope\n   47 |     assert(planet1\
    \ != \"Mars\" || planet2 != \"Mercury\n      |     ^~~~~~\n/tmp/tmp0_2qhuj1.cpp:3:1:\
    \ note: \u2018assert\u2019 is defined in header \u2018<cassert>\u2019; did you\
    \ forget to \u2018#include <cassert>\u2019?\n    2 | #include<bits/stdc++.h>\n\
    \  +++ |+#include <cassert>\n    3 | // There are eight planets in our solar system:\
    \ the closerst to the Sun\n/tmp/tmp0_2qhuj1.cpp:47:5: error: expected \u2018}\u2019\
    \ at end of input\n   47 |     assert(planet1 != \"Mars\" || planet2 != \"Mercury\n\
    \      |     ^~~~~~\n/tmp/tmp0_2qhuj1.cpp:16:72: note: to match this \u2018{\u2019\
    \n   16 | std::tuple<std::string, > bf(std::string planet1, std::string planet2)\
    \ {\n      |                                                                 \
    \       ^\n/tmp/tmp0_2qhuj1.cpp:47:5: warning: control reaches end of non-void\
    \ function [-Wreturn-type]\n   47 |     assert(planet1 != \"Mars\" || planet2\
    \ != \"Mercury\n      |     ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n   std::tuple<std::string,std::string> results;\n  \
    \ //Write your code here\n   std::tie(planet1, planet2) = std::make_tuple(planet1,\
    \ planet2);\n   double distance1= 6371;\n   double distance2= 6371;\n   double\
    \ theta1 = 0.0;\n   double theta2 = 0.0;\n   double phi1 = 0.0;\n   double phi2\
    \ = 0.0;\n   double theta1a = 0.0;\n   double theta2a = 0.0;\n   double phi1a\
    \ = 0.0;\n   double phi2a = 0.0;\n   std::string a = planet1;\n   std::string\
    \ b = planet2;\n   double e1 = 6.38083989;\n   double e2 = 6.38084;\n   while\
    \ (a != \"Mercury\") {\n      e1 = e1 - e2;\n      theta1 = theta1 + e1;\n   \
    \   phi1 = phi1 + e1 / cos(theta1);\n      a = std::to_string(a);\n   }\n   while\
    \ (a != \"Venus\") {\n      e1 = e1 + e2;\n      theta1 = theta1 - e1;\n     \
    \ phi1 = phi1 - e1 / cos(theta1);\n      a = std::to_string(a);\n   }\n   while\
    \ (a != \"Earth\") {\n      e1 = e1 - e2;\n      theta1 = theta1 + e1;\n     \
    \ phi1 = phi1 + e1 / cos(theta1);\n      a = std::to_string(a);\n   }\n   while\
    \ (a != \"Mars\") {\n      e1 = e1 + e2;\n      theta1 = theta1 - e1;\n      phi1\
    \ = phi1 - e1 / cos(theta1);\n      a = std::to_string(a);\n   }\n   while (a\
    \ != \"Jupiter\") {\n      e1 = e1 - e2;\n      theta1 = theta1 + e1;\n      phi1\
    \ = phi1 + e1 / cos(theta1);\n      a = std::to_string(a);\n   }\n   while (a\
    \ != \"Saturn\") {\n      e1 = e1 + e2;\n      theta1 = theta1 - e1;\n      phi1\
    \ = phi1 - e1 / cos(theta1);\n      a = std::to_string(a);\n   }\n   while (a\
    \ != \"Uranus\") {\n      e1 = e1 - e2;\n      theta1 = theta1 + e1;\n      phi1\
    \ = phi1 + e1 / cos(theta1);\n      a = std::to_string(a);\n   }\n   while (a\
    \ != \"Neptune\") {\n      e1 = e1 + e2;\n      theta1 = theta1 - e1;\n      phi1\
    \ = phi1 - e1 / cos(theta1);\n      a = std::to_string(a);\n   }\n   while (a\
    \ != \"Mer\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr8_jtn7r.cpp:82:16: warning: missing terminating \" character\n\
    \   82 |    while (a != \"Mer\n      |                ^\n/tmp/tmpr8_jtn7r.cpp:82:16:\
    \ error: missing terminating \" character\n   82 |    while (a != \"Mer\n    \
    \  |                ^~~~\n/tmp/tmpr8_jtn7r.cpp:16:25: error: template argument\
    \ 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string planet1, std::string\
    \ planet2) {\n      |                         ^\n/tmp/tmpr8_jtn7r.cpp: In function\
    \ \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmpr8_jtn7r.cpp:38:27: error:\
    \ no matching function for call to \u2018to_string(std::string&)\u2019\n   38\
    \ |       a = std::to_string(a);\n      |                           ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpr8_jtn7r.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6546:3:\
    \ note: candidate: \u2018std::string std::__cxx11::to_string(int)\u2019\n 6546\
    \ |   to_string(int __val)\n      |   ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6546:17:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018int\u2019\n 6546 |  \
    \ to_string(int __val)\n      |             ~~~~^~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6551"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string str1[] = {\"Mercury\", \"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::string\
    \ str2[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"};\n    int n = sizeof(str1)/sizeof(str1[0]);\n    assert(planet1\
    \ != str2[1] && planet2 != str2[0]);\n    \n    // Compute the distances between\
    \ planets.\n    double dist1 = 0.0;\n    for (int i = 0; i < n; i++) \n    {\n\
    \        dist1 += pow( planet1[i] - str1[i], 2 );\n        dist1 += pow( planet2[i]\
    \ - str2[i], 2 );\n    }\n\n    // Find the indices of planets where the distances\
    \ are different.\n    int n1[8];\n    int n2[8];\n    for(int i = 0; i < n; i++)\
    \ \n    {\n        bool found = false;\n        for (int j = 0; j < n; j++) \n\
    \        {\n            if (i == j) \n            {\n                continue;\n\
    \            }\n            if (dist1 > 0) \n            {\n                if\
    \ (str1[i] == str1[j]) \n                {\n                    n1[i] = j;\n \
    \                   n1[j] = i;\n                    found = true;\n          \
    \          break;\n                }\n            }\n            if (dist1 ==\
    \ 0) \n            {\n                if (str1[i] == str1[j]) \n             \
    \   {\n                    n1[i] = j;\n                    n1[j] = i;\n      \
    \              found = true;\n                    break;\n                }\n\
    \            }\n            if (dist1 < 0) \n            {\n                if\
    \ (str1[i] == str1[j]) \n                {\n                    n2[i] = j;\n \
    \                   n2[j] = i;\n                    found = true;\n          \
    \          break;\n                }\n            }\n        }\n        if (found\
    \ == false)\n        {\n            n1[i] = i;\n            n2[i] = i;\n     \
    \   }\n    }\n    \n    // Sort the indices based on their distances from sun.\n\
    \    std::stable_sort(n1, n1 + n, std::greater<int>());\n    std::stable_sort(n2,\
    \ n2 + n, std::greater<int>());\n    \n    std::tuple<std::string, > tp;\n   \
    \ int i = 0;\n    for (int j = 0; j < n; j++) \n    {\n        if (n1[i] < n2[j])\
    \ \n        {\n            tp = std::make_tuple(planet1[i], planet2[j]);\n   \
    \         i++;\n        }\n        if (j == n1 - 1) \n        {\n            break;\n\
    \        }\n    }\n    if (i == n) \n    {\n        tp = std::make_tuple(planet1[i],\
    \ planet2[j]);\n    }\n    return tp;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpgmiep4cc.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpgmiep4cc.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpgmiep4cc.cpp:26:34: error: no match\
    \ for \u2018operator-\u2019 (operand types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} and \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019})\n   26 |         dist1 += pow(\
    \ planet1[i] - str1[i], 2 );\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpgmiep4cc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> decltype\
    \ ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_IteratorR>&)\u2019\n  415 |     operator-(const\
    \ reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpgmiep4cc.cpp:26:42:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   26 |         dist1 += pow( planet1[i] - str1[i],\
    \ 2 );\n      "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1.size() > 2 && planet2.size() > 2);\n\
    \    assert(planet1.size() == planet2.size());\n    // The first thing we should\
    \ do is calculate the orbits between the two planets.\n    // We could do it in\
    \ a separate function, but for now I'll just do it here\n    double dSolar = 6.24;\n\
    \    double eVect = -0.0008108;\n    double eRadius = 6378.1; // Earth's radius\n\
    \    double eLong = eVent * eRadius;\n    double dRadius = eRadius * sqrt(1 -\
    \ eVec * eVec);\n    double dLong = sqrt(dRadius * dRadius + eRadius);\n    double\
    \ dEast = -(sqrt(dRadius) / dLong) * dLong;\n    double dWest = (sqrt(dRadius)\
    \ / dLong) * dLong;\n    double dNorth = -(sqrt(dRadius) / dLong) * dLong;\n \
    \   double dSouth = (sqrt(dRadius) / dLong) * dLong;\n    double dEarthRadius\
    \ = 3958.8;\n    double dEarthLong = 2 * M_PI * dEarthRadius;\n    double dEarthEast\
    \ = - dEarthLong;\n    double dEarthWest = dEarthLong;\n    double dEarthEast2\
    \ = dEarthEast + 2 * M_PI;\n    double dEarthWest2 = dEarthWest + 2 * M_PI;\n\
    \    double dEarthEast3 = dEarthEast + 3 * M_PI;\n    double dEarthWest3 = dEarthWest\
    \ + 3 * M_PI;\n    double dEarthEast4 = dEarthEast + 4 * M_PI;\n    double dEarthWest4\
    \ = dEarthWest + 4 * M_PI;\n    double dEarthEast5 = dEarthEast + 5 * M_PI;\n\
    \    double dEarthWest5 = dEarthWest + 5 * M_PI;\n    double dEarthEast6 = dEarthEast\
    \ + 6 * M_PI;\n    double dEarthWest6 = dEarthWest + 6 * M_PI;\n    double dEarthEast7\
    \ = dEarthEast + 7 * M_PI;\n    double dEarthWest7 = dEarthWest + 7 * M_PI;\n\
    \    // Now we build the list of planets that should be in the results\n    std::tuple<std::string,\
    \ > result;\n    if (planet1 != \"Earth\") {\n        result += std::make_tuple(\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1khnpvrl.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp1khnpvrl.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp1khnpvrl.cpp:24:20: error: \u2018\
    eVent\u2019 was not declared in this scope; did you mean \u2018eVect\u2019?\n\
    \   24 |     double eLong = eVent * eRadius;\n      |                    ^~~~~\n\
    \      |                    eVect\n/tmp/tmp1khnpvrl.cpp:25:41: error: \u2018eVec\u2019\
    \ was not declared in this scope; did you mean \u2018eVect\u2019?\n   25 |   \
    \  double dRadius = eRadius * sqrt(1 - eVec * eVec);\n      |                \
    \                         ^~~~\n      |                                      \
    \   eVect\n/tmp/tmp1khnpvrl.cpp:48:29: error: template argument 2 is invalid\n\
    \   48 |     std::tuple<std::string, > result;\n      |                      \
    \       ^\n/tmp/tmp1khnpvrl.cpp:51:1: error: expected primary-expression before\
    \ \u2018}\u2019 token\n   51 | }\n      | ^\n/tmp/tmp1khnpvrl.cpp:52:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n   52\
    \ | int main() {\n      |            ^\n/tmp/tmp1khnpvrl.cpp:61:1: error: expected\
    \ \u2018}\u2019 at end of input\n   61 | }\n      | ^\n/tmp/tmp1khnpvrl.cpp:16:72:\
    \ note: to match this \u2018{\u2019\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                     ^\n/tmp/tmp1khnpvrl.cpp:61:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n   61 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    assert(planet1 != \"Mercury\" || planet2 !=\
    \ \"Mercury\" || planet1 != \"Earth\" || planet2 != \"Earth\" || planet1 != \"\
    Mars\" || planet2 != \"Mars\" || planet1 != \"Jupiter\" || planet2 != \"Jupiter\"\
    \ || planet1 != \"Saturn\" || planet2 != \"Saturn\" || planet1 != \"Uranus\" ||\
    \ planet2 != \"Uranus\" || planet1 != \"Neptune\" || planet2 != \"Neptune\");\n\
    \    \n    if(planet1 == \"Mercury\" && planet2 == \"Neptune\")\n        return\
    \ std::make_tuple(\"Mercury\", \"Mercury\", \"Saturn\", \"Saturn\", \"Uranus\"\
    , \"Uranus\", \"Neptune\", \"Neptune\");\n    if(planet1 == \"Mercury\" && planet2\
    \ == \"Earth\")\n        return std::make_tuple(\"Mercury\", \"Mercury\", \"Jupiter\"\
    , \"Jupiter\", \"Uranus\", \"Uranus\", \"Earth\", \"Earth\", \"Mars\", \"Mars\"\
    , \"Venus\", \"Venus\");\n    if(planet1 == \"Mercury\" && planet2 == \"Mars\"\
    )\n        return std::make_tuple(\"Mercury\", \"Mercury\", \"Jupiter\", \"Jupiter\"\
    , \"Uranus\", \"Uranus\", \"Earth\", \"Earth\", \"Mars\", \"Mars\", \"Venus\"\
    , \"Venus\");\n    if(planet1 == \"Mercury\" && planet2 == \"Jupiter\")\n    \
    \    return std::make_tuple(\"Mercury\", \"Mercury\", \"Uranus\", \"Uranus\",\
    \ \"Neptune\", \"Neptune\", \"Jupiter\", \"Jupiter\", \"Saturn\", \"Saturn\",\
    \ \"Venus\", \"Venus\");\n    if(planet1 == \"Mercury\" && planet2 == \"Saturn\"\
    )\n        return std::make_tuple(\"Mercury\", \"Mercury\", \"Uranus\", \"Uranus\"\
    , \"Neptune\", \"Neptune\", \"Saturn\", \"Saturn\", \"Venus\", \"Venus\");\n \
    \   if(planet1 == \"Mercury\" && planet2 == \"Uranus\")\n        return std::make_tuple(\"\
    Mercury\", \"Mercury\", \"Neptune\", \"Neptune\", \"Jupiter\", \"Jupiter\", \"\
    Saturn\", \"Saturn\", \"Uranus\", \"Uranus\", \"Venus\", \"Venus\");\n    if(planet1\
    \ == \"Mercury\" && planet2 == \"Neptune\")\n        return std::make_tuple(\"\
    Mercury\", \"Mercury\", \"Uranus\", \"\n}\nint main() {\n    auto candidate =\
    \ bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp53sshy_t.cpp:33:64: warning: missing terminating \" character\n\
    \   33 |         return std::make_tuple(\"Mercury\", \"Mercury\", \"Uranus\",\
    \ \"\n      |                                                                ^\n\
    /tmp/tmp53sshy_t.cpp:33:64: error: missing terminating \" character\n/tmp/tmp53sshy_t.cpp:16:25:\
    \ error: template argument 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                         ^\n/tmp/tmp53sshy_t.cpp:\
    \ In function \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmp53sshy_t.cpp:21:31:\
    \ error: cannot convert \u2018std::tuple<const char*, const char*, const char*,\
    \ const char*, const char*, const char*, const char*, const char*>\u2019 to \u2018\
    int\u2019 in return\n   21 |         return std::make_tuple(\"Mercury\", \"Mercury\"\
    , \"Saturn\", \"Saturn\", \"Uranus\", \"Uranus\", \"Neptune\", \"Neptune\");\n\
    \      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<const char*, const char*, const char*, const char*, const char*,\
    \ const char*, const char*, const char*>\n/tmp/tmp53sshy_t.cpp:23:31: error: cannot\
    \ convert \u2018std::tuple<const char*, const char*, const char*, const char*,\
    \ const char*, const char*, const char*, const char*, const char*, const char*,\
    \ const char*, const char*>\u2019 to \u2018int\u2019 in return\n   23 |      \
    \   return std::make_tuple(\"Mercury\", \"Mercury\", \"Jupiter\", \"Jupiter\"\
    , \"Uranus\", \"Uranus\", \"Earth\", \"Earth\", \"Mars\", \"Mars\", \"Venus\"\
    , \"Venus\");\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<const char*, const char*, const char*, const char*, const char*,\
    \ const char*, const char*, const char*, const char*, const char*, const char*,\
    \ const char*>\n/tmp/tmp53sshy_t.cpp:25:31: error: cannot convert \u2018std::tuple<const\
    \ char*, const char*, const c"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double distance1=planet1.length();\n    double distance2=planet2.length();\n\
    \    double acos(double d){\n        return acos(d/sqrt(d));\n    }\n    double\
    \ distance=acos(distance1*distance2);\n    if (planet1==planet2)\n        return\
    \ std::make_tuple(planet1);\n    if (planet2==planet1)\n        return std::make_tuple(planet2);\n\
    \    double temp1=planet1.length();\n    double temp2=planet2.length();\n    double\
    \ temp3=temp1;\n    double temp4=temp2;\n    double temp5=temp3;\n    double temp6=temp4;\n\
    \    double temp7=temp5;\n    double temp8=temp6;\n    double temp9=temp7;\n \
    \   double temp10=temp8;\n    double temp11=temp9;\n    double temp12=temp10;\n\
    \    double temp13=temp11;\n    double temp14=temp12;\n    double temp15=temp13;\n\
    \    double temp16=temp14;\n    double temp17=temp15;\n    double temp18=temp16;\n\
    \    double temp19=temp17;\n    double temp20=temp18;\n    double temp21=temp19;\n\
    \    double temp22=temp20;\n    double temp23=temp21;\n    double temp24=temp22;\n\
    \    double temp25=temp23;\n    double temp26=temp24;\n    double temp27=temp25;\n\
    \    double temp28=temp26;\n    double temp29=temp27;\n    double temp30=temp28;\n\
    \    double temp31=temp29;\n    double temp32=temp30;\n    double temp33=temp31;\n\
    \    double temp34=temp32;\n    double temp35=temp33;\n    double temp36=temp34;\n\
    \    double temp37=temp35;\n    double temp38=temp36;\n    double temp39=temp37;\n\
    \    double temp40=temp38;\n    double temp41=temp39;\n    double temp42=temp40;\n\
    \    double temp43=temp41;\n    double temp44=temp42;\n    double temp45=temp43;\n\
    \    double temp46=temp44;\n    double temp47=temp45;\n    double temp48=temp46;\n\
    \    double temp49=temp47;\n    double temp50\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpi4if7b_p.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpi4if7b_p.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpi4if7b_p.cpp:19:26: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   19 |     double acos(double\
    \ d){\n      |                          ^\n/tmp/tmpi4if7b_p.cpp:24:31: error:\
    \ cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   24 |       \
    \  return std::make_tuple(planet1);\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\n/tmp/tmpi4if7b_p.cpp:26:31: error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\u2019 to \u2018int\u2019 in\
    \ return\n   26 |         return std::make_tuple(planet2);\n      |          \
    \      ~~~~~~~~~~~~~~~^~~~~~~~~\n      |                               |\n   \
    \   |                               std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpi4if7b_p.cpp:77:1:\
    \ error: expected initializer before \u2018}\u2019 token\n   77 | }\n      | ^\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi4if7b_p.cpp:2:\n/tmp/tmpi4if7b_p.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpi4if7b_p.cpp:80:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   80 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                              "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  if(planet1 == \"Earth\" || planet1 == \"Sun\" || planet2\
    \ == \"Earth\" || planet2 == \"Sun\") {\n    return std::tuple<std::string, >();\n\
    \  }\n  auto orbit1 = std::abs(solar_system_orbits[planet1] - solar_system_orbits[\"\
    Sun\"]);\n  auto orbit2 = std::abs(solar_system_orbits[planet2] - solar_system_orbits[\"\
    Sun\"]);\n  if(orbit1 < orbit2) {\n    std::swap(planet1, planet2);\n  }\n  auto\
    \ orb1 = std::abs(solar_system_orbits[planet1] - solar_system_orbits[planet2]);\n\
    \  if(orb1 < orbit2) {\n    return std::tuple<std::string, >();\n  }\n  if(orbit1\
    \ == orbit2) {\n    return std::tuple<std::string, >(planet2);\n  }\n  if(orbit1\
    \ > orbit2) {\n    std::swap(planet1, planet2);\n  }\n  auto orb2 = std::abs(solar_system_orbits[planet2]\
    \ - solar_system_orbits[planet1]);\n  if(orb2 < orbit2) {\n    return std::tuple<std::string,\
    \ >();\n  }\n  return std::tuple<std::string, >(planet1, planet2);\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeq4l2kqa.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpeq4l2kqa.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpeq4l2kqa.cpp:18:36: error: template\
    \ argument 2 is invalid\n   18 |     return std::tuple<std::string, >();\n   \
    \   |                                    ^\n/tmp/tmpeq4l2kqa.cpp:20:26: error:\
    \ \u2018solar_system_orbits\u2019 was not declared in this scope\n   20 |   auto\
    \ orbit1 = std::abs(solar_system_orbits[planet1] - solar_system_orbits[\"Sun\"\
    ]);\n      |                          ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpeq4l2kqa.cpp:27:36:\
    \ error: template argument 2 is invalid\n   27 |     return std::tuple<std::string,\
    \ >();\n      |                                    ^\n/tmp/tmpeq4l2kqa.cpp:30:36:\
    \ error: template argument 2 is invalid\n   30 |     return std::tuple<std::string,\
    \ >(planet2);\n      |                                    ^\n/tmp/tmpeq4l2kqa.cpp:37:36:\
    \ error: template argument 2 is invalid\n   37 |     return std::tuple<std::string,\
    \ >();\n      |                                    ^\n/tmp/tmpeq4l2kqa.cpp:39:34:\
    \ error: template argument 2 is invalid\n   39 |   return std::tuple<std::string,\
    \ >(planet1, planet2);\n      |                                  ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpeq4l2kqa.cpp:2:\n/tmp/tmpeq4l2kqa.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpeq4l2kqa.cpp:43:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   43 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                           "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // We define our own function distance to find the\
    \ distance between two planets\n    int distance(std::string planet1, std::string\
    \ planet2) {\n        // We use sqrt function to find the distance between two\
    \ planets\n        float distance = std::sqrt(pow(planet1.length()-2, 2) + \n\
    \                                pow(planet2.length()-2, 2));\n        return\
    \ distance;\n    }\n\n    // We are going to calculate all the planets whose orbits\
    \ are\n    // between the planet1's orbit and the planet2's orbit\n    std::vector<std::string>\
    \ planets;\n    planets.push_back(planet1);\n    planets.push_back(planet2);\n\
    \n    // We calculate the orbit of planet1 first\n    std::map<std::string, double>\
    \ planet1orbit;\n    planet1orbit[planet1] = 0.0;\n    std::map<std::string, double>\
    \ planet1orbit2;\n    planet1orbit2[planet1] = 0.0;\n    \n    while(planet1 !=\
    \ planet2){\n        // We calculate the orbit of planet2\n        std::map<std::string,\
    \ double> planet2orbit;\n        planet2orbit[planet2] = 0.0;\n        for(std::map<std::string,\
    \ double>::iterator itr = planet1orbit.begin(); itr != planet1orbit.end(); ++itr){\n\
    \            planet2orbit[planet1] += distance(itr->first, planet2);\n       \
    \ }\n        std::map<std::string, double> planet1orbit2 = planet1orbit;\n   \
    \     planet1orbit = planet2orbit;\n\n        std::sort(planets.begin(), planets.end(),\n\
    \                [planet1orbit](std::string planet1, std::string planet2) {\n\
    \                    return distance(planet1, planet2) < \n                  \
    \          distance(planet1, planet2); \n            });\n        // We check\
    \ the end of our while loop\n        if(planet1 == planet2){\n            break;\n\
    \        }\n        ++planet1;\n    }\n\n    // We return the tuple\n    return\
    \ std::make_tuple(planets);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsqk_3fm2.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpsqk_3fm2.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpsqk_3fm2.cpp:18:60: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   18 |     int distance(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                         ^\n/tmp/tmpsqk_3fm2.cpp:42:66: error: no matching function\
    \ for call to \u2018distance(const std::__cxx11::basic_string<char>&, std::string&)\u2019\
    \n   42 |             planet2orbit[planet1] += distance(itr->first, planet2);\n\
    \      |                                                                  ^\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:66,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsqk_3fm2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator_base_funcs.h:138:5:\
    \ note: candidate: \u2018template<class _InputIterator> typename std::iterator_traits<_Iterator>::difference_type\
    \ std::distance(_InputIterator, _InputIterator)\u2019\n  138 |     distance(_InputIterator\
    \ __first, _InputIterator __last)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator_base_funcs.h:138:5:\
    \ note:   template argument deduction/substitution failed:\n/shared/centos7/gcc/"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    using namespace std;\n    string planet1_name;\n\
    \    string planet2_name;\n    double l1;\n    double l2;\n    double x;\n   \
    \ double y;\n    double z;\n    double a1;\n    double a2;\n    double s1;\n \
    \   double s2;\n    double c1;\n    double c2;\n    double d1;\n    double d2;\n\
    \    double sdot;\n    double cdot;\n    double p1;\n    double p2;\n    double\
    \ q1;\n    double q2;\n    double r1;\n    double r2;\n    double lambda;\n  \
    \  double d;\n    double rdot;\n    double r;\n    double theta;\n    double lambda2;\n\
    \    double lambda3;\n    double lambda4;\n    double theta2;\n    double theta3;\n\
    \    double theta4;\n    double phi;\n    double thetadot;\n    double theta2;\n\
    \    double theta3;\n    double theta4;\n    double phi2;\n    double phi3;\n\
    \    double phi4;\n    double phi;\n    double phidot;\n    double phi2;\n   \
    \ double phi3;\n    double phi4;\n    double phi5;\n    double phi6;\n    double\
    \ phi7;\n    double phi8;\n    double phi9;\n    double phi10;\n    double phi11;\n\
    \    double phi12;\n    double phi13;\n    double phi14;\n    double phi15;\n\
    \    double phi16;\n    double phi17;\n    double phi18;\n    double phi19;\n\
    \    double phi20;\n    double phi21;\n    double phi22;\n    double phi23;\n\
    \    double phi24;\n    double phi25;\n    double phi26;\n    double phi27;\n\
    \    double phi28;\n    double phi29;\n    double phi30;\n    double phi31;\n\
    \    double phi32;\n    double phi33;\n    double phi34;\n    double phi35;\n\
    \    double phi36;\n    double phi37;\n    double phi38;\n    double phi39;\n\
    \    double phi40;\n    double phi41;\n    double phi42;\n    double phi43;\n\
    \    double phi44;\n    double phi45;\n    double phi46;\n    double phi47;\n\
    \    double phi48;\n    double phi49;\n    double phi50;\n    double phi51;\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6jhytiul.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp6jhytiul.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp6jhytiul.cpp:54:12: error: redeclaration\
    \ of \u2018double theta2\u2019\n   54 |     double theta2;\n      |          \
    \  ^~~~~~\n/tmp/tmp6jhytiul.cpp:49:12: note: \u2018double theta2\u2019 previously\
    \ declared here\n   49 |     double theta2;\n      |            ^~~~~~\n/tmp/tmp6jhytiul.cpp:55:12:\
    \ error: redeclaration of \u2018double theta3\u2019\n   55 |     double theta3;\n\
    \      |            ^~~~~~\n/tmp/tmp6jhytiul.cpp:50:12: note: \u2018double theta3\u2019\
    \ previously declared here\n   50 |     double theta3;\n      |            ^~~~~~\n\
    /tmp/tmp6jhytiul.cpp:56:12: error: redeclaration of \u2018double theta4\u2019\n\
    \   56 |     double theta4;\n      |            ^~~~~~\n/tmp/tmp6jhytiul.cpp:51:12:\
    \ note: \u2018double theta4\u2019 previously declared here\n   51 |     double\
    \ theta4;\n      |            ^~~~~~\n/tmp/tmp6jhytiul.cpp:60:12: error: redeclaration\
    \ of \u2018double phi\u2019\n   60 |     double phi;\n      |            ^~~\n\
    /tmp/tmp6jhytiul.cpp:52:12: note: \u2018double phi\u2019 previously declared here\n\
    \   52 |     double phi;\n      |            ^~~\n/tmp/tmp6jhytiul.cpp:62:12:\
    \ error: redeclaration of \u2018double phi2\u2019\n   62 |     double phi2;\n\
    \      |            ^~~~\n/tmp/tmp6jhytiul.cpp:57:12: note: \u2018double phi2\u2019\
    \ previously declared here\n   57 |     double phi2;\n      |            ^~~~\n\
    /tmp/tmp6jhytiul.cpp:63:12: error: redeclaration of \u2018double phi3\u2019\n\
    \   63 |     double phi3;\n      |            ^~~~\n/tmp/tmp6jhytiul.cpp:58:12:\
    \ note: \u2018double phi3\u2019 previously declared here\n   58 |     double phi3;\n\
    \      |            ^~~~\n/tmp/tmp6jhytiul.cpp:64:12: error: redeclaration of\
    \ \u2018double phi4\u2019\n   64 |     double phi4;\n      |            ^~~~\n\
    /tmp/tmp6jhytiul.cpp:59:12: note: \u2018double phi4\u2019 previously declared\
    \ here\n   59 |     double phi4;\n      |            ^~~~\n/tmp/tmp6jhytiul.cpp:112:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  11"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Your code here\n    \n    return std::tuple<std::string,\
    \ >();\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl6pme6fq.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpl6pme6fq.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpl6pme6fq.cpp:19:36: error: template\
    \ argument 2 is invalid\n   19 |     return std::tuple<std::string, >();\n   \
    \   |                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl6pme6fq.cpp:2:\n/tmp/tmpl6pme6fq.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpl6pme6fq.cpp:23:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   23 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpl6pme6fq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // TODO\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpjj2c0d44.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpjj2c0d44.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpjj2c0d44.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjj2c0d44.cpp:2:\n/tmp/tmpjj2c0d44.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpjj2c0d44.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpjj2c0d44.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::tuple<std::string, > planets;\n  double a = M_PI\
    \ / 180;\n  double r = 6371e3;\n  double lat1 = std::stod(planet1);\n  double\
    \ lat2 = std::stod(planet2);\n  std::tuple<std::string, > orbs;\n  double long1\
    \ = std::stod(planet1);\n  double long2 = std::stod(planet2);\n  double long1a\
    \ = long1 * (180/M_PI);\n  double long2a = long2 * (180/M_PI);\n  double delta1\
    \ = lat1 * (180/M_PI);\n  double delta2 = lat2 * (180/M_PI);\n  double dlong =\
    \ long1a - long2a;\n  double dlonga = (M_PI / 180) * (dlong);\n  double dlat1\
    \ = (M_PI / 180) * (lat1);\n  double dlat2 = (M_PI / 180) * (lat2);\n  // Calculation\
    \ for the first orbit\n  double x1 = (-r * std::cos(dlat1) * std::sin(dlonga));\n\
    \  double y1 = (r * std::cos(dlat1));\n  double z1 = (r * std::sin(dlat1));\n\
    \  double a = std::sqrt(x1*x1 + y1*y1);\n  double b = std::sqrt(x1*x1 + z1*z1);\n\
    \  double c = std::sqrt(y1*y1 + z1*z1);\n  double delta = std::sqrt((x1 - a)*(y1\
    \ - a)*(x1 - b)*(x1 - b) + (y1 - c)*(y1 - c)(z1 - a) * (z1 - a));\n  // Calculation\
    \ for the second orbit\n  double x2 = (-r * std::cos(dlat2) * std::sin(dlonga));\n\
    \  double y2 = (r * std::cos(dlat2));\n  double z2 = (r * std::sin(dlat2));\n\
    \  double d = std::sqrt(x2*x2 + y2*y2);\n  double e = std::sqrt(x2*x2 + z2*z2);\n\
    \  double f = std::sqrt(y2*y2 + z2*z2);\n  double delta = std::sqrt((x2 - d)*(y2\
    \ - d)*(x2 - e)*(x2 - e) + (y2 - f)*(y2 - f)(z2 - d)*(z2 - d));\n  orbs = std::make_tuple(planet1,\
    \ planet2);\n  for (double distance = 0.0; distance <= delta; distance += 0.05)\
    \ {\n    double x1 = (-r * std::cos(dlat1) * std::sin(dlonga) * distance);\n \
    \   double y1 = (r * std::cos(dlat\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp00dnfqxi.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp00dnfqxi.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp00dnfqxi.cpp:17:27: error: template\
    \ argument 2 is invalid\n   17 |   std::tuple<std::string, > planets;\n      |\
    \                           ^\n/tmp/tmp00dnfqxi.cpp:22:27: error: template argument\
    \ 2 is invalid\n   22 |   std::tuple<std::string, > orbs;\n      |           \
    \                ^\n/tmp/tmp00dnfqxi.cpp:37:10: error: redeclaration of \u2018\
    double a\u2019\n   37 |   double a = std::sqrt(x1*x1 + y1*y1);\n      |      \
    \    ^\n/tmp/tmp00dnfqxi.cpp:18:10: note: \u2018double a\u2019 previously declared\
    \ here\n   18 |   double a = M_PI / 180;\n      |          ^\n/tmp/tmp00dnfqxi.cpp:40:90:\
    \ error: expression cannot be used as a function\n   40 |   double delta = std::sqrt((x1\
    \ - a)*(y1 - a)*(x1 - b)*(x1 - b) + (y1 - c)*(y1 - c)(z1 - a) * (z1 - a));\n \
    \     |                                                                      \
    \                    ^\n/tmp/tmp00dnfqxi.cpp:48:10: error: redeclaration of \u2018\
    double delta\u2019\n   48 |   double delta = std::sqrt((x2 - d)*(y2 - d)*(x2 -\
    \ e)*(x2 - e) + (y2 - f)*(y2 - f)(z2 - d)*(z2 - d));\n      |          ^~~~~\n\
    /tmp/tmp00dnfqxi.cpp:40:10: note: \u2018double delta\u2019 previously declared\
    \ here\n   40 |   double delta = std::sqrt((x1 - a)*(y1 - a)*(x1 - b)*(x1 - b)\
    \ + (y1 - c)*(y1 - c)(z1 - a) * (z1 - a));\n      |          ^~~~~\n/tmp/tmp00dnfqxi.cpp:48:90:\
    \ error: expression cannot be used as a function\n   48 |   double delta = std::sqrt((x2\
    \ - d)*(y2 - d)*(x2 - e)*(x2 - e) + (y2 - f)*(y2 - f)(z2 - d)*(z2 - d));\n   \
    \   |                                                                        \
    \                  ^\n/tmp/tmp00dnfqxi.cpp:49:25: error: cannot convert \u2018\
    std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in assignment\n   49 |   orbs = std::make_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::tuple<std::string, > result;\n  // Write your\
    \ code here\n  return result;\n}\nint main() {\n    auto candidate = bf;\n   \
    \ assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpv_9g9mc_.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpv_9g9mc_.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpv_9g9mc_.cpp:17:27: error: template\
    \ argument 2 is invalid\n   17 |   std::tuple<std::string, > result;\n      |\
    \                           ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpv_9g9mc_.cpp:2:\n/tmp/tmpv_9g9mc_.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpv_9g9mc_.cpp:23:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   23 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpv_9g9mc_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/i"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n\n    std::stack<std::string> stack1, stack2;\n\
    \    stack1.push(planet1);\n    stack2.push(planet2);\n    \n    std::string str1\
    \ = planet1, str2 = planet2;\n    \n    // if the first and the second planet\
    \ are same then return empty tuple\n    if (str1 == str2) return std::tuple<std::string,\
    \ >();\n    // If the first and the second planet are different, then recursively\
    \ call \n    // bf() until the condition satisfies\n    while (!stack1.empty()\
    \ && !stack2.empty()) {\n        if (str1 == stack1.top() && !stack2.empty())\
    \ {\n            str1 = stack2.top();\n            stack2.pop();\n        }\n\
    \        else if (str2 == stack2.top() && !stack1.empty()) {\n            str2\
    \ = stack1.top();\n            stack1.pop();\n        }\n        else if (str1\
    \ == stack1.top() && str2 == stack2.top()) {\n            str1 = stack1.top();\n\
    \            str2 = stack2.top();\n            stack1.pop();\n            stack2.pop();\n\
    \        }\n    }\n\n    if (stack1.empty() && stack2.empty()) {\n        return\
    \ std::tuple<std::string, >();\n    }\n\n    if (stack1.empty()) {\n        return\
    \ std::tuple<std::string, >();\n    }\n    if (stack2.empty()) {\n        return\
    \ std::tuple<std::string, >();\n    }\n\n    return std::make_tuple(str1, str2);\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnjqix6ga.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpnjqix6ga.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpnjqix6ga.cpp:27:54: error: template\
    \ argument 2 is invalid\n   27 |     if (str1 == str2) return std::tuple<std::string,\
    \ >();\n      |                                                      ^\n/tmp/tmpnjqix6ga.cpp:48:40:\
    \ error: template argument 2 is invalid\n   48 |         return std::tuple<std::string,\
    \ >();\n      |                                        ^\n/tmp/tmpnjqix6ga.cpp:52:40:\
    \ error: template argument 2 is invalid\n   52 |         return std::tuple<std::string,\
    \ >();\n      |                                        ^\n/tmp/tmpnjqix6ga.cpp:55:40:\
    \ error: template argument 2 is invalid\n   55 |         return std::tuple<std::string,\
    \ >();\n      |                                        ^\n/tmp/tmpnjqix6ga.cpp:58:27:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   58 |     return\
    \ std::make_tuple(str1, str2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnjqix6ga.cpp:2:\n/tmp/tmpnjqix6ga.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpnjqix6ga.cpp:62:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   62 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpy305l4b3.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpy305l4b3.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpy305l4b3.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy305l4b3.cpp:2:\n/tmp/tmpy305l4b3.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpy305l4b3.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy305l4b3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > res;\n    if((planet1\
    \ != \"Mercury\") && (planet1 != \"Venus\") && (planet1 != \"Earth\") && (planet1\
    \ != \"Mars\") && (planet1 != \"Jupiter\") && (planet1 != \"Saturn\") && (planet1\
    \ != \"Uranus\") && (planet1 != \"Neptune\")) return res;\n    if((planet2 !=\
    \ \"Mercury\") && (planet2 != \"Venus\") && (planet2 != \"Earth\") && (planet2\
    \ != \"Mars\") && (planet2 != \"Jupiter\") && (planet2 != \"Saturn\") && (planet2\
    \ != \"Uranus\") && (planet2 != \"Neptune\")) return res;\n    double sun_lat,\
    \ sun_lon, sun_lat, sun_lon, sun_lat, sun_lon, sun_lat, sun_lon;\n    double lat1,\
    \ lon1, lat2, lon2;\n    sun_lat = std::get<0>(std::make_tuple(planet1, planet2));\n\
    \    sun_lon = std::get<1>(std::make_tuple(planet1, planet2));\n    lat1 = 40.783;\n\
    \    lon1 = -73.996;\n    lat2 = 40.794;\n    lon2 = -73.984;\n    double d_lat\
    \ = (lat2-lat1)*M_PI/180;\n    double d_lon = (lon2-lon1)*M_PI/180;\n    double\
    \ a = sin(d_lat/2);\n    double b = sin(d_lon/2);\n    double c = cos(d_lat/2);\n\
    \    double d = cos(d_lon/2);\n    double e = 0.0;\n    if(b == 0)\n        e\
    \ = 1e-7;\n    else\n        e = 1e-6;\n    double f = sqrt((1 + e)/(1 - e));\n\
    \    double G = 6.67384 * 10e-8;\n    double H = HALF_PI;\n    double M1 = H;\n\
    \    double M2 = H;\n    double M3 = H;\n    double M4 = H;\n    double M5 = H;\n\
    \    double M6 = H;\n    double M7 = H;\n    double M8 = H;\n    double M9 = H;\n\
    \    double M10 = H;\n    double M11 = H;\n    double M12 = H;\n    double M13\
    \ = H;\n    double M14 = H;\n    double M15 = H;\n    double M16 = H;\n    double\
    \ M17 = H;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzs9kgwew.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpzs9kgwew.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpzs9kgwew.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > res;\n      | \
    \                            ^\n/tmp/tmpzs9kgwew.cpp:20:30: error: redeclaration\
    \ of \u2018double sun_lat\u2019\n   20 |     double sun_lat, sun_lon, sun_lat,\
    \ sun_lon, sun_lat, sun_lon, sun_lat, sun_lon;\n      |                      \
    \        ^~~~~~~\n/tmp/tmpzs9kgwew.cpp:20:12: note: \u2018double sun_lat\u2019\
    \ previously declared here\n   20 |     double sun_lat, sun_lon, sun_lat, sun_lon,\
    \ sun_lat, sun_lon, sun_lat, sun_lon;\n      |            ^~~~~~~\n/tmp/tmpzs9kgwew.cpp:20:39:\
    \ error: redeclaration of \u2018double sun_lon\u2019\n   20 |     double sun_lat,\
    \ sun_lon, sun_lat, sun_lon, sun_lat, sun_lon, sun_lat, sun_lon;\n      |    \
    \                                   ^~~~~~~\n/tmp/tmpzs9kgwew.cpp:20:21: note:\
    \ \u2018double sun_lon\u2019 previously declared here\n   20 |     double sun_lat,\
    \ sun_lon, sun_lat, sun_lon, sun_lat, sun_lon, sun_lat, sun_lon;\n      |    \
    \                 ^~~~~~~\n/tmp/tmpzs9kgwew.cpp:20:48: error: redeclaration of\
    \ \u2018double sun_lat\u2019\n   20 |     double sun_lat, sun_lon, sun_lat, sun_lon,\
    \ sun_lat, sun_lon, sun_lat, sun_lon;\n      |                               \
    \                 ^~~~~~~\n/tmp/tmpzs9kgwew.cpp:20:12: note: \u2018double sun_lat\u2019\
    \ previously declared here\n   20 |     double sun_lat, sun_lon, sun_lat, sun_lon,\
    \ sun_lat, sun_lon, sun_lat, sun_lon;\n      |            ^~~~~~~\n/tmp/tmpzs9kgwew.cpp:20:57:\
    \ error: redeclaration of \u2018double sun_lon\u2019\n   20 |     double sun_lat,\
    \ sun_lon, sun_lat, sun_lon, sun_lat, sun_lon, sun_lat, sun_lon;\n      |    \
    \                                                     ^~~~~~~\n/tmp/tmpzs9kgwew.cpp:20:21:\
    \ note: \u2018double sun_lon\u2019 previously declared here\n   20 |     double\
    \ sun_lat, sun_lon, sun_lat, sun_lon, sun_lat, sun_lon, sun_lat, sun_lon;\n  \
    \    |           "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    std::tuple<double, double> orbit1 = orbit(planet1);\n\
    \    std::tuple<double, double> orbit2 = orbit(planet2);\n    double distance\
    \ = std::abs(orbit1.get<1>() - orbit2.get<1>());\n    \n    if(distance > 180)\
    \ return std::tuple<std::string, std::string, std::string, std::string, std::string,\
    \ std::string, std::string, std::string>{};\n    \n    double a1 = orbit1.get<1>();\n\
    \    double a2 = orbit2.get<1>();\n    double a3 = a1 + a2;\n    double a4 = sqrt(pow((pow(a1,\
    \ 2) + pow(a2, 2)), 0.5));\n    double a5 = a3 / a4;\n    double a6 = a5 / a2;\n\
    \    double a7 = a6 / a1;\n    double a8 = (a8 * pow(cos((a1 / a3)*pi/180), 2));\n\
    \    double a9 = (a9 * a8);\n    double a10 = (a9 * a8);\n    double a11 = (a10\
    \ * a8);\n    double a12 = (a11 * a8);\n    double a13 = (a12 * a8);\n    double\
    \ a14 = (a13 * a8);\n    double a15 = (a14 * a8);\n    double a16 = (a15 * a8);\n\
    \    double a17 = (a16 * a8);\n    double a18 = (a17 * a8);\n    double a19 =\
    \ (a18 * a8);\n    double a20 = (a19 * a8);\n    double a21 = (a20 * a8);\n  \
    \  double a22 = (a21 * a8);\n    double a23 = (a22 * a8);\n    double a24 = (a23\
    \ * a8);\n    double a25 = (a24 * a8);\n    double a26 = (a25 * a8);\n    double\
    \ a27 = (a26 * a8);\n    double a28 = (a27 * a8);\n    double a29 = (a28 * a8);\n\
    \    double a30 = (a29 * a8);\n    double a31 = (a30 * a8);\n    double a32 =\
    \ (a31 * a8);\n    double a33 = (a32 * a8);\n    double a34 = (a33 * a8);\n  \
    \  double a35 = (a34 * a8);\n    double a36 = (a35 * a8);\n    double a37 = (a36\
    \ * a8);\n    double a38 = (a37 * a8);\n    double a39 = (a38 * a8);\n    double\
    \ a40 = (a39 * a8);\n    double a41 = (a40 * a8);\n    double a42 = (a41 * a8);\n\
    \    double a43 = (a42 * a8);\n    double a44 = (a43 * a8);\n    double a45 =\
    \ (a44 * a8);\n    double a46 = (a45 * a\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpy4ip_386.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpy4ip_386.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpy4ip_386.cpp:18:41: error: \u2018\
    orbit\u2019 was not declared in this scope; did you mean \u2018orbit1\u2019?\n\
    \   18 |     std::tuple<double, double> orbit1 = orbit(planet1);\n      |    \
    \                                     ^~~~~\n      |                         \
    \                orbit1\n/tmp/tmpy4ip_386.cpp:20:39: error: \u2018class std::tuple<double,\
    \ double>\u2019 has no member named \u2018get\u2019\n   20 |     double distance\
    \ = std::abs(orbit1.get<1>() - orbit2.get<1>());\n      |                    \
    \                   ^~~\n/tmp/tmpy4ip_386.cpp:20:46: error: expected primary-expression\
    \ before \u2018)\u2019 token\n   20 |     double distance = std::abs(orbit1.get<1>()\
    \ - orbit2.get<1>());\n      |                                              ^\n\
    /tmp/tmpy4ip_386.cpp:20:57: error: \u2018class std::tuple<double, double>\u2019\
    \ has no member named \u2018get\u2019\n   20 |     double distance = std::abs(orbit1.get<1>()\
    \ - orbit2.get<1>());\n      |                                               \
    \          ^~~\n/tmp/tmpy4ip_386.cpp:20:64: error: expected primary-expression\
    \ before \u2018)\u2019 token\n   20 |     double distance = std::abs(orbit1.get<1>()\
    \ - orbit2.get<1>());\n      |                                               \
    \                 ^\n/tmp/tmpy4ip_386.cpp:22:36: error: cannot convert \u2018\
    std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >,"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1 == \"Jupiter\" && planet2 == \"Neptune\"\
    ) \n        return std::make_tuple(\"Saturn\", \"Uranus\");\n    if (planet1 ==\
    \ \"Earth\" && planet2 == \"Mercury\") \n        return std::make_tuple(\"Venus\"\
    );\n    if (planet1 == \"Mercury\" && planet2 == \"Uranus\") \n        return\
    \ std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n\
    \    return std::tuple<std::string, >();\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpjnjthr0n.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpjnjthr0n.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpjnjthr0n.cpp:18:31: error: cannot\
    \ convert \u2018std::tuple<const char*, const char*>\u2019 to \u2018int\u2019\
    \ in return\n   18 |         return std::make_tuple(\"Saturn\", \"Uranus\");\n\
    \      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n      |         \
    \                      |\n      |                               std::tuple<const\
    \ char*, const char*>\n/tmp/tmpjnjthr0n.cpp:20:31: error: cannot convert \u2018\
    std::tuple<const char*>\u2019 to \u2018int\u2019 in return\n   20 |         return\
    \ std::make_tuple(\"Venus\");\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<const char*>\n/tmp/tmpjnjthr0n.cpp:22:31: error: cannot convert\
    \ \u2018std::tuple<const char*, const char*, const char*, const char*, const char*>\u2019\
    \ to \u2018int\u2019 in return\n   22 |         return std::make_tuple(\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<const char*, const char*, const char*, const char*, const char*>\n\
    /tmp/tmpjnjthr0n.cpp:23:36: error: template argument 2 is invalid\n   23 |   \
    \  return std::tuple<std::string, >();\n      |                              \
    \      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjnjthr0n.cpp:2:\n/tmp/tmpjnjthr0n.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpjnjthr0n.cpp:27:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   27 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |   "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double distEarth;\n    double distMercury;\n   \
    \ double distVenus;\n    double distEarthEarth;\n    double distMercuryMercury;\n\
    \    double distVenusVenus;\n    double distMercuryEarth;\n    double distMercuryMercuryEarth;\n\
    \    double distMercuryVenus;\n    double distMercuryMercuryVenus;\n    double\
    \ distMercuryMercuryMercury;\n    double distMercuryMercuryMercuryEarth;\n   \
    \ double distMercuryMercuryMercuryVenus;\n    double distMercuryMercuryMercuryMercuryEarth;\n\
    \    double distMercuryVenusMercury;\n    double distMercuryMercuryVenusMercury;\n\
    \    double distMercuryMercuryMercuryMercuryEarth;\n    double distMercuryMercuryMercuryMercuryVenus;\n\
    \    double distMercuryMercuryMercuryMercuryMercuryEarth;\n    double distMercuryVenusMercuryMercury;\n\
    \    double distMercuryMercuryVenusMercuryMercury;\n    double distMercuryMercuryMercuryMercuryMercuryEarth;\n\
    \    double distMercuryMercuryMercuryMercuryMercuryVenus;\n    double distMercuryMercuryMercuryMercuryMercuryMercuryEarth;\n\
    \    double distMercuryVenusMercuryMercuryMercury;\n    double distMercuryMercuryVenusMercuryMercuryMercury;\n\
    \    double distMercuryMercuryMercuryMercuryMercuryMercuryEarth;\n    double distMercuryMercuryMercuryMercuryMercuryMercuryVenus;\n\
    \    double distMercuryMercuryMercuryMercuryMercuryMercuryMercuryEarth;\n    double\
    \ distMercuryVenusMercuryMercuryMercuryMercury;\n    double distMercuryMercuryVenusMercuryMercuryMercuryMercury;\n\
    \    double distMercuryMercuryMercuryMercury\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp0wnrvd2f.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp0wnrvd2f.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp0wnrvd2f.cpp:33:12: error: redeclaration\
    \ of \u2018double distMercuryMercuryMercuryMercuryEarth\u2019\n   33 |     double\
    \ distMercuryMercuryMercuryMercuryEarth;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0wnrvd2f.cpp:30:12: note: \u2018double distMercuryMercuryMercuryMercuryEarth\u2019\
    \ previously declared here\n   30 |     double distMercuryMercuryMercuryMercuryEarth;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0wnrvd2f.cpp:38:12:\
    \ error: redeclaration of \u2018double distMercuryMercuryMercuryMercuryMercuryEarth\u2019\
    \n   38 |     double distMercuryMercuryMercuryMercuryMercuryEarth;\n      |  \
    \          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0wnrvd2f.cpp:35:12:\
    \ note: \u2018double distMercuryMercuryMercuryMercuryMercuryEarth\u2019 previously\
    \ declared here\n   35 |     double distMercuryMercuryMercuryMercuryMercuryEarth;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0wnrvd2f.cpp:43:12:\
    \ error: redeclaration of \u2018double distMercuryMercuryMercuryMercuryMercuryMercuryEarth\u2019\
    \n   43 |     double distMercuryMercuryMercuryMercuryMercuryMercuryEarth;\n  \
    \    |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0wnrvd2f.cpp:40:12:\
    \ note: \u2018double distMercuryMercuryMercuryMercuryMercuryMercuryEarth\u2019\
    \ previously declared here\n   40 |     double distMercuryMercuryMercuryMercuryMercuryMercuryEarth;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0wnrvd2f.cpp:49:1:\
    \ error: expected initializer before \u2018}\u2019 token\n   49 | }\n      | ^\n\
    /tmp/tmp0wnrvd2f.cpp:49:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-l"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::tuple<std::string, >> orbits;\n \
    \ // write your code here\n  for(int i=0;i<125;i++){\n    if(i%2==0)\n      orbits.push_back(std::make_tuple(planet1,planet2));\n\
    \    else\n      orbits.push_back(std::make_tuple(planet2,planet1));\n  }\n  orbits.sort();\n\
    \  if(orbits[0]==std::make_tuple(planet1,planet2))\n    return std::make_tuple(planet1);\n\
    \  if(orbits[orbits.size()-1]==std::make_tuple(planet1,planet2))\n    return std::make_tuple(planet2);\n\
    \  if(orbits[0]==std::make_tuple(planet2,planet1))\n    return std::make_tuple(planet2);\n\
    \  if(orbits[orbits.size()-1]==std::make_tuple(planet2,planet1))\n    return std::make_tuple(planet1);\n\
    \  return std::make_tuple(\"\");\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmppcv5znk1.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmppcv5znk1.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmppcv5znk1.cpp:17:37: error: template\
    \ argument 2 is invalid\n   17 |   std::vector<std::tuple<std::string, >> orbits;\n\
    \      |                                     ^\n/tmp/tmppcv5znk1.cpp:17:39: error:\
    \ template argument 1 is invalid\n   17 |   std::vector<std::tuple<std::string,\
    \ >> orbits;\n      |                                       ^~\n/tmp/tmppcv5znk1.cpp:17:39:\
    \ error: template argument 2 is invalid\n/tmp/tmppcv5znk1.cpp:21:14: error: request\
    \ for member \u2018push_back\u2019 in \u2018orbits\u2019, which is of non-class\
    \ type \u2018int\u2019\n   21 |       orbits.push_back(std::make_tuple(planet1,planet2));\n\
    \      |              ^~~~~~~~~\n/tmp/tmppcv5znk1.cpp:23:14: error: request for\
    \ member \u2018push_back\u2019 in \u2018orbits\u2019, which is of non-class type\
    \ \u2018int\u2019\n   23 |       orbits.push_back(std::make_tuple(planet2,planet1));\n\
    \      |              ^~~~~~~~~\n/tmp/tmppcv5znk1.cpp:25:10: error: request for\
    \ member \u2018sort\u2019 in \u2018orbits\u2019, which is of non-class type \u2018\
    int\u2019\n   25 |   orbits.sort();\n      |          ^~~~\n/tmp/tmppcv5znk1.cpp:26:14:\
    \ error: invalid types \u2018int[int]\u2019 for array subscript\n   26 |   if(orbits[0]==std::make_tuple(planet1,planet2))\n\
    \      |              ^\n/tmp/tmppcv5znk1.cpp:27:27: error: cannot convert \u2018\
    std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in return\n   27 |     return std::make_tuple(planet1);\n\
    \      |            ~~~~~~~~~~~~~~~^~~~~~~~~\n      |                        \
    \   |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmppcv5znk1.cpp:28:20:\
    \ error: request for member \u2018size\u2019 in \u2018orbits\u2019, which is of\
    \ non-class type \u2018int\u2019\n   28 |   if(orbits[orbits.size()-1]==std::make_tuple(planet1,planet2))\n\
    \      |                    ^~~~\n/tmp/tmppcv5znk1.cpp:29:27: er"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    using std::cout;\n    using std::endl;\n    using\
    \ std::string;\n    using std::to_string;\n    using std::tuple;\n    using std::get;\n\
    \    using std::make_tuple;\n    using std::swap;\n    assert(planet1.size() <=\
    \ 3 && planet1.size() >= 1 && planet2.size() <= 3 && planet2.size() >= 1);\n \
    \   auto a = to_string(atoi(planet1.substr(0, 1)));\n    auto b = to_string(atoi(planet2.substr(0,\
    \ 1)));\n    auto c = a + b;\n    int d = std::stol(c);\n    std::string e;\n\
    \    bool f = (atoi(a) == 0 && atoi(b) == 0);\n    if (f == false) {\n       \
    \ cout << endl << \"Your inputs are incorrect!\" << endl << endl;\n        cout\
    \ << \"Please input the right planet names!\" << endl;\n        swap(a, e);\n\
    \        swap(b, d);\n    } else if (f == true) {\n        e = \"Venus\";\n  \
    \  }\n    bool g = (e == \"Mercury\" || e == \"Venus\");\n    if (g == true) {\n\
    \        cout << \"Your inputs are correct!\" << endl;\n        std::pair<string,\
    \ string> p = std::make_tuple(e, planet2);\n        swap(a, p.first);\n      \
    \  swap(b, d);\n    } else if (g == false) {\n        cout << \"Your inputs are\
    \ incorrect!\" << endl;\n        swap(a, e);\n        swap(b, d);\n    }\n   \
    \ bool h = (d < 4);\n    if (h == true) {\n        std::pair<string, string> p\
    \ = std::make_tuple(a, planet2);\n        swap(a, p.first);\n        swap(b, d);\n\
    \    } else if (h == false) {\n        std::pair<string, string> p = std::make_tuple(a,\
    \ planet2);\n        swap(a, p.first);\n        swap(b, d);\n    }\n    bool i\
    \ = (a == planet1 && b == planet2);\n    if (i == true) {\n        std::pair<string,\
    \ string> p = std::make_tuple(a, planet2);\n        swap(a, p.first);\n      \
    \  swap(b, d);\n    } else if (i == false) {\n        std::pair<string, string>\
    \ p = std::make_tuple(a, planet2);\n        swap(a, p.first);\n        swap(b,\
    \ d);\n    }\n    if (planet1.size() == 3) {\n        std::pair<string, string>\
    \ p = std::make_tuple(a, planet2);\n        swap(a, p.first);\n        swap(b,\
    \ d);\n    }\n    if (planet2.size() == 3) {\n        std::pair<string, string>\
    \ p = std::make_tuple(a, planet2);\n\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpsjz2qzsc.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpsjz2qzsc.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpsjz2qzsc.cpp:26:43: error: cannot\
    \ convert \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const char*\u2019\
    \n   26 |     auto a = to_string(atoi(planet1.substr(0, 1)));\n      |       \
    \                      ~~~~~~~~~~~~~~^~~~~~\n      |                         \
    \                  |\n      |                                           std::__cxx11::basic_string<char>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:47,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpsjz2qzsc.cpp:2:\n/usr/include/stdlib.h:147:30:\
    \ note:   initializing argument 1 of \u2018int atoi(const char*)\u2019\n  147\
    \ | extern int atoi (const char *__nptr)\n      |                  ~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmpsjz2qzsc.cpp:27:43: error: cannot convert \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const char*\u2019\n   27 |     auto b = to_string(atoi(planet2.substr(0,\
    \ 1)));\n      |                             ~~~~~~~~~~~~~~^~~~~~\n      |   \
    \                                        |\n      |                          \
    \                 std::__cxx11::basic_string<char>\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:47,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpsjz2qzsc.cpp:2:\n/usr/include/stdlib.h:147:30:\
    \ note:   initializing argument 1 of \u2018int atoi(const char*)\u2019\n  147\
    \ | extern int atoi (const char *__nptr)\n      |                  ~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmpsjz2qzsc.cpp:43:54: error: conversion from \u2018std::tuple<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    using namespace std;\n    \n    // Check if planet\
    \ names are valid\n    if (!planet1.empty() && !planet2.empty()) {\n        string\
    \ planet1Orbit, planet2Orbit;\n        // If planet2 orbital is larger, return\
    \ an empty tuple\n        if (planet1.size() > planet2.size()) {\n           \
    \ return std::tuple<string, >();\n        }\n        \n        // Get the orbits\
    \ of planet1\n        orbits(planet1, planet1Orbit);\n        \n        // Get\
    \ the orbits of planet2\n        orbits(planet2, planet2Orbit);\n        \n  \
    \      // Check if both planets are orbits\n        if (planet1Orbit.empty() ||\
    \ planet2Orbit.empty()) {\n            return std::tuple<string, >();\n      \
    \  }\n        \n        // Find the orbital distance between the two orbits\n\
    \        double dist = distance(planet1Orbit, planet2Orbit);\n        \n     \
    \   // Sort the planets by proximity to sun \n        auto comp = [](std::string\
    \ s1, std::string s2) -> bool {\n            double d1, d2;\n            \n  \
    \          // Check if s1 is a valid planet and s2 is empty\n            if (s1.size()\
    \ > 0 && !s2.empty()) {\n                // Find the orbital distance of s1 from\
    \ sun\n                d1 = distance(planet1, s1);\n                // Find the\
    \ orbital distance of s2 from sun\n                d2 = distance(planet2, s2);\n\
    \            }\n            \n            // Check if s2 has a valid planet\n\
    \            else if (!s1.empty() && s2.size() > 0) {\n                d1 = distance(planet1,\
    \ s2);\n                d2 = distance(planet2, s1);\n            }\n         \
    \   \n            // If both s1 and s2 are valid planets \n            if (d1.empty()\
    \ && d2.empty()) {\n                return s1.size() < s2.size();\n          \
    \  }\n            \n            // If s1 is a valid planet and s2 is empty\n \
    \           else if (s1.size() > 0 && !s2.empty()) {\n                return s1\
    \ < s2;\n            }\n            \n            // If s1 is a valid planet and\
    \ s2 is not empty\n            else if (s1.size() > 0 && s2.size() > 0) {\n  \
    \              return s1 < s2;\n            }\n            \n            // If\
    \ s1 is not valid\n            else {\n                return s2 < s1;\n     \
    \       }\n        };\n        \n        // Return the sorted tuple of planets\n\
    \        return std::make_tuple(planet1, planet2, std::make_tuple(planet1, planet2,\
    \ planet1, planet2, planet1, planet2));\n    }\n    \n    // Else return a empty\
    \ tuple\n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm8cymmhz.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpm8cymmhz.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpm8cymmhz.cpp:24:39: error: template\
    \ argument 2 is invalid\n   24 |             return std::tuple<string, >();\n\
    \      |                                       ^\n/tmp/tmpm8cymmhz.cpp:28:9: error:\
    \ \u2018orbits\u2019 was not declared in this scope\n   28 |         orbits(planet1,\
    \ planet1Orbit);\n      |         ^~~~~~\n/tmp/tmpm8cymmhz.cpp:35:39: error: template\
    \ argument 2 is invalid\n   35 |             return std::tuple<string, >();\n\
    \      |                                       ^\n/tmp/tmpm8cymmhz.cpp:39:58:\
    \ error: no matching function for call to \u2018distance(std::string&, std::string&)\u2019\
    \n   39 |         double dist = distance(planet1Orbit, planet2Orbit);\n      |\
    \                                                          ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:66,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpm8cymmhz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator_base_funcs.h:138:5:\
    \ note: candidate: \u2018template<class _InputIterator> typename std::iterator_traits<_Iterator>::difference_type\
    \ std::distance(_InputIterator, _InputIterator)\u2019\n  138 |     distance(_InputIterator\
    \ __first, _InputIterat"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    auto a = [&](auto &b) { return std::tie(b.second,\
    \ b.first); };\n    std::set<std::string> s1, s2;\n    \n    std::transform(planet1.begin(),\
    \ planet1.end(), std::inserter(s1, s1.begin()), \n                   [&](std::string\
    \ &a) { a.swap(planet1); });\n    \n    std::transform(planet2.begin(), planet2.end(),\
    \ std::inserter(s2, s2.begin()), \n                   [&](std::string &a) { a.swap(planet2);\
    \ });\n    \n    auto p1 = std::find_if(planet1.begin(), planet1.end(), [&](std::string\
    \ &a) { return s1.find(a) != s1.end(); });\n    auto p2 = std::find_if(planet2.begin(),\
    \ planet2.end(), [&](std::string &a) { return s2.find(a) != s2.end(); });\n  \
    \  \n    if (p1 == planet1.end() && p2 == planet2.end())\n        return std::tuple<std::string>{};\n\
    \    \n    return std::tuple<std::string>{ planet1, p1, planet2, p2 };\n    \n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj7x0nb9q.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpj7x0nb9q.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpj7x0nb9q.cpp:31:21: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   31 |       \
    \  return std::tuple<std::string>{};\n      |                     ^~~~~~~~~~~~~~~~~~~~\n\
    \      |                     |\n      |                     std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpj7x0nb9q.cpp:33:62:\
    \ error: no matching function for call to \u2018std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >::tuple(<brace-enclosed initializer\
    \ list>)\u2019\n   33 |     return std::tuple<std::string>{ planet1, p1, planet2,\
    \ p2 };\n      |                                                             \
    \ ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/functional:54,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpj7x0nb9q.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/tuple:808:11:\
    \ note: candidate: \u2018template<class _Alloc, class _Dummy, class ... _UElements,\
    \ typename std::enable_if<((std::_TC<((1 == sizeof... (_UElements)) && (! std::is_same<std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >, std::tuple<_Tail ...> >::value)),\
    \ std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >::_MoveConstructibleTuple<_UElements ...>() && (! std::_TC<((1 == sizeof...\
    \ (_UElements)) && (! std::is_same<std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >, std::tuple<_Tail ...> >::value)),\
    \ std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >::_ImplicitlyMoveConvertibleTuple"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::vector<std::tuple<double, std::string>> orbits;\n\
    \    double sun_distance = 0;\n    std::pair<std::string, std::string> planet1_orbit\
    \ = std::make_pair(planet1, planet2);\n    std::pair<std::string, std::string>\
    \ planet2_orbit = std::make_pair(planet2, planet1);\n    // We calculate the orbits\
    \ between the planets.\n    // We are interested in all the orbits between the\
    \ planets, \n    // so a loop will do fine.\n    for (double x = 0.0; x <= PI;\
    \ x += PI/20) {\n        for (double y = 0.0; y <= 2*PI; y += PI/20) {\n     \
    \       double r = x * x + y * y;\n            if (r > 1.0) \n               \
    \ r = 1.0; // Discard small values of r. \n            std::tuple<double, std::string>\
    \ orbit = std::make_tuple(r, planet1_orbit.second);\n            std::pair<std::string,\
    \ std::string> planet_orbit =\n                std::make_pair(planet1_orbit.first,\
    \ planet2_orbit.first);\n            if (std::get<0>(orbit) <= std::get<0>(planet_orbit)\
    \ &&\n                std::get<0>(orbit) < std::get<1>(planet_orbit) &&\n    \
    \            std::get<1>(orbit) <= std::get<1>(planet_orbit) &&\n            \
    \    std::get<1>(orbit) < std::get<2>(planet_orbit))\n                orbits.push_back(orbit);\n\
    \        }\n    }\n\n    // For each orbit, we calculate the distance to the Sun\
    \ and \n    // sort them according to their distance.\n    for (auto orbit : orbits)\
    \ {\n        std::tuple<double, std::string> planet_orbit = std::make_tuple(orbit.first,\
    \ orbit.second);\n        double distance = std::sqrt(std::get<0>(planet_orbit))\
    \ * std::sqrt(std::get<1>(planet_orbit));\n        std::cout << std::get<1>(orbit)\
    \ << \" -- \" << std::get<0>(orbit) << \" = \" << distance << std::endl;\n   \
    \     std::tie(planet1_orbit, planet2_orbit) = std::make_pair(std::get<1>(orbit),\
    \ std::get<0>(orbit));\n        double sun_distance = distance * 0.000001;\n \
    \       if (distance < sun_distance)\n            std::tie(planet2_orbit, planet1_orbit)\
    \ = std::make_pair(std::get<1>(orbit), std::get<0>(orbit));\n    }\n\n    // We\
    \ return the planets whose orbits are between the orbits of the two planets.\n\
    \    std::set<std::tuple<double, std::string>> planets;\n    planet\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwqtqoe0u.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpwqtqoe0u.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpwqtqoe0u.cpp:24:31: error: \u2018\
    PI\u2019 was not declared in this scope\n   24 |     for (double x = 0.0; x <=\
    \ PI; x += PI/20) {\n      |                               ^~\n/tmp/tmpwqtqoe0u.cpp:32:36:\
    \ error: no match for \u2018operator<=\u2019 (operand types are \u2018std::__tuple_element_t<0,\
    \ std::tuple<double, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > > >\u2019 {aka \u2018double\u2019} and \u2018std::tuple_element<0,\
    \ std::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char>\
    \ > >::type\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019})\n   32 |\
    \             if (std::get<0>(orbit) <= std::get<0>(planet_orbit) &&\n      |\
    \                 ~~~~~~~~~~~~~~~~~~ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~\n      |   \
    \                         |                     |\n      |                   \
    \         |                     std::tuple_element<0, std::pair<std::__cxx11::basic_string<char>,\
    \ std::__cxx11::basic_string<char> > >::type {aka std::__cxx11::basic_string<char>}\n\
    \      |                            std::__tuple_element_t<0, std::tuple<double,\
    \ std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > > > {aka double}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpwqtqoe0u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1059:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1059 |     operator<=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1059:5:\
    \ note"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > result;\n    double distance\
    \ = 5.0;\n    // To calculate the distance of planet1 to planet2, use formula:\
    \ \n    // http://mathworld.wolfram.com/Point-LineDistance2-Dimensional.html\n\
    \    double a = pow(distance, 2);\n    double b = pow(distance, 3);\n    double\
    \ c = pow(distance, 4);\n    double d = pow(distance, 5);\n    double e = pow(distance,\
    \ 6);\n    double f = pow(distance, 7);\n    double g = pow(distance, 8);\n  \
    \  double h = pow(distance, 9);\n    double i = pow(distance, 10);\n    double\
    \ j = pow(distance, 11);\n    double k = pow(distance, 12);\n    double l = pow(distance,\
    \ 13);\n    double m = pow(distance, 14);\n    double n = pow(distance, 15);\n\
    \    double o = pow(distance, 16);\n    double p = pow(distance, 17);\n    double\
    \ q = pow(distance, 18);\n    double r = pow(distance, 19);\n    double s = pow(distance,\
    \ 20);\n    double t = pow(distance, 21);\n    double u = pow(distance, 22);\n\
    \    double v = pow(distance, 23);\n    double w = pow(distance, 24);\n    double\
    \ x = pow(distance, 25);\n    double y = pow(distance, 26);\n    double z = pow(distance,\
    \ 27);\n    double a1 = pow(distance, 28);\n    double b1 = pow(distance, 29);\n\
    \    double c1 = pow(distance, 30);\n    double d1 = pow(distance, 31);\n    double\
    \ e1 = pow(distance, 32);\n    double f1 = pow(distance, 33);\n    double g1 =\
    \ pow(distance, 34);\n    double h1 = pow(distance, 35);\n    double i1 = pow(distance,\
    \ 36);\n    double j1 = pow(distance, 37);\n    double k1 = pow(distance, 38);\n\
    \    double l1 = pow(distance, 39);\n    double m1 = pow(distance, 40);\n    double\
    \ n1 = pow(distance, 41);\n    double o1 = pow(distance, 42);\n    double p1 =\
    \ pow(distance, 43);\n    double q1 = pow(distance, 44);\n    double r1 = pow(distance,\
    \ 45);\n    double s1 = pow(distance, 46);\n    double t1 = pow(distance, 47);\n\
    \    double u1 = pow(distance, 48);\n    double v1 = pow(distance, 49);\n    double\
    \ w1 = pow(distance, 50);\n    double x1 = pow(distance, 51);\n    double y1 =\
    \ pow(distance, 52);\n    double z1 = pow(distance, 53);\n    double a2 = pow(distance,\
    \ 54);\n    double b2 = pow(distance, 55);\n    double c2 = pow(distance, 56);\n\
    \    double d2 = pow(distance, 57);\n    double e2 = pow(distance, 58);\n    double\
    \ f2 = \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbnm9hlf4.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpbnm9hlf4.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpbnm9hlf4.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmpbnm9hlf4.cpp:79:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   79 | }\n      | ^\n/tmp/tmpbnm9hlf4.cpp:79:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbnm9hlf4.cpp:2:\n/tmp/tmpbnm9hlf4.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpbnm9hlf4.cpp:82:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   82 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpbnm9hlf4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:10"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > res;\n    // Write your\
    \ code here\n    int i = 0; \n    for (int j = 0; j < 8; j++) {\n        if (i\
    \ != j) {\n            if (planet1[i] == planet2[j]) {\n                i++;\n\
    \                j++;\n            }\n        }\n    }\n    std::string name =\
    \ planet1;\n    if (i == 1) {\n        name += \"s\"; \n    } else {\n       \
    \ name += \"es\";\n    }\n    res[0] = name;\n    return res;\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxkesz0_3.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpxkesz0_3.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpxkesz0_3.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > res;\n      | \
    \                            ^\n/tmp/tmpxkesz0_3.cpp:34:10: error: invalid types\
    \ \u2018int[int]\u2019 for array subscript\n   34 |     res[0] = name;\n     \
    \ |          ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxkesz0_3.cpp:2:\n/tmp/tmpxkesz0_3.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpxkesz0_3.cpp:39:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   39 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpxkesz0_3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1.compare(planet2) != 0) return std::tuple<std::string,>();\n\
    \    double sd = std::abs(get_body_longitude_dist(planet1, planet2));\n    double\
    \ e = std::abs(get_body_electron_dist(planet1, planet2));\n    // we know that\
    \ if the distance between the two planets is less than \n    // 2 solar radii,\
    \ then they're in the same orbit\n    if (sd <= 2) return std::tuple<std::string,>();\n\
    \    // otherwise, they're in different orbits and we sort them by their \n  \
    \  // distance\n    std::vector<std::string> sorted_orbits;\n    sorted_orbits.reserve(4);\n\
    \    std::pair<double,double> p_1 = get_body_orbit(planet1);\n    std::pair<double,double>\
    \ p_2 = get_body_orbit(planet2);\n    sorted_orbits.push_back(get_body_name(p_1.first));\n\
    \    sorted_orbits.push_back(get_body_name(p_2.first));\n    sorted_orbits.push_back(get_body_name(p_1.second));\n\
    \    sorted_orbits.push_back(get_body_name(p_2.second));\n    sort_orbits(sorted_orbits);\n\
    \    return std::tuple<std::string,>(sorted_orbits[0]);\n}\nint main() {\n   \
    \ auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_l04xmg1.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp_l04xmg1.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp_l04xmg1.cpp:17:70: error: template\
    \ argument 2 is invalid\n   17 |     if (planet1.compare(planet2) != 0) return\
    \ std::tuple<std::string,>();\n      |                                       \
    \                               ^\n/tmp/tmp_l04xmg1.cpp:18:26: error: \u2018get_body_longitude_dist\u2019\
    \ was not declared in this scope\n   18 |     double sd = std::abs(get_body_longitude_dist(planet1,\
    \ planet2));\n      |                          ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_l04xmg1.cpp:19:25:\
    \ error: \u2018get_body_electron_dist\u2019 was not declared in this scope\n \
    \  19 |     double e = std::abs(get_body_electron_dist(planet1, planet2));\n \
    \     |                         ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_l04xmg1.cpp:22:48:\
    \ error: template argument 2 is invalid\n   22 |     if (sd <= 2) return std::tuple<std::string,>();\n\
    \      |                                                ^\n/tmp/tmp_l04xmg1.cpp:27:36:\
    \ error: \u2018get_body_orbit\u2019 was not declared in this scope\n   27 |  \
    \   std::pair<double,double> p_1 = get_body_orbit(planet1);\n      |         \
    \                           ^~~~~~~~~~~~~~\n/tmp/tmp_l04xmg1.cpp:29:29: error:\
    \ \u2018get_body_name\u2019 was not declared in this scope\n   29 |     sorted_orbits.push_back(get_body_name(p_1.first));\n\
    \      |                             ^~~~~~~~~~~~~\n/tmp/tmp_l04xmg1.cpp:33:5:\
    \ error: \u2018sort_orbits\u2019 was not declared in this scope; did you mean\
    \ \u2018sorted_orbits\u2019?\n   33 |     sort_orbits(sorted_orbits);\n      |\
    \     ^~~~~~~~~~~\n      |     sorted_orbits\n/tmp/tmp_l04xmg1.cpp:34:35: error:\
    \ template argument 2 is invalid\n   34 |     return std::tuple<std::string,>(sorted_orbits[0]);\n\
    \      |                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\");\n\
    \    assert(planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\"\
    \ || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" ||\
    \ planet2 == \"Uranus\" || planet2 == \"Neptune\");\n    \n    std::tuple<std::string,\
    \ > res;\n    if (planet1 == \"Mercury\" && planet2 == \"Earth\") {\n        res\
    \ = {planet1, \"Earth\"};\n    } else if (planet1 == \"Earth\" && planet2 == \"\
    Venus\") {\n        res = {planet1, \"Venus\"};\n    } else if (planet1 == \"\
    Venus\" && planet2 == \"Mercury\") {\n        res = {planet1, \"Mercury\"};\n\
    \    } else if (planet1 == \"Mercury\" && planet2 == \"Mars\") {\n        res\
    \ = {planet1, \"Mars\"};\n    } else if (planet1 == \"Mars\" && planet2 == \"\
    Mercury\") {\n        res = {planet1, \"Mercury\"};\n    } else if (planet1 ==\
    \ \"Mercury\" && planet2 == \"Jupiter\") {\n        res = {planet1, \"Jupiter\"\
    };\n    } else if (planet1 == \"Jupiter\" && planet2 == \"Mercury\") {\n     \
    \   res = {planet1, \"Mercury\"};\n    } else if (planet1 == \"Mercury\" && planet2\
    \ == \"Saturn\") {\n        res = {planet1, \"Saturn\"};\n    } else if (planet1\
    \ == \"Saturn\" && planet2 == \"Mercury\") {\n        res = {planet1, \"Mercury\"\
    };\n    } else if (planet1 == \"Mercury\" && planet2 == \"Uranus\") {\n      \
    \  res = {planet1, \"Uranus\"};\n    } else if (planet1 == \"Uranus\" && planet2\
    \ == \"Mercury\") {\n        res = {planet1, \"Mercury\"};\n    } else if (planet1\
    \ == \"Mercury\" && planet2 == \"Neptune\") {\n        res = {planet1, \"Neptune\"\
    };\n    } else if (planet1 == \"Neptune\" && planet2 == \"Mercury\") {\n     \
    \   res = {planet1, \"Mercury\"};\n    } else if (planet1 == \"Mercury\" && planet2\
    \ == \"Earth\") {\n        res = {planet2, \"\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpx00fedym.cpp:48:25: warning: missing terminating \" character\n\
    \   48 |         res = {planet2, \"\n      |                         ^\n/tmp/tmpx00fedym.cpp:48:25:\
    \ error: missing terminating \" character\n/tmp/tmpx00fedym.cpp:16:25: error:\
    \ template argument 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                         ^\n/tmp/tmpx00fedym.cpp:\
    \ In function \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmpx00fedym.cpp:20:29:\
    \ error: template argument 2 is invalid\n   20 |     std::tuple<std::string, >\
    \ res;\n      |                             ^\n/tmp/tmpx00fedym.cpp:22:32: error:\
    \ cannot convert \u2018<brace-enclosed initializer list>\u2019 to \u2018int\u2019\
    \ in assignment\n   22 |         res = {planet1, \"Earth\"};\n      |        \
    \                        ^\n/tmp/tmpx00fedym.cpp:24:32: error: cannot convert\
    \ \u2018<brace-enclosed initializer list>\u2019 to \u2018int\u2019 in assignment\n\
    \   24 |         res = {planet1, \"Venus\"};\n      |                        \
    \        ^\n/tmp/tmpx00fedym.cpp:26:34: error: cannot convert \u2018<brace-enclosed\
    \ initializer list>\u2019 to \u2018int\u2019 in assignment\n   26 |         res\
    \ = {planet1, \"Mercury\"};\n      |                                  ^\n/tmp/tmpx00fedym.cpp:28:31:\
    \ error: cannot convert \u2018<brace-enclosed initializer list>\u2019 to \u2018\
    int\u2019 in assignment\n   28 |         res = {planet1, \"Mars\"};\n      | \
    \                              ^\n/tmp/tmpx00fedym.cpp:30:34: error: cannot convert\
    \ \u2018<brace-enclosed initializer list>\u2019 to \u2018int\u2019 in assignment\n\
    \   30 |         res = {planet1, \"Mercury\"};\n      |                      \
    \            ^\n/tmp/tmpx00fedym.cpp:32:34: error: cannot convert \u2018<brace-enclosed\
    \ initializer list>\u2019 to \u2018int\u2019 in assignment\n   32 |         res\
    \ = {planet1, \"Jupiter\"};\n      |                                  ^\n/tmp/tmpx00fedym.cpp:34:34:\
    \ error: cannot convert \u2018<brace-enclosed initializer list>\u2019 to \u2018\
    int\u2019 in assignment\n   34 |         res = {planet1, \"Mercury\"};\n     \
    \ |                                  ^\n/tmp/tmpx00fedym.cpp:36:33: error: cannot\
    \ convert \u2018<brace-enclosed initializer list>\u2019 to"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Complete the function here\n    assert(planet1\
    \ != planet2);\n    if (planet1 == planet2) {\n        return std::make_tuple(planet2);\n\
    \    }\n    std::tuple<std::string, > orbits;\n    orbits.emplace(planet1);\n\
    \    orbits.emplace(planet2);\n    return orbits;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp59nd3tfh.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp59nd3tfh.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp59nd3tfh.cpp:20:31: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |       \
    \  return std::make_tuple(planet2);\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\n/tmp/tmp59nd3tfh.cpp:22:29: error: template argument 2 is invalid\n   22\
    \ |     std::tuple<std::string, > orbits;\n      |                           \
    \  ^\n/tmp/tmp59nd3tfh.cpp:23:12: error: request for member \u2018emplace\u2019\
    \ in \u2018orbits\u2019, which is of non-class type \u2018int\u2019\n   23 | \
    \    orbits.emplace(planet1);\n      |            ^~~~~~~\n/tmp/tmp59nd3tfh.cpp:24:12:\
    \ error: request for member \u2018emplace\u2019 in \u2018orbits\u2019, which is\
    \ of non-class type \u2018int\u2019\n   24 |     orbits.emplace(planet2);\n  \
    \    |            ^~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp59nd3tfh.cpp:2:\n/tmp/tmp59nd3tfh.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp59nd3tfh.cpp:29:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   29 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\");\n\
    \  assert(planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\"\
    \ || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" ||\
    \ planet2 == \"Uranus\" || planet2 == \"Neptune\");\n  std::tuple<std::string,\
    \ > ans;\n  if (planet1 == planet2) {\n    return ans;\n  }\n  std::string sun\
    \ = std::to_string(std::numeric_limits<double>::max());\n  double sun_planet_orbit_distance\
    \ = std::numeric_limits<double>::max();\n  double planet1_orbit_distance = std::numeric_limits<double>::max();\n\
    \  double planet2_orbit_distance = std::numeric_limits<double>::max();\n  double\
    \ planet1_sun_distance = std::numeric_limits<double>::max();\n  double planet2_sun_distance\
    \ = std::numeric_limits<double>::max();\n  \n  // Calculate sun orbit distance\
    \ and planet orbit distance\n  for (int i = 0; i < (int) SolarSystem::n; i = i\
    \ + 1) {\n    double angle = std::atan2(SolarSystem::x[i], SolarSystem::y[i]);\n\
    \    double sun_orbit_distance = std::sin(angle) * std::sin(angle) + std::cos(angle)\
    \ * std::cos(angle) * std::cos(angle);\n    if (sun_orbit_distance <= sun) {\n\
    \      sun = sun_orbit_distance;\n      sun_planet_orbit_distance = i;\n    }\n\
    \  }\n  for (int i = 0; i < (int) SolarSystem::n; i = i + 1) {\n    double angle\
    \ = std::atan2(SolarSystem::x[i], SolarSystem::y[i]);\n    double planet1_orbit_distance\
    \ = std::sin(angle) * std::sin(angle) + std::cos(angle) * std::cos(angle) * std::cos(angle);\n\
    \    if (planet1_orbit_distance < planet1_sun_distance) {\n      planet1_sun_distance\
    \ = planet1_orbit_distance;\n      planet1_orbit_distance = i;\n    }\n  }\n \
    \ for (int i = 0; i < (int) SolarSystem::n; i = i + 1) {\n    double angle = std::atan2(SolarSystem::x[i],\
    \ SolarSystem::y[i]);\n    double plan\n}\nint main() {\n    auto candidate =\
    \ bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp47j_2tkg.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp47j_2tkg.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp47j_2tkg.cpp:19:27: error: template\
    \ argument 2 is invalid\n   19 |   std::tuple<std::string, > ans;\n      |   \
    \                        ^\n/tmp/tmp47j_2tkg.cpp:31:29: error: \u2018SolarSystem\u2019\
    \ has not been declared\n   31 |   for (int i = 0; i < (int) SolarSystem::n; i\
    \ = i + 1) {\n      |                             ^~~~~~~~~~~\n/tmp/tmp47j_2tkg.cpp:32:31:\
    \ error: \u2018SolarSystem\u2019 has not been declared\n   32 |     double angle\
    \ = std::atan2(SolarSystem::x[i], SolarSystem::y[i]);\n      |               \
    \                ^~~~~~~~~~~\n/tmp/tmp47j_2tkg.cpp:32:50: error: \u2018SolarSystem\u2019\
    \ has not been declared\n   32 |     double angle = std::atan2(SolarSystem::x[i],\
    \ SolarSystem::y[i]);\n      |                                               \
    \   ^~~~~~~~~~~\n/tmp/tmp47j_2tkg.cpp:34:28: error: no match for \u2018operator<=\u2019\
    \ (operand types are \u2018double\u2019 and \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019})\n   34 |     if (sun_orbit_distance <=\
    \ sun) {\n      |         ~~~~~~~~~~~~~~~~~~ ^~ ~~~\n      |         |       \
    \              |\n      |         double                std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp47j_2tkg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1059:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1059 |     operator<=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1059:5:\
    \ note:   template argument deduction/"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > result;\n    // your code\
    \ goes here\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplk2pv9pl.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmplk2pv9pl.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmplk2pv9pl.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmplk2pv9pl.cpp:19:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n   19 | }\n      |\
    \ ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplk2pv9pl.cpp:2:\n/tmp/tmplk2pv9pl.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmplk2pv9pl.cpp:22:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   22 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmplk2pv9pl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  if (planet1 == \"Mercury\") {\n    if (planet2 ==\
    \ \"Earth\") {\n      return std::make_tuple(\"Venus\");\n    } else if (planet2\
    \ == \"Mars\") {\n      return std::make_tuple(\"Jupiter\", \"Saturn\");\n   \
    \ } else if (planet2 == \"Jupiter\") {\n      return std::make_tuple(\"Saturn\"\
    , \"Uranus\");\n    } else if (planet2 == \"Saturn\") {\n      return std::make_tuple(\"\
    Uranus\");\n    } else if (planet2 == \"Uranus\") {\n      return std::make_tuple();\n\
    \    }\n  } else if (planet1 == \"Venus\") {\n    if (planet2 == \"Earth\") {\n\
    \      return std::make_tuple();\n    } else if (planet2 == \"Mars\") {\n    \
    \  return std::make_tuple(\"Jupiter\", \"Saturn\");\n    } else if (planet2 ==\
    \ \"Jupiter\") {\n      return std::make_tuple(\"Saturn\", \"Uranus\");\n    }\
    \ else if (planet2 == \"Saturn\") {\n      return std::make_tuple(\"Uranus\");\n\
    \    } else if (planet2 == \"Uranus\") {\n      return std::make_tuple(\"Mercury\"\
    );\n    }\n  } else if (planet1 == \"Earth\") {\n    if (planet2 == \"Mars\")\
    \ {\n      return std::make_tuple(\"Jupiter\", \"Saturn\");\n    } else if (planet2\
    \ == \"Jupiter\") {\n      return std::make_tuple(\"Saturn\", \"Uranus\");\n \
    \   } else if (planet2 == \"Saturn\") {\n      return std::make_tuple(\"Uranus\"\
    );\n    } else if (planet2 == \"Uranus\") {\n      return std::make_tuple(\"Mercury\"\
    , \"Venus\");\n    }\n  } else if (planet1 == \"Mars\") {\n    if (planet2 ==\
    \ \"Jupiter\") {\n      return std::make_tuple(\"Saturn\", \"Uranus\");\n    }\
    \ else if (planet2 == \"Saturn\") {\n      return std::make_tuple(\"Uranus\");\n\
    \    } else if (planet2 == \"Uranus\") {\n      return std::make_tuple(\"Mercury\"\
    , \"Venus\", \"Earth\");\n    } else if (planet2 == \"Neptune\") {\n      return\
    \ std::make_tuple();\n    }\n  } else if (planet1 == \"Jupiter\") {\n    if (planet2\
    \ == \"Saturn\") {\n      return std::make_tuple(\"Uranus\");\n    } else if (planet2\
    \ == \"Uranus\") {\n      return std::make_tuple(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Neptune\");\n    } else if (planet2 == \"Neptune\") {\n      return\
    \ std::make_tuple();\n    } else if (planet2 == \"Neptune\") {\n      return std::make_tuple(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"J\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpts4u1zm7.cpp:69:67: warning: missing terminating \" character\n\
    \   69 |       return std::make_tuple(\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"J\n      |                                                               \
    \    ^\n/tmp/tmpts4u1zm7.cpp:69:67: error: missing terminating \" character\n\
    \   69 |       return std::make_tuple(\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"J\n      |                                                               \
    \    ^~\n/tmp/tmpts4u1zm7.cpp:16:25: error: template argument 2 is invalid\n \
    \  16 | std::tuple<std::string, > bf(std::string planet1, std::string planet2)\
    \ {\n      |                         ^\n/tmp/tmpts4u1zm7.cpp: In function \u2018\
    int bf(std::string, std::string)\u2019:\n/tmp/tmpts4u1zm7.cpp:19:29: error: cannot\
    \ convert \u2018std::tuple<const char*>\u2019 to \u2018int\u2019 in return\n \
    \  19 |       return std::make_tuple(\"Venus\");\n      |              ~~~~~~~~~~~~~~~^~~~~~~~~\n\
    \      |                             |\n      |                             std::tuple<const\
    \ char*>\n/tmp/tmpts4u1zm7.cpp:21:29: error: cannot convert \u2018std::tuple<const\
    \ char*, const char*>\u2019 to \u2018int\u2019 in return\n   21 |       return\
    \ std::make_tuple(\"Jupiter\", \"Saturn\");\n      |              ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n\
    \      |                             |\n      |                             std::tuple<const\
    \ char*, const char*>\n/tmp/tmpts4u1zm7.cpp:23:29: error: cannot convert \u2018\
    std::tuple<const char*, const char*>\u2019 to \u2018int\u2019 in return\n   23\
    \ |       return std::make_tuple(\"Saturn\", \"Uranus\");\n      |           \
    \   ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n      |                             |\n\
    \      |                             std::tuple<const char*, const char*>\n/tmp/tmpts4u1zm7.cpp:25:29:\
    \ error: cannot convert \u2018std::tuple<const char*>\u2019 to \u2018int\u2019\
    \ in return\n   25 |       return std::make_tuple(\"Uranus\");\n      |      \
    \        ~~~~~~~~~~~~~~~^~~~~~~~~~\n      |                             |\n  \
    \    |                             std::tuple<const char*>\n/tmp/tmpts4u1zm7.cpp:27:29:\
    \ error: cannot convert \u2018std::tuple<>\u2019 to \u2018int\u2019 in return\n\
    \   27 |       return std::"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > orbits;\n    auto p =\
    \ std::tuple<std::string, > orbits;\n    // (*orbits).first == (*orbits).second\
    \ == (*orbits).third\n    if ( planet1 == \"Venus\" && planet2 == \"Earth\" ||\
    \ planet1 == \"Earth\" && planet2 == \"Venus\") {\n        (*orbits).first = \"\
    Venus\";\n        return orbits;\n    }\n    if ( planet1 == \"Mercury\" && planet2\
    \ == \"Earth\" || planet1 == \"Earth\" && planet2 == \"Mercury\") {\n        (*orbits).first\
    \ = \"Mercury\";\n        return orbits;\n    }\n    if ( planet1 == \"Jupiter\"\
    \ && planet2 == \"Earth\" || planet1 == \"Earth\" && planet2 == \"Jupiter\") {\n\
    \        (*orbits).first = \"Jupiter\";\n        return orbits;\n    }\n    if\
    \ ( planet1 == \"Saturn\" && planet2 == \"Earth\" || planet1 == \"Earth\" && planet2\
    \ == \"Saturn\") {\n        (*orbits).first = \"Saturn\";\n        return orbits;\n\
    \    }\n    if ( planet1 == \"Uranus\" && planet2 == \"Earth\" || planet1 == \"\
    Earth\" && planet2 == \"Uranus\") {\n        (*orbits).first = \"Uranus\";\n \
    \       return orbits;\n    }\n    if ( planet1 == \"Neptune\" && planet2 == \"\
    Earth\" || planet1 == \"Earth\" && planet2 == \"Neptune\") {\n        (*orbits).first\
    \ = \"Neptune\";\n        return orbits;\n    }\n    if ( planet1 == \"Mars\"\
    \ && planet2 == \"Earth\" || planet1 == \"Earth\" && planet2 == \"Mars\") {\n\
    \        (*orbits).first = \"Mars\";\n        return orbits;\n    }\n    if (\
    \ planet1 == \"Mercury\" && planet2 == \"Mars\" || planet1 == \"Mars\" && planet2\
    \ == \"Mercury\") {\n        (*orbits).first = \"Mercury\";\n        return orbits;\n\
    \    }\n    if ( planet1 == \"Venus\" && planet2 == \"Mars\" || planet1 == \"\
    Mars\" && planet2 == \"Venus\") {\n        (*orbits).first = \"Venus\";\n    \
    \    return orbits;\n    }\n    if ( planet1 == \"Jupiter\" && planet2 == \"Mars\"\
    \ || planet1 == \"Mars\" && planet2 == \"Jupiter\") {\n        (*orbits).first\
    \ = \"Jupiter\";\n        return orbits;\n    }\n\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4mjb7cen.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp4mjb7cen.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp4mjb7cen.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > orbits;\n     \
    \ |                             ^\n/tmp/tmp4mjb7cen.cpp:18:38: error: template\
    \ argument 2 is invalid\n   18 |     auto p = std::tuple<std::string, > orbits;\n\
    \      |                                      ^\n/tmp/tmp4mjb7cen.cpp:21:11: error:\
    \ invalid type argument of unary \u2018*\u2019 (have \u2018int\u2019)\n   21 |\
    \         (*orbits).first = \"Venus\";\n      |           ^~~~~~\n/tmp/tmp4mjb7cen.cpp:25:11:\
    \ error: invalid type argument of unary \u2018*\u2019 (have \u2018int\u2019)\n\
    \   25 |         (*orbits).first = \"Mercury\";\n      |           ^~~~~~\n/tmp/tmp4mjb7cen.cpp:29:11:\
    \ error: invalid type argument of unary \u2018*\u2019 (have \u2018int\u2019)\n\
    \   29 |         (*orbits).first = \"Jupiter\";\n      |           ^~~~~~\n/tmp/tmp4mjb7cen.cpp:33:11:\
    \ error: invalid type argument of unary \u2018*\u2019 (have \u2018int\u2019)\n\
    \   33 |         (*orbits).first = \"Saturn\";\n      |           ^~~~~~\n/tmp/tmp4mjb7cen.cpp:37:11:\
    \ error: invalid type argument of unary \u2018*\u2019 (have \u2018int\u2019)\n\
    \   37 |         (*orbits).first = \"Uranus\";\n      |           ^~~~~~\n/tmp/tmp4mjb7cen.cpp:41:11:\
    \ error: invalid type argument of unary \u2018*\u2019 (have \u2018int\u2019)\n\
    \   41 |         (*orbits).first = \"Neptune\";\n      |           ^~~~~~\n/tmp/tmp4mjb7cen.cpp:45:11:\
    \ error: invalid type argument of unary \u2018*\u2019 (have \u2018int\u2019)\n\
    \   45 |         (*orbits).first = \"Mars\";\n      |           ^~~~~~\n/tmp/tmp4mjb7cen.cpp:49:11:\
    \ error: invalid type argument of unary \u2018*\u2019 (have \u2018int\u2019)\n\
    \   49 |         (*orbits).first = \"Mercury\";\n      |           ^~~~~~\n/tmp/tmp4mjb7cen.cpp:53:11:\
    \ error: invalid type argument of unary \u2018*\u2019 (have \u2018int\u2019)\n\
    \   53 |         (*orbits).first = \"Venus\";\n      |           ^~~~~~\n/tmp/tmp4mjb7cen.cpp:57:11:\
    \ error: invalid type argument of unary \u2018*\u2019 (have \u2018int\u2019)\n\
    \   57 |         (*orbits).fi"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1.length() != 2) return std::tuple<std::string,\
    \ >();\n    if (planet2.length() != 2) return std::tuple<std::string, >();\n \
    \   if (planet1[0] > planet2[0]) return std::tuple<std::string, >();\n    if (planet1[0]\
    \ < planet2[0]) return std::tuple<std::string, >();\n    if (planet1[1] > planet2[1])\
    \ return std::tuple<std::string, >();\n    if (planet1[1] < planet2[1]) return\
    \ std::tuple<std::string, >();\n    return std::tuple<std::string, >();\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2wc6lq6h.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp2wc6lq6h.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp2wc6lq6h.cpp:17:63: error: template\
    \ argument 2 is invalid\n   17 |     if (planet1.length() != 2) return std::tuple<std::string,\
    \ >();\n      |                                                              \
    \ ^\n/tmp/tmp2wc6lq6h.cpp:18:63: error: template argument 2 is invalid\n   18\
    \ |     if (planet2.length() != 2) return std::tuple<std::string, >();\n     \
    \ |                                                               ^\n/tmp/tmp2wc6lq6h.cpp:19:65:\
    \ error: template argument 2 is invalid\n   19 |     if (planet1[0] > planet2[0])\
    \ return std::tuple<std::string, >();\n      |                               \
    \                                  ^\n/tmp/tmp2wc6lq6h.cpp:20:65: error: template\
    \ argument 2 is invalid\n   20 |     if (planet1[0] < planet2[0]) return std::tuple<std::string,\
    \ >();\n      |                                                              \
    \   ^\n/tmp/tmp2wc6lq6h.cpp:21:65: error: template argument 2 is invalid\n   21\
    \ |     if (planet1[1] > planet2[1]) return std::tuple<std::string, >();\n   \
    \   |                                                                 ^\n/tmp/tmp2wc6lq6h.cpp:22:65:\
    \ error: template argument 2 is invalid\n   22 |     if (planet1[1] < planet2[1])\
    \ return std::tuple<std::string, >();\n      |                               \
    \                                  ^\n/tmp/tmp2wc6lq6h.cpp:23:36: error: template\
    \ argument 2 is invalid\n   23 |     return std::tuple<std::string, >();\n   \
    \   |                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2wc6lq6h.cpp:2:\n/tmp/tmp2wc6lq6h.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp2wc6lq6h.cpp:27:48: error: no match for \u2018\
    ope"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n   auto t1 = planet1.length();\n   auto t2 = planet2.length();\n\
    \   if(t1 != t2){\n      return std::make_tuple(\"\");\n   }\n   std::string planet\
    \ = planet1;\n   for(auto i = 0; i < t1 - t2; i++){\n      if(planet[i] == planet2[i]){\n\
    \         planet = planet1 + planet2 + planet1[i] + planet2[i];\n      }\n   }\n\
    \   return std::make_tuple(planet);\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpfmmcahrq.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpfmmcahrq.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpfmmcahrq.cpp:20:29: error: cannot\
    \ convert \u2018std::tuple<const char*>\u2019 to \u2018int\u2019 in return\n \
    \  20 |       return std::make_tuple(\"\");\n      |              ~~~~~~~~~~~~~~~^~~~\n\
    \      |                             |\n      |                             std::tuple<const\
    \ char*>\n/tmp/tmpfmmcahrq.cpp:28:26: error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\u2019 to \u2018int\u2019 in\
    \ return\n   28 |    return std::make_tuple(planet);\n      |           ~~~~~~~~~~~~~~~^~~~~~~~\n\
    \      |                          |\n      |                          std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfmmcahrq.cpp:2:\n/tmp/tmpfmmcahrq.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpfmmcahrq.cpp:32:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   32 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfmmcahrq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double r = 6371;  // Earth radius in km\n    double\
    \ R = (r*r)/2;\n    double a1 = (r/R) * std::atan2(std::sqrt(R*R-(r*r)), R);\n\
    \    double a2 = (r/R) * std::atan2(std::sqrt(R*R-(r*r)), r);\n    double d1 =\
    \ a1-a2;\n    double d2 = a1+a2;\n    if (std::abs(d1) < std::abs(d2)) {\n   \
    \     std::swap(a1, a2);\n        std::swap(d1, d2);\n    }\n    double A = a1*a1;\n\
    \    double B = a1*a2;\n    double C = a2*a2;\n    double D = a2+a1;\n    double\
    \ E = A+B;\n    double F = B-A;\n    double G = C+D;\n    double H = C-D;\n  \
    \  double I = E+F;\n    double J = F-E;\n    double K = G+H;\n    double L = G-H;\n\
    \    double M = I+J;\n    double N = J-I;\n    double O = K+L;\n    double P =\
    \ K-L;\n    double Q = O+P;\n    double R = P-O;\n    double S = std::sqrt(A*A+B*B+C*C+D*D+E*E+F*F+G*G+H*H+I*I+J*J+K*K+L*L+M*M+N*N+O*O+P*P+Q*Q+R*R);\n\
    \    double t = std::atan2(S, r);\n    double A = std::cos(t);\n    double B =\
    \ std::sin(t);\n    std::tuple<std::string, > res;\n    if (A*A+B*B > 0) {\n \
    \       if (std::abs(A) < 1) {\n            res = {planet1};\n        }\n    \
    \    if (std::abs(B) < 1) {\n            res = {planet2};\n        }\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj6nnws_6.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpj6nnws_6.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpj6nnws_6.cpp:44:12: error: redeclaration\
    \ of \u2018double R\u2019\n   44 |     double R = P-O;\n      |            ^\n\
    /tmp/tmpj6nnws_6.cpp:18:12: note: \u2018double R\u2019 previously declared here\n\
    \   18 |     double R = (r*r)/2;\n      |            ^\n/tmp/tmpj6nnws_6.cpp:47:12:\
    \ error: redeclaration of \u2018double A\u2019\n   47 |     double A = std::cos(t);\n\
    \      |            ^\n/tmp/tmpj6nnws_6.cpp:27:12: note: \u2018double A\u2019\
    \ previously declared here\n   27 |     double A = a1*a1;\n      |           \
    \ ^\n/tmp/tmpj6nnws_6.cpp:48:12: error: redeclaration of \u2018double B\u2019\n\
    \   48 |     double B = std::sin(t);\n      |            ^\n/tmp/tmpj6nnws_6.cpp:28:12:\
    \ note: \u2018double B\u2019 previously declared here\n   28 |     double B =\
    \ a1*a2;\n      |            ^\n/tmp/tmpj6nnws_6.cpp:49:29: error: template argument\
    \ 2 is invalid\n   49 |     std::tuple<std::string, > res;\n      |          \
    \                   ^\n/tmp/tmpj6nnws_6.cpp:52:27: error: cannot convert \u2018\
    <brace-enclosed initializer list>\u2019 to \u2018int\u2019 in assignment\n   52\
    \ |             res = {planet1};\n      |                           ^\n/tmp/tmpj6nnws_6.cpp:55:27:\
    \ error: cannot convert \u2018<brace-enclosed initializer list>\u2019 to \u2018\
    int\u2019 in assignment\n   55 |             res = {planet2};\n      |       \
    \                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpj6nnws_6.cpp:2:\n/tmp/tmpj6nnws_6.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpj6nnws_6.cpp:62:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   62 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 != planet2);\n    std::string planet1planet2\
    \ = \"Mercury\";\n    std::string planet1planet2orbit = \"Mars\";\n    std::string\
    \ planet1planet2orbitorbit = \"Jupiter\";\n    std::string planet1planet2orbitorbitorbit\
    \ = \"Saturn\";\n    std::string planet1planet2orbitorbitorbitorbit = \"Uranus\"\
    ;\n    std::string planet1planet2orbitorbitorbitorbitorbit = \"Neptune\";\n  \
    \  std::tuple<std::string, > result;\n    // TODO: Write your code\n    return\
    \ result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp22ncciwk.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp22ncciwk.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp22ncciwk.cpp:24:29: error: template\
    \ argument 2 is invalid\n   24 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp22ncciwk.cpp:2:\n/tmp/tmp22ncciwk.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp22ncciwk.cpp:30:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   30 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp22ncciwk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skyla"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > planets;\n    assert(planet1\
    \ != \"\");\n    assert(planet2 != \"\");\n\n    // Write your code here\n   \
    \ int n1 = 0, n2 = 0, n3 = 0, n4 = 0, n5 = 0, n6 = 0, n7 = 0;\n    int a = 0;\n\
    \    int b = 0;\n    for (int i = 1; i <= 5; i++) {\n        if (planet1 == planets[i])\
    \ {\n            n1++;\n        }\n        if (planet2 == planets[i]) {\n    \
    \        n2++;\n        }\n    }\n    for (int i = 6; i <= 10; i++) {\n      \
    \  if (planet1 == planets[i]) {\n            n3++;\n        }\n        if (planet2\
    \ == planets[i]) {\n            n4++;\n        }\n    }\n    for (int i = 1; i\
    \ <= 3; i++) {\n        if (planet1 == planets[i]) {\n            n5++;\n    \
    \    }\n        if (planet2 == planets[i]) {\n            n6++;\n        }\n \
    \   }\n    for (int i = 4; i <= 6; i++) {\n        if (planet1 == planets[i])\
    \ {\n            n7++;\n        }\n        if (planet2 == planets[i]) {\n    \
    \        a++;\n        }\n    }\n\n    std::cout << \"n1: \" << n1 << std::endl;\n\
    \    std::cout << \"n2: \" << n2 << std::endl;\n    std::cout << \"n3: \" << n3\
    \ << std::endl;\n    std::cout << \"n4: \" << n4 << std::endl;\n    std::cout\
    \ << \"n5: \" << n5 << std::endl;\n    std::cout << \"n6: \" << n6 << std::endl;\n\
    \    std::cout << \"n7: \" << n7 << std::endl;\n    std::cout << \"a: \" << a\
    \ << std::endl;\n    std::cout << \"b: \" << b << std::endl;\n\n    if (n1 > n2)\
    \ {\n        if (n1 > n3) {\n            if (n1 > n5) {\n                if (n1\
    \ > n6) {\n                    if (n1 > n7) {\n                        planets\
    \ = std::make_tuple(planet1, planet2);\n                    }\n              \
    \  }\n            }\n        }\n    }\n\n    if (n2 > n1) {\n        if (n2 >\
    \ n3) {\n            if (n2 > n5) {\n                if (n2 > n6) {\n        \
    \            if (n2 > n7) {\n                        planets = std::make_tuple(planet1,\
    \ planet2);\n                    }\n                }\n            }\n       \
    \ }\n    }\n\n    if (n3 > n1) {\n        if (n3 > n2) {\n            if (n3 >\
    \ n5) {\n                if (n3 > n6) {\n                    if (n3 > n7) {\n\
    \                        planets = std::make_tuple(planet1, planet2);\n      \
    \              }\n                }\n            }\n        }\n    }\n\n    if\
    \ (n4 > n1) {\n        if (n4 > n2) {\n            if (n4 > n3) {\n          \
    \      if (n4 > n5) {\n                    if (n4 > n6\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmptxss_cqj.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmptxss_cqj.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmptxss_cqj.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > planets;\n    \
    \  |                             ^\n/tmp/tmptxss_cqj.cpp:26:33: error: invalid\
    \ types \u2018int[int]\u2019 for array subscript\n   26 |         if (planet1\
    \ == planets[i]) {\n      |                                 ^\n/tmp/tmptxss_cqj.cpp:29:33:\
    \ error: invalid types \u2018int[int]\u2019 for array subscript\n   29 |     \
    \    if (planet2 == planets[i]) {\n      |                                 ^\n\
    /tmp/tmptxss_cqj.cpp:34:33: error: invalid types \u2018int[int]\u2019 for array\
    \ subscript\n   34 |         if (planet1 == planets[i]) {\n      |           \
    \                      ^\n/tmp/tmptxss_cqj.cpp:37:33: error: invalid types \u2018\
    int[int]\u2019 for array subscript\n   37 |         if (planet2 == planets[i])\
    \ {\n      |                                 ^\n/tmp/tmptxss_cqj.cpp:42:33: error:\
    \ invalid types \u2018int[int]\u2019 for array subscript\n   42 |         if (planet1\
    \ == planets[i]) {\n      |                                 ^\n/tmp/tmptxss_cqj.cpp:45:33:\
    \ error: invalid types \u2018int[int]\u2019 for array subscript\n   45 |     \
    \    if (planet2 == planets[i]) {\n      |                                 ^\n\
    /tmp/tmptxss_cqj.cpp:50:33: error: invalid types \u2018int[int]\u2019 for array\
    \ subscript\n   50 |         if (planet1 == planets[i]) {\n      |           \
    \                      ^\n/tmp/tmptxss_cqj.cpp:53:33: error: invalid types \u2018\
    int[int]\u2019 for array subscript\n   53 |         if (planet2 == planets[i])\
    \ {\n      |                                 ^\n/tmp/tmptxss_cqj.cpp:73:50: error:\
    \ cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in assignment\n   73 |   \
    \                      planets = std::make_tuple(pla"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    int a1 = getRadians(planet1);\n    int a2 = getRadians(planet2);\n\
    \    int b1 = 90; // Earth's right ascension\n    int b2 = 90; // Earth's right\
    \ ascension\n    int i1, i2, i3, i4, i5;\n    double l1 = 0, l1s = 0, l2 = 0;\
    \ \n    double d = 0;\n    for (i1 = getSunDistance(planet1, a1, b1); i1 <= getSunDistance(planet1,\
    \ a1, b2); i1++) {\n        l1 = l1 + 1;\n        l1s = l1s + getSunDistance(planet1,\
    \ a1, i1);\n    }\n    for (i2 = getSunDistance(planet2, a2, b2); i2 <= getSunDistance(planet2,\
    \ a2, b1); i2++) {\n        l2 = l2 + 1;\n        l2s = l2s + getSunDistance(planet2,\
    \ a2, i2);\n    }\n    std::vector<double> d(8);\n    int i1, i2, i3, i4, i5;\n\
    \    for (i1 = 0; i1 < 8; i1++) {\n        d[i1] = 0;\n    }\n    for (i2 = 0;\
    \ i2 < 8; i2++) {\n        d[i2] = 0;\n    }\n    for (d = d1; d < d2; d++) {\n\
    \        for (i1 = getSunDistance(planet1, a1, b1) - l1 - 1; i1 <= getSunDistance(planet1,\
    \ a1, b2) - l1 - 1; i1++) {\n            for (i2 = getSunDistance(planet2, a2,\
    \ b2) - l2 - 1; i2 <= getSunDistance(planet2, a2, b1) - l2 - 1; i2++) {\n    \
    \            for (d = d1 - 1; d < d2; d++) {\n                    i3 = (d + 8)\
    \ % 8;\n                    i4 = (d + 8 + 1) % 8;\n                    i5 = (d\
    \ + 8 + 2) % 8;\n                    d[i3] = (d[i3] < getSunDistance(planet1,\
    \ a1, i3)) ? d[i3] : getSunDistance(planet1, a1, i3);\n                    d[i4]\
    \ = (d[i4] < getSunDistance(planet2, a2, i4)) ? d[i4] : getSunDistance(planet2,\
    \ a2, i4);\n                    d[i5] = (d[i5] < getSunDistance(planet1, a1, i5))\
    \ ? d[i5] : getSunDistance(planet1, a1, i5);\n                    i3 = (d + 8\
    \ + 1) % 8;\n                    i4 = (d + 8) % 8;\n                    i5 = (d\
    \ + 8 + 2) % 8;\n                    \n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp6ee2o1nu.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp6ee2o1nu.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp6ee2o1nu.cpp:17:14: error: \u2018\
    getRadians\u2019 was not declared in this scope\n   17 |     int a1 = getRadians(planet1);\n\
    \      |              ^~~~~~~~~~\n/tmp/tmp6ee2o1nu.cpp:24:15: error: \u2018getSunDistance\u2019\
    \ was not declared in this scope\n   24 |     for (i1 = getSunDistance(planet1,\
    \ a1, b1); i1 <= getSunDistance(planet1, a1, b2); i1++) {\n      |           \
    \    ^~~~~~~~~~~~~~\n/tmp/tmp6ee2o1nu.cpp:28:15: error: \u2018getSunDistance\u2019\
    \ was not declared in this scope\n   28 |     for (i2 = getSunDistance(planet2,\
    \ a2, b2); i2 <= getSunDistance(planet2, a2, b1); i2++) {\n      |           \
    \    ^~~~~~~~~~~~~~\n/tmp/tmp6ee2o1nu.cpp:30:9: error: \u2018l2s\u2019 was not\
    \ declared in this scope; did you mean \u2018l2\u2019?\n   30 |         l2s =\
    \ l2s + getSunDistance(planet2, a2, i2);\n      |         ^~~\n      |       \
    \  l2\n/tmp/tmp6ee2o1nu.cpp:32:25: error: conflicting declaration \u2018std::vector<double>\
    \ d\u2019\n   32 |     std::vector<double> d(8);\n      |                    \
    \     ^\n/tmp/tmp6ee2o1nu.cpp:23:12: note: previous declaration as \u2018double\
    \ d\u2019\n   23 |     double d = 0;\n      |            ^\n/tmp/tmp6ee2o1nu.cpp:33:9:\
    \ error: redeclaration of \u2018int i1\u2019\n   33 |     int i1, i2, i3, i4,\
    \ i5;\n      |         ^~\n/tmp/tmp6ee2o1nu.cpp:21:9: note: \u2018int i1\u2019\
    \ previously declared here\n   21 |     int i1, i2, i3, i4, i5;\n      |     \
    \    ^~\n/tmp/tmp6ee2o1nu.cpp:33:13: error: redeclaration of \u2018int i2\u2019\
    \n   33 |     int i1, i2, i3, i4, i5;\n      |             ^~\n/tmp/tmp6ee2o1nu.cpp:21:13:\
    \ note: \u2018int i2\u2019 previously declared here\n   21 |     int i1, i2, i3,\
    \ i4, i5;\n      |             ^~\n/tmp/tmp6ee2o1nu.cpp:33:17: error: redeclaration\
    \ of \u2018int i3\u2019\n   33 |     int i1, i2, i3, i4, i5;\n      |        \
    \         ^~\n/tmp/tmp6ee2o1nu.cpp:21:17: note: \u2018int i3\u2019 previously\
    \ declared here\n   21 |     int i1, i2, i3, i4, i5;\n      |                \
    \ ^~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 != \"\");\n    assert(planet2 !=\
    \ \"\");\n    std::tuple<std::string, > orbits;\n    if (planet1 == planet2) {\n\
    \        orbits.emplace_back(planet1);\n        return orbits;\n    }\n    std::vector<std::tuple<std::string,\
    \ std::string>> orbits1; // orbits of planet1\n    std::vector<std::tuple<std::string,\
    \ std::string>> orbits2; // orbits of planet2\n    std::vector<std::tuple<std::string,\
    \ std::string>> orbits3; // orbits of planet1 + planet2\n    orbits1.emplace_back(planet1);\n\
    \    orbits2.emplace_back(planet2);\n    orbits3.emplace_back(planet1);\n    orbits3.emplace_back(planet2);\n\
    \    for (auto &orbit : orbits1) {\n        auto distance = orbit_distance(orbits2,\
    \ orbit);\n        for (auto &orbit : orbits2) {\n            if (orbit_distance(orbits2,\
    \ orbit) <= distance) {\n                orbits3.emplace_back(planet1, planet2);\n\
    \                break;\n            }\n        }\n    }\n    orbits = std::tuple_cat(orbits,\
    \ orbits3);\n    std::sort(orbits.begin(), orbits.end(), [](auto &a, auto &b)\
    \ { return a.size() > b.size(); });\n    return orbits;\n}\nint main() {\n   \
    \ auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdw3dfr70.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpdw3dfr70.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpdw3dfr70.cpp:19:29: error: template\
    \ argument 2 is invalid\n   19 |     std::tuple<std::string, > orbits;\n     \
    \ |                             ^\n/tmp/tmpdw3dfr70.cpp:21:16: error: request\
    \ for member \u2018emplace_back\u2019 in \u2018orbits\u2019, which is of non-class\
    \ type \u2018int\u2019\n   21 |         orbits.emplace_back(planet1);\n      |\
    \                ^~~~~~~~~~~~\n/tmp/tmpdw3dfr70.cpp:32:25: error: \u2018orbit_distance\u2019\
    \ was not declared in this scope\n   32 |         auto distance = orbit_distance(orbits2,\
    \ orbit);\n      |                         ^~~~~~~~~~~~~~\n/tmp/tmpdw3dfr70.cpp:40:44:\
    \ error: no matching function for call to \u2018tuple_cat(int&, std::vector<std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > > >&)\u2019\n   40 |     orbits\
    \ = std::tuple_cat(orbits, orbits3);\n      |                                \
    \            ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/functional:54,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpdw3dfr70.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/tuple:1597:5:\
    \ note: candidate: \u2018template<class ... _Tpls, class> constexpr typename std::__tuple_cat_result<_Tpls\
    \ ...>::__type std::tuple_cat(_Tpls&& ...)\u2019\n 1597 |     tuple_cat(_Tpls&&...\
    \ __tpls)\n      |     ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/tuple:1597:5:\
    \ note:   template argument deduction/substitution failed:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/tuple:1594:31:\
    \ error: no type named \u2018type\u2019 in \u2018struct std::enable_if<false,\
    \ void>\u2019\n 1594 |   template<typename... _Tpls, typename = typename\n   \
    \   |                               ^"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" ||\
    \ planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2\
    \ == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 ==\
    \ \"Uranus\" || planet2 == \"Neptune\");\n    assert(planet2 == \"Mercury\" ||\
    \ planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\");\n    // initialize variables\n    double distance = 0.0, angle\
    \ = 0.0;\n    std::string firstPlanet = planet1, secondPlanet = planet2;\n   \
    \ while (1) {\n        // calculate the distance between the planets\n       \
    \ if (firstPlanet == \"Mercury\") {\n            if (secondPlanet == \"Saturn\"\
    ) distance = 2.45;\n            if (secondPlanet == \"Uranus\") distance = 0.0;\n\
    \            if (secondPlanet == \"Neptune\") distance = 0.0;\n        }\n   \
    \     if (firstPlanet == \"Venus\") {\n            if (secondPlanet == \"Saturn\"\
    ) distance = 1.7;\n            if (secondPlanet == \"Uranus\") distance = 2.0;\n\
    \            if (secondPlanet == \"Neptune\") distance = 0.0;\n        }\n   \
    \     if (firstPlanet == \"Earth\") {\n            if (secondPlanet == \"Saturn\"\
    ) distance = 0.0;\n            if (secondPlanet == \"Uranus\") distance = 1.0;\n\
    \            if (secondPlanet == \"Neptune\") distance = 0.0;\n        }\n   \
    \     if (firstPlanet == \"Mars\") {\n            if (secondPlanet == \"Saturn\"\
    ) distance = 0.0;\n            if (secondPlanet == \"Uranus\") distance = 1.0;\n\
    \            if (secondPlanet == \"Neptune\") distance = 0.0;\n        }\n   \
    \     if (firstPlanet == \"Jupiter\") {\n            if (secondPlanet == \"Saturn\"\
    ) distance = 1.5;\n            if (secondPlanet == \"Uranus\") distance = 1.0;\n\
    \            if (secondPlanet == \"Neptune\") distance = 0.0;\n        }\n   \
    \     if (firstPlanet == \"Saturn\") {\n            if (secondPlanet == \"Uranus\"\
    ) distance = 1.5;\n            if (secondPlanet == \"Neptune\") distance = 1.0;\n\
    \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpze_z1732.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpze_z1732.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpze_z1732.cpp:54:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   54 | int main() {\n     \
    \ |            ^\n/tmp/tmpze_z1732.cpp:63:1: error: expected \u2018}\u2019 at\
    \ end of input\n   63 | }\n      | ^\n/tmp/tmpze_z1732.cpp:22:15: note: to match\
    \ this \u2018{\u2019\n   22 |     while (1) {\n      |               ^\n/tmp/tmpze_z1732.cpp:63:1:\
    \ error: expected \u2018}\u2019 at end of input\n   63 | }\n      | ^\n/tmp/tmpze_z1732.cpp:16:72:\
    \ note: to match this \u2018{\u2019\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                                   \
    \                                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    std::pair<double, double> planet_1,\
    \ planet_2;\n    double distance;\n    double distance_sq;\n    double theta1,\
    \ theta2;\n    int k;\n    double dist_m;\n    double dist_m_sq;\n    \n    \n\
    \    \n    if (planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"\
    Earth\" || \n        planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1\
    \ == \"Saturn\" || \n        planet1 == \"Uranus\" || planet1 == \"Neptune\" ||\
    \ planet1 == \"Ceres\" || \n        planet1 == \"Pluto\") {\n        planet_1\
    \ = std::make_pair(0.0, 0.0);\n    } else {\n        planet_1 = std::make_pair(0.0,\
    \ 0.0);\n    }\n    if (planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || \n        planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2\
    \ == \"Saturn\" || \n        planet2 == \"Uranus\" || planet2 == \"Neptune\" ||\
    \ planet2 == \"Ceres\" || \n        planet2 == \"Pluto\") {\n        planet_2\
    \ = std::make_pair(0.0, 0.0);\n    } else {\n        planet_2 = std::make_pair(0.0,\
    \ 0.0);\n    }\n    \n    \n    if (planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || \n        planet1 == \"Mars\" || planet1 == \"Jupiter\"\
    \ || planet1 == \"Saturn\" || \n        planet1 == \"Uranus\" || planet1 == \"\
    Neptune\" || planet1 == \"Ceres\" || \n        planet1 == \"Pluto\") {\n     \
    \   planet_1 = std::make_pair(0.0, 0.0);\n    } else {\n        planet_1 = std::make_pair(0.0,\
    \ 0.0);\n    }\n    if (planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || \n        planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2\
    \ == \"Saturn\" || \n        planet2 == \"Uranus\" || planet2 == \"Neptune\" ||\
    \ planet2 == \"Ceres\" || \n        planet2 == \"Pluto\") {\n        planet_2\
    \ = std::make_pair(0.0, 0.0);\n    } else {\n        planet_2 = std::make_pair(0.0,\
    \ 0.0);\n    }\n    \n    \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzdgv3n6u.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpzdgv3n6u.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpzdgv3n6u.cpp:65:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   65 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzdgv3n6u.cpp:2:\n/tmp/tmpzdgv3n6u.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpzdgv3n6u.cpp:68:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   68 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpzdgv3n6u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string solarSystem[] = {\n        \"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \n    \
    \    \"Neptune\"};\n    std::map<std::string, std::string> mapSolarSystem = {\n\
    \        {\"Mercury\", \"Mercury\"},\n        {\"Venus\", \"Venus\"},\n      \
    \  {\"Earth\", \"Earth\"},\n        {\"Mars\", \"Mars\"},\n        {\"Jupiter\"\
    , \"Jupiter\"},\n        {\"Saturn\", \"Saturn\"},\n        {\"Uranus\", \"Uranus\"\
    },\n        {\"Neptune\", \"Neptune\"}};\n\n    auto planet1Index = std::distance(solarSystem,\
    \ std::find(solarSystem, \n        planet1, std::end(solarSystem)));\n    auto\
    \ planet2Index = std::distance(solarSystem, std::find(solarSystem, \n        planet2,\
    \ std::end(solarSystem)));\n\n    if(planet1Index == planet2Index) \n        return\
    \ std::make_tuple(std::make_tuple(planet1, planet2));\n    else\n        return\
    \ std::make_tuple();\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpebdcjmom.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpebdcjmom.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpebdcjmom.cpp:31:39: error: no matching\
    \ function for call to \u2018find(std::string [8], std::string&, std::__cxx11::basic_string<char>*)\u2019\
    \n   31 |         planet1, std::end(solarSystem)));\n      |                 \
    \                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_facets.h:48,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_ios.h:37,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpebdcjmom.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/streambuf_iterator.h:373:5:\
    \ note: candidate: \u2018template<class _CharT2> typename __gnu_cxx::__enable_if<std::__is_char<_CharT2>::__value,\
    \ std::istreambuf_iterator<_CharT> >::__type std::find(std::istreambuf_iterator<_CharT>,\
    \ std::istreambuf_iterator<_CharT>, const _CharT2&)\u2019\n  373 |     find(istreambuf_iterator<_CharT>\
    \ __first,\n      |     ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/streambuf_iterator.h:373:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpebdcjmom.cpp:31:39:\
    \ note:   mismatched types \u2018std::istreambuf_iterator<_CharT>\u2019 and \u2018\
    std::string*\u2019 {aka \u2018std::__cxx11::basic_string<char>*\u2019}\n   31\
    \ |         planet1, std::end(solarSystem)));\n      |                       \
    \      "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1 == \"Jupiter\" && planet2 == \"Neptune\"\
    ) {\n        return (\"Saturn\", \"Uranus\");\n    } else if (planet1 == \"Earth\"\
    \ && planet2 == \"Mercury\") {\n        return (\"Venus\");\n    } else if (planet1\
    \ == \"Mercury\" && planet2 == \"Uranus\") {\n        return (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\");\n    }\n    return std::tuple<std::string,\
    \ >();\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9c2f2hdy.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp9c2f2hdy.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp9c2f2hdy.cpp:18:35: error: invalid\
    \ conversion from \u2018const char*\u2019 to \u2018int\u2019 [-fpermissive]\n\
    \   18 |         return (\"Saturn\", \"Uranus\");\n      |                   \
    \                ^\n      |                                   |\n      |     \
    \                              const char*\n/tmp/tmp9c2f2hdy.cpp:20:24: error:\
    \ invalid conversion from \u2018const char*\u2019 to \u2018int\u2019 [-fpermissive]\n\
    \   20 |         return (\"Venus\");\n      |                        ^\n     \
    \ |                        |\n      |                        const char*\n/tmp/tmp9c2f2hdy.cpp:22:62:\
    \ error: invalid conversion from \u2018const char*\u2019 to \u2018int\u2019 [-fpermissive]\n\
    \   22 |         return (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    );\n      |                                                              ^\n \
    \     |                                                              |\n     \
    \ |                                                              const char*\n\
    /tmp/tmp9c2f2hdy.cpp:24:36: error: template argument 2 is invalid\n   24 |   \
    \  return std::tuple<std::string, >();\n      |                              \
    \      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9c2f2hdy.cpp:2:\n/tmp/tmp9c2f2hdy.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp9c2f2hdy.cpp:28:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   28 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    int n = planet1.size();\n\
    \    int m = planet2.size();\n    std::string str1 = planet1;\n    std::string\
    \ str2 = planet2;\n    if (str1[n-1] == 's' && str2[m-1] == 's') str1.erase(n-1);\n\
    \    if (str1[m-1] == 's' && str2[n-1] == 's') str2.erase(m-1);\n    if (str1[m-1]\
    \ == 's' && str2[m-1] == 's') str1.erase(m-1);\n    if (str1[n-1] == 's' && str2[n-1]\
    \ == 's') str2.erase(n-1);\n    if (str1[m-1] == 's' && str2[n-1] == 's') str2.erase(m-1);\n\
    \    if (str1[n-1] == 's' && str2[m-1] == 's') str1.erase(n-1);\n    if (str1[m-1]\
    \ == 's' && str2[m-1] == 's') str2.erase(m-1);\n    if (str1[n-1] == 's' && str2[m-1]\
    \ == 's') str1.erase(n-1);\n    if (str1[m-1] == 's' && str2[m-1] == 's') str2.erase(m-1);\n\
    \    if (str1[n-1] == 's' && str2[m-1] == 's') str1.erase(n-1);\n    if (str1[m-1]\
    \ == 's' && str2[m-1] == 's') str2.erase(m-1);\n    if (str1[n-1] == 's' && str2[m-1]\
    \ == 's') str1.erase(n-1);\n    if (str1[m-1] == 's' && str2[m-1] == 's') str2.erase(m-1);\n\
    \    if (str1[n-1] == 's' && str2[m-1] == 's') str1.erase(n-1);\n    if (str1[m-1]\
    \ == 's' && str2[m-1] == 's') str2.erase(m-1);\n    if (str1[n-1] == 's' && str2[m-1]\
    \ == 's') str1.erase(n-1);\n    if (str1[m-1] == 's' && str2[m-1] == 's') str2.erase(m-1);\n\
    \    if (str1[n-1] == 's' && str2[m-1] == 's') str1.erase(n-1);\n    if (str1[m-1]\
    \ == 's' && str2[m-1] == 's') str2.erase(m-1);\n    if (str1[n-1] == 's' && str2[m-1]\
    \ == 's') str1.erase(n-1);\n    if (str1[m-1] == 's' && str2[m-1] == 's') str2.erase(m-1);\n\
    \    if (str1[n-1] == 's' && str2[m-1] == 's') str1.erase(n-1);\n    if (str1[m-1]\
    \ == 's' && str2[m-1] == 's') str2.erase(m-1);\n    if (str1[n-1] == 's' && str2[m-1]\
    \ == 's\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx55oh946.cpp:46:42: warning: missing terminating ' character\n\
    \   46 |     if (str1[n-1] == 's' && str2[m-1] == 's\n      |                \
    \                          ^\n/tmp/tmpx55oh946.cpp:46:42: error: missing terminating\
    \ ' character\n   46 |     if (str1[n-1] == 's' && str2[m-1] == 's\n      |  \
    \                                        ^~\n/tmp/tmpx55oh946.cpp:16:25: error:\
    \ template argument 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                         ^\n/tmp/tmpx55oh946.cpp:\
    \ In function \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmpx55oh946.cpp:47:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   47 | }\n \
    \     | ^\n/tmp/tmpx55oh946.cpp:46:41: error: expected \u2018)\u2019 before \u2018\
    }\u2019 token\n   46 |     if (str1[n-1] == 's' && str2[m-1] == 's\n      |  \
    \      ~                                ^\n      |                           \
    \              )\n   47 | }\n      | ~                                       \
    \ \n/tmp/tmpx55oh946.cpp:47:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   47 | }\n      | ^\n/tmp/tmpx55oh946.cpp:47:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx55oh946.cpp:2:\n/tmp/tmpx55oh946.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpx55oh946.cpp:50:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   50 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n   \n   if((planet1 == \"Mercury\") || (planet1 == \"\
    Venus\") || (planet1 == \"Earth\") ||\n       (planet1 == \"Mars\") || (planet1\
    \ == \"Jupiter\") || (planet1 == \"Saturn\") ||\n       (planet1 == \"Uranus\"\
    ) || (planet1 == \"Neptune\") || (planet2 == \"Mercury\") ||\n       (planet2\
    \ == \"Venus\") || (planet2 == \"Earth\") || (planet2 == \"Mars\") ||\n      \
    \ (planet2 == \"Jupiter\") || (planet2 == \"Saturn\") || (planet2 == \"Uranus\"\
    ) ||\n       (planet2 == \"Neptune\")) {\n       std::cout << \"We do not have\
    \ planets\" << planet1 << \" and \" << planet2 << \"!\" << std::endl;\n      \
    \ return std::make_tuple();\n   }\n\n   std::cin >> planet1;\n   std::cin >> planet2;\n\
    \   assert(std::string(planet1).size() == std::string(planet2).size());\n\n  \
    \ // initialize all the planets' coordinates to zero\n   double x = 0, y = 0,\
    \ z = 0; \n\n   // loop over all the planets, checking the distance between them\
    \ and the sun\n   for(size_t i = 0; i < planet1.size(); i++) {\n       // calculate\
    \ the distance between each planet and the sun\n       double distance = std::sqrt(\
    \ (x - planet2[i]) * (x - planet2[i]) + (y - planet2[i]) * (y - planet2[i]) +\
    \ (z - planet2[i]) * (z - planet2[i]));\n       // if the distance between planets\
    \ is less than the sun's distance\n       if(distance < 0.034) {\n           //\
    \ we found a planet that is located on the sun orbit, return it\n           return\
    \ std::make_tuple(planet1, planet2);\n       }\n       // otherwise move on the\
    \ planets one at a time\n       else {\n           // add the distance between\
    \ the planets to the current planet\n           x += planet2[i];\n           y\
    \ += planet2[i];\n           z += planet2[i];\n       }\n   }\n   // if the for\
    \ loop exited before finding all the planets \n   // on the sun orbit we found\
    \ all the planets located on the sun orbit\n   return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp52fgjauv.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp52fgjauv.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp52fgjauv.cpp:25:30: error: cannot\
    \ convert \u2018std::tuple<>\u2019 to \u2018int\u2019 in return\n   25 |     \
    \   return std::make_tuple();\n      |               ~~~~~~~~~~~~~~~^~\n     \
    \ |                              |\n      |                              std::tuple<>\n\
    /tmp/tmp52fgjauv.cpp:42:34: error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\u2019 to \u2018int\u2019 in\
    \ return\n   42 |            return std::make_tuple(planet1, planet2);\n     \
    \ |                   ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |             \
    \                     |\n      |                                  std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmp52fgjauv.cpp:54:26:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   54 |    return\
    \ std::make_tuple(planet1, planet2);\n      |           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                          |\n      |                          std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp52fgjauv.cpp:2:\n/tmp/tmp52fgjauv.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp52fgjauv.cpp:58:48: error: "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > result;\n    std::string\
    \ planet1_orbit = planet1 + planet2;\n    std::string planet2_orbit = planet2\
    \ + planet1;\n    std::string planet3_orbit = planet2 + planet1;\n    \n    if\
    \ (planet1.size() < planet2.size()) {\n        result.emplace_back(planet2);\n\
    \        result.emplace_back(planet1_orbit);\n        result.emplace_back(planet3_orbit);\n\
    \    }\n    else if (planet1.size() > planet2.size()) {\n        result.emplace_back(planet1_orbit);\n\
    \        result.emplace_back(planet2);\n        result.emplace_back(planet3_orbit);\n\
    \    }\n    else {\n        result.emplace_back(planet1_orbit);\n        result.emplace_back(planet2);\n\
    \        result.emplace_back(planet3_orbit);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpskd2rus8.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpskd2rus8.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpskd2rus8.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmpskd2rus8.cpp:23:16: error: request\
    \ for member \u2018emplace_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   23 |         result.emplace_back(planet2);\n      |\
    \                ^~~~~~~~~~~~\n/tmp/tmpskd2rus8.cpp:24:16: error: request for\
    \ member \u2018emplace_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   24 |         result.emplace_back(planet1_orbit);\n\
    \      |                ^~~~~~~~~~~~\n/tmp/tmpskd2rus8.cpp:25:16: error: request\
    \ for member \u2018emplace_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   25 |         result.emplace_back(planet3_orbit);\n\
    \      |                ^~~~~~~~~~~~\n/tmp/tmpskd2rus8.cpp:28:16: error: request\
    \ for member \u2018emplace_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   28 |         result.emplace_back(planet1_orbit);\n\
    \      |                ^~~~~~~~~~~~\n/tmp/tmpskd2rus8.cpp:29:16: error: request\
    \ for member \u2018emplace_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   29 |         result.emplace_back(planet2);\n      |\
    \                ^~~~~~~~~~~~\n/tmp/tmpskd2rus8.cpp:30:16: error: request for\
    \ member \u2018emplace_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   30 |         result.emplace_back(planet3_orbit);\n\
    \      |                ^~~~~~~~~~~~\n/tmp/tmpskd2rus8.cpp:33:16: error: request\
    \ for member \u2018emplace_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   33 |         result.emplace_back(planet1_orbit);\n\
    \      |                ^~~~~~~~~~~~\n/tmp/tmpskd2rus8.cpp:34:16: error: request\
    \ for member \u2018emplace_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   34 |         result.emplace_back(planet2);\n      |\
    \                ^~~~~~~~~~~~\n/tmp/tmpskd2rus8.cpp:35:16: error: reques"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_name;\n    std::string planet2_name;\n\
    \    std::cout << \"Enter name of first planet \\n\";\n    std::cin >> planet1_name;\n\
    \    std::cout << \"Enter name of second planet \\n\";\n    std::cin >> planet2_name;\n\
    \    if (planet1_name == \"Jupiter\" && planet2_name == \"Neptune\")\n    {\n\
    \        std::cout << \"Planets match \" << planet1_name << \" and \" << planet2_name\
    \ << std::endl;\n        std::cout << \"Earth, Mercury, Venus \\n\";\n       \
    \ return std::make_tuple(planet1_name);\n    }\n    else if (planet1_name == \"\
    Earth\" && planet2_name == \"Mercury\")\n    {\n        std::cout << \"Planets\
    \ match \" << planet1_name << \" and \" << planet2_name << std::endl;\n      \
    \  std::cout << \"Mercury, Venus \\n\";\n        return std::make_tuple(planet1_name);\n\
    \    }\n    else if (planet1_name == \"Mercury\" && planet2_name == \"Uranus\"\
    )\n    {\n        std::cout << \"Planets match \" << planet1_name << \" and \"\
    \ << planet2_name << std::endl;\n        std::cout << \"Mercury, Venus \\n\";\n\
    \        return std::make_tuple(planet1_name, planet2_name);\n    }\n    else\
    \ if (planet1_name == \"Venus\" && planet2_name == \"Earth\")\n    {\n       \
    \ std::cout << \"Planets match \" << planet1_name << \" and \" << planet2_name\
    \ << std::endl;\n        std::cout << \"Mercury, Venus \\n\";\n        return\
    \ std::make_tuple(planet1_name, planet2_name);\n    }\n    else if (planet1_name\
    \ == \"Mars\" && planet2_name == \"Jupiter\")\n    {\n        std::cout << \"\
    Planets match \" << planet1_name << \" and \" << planet2_name << std::endl;\n\
    \        std::cout << \"Mercury, Venus \\n\";\n        return std::make_tuple(planet1_name,\
    \ planet2_name);\n    }\n    else if (planet1_name == \"Saturn\" && planet2_name\
    \ == \"Uranus\")\n    {\n        std::cout << \"Planets match \" << planet1_name\
    \ << \" and \" << planet2_name << std::endl;\n        std::cout << \"Mercury,\
    \ Venus \\n\";\n        return std::make_tuple(planet1_name, planet2_name);\n\
    \    }\n    else if (planet1_name == \"Uranus\" && planet2_name == \"Neptune\"\
    )\n    {\n        std::cout << \"Planets match \" << planet1_name << \" and \"\
    \ << planet2_name << std::endl;\n        std::cout << \"Mercury, Venus \\n\";\n\
    \        return std::make_tuple(planet1_name, planet2_name);\n    }\n    else\
    \ if (\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfmni03t_.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpfmni03t_.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpfmni03t_.cpp:27:31: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   27 |       \
    \  return std::make_tuple(planet1_name);\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\n/tmp/tmpfmni03t_.cpp:33:31: error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\u2019 to \u2018int\u2019 in\
    \ return\n   33 |         return std::make_tuple(planet1_name);\n      |     \
    \           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~\n      |                           \
    \    |\n      |                               std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpfmni03t_.cpp:39:31:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   39 |       \
    \  return std::make_tuple(planet1_name, planet2_name);\n      |              \
    \  ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                      \
    \         |\n      |                               std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpfmni03t_.cpp:45:31:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   45 |       \
    \  return std::make_tup"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  if(planet1 == \"Earth\" || planet2 == \"Earth\") return\
    \ std::tuple<std::string, > {};\n  if(planet1 == \"Mercury\" || planet2 == \"\
    Mercury\") return std::tuple<std::string, > {};\n  if(planet1 == \"Venus\" ||\
    \ planet2 == \"Venus\") return std::tuple<std::string, > {};\n  if(planet1 ==\
    \ \"Mars\" || planet2 == \"Mars\") return std::tuple<std::string, > {};\n  if(planet1\
    \ == \"Jupiter\" || planet2 == \"Jupiter\") return std::tuple<std::string, > {};\n\
    \  if(planet1 == \"Saturn\" || planet2 == \"Saturn\") return std::tuple<std::string,\
    \ > {};\n  if(planet1 == \"Uranus\" || planet2 == \"Uranus\") return std::tuple<std::string,\
    \ > {};\n  if(planet1 == \"Neptune\" || planet2 == \"Neptune\") return std::tuple<std::string,\
    \ > {};\n\n  double sun_distance = calcSunDistance(planet1, planet2);\n\n  if(sun_distance\
    \ < 3) return std::tuple<std::string, > {};\n  return std::tuple<std::string,>\
    \ { planet1, planet2 };\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1jnnghew.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp1jnnghew.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp1jnnghew.cpp:17:79: error: template\
    \ argument 2 is invalid\n   17 |   if(planet1 == \"Earth\" || planet2 == \"Earth\"\
    ) return std::tuple<std::string, > {};\n      |                              \
    \                                                 ^\n/tmp/tmp1jnnghew.cpp:18:83:\
    \ error: template argument 2 is invalid\n   18 |   if(planet1 == \"Mercury\" ||\
    \ planet2 == \"Mercury\") return std::tuple<std::string, > {};\n      |      \
    \                                                                            \
    \ ^\n/tmp/tmp1jnnghew.cpp:19:79: error: template argument 2 is invalid\n   19\
    \ |   if(planet1 == \"Venus\" || planet2 == \"Venus\") return std::tuple<std::string,\
    \ > {};\n      |                                                             \
    \                  ^\n/tmp/tmp1jnnghew.cpp:20:77: error: template argument 2 is\
    \ invalid\n   20 |   if(planet1 == \"Mars\" || planet2 == \"Mars\") return std::tuple<std::string,\
    \ > {};\n      |                                                             \
    \                ^\n/tmp/tmp1jnnghew.cpp:21:83: error: template argument 2 is\
    \ invalid\n   21 |   if(planet1 == \"Jupiter\" || planet2 == \"Jupiter\") return\
    \ std::tuple<std::string, > {};\n      |                                     \
    \                                              ^\n/tmp/tmp1jnnghew.cpp:22:81:\
    \ error: template argument 2 is invalid\n   22 |   if(planet1 == \"Saturn\" ||\
    \ planet2 == \"Saturn\") return std::tuple<std::string, > {};\n      |       \
    \                                                                          ^\n\
    /tmp/tmp1jnnghew.cpp:23:81: error: template argument 2 is invalid\n   23 |   if(planet1\
    \ == \"Uranus\" || planet2 == \"Uranus\") return std::tuple<std::string, > {};\n\
    \      |                                                                     \
    \            ^\n/tmp/tmp1jnnghew.cpp:24:83: error: template argument 2 "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" ||\
    \ planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2\
    \ == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 ==\
    \ \"Uranus\" || planet2 == \"Neptune\");\n    std::tuple<std::string, > ret;\n\
    \    if (planet1 == planet2) {\n        ret.emplace(planet1);\n        return\
    \ ret;\n    }\n    else if (planet1 == \"Jupiter\") {\n        if (planet2 ==\
    \ \"Mercury\") {\n            ret.emplace(planet1);\n            return ret;\n\
    \        }\n    }\n    else if (planet1 == \"Venus\") {\n        if (planet2 ==\
    \ \"Mercury\") {\n            ret.emplace(planet1);\n            return ret;\n\
    \        }\n        if (planet2 == \"Earth\") {\n            ret.emplace(planet1);\n\
    \            return ret;\n        }\n    }\n    else if (planet1 == \"Earth\"\
    ) {\n        if (planet2 == \"Mercury\") {\n            ret.emplace(planet1);\n\
    \            return ret;\n        }\n        if (planet2 == \"Venus\") {\n   \
    \         ret.emplace(planet1);\n            return ret;\n        }\n    }\n \
    \   else if (planet1 == \"Mars\") {\n        if (planet2 == \"Jupiter\") {\n \
    \           ret.emplace(planet1);\n            return ret;\n        }\n      \
    \  if (planet2 == \"Venus\") {\n            ret.emplace(planet1);\n          \
    \  return ret;\n        }\n    }\n    else if (planet1 == \"Saturn\") {\n    \
    \    if (planet2 == \"Jupiter\") {\n            ret.emplace(planet1);\n      \
    \      return ret;\n        }\n        if (planet2 == \"Venus\") {\n         \
    \   ret.emplace(planet1);\n            return ret;\n        }\n        if (planet2\
    \ == \"Earth\") {\n            ret.emplace(planet1);\n            return ret;\n\
    \        }\n    }\n    else if (planet1 == \"Uranus\") {\n        if (planet2\
    \ == \"Jupiter\") {\n            ret.emplace(planet1);\n            return ret;\n\
    \        }\n        if (planet2 == \"Venus\") {\n            ret.emplace(planet1);\n\
    \            return ret;\n        }\n        if (planet2 == \"Earth\") {\n   \
    \         ret.emplace(planet1);\n}\nint main() {\n    auto candidate = bf;\n \
    \   assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp9mvcdn1p.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp9mvcdn1p.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp9mvcdn1p.cpp:18:29: error: template\
    \ argument 2 is invalid\n   18 |     std::tuple<std::string, > ret;\n      | \
    \                            ^\n/tmp/tmp9mvcdn1p.cpp:20:13: error: request for\
    \ member \u2018emplace\u2019 in \u2018ret\u2019, which is of non-class type \u2018\
    int\u2019\n   20 |         ret.emplace(planet1);\n      |             ^~~~~~~\n\
    /tmp/tmp9mvcdn1p.cpp:25:17: error: request for member \u2018emplace\u2019 in \u2018\
    ret\u2019, which is of non-class type \u2018int\u2019\n   25 |             ret.emplace(planet1);\n\
    \      |                 ^~~~~~~\n/tmp/tmp9mvcdn1p.cpp:31:17: error: request for\
    \ member \u2018emplace\u2019 in \u2018ret\u2019, which is of non-class type \u2018\
    int\u2019\n   31 |             ret.emplace(planet1);\n      |                \
    \ ^~~~~~~\n/tmp/tmp9mvcdn1p.cpp:35:17: error: request for member \u2018emplace\u2019\
    \ in \u2018ret\u2019, which is of non-class type \u2018int\u2019\n   35 |    \
    \         ret.emplace(planet1);\n      |                 ^~~~~~~\n/tmp/tmp9mvcdn1p.cpp:41:17:\
    \ error: request for member \u2018emplace\u2019 in \u2018ret\u2019, which is of\
    \ non-class type \u2018int\u2019\n   41 |             ret.emplace(planet1);\n\
    \      |                 ^~~~~~~\n/tmp/tmp9mvcdn1p.cpp:45:17: error: request for\
    \ member \u2018emplace\u2019 in \u2018ret\u2019, which is of non-class type \u2018\
    int\u2019\n   45 |             ret.emplace(planet1);\n      |                \
    \ ^~~~~~~\n/tmp/tmp9mvcdn1p.cpp:51:17: error: request for member \u2018emplace\u2019\
    \ in \u2018ret\u2019, which is of non-class type \u2018int\u2019\n   51 |    \
    \         ret.emplace(planet1);\n      |                 ^~~~~~~\n/tmp/tmp9mvcdn1p.cpp:55:17:\
    \ error: request for member \u2018emplace\u2019 in \u2018ret\u2019, which is of\
    \ non-class type \u2018int\u2019\n   55 |             ret.emplace(planet1);\n\
    \      |                 ^~~~~~~\n/tmp/tmp9mvcdn1p.cpp:61:17: error: request for\
    \ member \u2018emplace\u2019 in \u2018ret\u2019, which is of non-class type \u2018\
    int\u2019\n   61 |             ret.emplace(planet1);\n      |                \
    \ ^~~~~~~\n/tmp/tmp9mvcdn1p.cpp:65:17: e"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\"\n            || planet1 == \"Mars\" || planet1 == \"\
    Jupiter\" || planet1 == \"Saturn\"\n            || planet1 == \"Uranus\" || planet1\
    \ == \"Neptune\");\n    assert(planet2 == \"Mercury\" || planet2 == \"Venus\"\
    \ || planet2 == \"Earth\"\n            || planet2 == \"Mars\" || planet2 == \"\
    Jupiter\" || planet2 == \"Saturn\"\n            || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\");\n    int planet1_orbital_time = 36525 / planet1.size();\n \
    \   int planet2_orbital_time = 7375 / planet2.size();\n    std::string planet1_orbit_str\
    \ = planet1 + \"O\";\n    std::string planet2_orbit_str = planet2 + \"O\";\n \
    \   // Find how many orbits of planet1 are between planet2 orbits. \n    int num_orbit_inbetween\
    \ = \n        std::count_if(planet1_orbit_str.begin(), planet1_orbit_str.end(),\
    \ \n        [planet2](const char c) { \n            char planet2_orbit_str[2]\
    \ = {planet2[0], c}; \n            int res = std::count_if(planet2_orbit_str,\
    \ planet2_orbit_str + 2, \n                [planet1](const char c) { \n      \
    \              char planet1_orbit_str[2] = {planet1[0], c}; \n               \
    \     int res = std::count_if(planet1_orbit_str, planet1_orbit_str + 2, \n   \
    \                     [](char c) { return (c == 0 || c == 'O'); });\n        \
    \            return res == 0;\n                });\n            return res ==\
    \ 0;\n        });\n    std::string planet1_orbit_str_rev = planet1_orbit_str +\
    \ '0';\n    std::string planet2_orbit_str_rev = planet2_orbit_str + '0';\n   \
    \ if (num_orbit_inbetween != 0) return std::tuple<>();\n    // Find how many orbits\
    \ of planet2 are between planet1 orbits. \n    int num_orbit_between = std::count_if(planet2_orbit_str_rev.begin(),\
    \ \n        planet2_orbit_str_rev.end(), \n        [planet1](const char c) { \n\
    \            char planet1_orbit_str[2] = {planet1[0], c}; \n            int res\
    \ = std::count_if(planet1_orbit_str, planet1_orbit_str\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpk7gur50m.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpk7gur50m.cpp: In lambda function:\n\
    /tmp/tmpk7gur50m.cpp:33:18: error: \u2018planet1\u2019 is not captured\n   33\
    \ |                 [planet1](const char c) {\n      |                  ^~~~~~~\n\
    /tmp/tmpk7gur50m.cpp:30:17: note: the lambda has no capture-default\n   30 | \
    \        [planet2](const char c) {\n      |                 ^\n/tmp/tmpk7gur50m.cpp:16:42:\
    \ note: \u2018std::string planet1\u2019 declared here\n   16 | std::tuple<std::string,\
    \ > bf(std::string planet1, std::string planet2) {\n      |                  \
    \            ~~~~~~~~~~~~^~~~~~~\n/tmp/tmpk7gur50m.cpp: In lambda function:\n\
    /tmp/tmpk7gur50m.cpp:34:50: error: \u2018planet1\u2019 is not captured\n   34\
    \ |                     char planet1_orbit_str[2] = {planet1[0], c};\n      |\
    \                                                  ^~~~~~~\n/tmp/tmpk7gur50m.cpp:33:25:\
    \ note: the lambda has no capture-default\n   33 |                 [planet1](const\
    \ char c) {\n      |                         ^\n/tmp/tmpk7gur50m.cpp:16:42: note:\
    \ \u2018std::string planet1\u2019 declared here\n   16 | std::tuple<std::string,\
    \ > bf(std::string planet1, std::string planet2) {\n      |                  \
    \            ~~~~~~~~~~~~^~~~~~~\n/tmp/tmpk7gur50m.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpk7gur50m.cpp:43:47: error: cannot\
    \ convert \u2018std::tuple<>\u2019 to \u2018int\u2019 in return\n   43 |     if\
    \ (num_orbit_inbetween != 0) return std::tuple<>();\n      |                 \
    \                              ^~~~~~~~~\n      |                            \
    \                   |\n      |                                               std::tuple<>\n\
    /tmp/tmpk7gur50m.cpp: In lambda function:\n/tmp/tmpk7gur50m.cpp:49:73: error:\
    \ expected \u2018)\u2019 before \u2018}\u2019 token\n   49 |             int res\
    \ = std::count_if(planet1_orbit_str, planet1_orbit_str\n      |              \
    \                      ~                                    ^\n      |       \
    \                                              "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n\tstd::tuple<std::string, > result;\n\tdouble d = acos(cos(2\
    \ * M_PI * (planet1.size() + planet2.size()) / 2));\n\tauto orbit1 = (planet1.size()\
    \ + planet2.size()) / 2 * M_PI * d / 2;\n\tauto orbit2 = (planet1.size() + planet2.size())\
    \ / 2 * M_PI * d;\n\tstd::cout << planet1 << \" \" << orbit1 << \" \" << planet2\
    \ << \" \" << orbit2 << std::endl;\n\tif (planet1 == planet2 && orbit1 < orbit2)\
    \ {\n\t\tresult.emplace_back(planet1);\n\t\tresult.emplace_back(planet2);\n\t\
    } else {\n\t\tresult.emplace_back(planet1);\n\t\tresult.emplace_back(planet2);\n\
    \t}\n\treturn result;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4y4e2vzo.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp4y4e2vzo.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp4y4e2vzo.cpp:17:26: error: template\
    \ argument 2 is invalid\n   17 |  std::tuple<std::string, > result;\n      | \
    \                         ^\n/tmp/tmp4y4e2vzo.cpp:23:10: error: request for member\
    \ \u2018emplace_back\u2019 in \u2018result\u2019, which is of non-class type \u2018\
    int\u2019\n   23 |   result.emplace_back(planet1);\n      |          ^~~~~~~~~~~~\n\
    /tmp/tmp4y4e2vzo.cpp:24:10: error: request for member \u2018emplace_back\u2019\
    \ in \u2018result\u2019, which is of non-class type \u2018int\u2019\n   24 | \
    \  result.emplace_back(planet2);\n      |          ^~~~~~~~~~~~\n/tmp/tmp4y4e2vzo.cpp:26:10:\
    \ error: request for member \u2018emplace_back\u2019 in \u2018result\u2019, which\
    \ is of non-class type \u2018int\u2019\n   26 |   result.emplace_back(planet1);\n\
    \      |          ^~~~~~~~~~~~\n/tmp/tmp4y4e2vzo.cpp:27:10: error: request for\
    \ member \u2018emplace_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   27 |   result.emplace_back(planet2);\n      |     \
    \     ^~~~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4y4e2vzo.cpp:2:\n/tmp/tmp4y4e2vzo.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp4y4e2vzo.cpp:33:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   33 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/ce"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > orbits;\n    assert(planet1\
    \ != \"Mercury\" && planet1 != \"Venus\" && planet1 != \"Earth\" &&\n    planet1\
    \ != \"Mars\" && planet1 != \"Jupiter\" && planet1 != \"Saturn\" &&\n    planet1\
    \ != \"Uranus\" && planet1 != \"Neptune\" && planet2 != \"Mercury\" &&\n    planet2\
    \ != \"Venus\" && planet2 != \"Earth\" && planet2 != \"Mars\" &&\n    planet2\
    \ != \"Jupiter\" && planet2 != \"Saturn\" && planet2 != \"Uranus\" &&\n    planet2\
    \ != \"Neptune\");\n    assert(planet2 != \"Mercury\" && planet2 != \"Venus\"\
    \ && planet2 != \"Earth\" &&\n    planet2 != \"Mars\" && planet2 != \"Jupiter\"\
    \ && planet2 != \"Saturn\" &&\n    planet2 != \"Uranus\" && planet2 != \"Neptune\"\
    );\n    // Define two points for the planets being searched for.\n    double a1\
    \ = 1.32e7;\n    double b1 = 4.67e8;\n    double a2 = 5.97e7;\n    double b2 =\
    \ 1.05e6;\n    // Define a point on the plane defined by the line defined by points\
    \ a1 and b1.\n    double p1 = (b1 - a1) * (b2 - a2) / (b1 + a1);\n    double p2\
    \ = (b1 - a1) * (b2 + a2) / (b1 + a1);\n    // The distance between the two points\
    \ is sqrt( (x1-x2)^2 + (y1-y2)^2 ).\n    double distance2 = std::sqrt( (p1 - a1)*(p1\
    \ - a1) + (p2 - a2)*(p2 - a2) );\n    double distance1 = std::sqrt( (a1 - p1)*(a1\
    \ - p1) + (b1 - a1)*(b1 - a1) );\n    // The two points can be easily translated\
    \ to cartesian coordinates using the \n    // formulae y = mx + b and m = a1-x1\
    \ and b = a2-x2.\n    double x1 = (a1 - p1) / distance1;\n    double x2 = (a2\
    \ - p2) / distance2;\n    double y1 = (b1 - a1) / (distance1 - distance2);\n \
    \   double y2 = (b2 - a2) / (distance2 - distance1);\n    // The angle between\
    \ the two points is atan2(y2-y1,x2-x1)\n    double angle = std::atan2(y2 - y1,\
    \ x2 - x1);\n    double cosAngle = std::cos(angle);\n\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpls61553u.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpls61553u.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpls61553u.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > orbits;\n     \
    \ |                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpls61553u.cpp:2:\n/tmp/tmpls61553u.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpls61553u.cpp:51:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   51 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpls61553u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skyla"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> planets1;\n  std::vector<std::string>\
    \ planets2;\n  planets1.push_back(planet1);\n  planets2.push_back(planet2);\n\
    \  \n  int m = planets1.size();\n  int n = planets2.size();\n  \n  if (m > 0 &&\
    \ n > 0) {\n    if (planets1[m-1] == planets2[n-1]) {\n      int k = m - 1;\n\
    \      int i = n - 1;\n      int j = 0;\n      while (k < m) {\n        while\
    \ (j < n) {\n          if (planets1[k] == planets2[j]) {\n            i++;\n \
    \           j++;\n          }\n          else {\n            j++;\n          }\n\
    \          k++;\n        }\n        k++;\n      }\n      \n      std::tuple<std::string,\
    \ > result;\n      if (i == 0) {\n        result.push_back(planets2[0]);\n   \
    \   }\n      if (i == m) {\n        result.push_back(planets1[0]);\n      }\n\
    \      if (j == 0) {\n        result.push_back(planets1[0]);\n      }\n      if\
    \ (j == n) {\n        result.push_back(planets2[0]);\n      }\n      \n      return\
    \ result;\n    }\n    else if (planets1[m-1] < planets2[n-1]) {\n      int k =\
    \ m - 1;\n      int i = n - 1;\n      int j = 0;\n      while (k < m) {\n    \
    \    while (j < n) {\n          if (planets1[k] == planets2[j]) {\n          \
    \  i++;\n            j++;\n          }\n          else {\n            j++;\n \
    \         }\n          k++;\n        }\n        k++;\n      }\n      \n      std::tuple<std::string,\
    \ > result;\n      if (i == 0) {\n        result.push_back(planets2[0]);\n   \
    \   }\n      if (i == m) {\n        result.push_back(planets1[0]);\n      }\n\
    \      if (j == 0) {\n        result.push_back(planets1[0]);\n      }\n      if\
    \ (j == n) {\n        result.push_back(planets2[0]);\n      }\n      \n      return\
    \ result;\n    }\n    else if (planets1[m-1] > planets2[n-1]) {\n      int k =\
    \ m - 1;\n      int i = n - 1;\n      int j = 0;\n      while (k < m) {\n    \
    \    while (j < n) {\n          if (planets1[k] == planets2[j]) {\n          \
    \  i++;\n            j++;\n          }\n          else {\n            j++;\n \
    \         }\n          k++;\n        }\n        k++;\n      }\n      \n      std::tuple<std::string,\
    \ > result;\n      if (i == 0) {\n        result.push_back(planets1[0]);\n   \
    \   }\n      if (i == m) {\n        result.push_back(planets2[0]);\n      }\n\
    \      if (j == 0) {\n        result.push_back(planets2[0]);\n      }\n      if\
    \ (j == n) {\n        result.push_back(planets1[0]);\n      }\n      \n      return\
    \ result;\n    }\n  }\n  \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc9fvui4n.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpc9fvui4n.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpc9fvui4n.cpp:44:31: error: template\
    \ argument 2 is invalid\n   44 |       std::tuple<std::string, > result;\n   \
    \   |                               ^\n/tmp/tmpc9fvui4n.cpp:46:16: error: request\
    \ for member \u2018push_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   46 |         result.push_back(planets2[0]);\n     \
    \ |                ^~~~~~~~~\n/tmp/tmpc9fvui4n.cpp:49:16: error: request for member\
    \ \u2018push_back\u2019 in \u2018result\u2019, which is of non-class type \u2018\
    int\u2019\n   49 |         result.push_back(planets1[0]);\n      |           \
    \     ^~~~~~~~~\n/tmp/tmpc9fvui4n.cpp:52:16: error: request for member \u2018\
    push_back\u2019 in \u2018result\u2019, which is of non-class type \u2018int\u2019\
    \n   52 |         result.push_back(planets1[0]);\n      |                ^~~~~~~~~\n\
    /tmp/tmpc9fvui4n.cpp:55:16: error: request for member \u2018push_back\u2019 in\
    \ \u2018result\u2019, which is of non-class type \u2018int\u2019\n   55 |    \
    \     result.push_back(planets2[0]);\n      |                ^~~~~~~~~\n/tmp/tmpc9fvui4n.cpp:78:31:\
    \ error: template argument 2 is invalid\n   78 |       std::tuple<std::string,\
    \ > result;\n      |                               ^\n/tmp/tmpc9fvui4n.cpp:80:16:\
    \ error: request for member \u2018push_back\u2019 in \u2018result\u2019, which\
    \ is of non-class type \u2018int\u2019\n   80 |         result.push_back(planets2[0]);\n\
    \      |                ^~~~~~~~~\n/tmp/tmpc9fvui4n.cpp:83:16: error: request\
    \ for member \u2018push_back\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   83 |         result.push_back(planets1[0]);\n     \
    \ |                ^~~~~~~~~\n/tmp/tmpc9fvui4n.cpp:86:16: error: request for member\
    \ \u2018push_back\u2019 in \u2018result\u2019, which is of non-class type \u2018\
    int\u2019\n   86 |         result.push_back(planets1[0]);\n      |           \
    \     ^~~~~~~~~\n/tmp/tmpc9fvui4n.cpp:89:16: error: request for member \u2018\
    push_back\u2019 in \u2018result\u2019, which is of non-class type \u2018int\u2019\
    \n   89 |         result.push_back("
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n     if (planet1 == \"Mercury\" && planet2 == \"Venus\"\
    ) return std::tuple<std::string, > {\"Venus\"};\n     if (planet1 == \"Venus\"\
    \ && planet2 == \"Earth\") return std::tuple<std::string, > {\"Earth\"};\n   \
    \  if (planet1 == \"Venus\" && planet2 == \"Mercury\") return std::tuple<std::string,\
    \ > {\"Venus\"};\n     if (planet1 == \"Earth\" && planet2 == \"Mars\") return\
    \ std::tuple<std::string, > {\"Mars\"};\n     if (planet1 == \"Mars\" && planet2\
    \ == \"Jupiter\") return std::tuple<std::string, > {\"Jupiter\"};\n     if (planet1\
    \ == \"Jupiter\" && planet2 == \"Saturn\") return std::tuple<std::string, > {\"\
    Saturn\"};\n     if (planet1 == \"Saturn\" && planet2 == \"Uranus\") return std::tuple<std::string,\
    \ > {\"Uranus\"};\n     if (planet1 == \"Uranus\" && planet2 == \"Neptune\") return\
    \ std::tuple<std::string, > {\"Neptune\"};\n     return std::tuple<std::string,\
    \ > {};\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt52ue7gb.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpt52ue7gb.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpt52ue7gb.cpp:17:85: error: template\
    \ argument 2 is invalid\n   17 |      if (planet1 == \"Mercury\" && planet2 ==\
    \ \"Venus\") return std::tuple<std::string, > {\"Venus\"};\n      |          \
    \                                                                           ^\n\
    /tmp/tmpt52ue7gb.cpp:18:83: error: template argument 2 is invalid\n   18 |   \
    \   if (planet1 == \"Venus\" && planet2 == \"Earth\") return std::tuple<std::string,\
    \ > {\"Earth\"};\n      |                                                    \
    \                               ^\n/tmp/tmpt52ue7gb.cpp:19:85: error: template\
    \ argument 2 is invalid\n   19 |      if (planet1 == \"Venus\" && planet2 == \"\
    Mercury\") return std::tuple<std::string, > {\"Venus\"};\n      |            \
    \                                                                         ^\n\
    /tmp/tmpt52ue7gb.cpp:20:82: error: template argument 2 is invalid\n   20 |   \
    \   if (planet1 == \"Earth\" && planet2 == \"Mars\") return std::tuple<std::string,\
    \ > {\"Mars\"};\n      |                                                     \
    \                             ^\n/tmp/tmpt52ue7gb.cpp:21:84: error: template argument\
    \ 2 is invalid\n   21 |      if (planet1 == \"Mars\" && planet2 == \"Jupiter\"\
    ) return std::tuple<std::string, > {\"Jupiter\"};\n      |                   \
    \                                                                 ^\n/tmp/tmpt52ue7gb.cpp:22:86:\
    \ error: template argument 2 is invalid\n   22 |      if (planet1 == \"Jupiter\"\
    \ && planet2 == \"Saturn\") return std::tuple<std::string, > {\"Saturn\"};\n \
    \     |                                                                      \
    \                ^\n/tmp/tmpt52ue7gb.cpp:23:85: error: template argument 2 is\
    \ invalid\n   23 |      if (planet1 == \"Saturn\" && planet2 == \"Uranus\") return\
    \ std::tuple<std::string, > {\"Uranus\"};\n      |                           \
    \         "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    using std::cout;\n    using std::endl;\n    using\
    \ std::cin;\n    using std::tuple;\n    using std::get;\n    using std::tuple_element;\n\
    \    using std::get<0>;\n    using std::sort;\n    using std::pair;\n    using\
    \ std::pair<string, int>;\n    using std::get<1>;\n    using std::swap;\n    auto\
    \ a = make_pair(planet1, 1);\n    auto b = make_pair(planet2, -1);\n    auto planet1_and_planet2\
    \ = tuples::make_tuple(a, b);\n    // sort the planets\n    sort(planet1_and_planet2.begin(),\
    \ planet1_and_planet2.end(), \n        [](const pair<string, int>& a, const pair<string,\
    \ int>& b) {\n            if (a.first == b.first) {\n                return a.second\
    \ < b.second;\n            }\n            return a.first < b.first;\n    });\n\
    \    // loop through sorted pairs to find pairs whose first element is not equal\n\
    \    // to the second element of the pair.\n    auto it = planet1_and_planet2.begin();\n\
    \    for (; it != planet1_and_planet2.end(); ++it) {\n        if (it->first !=\
    \ it->second) {\n            // copy the pair with one element less to the output\
    \ tuple and swap\n            // the second element of the pair.\n           \
    \ auto t = it;\n            ++t;\n            auto b = t;\n            swap(b->second,\
    \ b->first);\n            // break the loop as it is already sorted.\n       \
    \     break;\n        }\n    }\n    return planet1_and_planet2;\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnt69xxu3.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpnt69xxu3.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpnt69xxu3.cpp:23:16: error: a template-id\
    \ may not appear in a using-declaration\n   23 |     using std::get<0>;\n    \
    \  |                ^~~~~~\n/tmp/tmpnt69xxu3.cpp:26:21: error: \u2018string\u2019\
    \ was not declared in this scope; did you mean \u2018std::string\u2019?\n   26\
    \ |     using std::pair<string, int>;\n      |                     ^~~~~~\n  \
    \    |                     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnt69xxu3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpnt69xxu3.cpp:26:32:\
    \ error: template argument 1 is invalid\n   26 |     using std::pair<string, int>;\n\
    \      |                                ^\n/tmp/tmpnt69xxu3.cpp:27:16: error:\
    \ a template-id may not appear in a using-declaration\n   27 |     using std::get<1>;\n\
    \      |                ^~~~~~\n/tmp/tmpnt69xxu3.cpp:31:32: error: \u2018tuples\u2019\
    \ has not been declared\n   31 |     auto planet1_and_planet2 = tuples::make_tuple(a,\
    \ b);\n      |                                ^~~~~~\n/tmp/tmpnt69xxu3.cpp: In\
    \ lambda function:\n/tmp/tmpnt69xxu3.cpp:35:19: error: re"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::tuple<std::string, > result;\n  assert(std::cin.good());\n\
    \  std::cin>>planet1;\n  std::cin>>planet2;\n  std::cin.ignore(100, '\\n');\n\
    \  if(planet1 == \"Mercury\") {\n    if(planet2 == \"Neptune\") {\n      result\
    \  = std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\",\
    \ \"Uranus\", \"Neptune\");\n    } else {\n      result = std::make_tuple(\"Venus\"\
    , \"Mercury\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n\
    \    }\n  } else if(planet1 == \"Earth\") {\n    if(planet2 == \"Mars\") {\n \
    \     result = std::make_tuple(\"Mercury\", \"Venus\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\");\n    } else {\n      result = std::make_tuple(\"Mercury\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n  \
    \  }\n  } else if(planet1 == \"Mars\") {\n    if(planet2 == \"Jupiter\") {\n \
    \     result = std::make_tuple(\"Mercury\", \"Venus\", \"Earth\", \"Saturn\",\
    \ \"Uranus\", \"Neptune\");\n    } else {\n      result = std::make_tuple(\"Mercury\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n    }\n  } else\
    \ if(planet1 == \"Jupiter\") {\n    if(planet2 == \"Saturn\") {\n      result\
    \ = std::make_tuple(\"Mercury\", \"Venus\", \"Mars\", \"Earth\", \"Uranus\", \"\
    Neptune\");\n    } else {\n      result = std::make_tuple(\"Mercury\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n    }\n  } else if(planet1\
    \ == \"Saturn\") {\n    if(planet2 == \"Uranus\") {\n      result = std::make_tuple(\"\
    Mercury\", \"Venus\", \"Mars\", \"Jupiter\", \"Earth\", \"Neptune\");\n    } else\
    \ {\n      result = std::make_tuple(\"Mercury\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\");\n    }\n  } else if(planet1 == \"Uranus\") {\n   \
    \ if(planet2 == \"Neptune\") {\n      result = std::make_tuple(\"Mercury\", \"\
    Venus\", \"Mars\", \"Jupiter\", \"Saturn\", \"Neptune\");\n    } else {\n    \
    \  result = std::make_tuple(\"Mercury\", \"Mars\", \"J\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpl0uypqmz.cpp:56:51: warning: missing terminating \" character\n\
    \   56 |       result = std::make_tuple(\"Mercury\", \"Mars\", \"J\n      |  \
    \                                                 ^\n/tmp/tmpl0uypqmz.cpp:56:51:\
    \ error: missing terminating \" character\n   56 |       result = std::make_tuple(\"\
    Mercury\", \"Mars\", \"J\n      |                                            \
    \       ^~\n/tmp/tmpl0uypqmz.cpp:16:25: error: template argument 2 is invalid\n\
    \   16 | std::tuple<std::string, > bf(std::string planet1, std::string planet2)\
    \ {\n      |                         ^\n/tmp/tmpl0uypqmz.cpp: In function \u2018\
    int bf(std::string, std::string)\u2019:\n/tmp/tmpl0uypqmz.cpp:17:27: error: template\
    \ argument 2 is invalid\n   17 |   std::tuple<std::string, > result;\n      |\
    \                           ^\n/tmp/tmpl0uypqmz.cpp:24:32: error: cannot convert\
    \ \u2018std::tuple<const char*, const char*, const char*, const char*, const char*,\
    \ const char*, const char*>\u2019 to \u2018int\u2019 in assignment\n   24 |  \
    \     result  = std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\");\n      |                 ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                |\n      |                           \
    \     std::tuple<const char*, const char*, const char*, const char*, const char*,\
    \ const char*, const char*>\n/tmp/tmpl0uypqmz.cpp:26:31: error: cannot convert\
    \ \u2018std::tuple<const char*, const char*, const char*, const char*, const char*,\
    \ const char*, const char*>\u2019 to \u2018int\u2019 in assignment\n   26 |  \
    \     result = std::make_tuple(\"Venus\", \"Mercury\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\", \"Neptune\");\n      |                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                               |\n      |                            \
    \   std::tuple<const char*, const char*, const char*, const char*, const char*,\
    \ const char*, const char*>\n/tmp/tmpl0uypqmz.cpp:30:31: error: cannot convert\
    \ \u2018std::tuple<const char*, const char*, const char*, const char*, const "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > answer;\n    // Your code\
    \ here\n    return 0;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe245ij2g.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpe245ij2g.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpe245ij2g.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > answer;\n     \
    \ |                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe245ij2g.cpp:2:\n/tmp/tmpe245ij2g.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpe245ij2g.cpp:23:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   23 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpe245ij2g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skyla"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // assert(planet1 == \"Mercury\" || planet1 == \"\
    Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\"\
    \ || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    );\n    // assert(planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\");\n    \n    std::map<std::string,\
    \ double> M;\n    std::map<std::string, double> D;\n    \n    std::map<std::string,\
    \ double> M2;\n    std::map<std::string, double> D2;\n    \n    // We take all\
    \ planets and their distances to Mercury, Venus, \n    // Earth and Mars in the\
    \ order of ascending distance from the sun\n    // as M \n    M[\"Mercury\"] =\
    \ 5.974;\n    M[\"Venus\"] = 8.343;\n    M[\"Earth\"] = 11.389;\n    M[\"Mars\"\
    ]  = 7.851;\n    M[\"Jupiter\"]  = 21.348;\n    M[\"Saturn\"]  = 24.338;\n   \
    \ M[\"Uranus\"]  = 29.733;\n    M[\"Neptune\"]  = 34.333;\n    \n    // And for\
    \ Mercury and Venus, the distances to each planet in \n    // the order of ascending\
    \ distance\n    D[\"Mercury\"] = 1.306;\n    D[\"Venus\"] = 0.978;\n    \n   \
    \ // And for Earth and Mars, the same distances as Mercury and Venus\n    D[\"\
    Earth\"] = 1.306;\n    D[\"Mars\"] = 0.978;\n    \n    // And for Jupiter and\
    \ Saturn, distances to each planet \n    // in the order of ascending distance\n\
    \    D[\"Jupiter\"] = 1.306;\n    D[\"Saturn\"] = 0.978;\n    \n    // And for\
    \ Uranus and Neptune, distances to each planet \n    // in the order of ascending\
    \ distance\n    D[\"Uranus\"] = 1.306;\n    D[\"Neptune\"] = 0.978;\n    \n  \
    \  // Now for Mercury and Venus, the distances to each planet \n    // will be\
    \ the same as the distances to Mercury and Venus in \n    // Mercury and Venus\
    \ order\n    M2[\"Mercury\"] = 1.306;\n    M2[\"Venus\"] = 1.306;\n    \n    //\
    \ \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbllksjso.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpbllksjso.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpbllksjso.cpp:64:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   64 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbllksjso.cpp:2:\n/tmp/tmpbllksjso.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpbllksjso.cpp:67:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   67 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpbllksjso.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    struct planet {\n        std::string name;\n   \
    \     double distance;\n        double orbit;\n        double omega;\n    } earth\
    \ = {{\"Earth\", 0, 4 * M_PI, M_PI},\n               {\"Mercury\", 4 * M_PI, 2\
    \ * M_PI, 0},\n               {\"Venus\", 2 * M_PI, 1 * M_PI, 0},\n          \
    \     {\"Earth\", 1 * M_PI, 2 * M_PI, M_PI},\n               {\"Mars\", 2 * M_PI,\
    \ 1 * M_PI, 0},\n               {\"Jupiter\", 1 * M_PI, 1 * M_PI, 0},\n      \
    \         {\"Saturn\", 1 * M_PI, 0.5 * M_PI, 0},\n               {\"Uranus\",\
    \ 0.5 * M_PI, 0.5 * M_PI, M_PI},\n               {\"Neptune\", 0.5 * M_PI, 0.5\
    \ * M_PI, 0}};\n\n    auto p1 = std::find_if(earth.begin(), earth.end(), [&](const\
    \ planet& p) {\n        return p.name == planet1;\n    });\n    if (p1 == earth.end())\
    \ {\n        return std::tuple<std::string,>();\n    }\n    auto p2 = std::find_if(earth.begin(),\
    \ earth.end(), [&](const planet& p) {\n        return p.name == planet2;\n   \
    \ });\n    if (p2 == earth.end()) {\n        return std::tuple<std::string,>();\n\
    \    }\n    auto s0 = p1 - earth;\n    auto s1 = p2 - earth;\n    // Distance\
    \ between Earth and Earth\n    const double d0 = p1 - p2;\n    // Distance between\
    \ Earth and Mercury\n    const double d1 = p2 - p1;\n    // Distance between Mercury\
    \ and Venus\n    const double d2 = p1 - p0;\n    // Distance between Mercury and\
    \ Mercury\n    const double d3 = p1 - p0;\n\n    double x = s0.distance;\n   \
    \ double y = s1.distance;\n    double z = d0;\n    double w = d1;\n    double\
    \ p = s0.orbit;\n    double q = s1.orbit;\n    double r = d2;\n    double s =\
    \ d3;\n    double vx = p * q - r * s;\n    double vy = r * s - p * q;\n\n    auto\
    \ f = std::make_tuple(s0.name, p1, s0.distance,\n                            \
    \ s0.omega, s1.name, p2, s1.distance,\n                             s1.omega,\
    \ d0, d1, d2, d3, vx, vy);\n    return f;\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_2eb0jqz.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp_2eb0jqz.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp_2eb0jqz.cpp:30:54: error: too\
    \ many initializers for \u2018bf(std::string, std::string)::planet\u2019\n   30\
    \ |                {\"Neptune\", 0.5 * M_PI, 0.5 * M_PI, 0}};\n      |       \
    \                                               ^\n/tmp/tmp_2eb0jqz.cpp:32:34:\
    \ error: \u2018struct bf(std::string, std::string)::planet\u2019 has no member\
    \ named \u2018begin\u2019\n   32 |     auto p1 = std::find_if(earth.begin(), earth.end(),\
    \ [&](const planet& p) {\n      |                                  ^~~~~\n/tmp/tmp_2eb0jqz.cpp:32:49:\
    \ error: \u2018struct bf(std::string, std::string)::planet\u2019 has no member\
    \ named \u2018end\u2019\n   32 |     auto p1 = std::find_if(earth.begin(), earth.end(),\
    \ [&](const planet& p) {\n      |                                            \
    \     ^~~\n/tmp/tmp_2eb0jqz.cpp:35:21: error: \u2018struct bf(std::string, std::string)::planet\u2019\
    \ has no member named \u2018end\u2019\n   35 |     if (p1 == earth.end()) {\n\
    \      |                     ^~~\n/tmp/tmp_2eb0jqz.cpp:36:39: error: template\
    \ argument 2 is invalid\n   36 |         return std::tuple<std::string,>();\n\
    \      |                                       ^\n/tmp/tmp_2eb0jqz.cpp:38:34:\
    \ error: \u2018struct bf(std::string, std::string)::planet\u2019 has no member\
    \ named \u2018begin\u2019\n   38 |     auto p2 = std::find_if(earth.begin(), earth.end(),\
    \ [&](const planet& p) {\n      |                                  ^~~~~\n/tmp/tmp_2eb0jqz.cpp:38:49:\
    \ error: \u2018struct bf(std::string, std::string)::planet\u2019 has no member\
    \ named \u2018end\u2019\n   38 |     auto p2 = std::find_if(earth.begin(), earth.end(),\
    \ [&](const planet& p) {\n      |                                            \
    \     ^~~\n/tmp/tmp_2eb0jqz.cpp:41:21: error: \u2018struct bf(std::string, std::string)::planet\u2019\
    \ has no member named \u2018end\u2019\n   41 |     if (p2 == earth.end()) {\n\
    \      |                     ^~~\n/tmp/tmp_2eb0jqz.cpp:42:39: error: template\
    \ argument 2 is inval"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::tuple<std::string, > result;\n    assert(planet1\
    \ == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 ==\
    \ \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"\
    Uranus\" || planet1 == \"Neptune\");\n    assert(planet2 == \"Mercury\" || planet2\
    \ == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2 == \"\
    Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\"\
    );\n\n    std::tuple <bool, std::tuple<std::string, >> orbits_between;\n\n   \
    \ if (planet1 == \"Mercury\") {\n        orbits_between = bf2(\"Mercury\", \"\
    Venus\", planet2);\n    } else if (planet1 == \"Venus\") {\n        orbits_between\
    \ = bf2(\"Mercury\", \"Venus\", planet2);\n    } else if (planet1 == \"Earth\"\
    ) {\n        orbits_between = bf2(\"Mercury\", \"Venus\", planet2);\n    } else\
    \ if (planet1 == \"Mars\") {\n        orbits_between = bf2(\"Mercury\", \"Venus\"\
    , planet2);\n    } else if (planet1 == \"Jupiter\") {\n        orbits_between\
    \ = bf2(\"Mercury\", \"Venus\", planet2);\n    } else if (planet1 == \"Saturn\"\
    ) {\n        orbits_between = bf2(\"Mercury\", \"Venus\", planet2);\n    } else\
    \ if (planet1 == \"Uranus\") {\n        orbits_between = bf2(\"Mercury\", \"Venus\"\
    , planet2);\n    } else if (planet1 == \"Neptune\") {\n        orbits_between\
    \ = bf2(\"Mercury\", \"Venus\", planet2);\n    } else {\n        std::cout <<\
    \ planet1 << \" is not a valid planet name\\n\";\n        return {};\n    }\n\n\
    \    return orbits_between;\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpslxn1ftf.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpslxn1ftf.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpslxn1ftf.cpp:17:29: error: template\
    \ argument 2 is invalid\n   17 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmpslxn1ftf.cpp:21:45: error: template\
    \ argument 2 is invalid\n   21 |     std::tuple <bool, std::tuple<std::string,\
    \ >> orbits_between;\n      |                                             ^\n\
    /tmp/tmpslxn1ftf.cpp:21:47: error: template argument 2 is invalid\n   21 |   \
    \  std::tuple <bool, std::tuple<std::string, >> orbits_between;\n      |     \
    \                                          ^~\n/tmp/tmpslxn1ftf.cpp:24:26: error:\
    \ \u2018bf2\u2019 was not declared in this scope; did you mean \u2018bf\u2019\
    ?\n   24 |         orbits_between = bf2(\"Mercury\", \"Venus\", planet2);\n  \
    \    |                          ^~~\n      |                          bf\n/tmp/tmpslxn1ftf.cpp:26:26:\
    \ error: \u2018bf2\u2019 was not declared in this scope; did you mean \u2018bf\u2019\
    ?\n   26 |         orbits_between = bf2(\"Mercury\", \"Venus\", planet2);\n  \
    \    |                          ^~~\n      |                          bf\n/tmp/tmpslxn1ftf.cpp:28:26:\
    \ error: \u2018bf2\u2019 was not declared in this scope; did you mean \u2018bf\u2019\
    ?\n   28 |         orbits_between = bf2(\"Mercury\", \"Venus\", planet2);\n  \
    \    |                          ^~~\n      |                          bf\n/tmp/tmpslxn1ftf.cpp:30:26:\
    \ error: \u2018bf2\u2019 was not declared in this scope; did you mean \u2018bf\u2019\
    ?\n   30 |         orbits_between = bf2(\"Mercury\", \"Venus\", planet2);\n  \
    \    |                          ^~~\n      |                          bf\n/tmp/tmpslxn1ftf.cpp:32:26:\
    \ error: \u2018bf2\u2019 was not declared in this scope; did you mean \u2018bf\u2019\
    ?\n   32 |         orbits_between = bf2(\"Mercury\", \"Venus\", planet2);\n  \
    \    |                          ^~~\n      |                          bf\n/tmp/tmpslxn1ftf.cpp:34:26:\
    \ error: \u2018bf2\u2019 was not declared in this scope; did you mean \u2018bf\u2019\
    ?\n   34 "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n   assert(planet1 != \"Mercury\" && planet1 != \"Earth\"\
    \ && planet1 != \"Venus\" && \n      planet1 != \"Mars\" && planet1 != \"Jupiter\"\
    \ && planet1 != \"Saturn\" && \n      planet1 != \"Uranus\" && planet1 != \"Neptune\"\
    \ && planet2 != \"Mercury\" && \n      planet2 != \"Earth\" && planet2 != \"Venus\"\
    \ && planet2 != \"Mars\" && \n      planet2 != \"Jupiter\" && planet2 != \"Saturn\"\
    \ && planet2 != \"Uranus\" && \n      planet2 != \"Neptune\");\n   std::set<std::string>\
    \ planets;\n   planets.insert(planet1);\n   planets.insert(planet2);\n   std::pair<std::set<std::string>::iterator,\
    \ std::set<std::string>::iterator> \n      p;\n   p = planets.equal_range(planet2);\n\
    \   p.second = planets.lower_bound(planet1);\n   return std::make_tuple(p.first,\
    \ p.second);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2iy74km8.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp2iy74km8.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp2iy74km8.cpp:30:26: error: cannot\
    \ convert \u2018std::tuple<std::_Rb_tree_const_iterator<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >, std::_Rb_tree_const_iterator<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > > >\u2019 to \u2018int\u2019\
    \ in return\n   30 |    return std::make_tuple(p.first, p.second);\n      |  \
    \         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n      |                        \
    \  |\n      |                          std::tuple<std::_Rb_tree_const_iterator<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >, std::_Rb_tree_const_iterator<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2iy74km8.cpp:2:\n/tmp/tmp2iy74km8.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp2iy74km8.cpp:34:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   34 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp2iy74km8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/inclu"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  std::vector<std::string> sOrbits;\n  std::cin >> sOrbits;\n\
    \  if(planet1 == planet2) return std::make_tuple(planet1);\n  else if(sOrbits.size()\
    \ < 2) return std::make_tuple(\"\");\n  std::string tempPlanet1 = planet1, tempPlanet2\
    \ = planet2;\n  int n = sOrbits.size();\n  if(tempPlanet1.compare(tempPlanet2)\
    \ == 0) return std::make_tuple(\"\");\n  for(int i = 0; i < n - 1; i++) {\n  \
    \  if(tempPlanet1.compare(sOrbits[i]) < 0) tempPlanet1 = sOrbits[i];\n    if(tempPlanet2.compare(sOrbits[i])\
    \ > 0) tempPlanet2 = sOrbits[i];\n  }\n  if(tempPlanet1.compare(tempPlanet2) >\
    \ 0) return std::make_tuple(\"\");\n  for(int i = n - 1; i > 0; i--) {\n    if(tempPlanet1.compare(sOrbits[i])\
    \ < 0) tempPlanet1 = sOrbits[i];\n    if(tempPlanet2.compare(sOrbits[i]) > 0)\
    \ tempPlanet2 = sOrbits[i];\n  }\n  return std::make_tuple(planet1, planet2);\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp10jghw8w.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp10jghw8w.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp10jghw8w.cpp:18:12: error: no match\
    \ for \u2018operator>>\u2019 (operand types are \u2018std::istream\u2019 {aka\
    \ \u2018std::basic_istream<char>\u2019} and \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019)\n   18 |   std::cin >> sOrbits;\n      |   ~~~~~~~~ ^~ ~~~~~~~\n  \
    \    |        |      |\n      |        |      std::vector<std::__cxx11::basic_string<char>\
    \ >\n      |        std::istream {aka std::basic_istream<char>}\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp10jghw8w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:120:7:\
    \ note: candidate: \u2018std::basic_istream<_CharT, _Traits>::__istream_type&\
    \ std::basic_istream<_CharT, _Traits>::operator>>(std::basic_istream<_CharT, _Traits>::__istream_type&\
    \ (*)(std::basic_istream<_CharT, _Traits>::__istream_type&)) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; std::basic_istream<_CharT, _Traits>::__istream_type\
    \ = std::basic_istream<char>]\u2019\n  120 |       operator>>(__istream_type&\
    \ (*__pf)(__istream_type&))\n      |       ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:120:36:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::basic_istream<char>::__istream_type& (*)(std::basic_istream<char>::__istream_type&)\u2019\
    \ {aka \u2018std::basic_istream<char>& (*)(std::basic_istream<char>&)\u2019}\n\
    \  120 |       operator>>(__istream_type& (*__pf)(__istream_type&))\n      | \
    \                 ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~\n/sha"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n\tif (planet1.empty() || planet2.empty()) {\n\t\treturn\
    \ std::tuple<std::string,>();\n\t}\n\tstd::string planet1Name;\n\tstd::string\
    \ planet2Name;\n\tdouble distance1;\n\tdouble distance2;\n\tdouble distance;\n\
    \tfor (auto &name : planet1) {\n\t\tfor (auto &name2 : planet2) {\n\t\t\tplanet1Name\
    \ = name;\n\t\t\tplanet2Name = name2;\n\t\t\tif (planet1Name == planet2Name) {\n\
    \t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// get the distance of the planet to the sun\n\
    \t\t\tdistance = hypot((-69.29 + 17.3 * cos(2 * pi * planet1Name) - \n\t\t\t\t\
    29.3 * cos(2 * pi * planet2Name)), 5.97 + 13.75 * \n\t\t\t\tcos(2 * pi * planet1Name)\
    \ - 4.21 * cos(2 * pi * planet2Name));\n\t\t\t// compare the distance to the sun\n\
    \t\t\tif (distance < 5.0) {\n\t\t\t\t// sort the planets by proximity to the sun\n\
    \t\t\t\tstd::sort(planet1.begin(), planet1.end());\n\t\t\t\tstd::sort(planet2.begin(),\
    \ planet2.end());\n\t\t\t\tauto iter = find(planet1.begin(), planet1.end(), planet2Name);\n\
    \t\t\t\treturn std::tuple<string, >(planet1.begin(), iter);\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn std::tuple<std::string,>();\n}\nint main() {\n    auto candidate =\
    \ bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpz94zih_k.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpz94zih_k.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpz94zih_k.cpp:18:33: error: template\
    \ argument 2 is invalid\n   18 |   return std::tuple<std::string,>();\n      |\
    \                                 ^\n/tmp/tmpz94zih_k.cpp:33:46: error: \u2018\
    pi\u2019 was not declared in this scope\n   33 |    distance = hypot((-69.29 +\
    \ 17.3 * cos(2 * pi * planet1Name) -\n      |                                \
    \              ^~\n/tmp/tmpz94zih_k.cpp:42:23: error: \u2018string\u2019 was not\
    \ declared in this scope; did you mean \u2018std::string\u2019?\n   42 |     return\
    \ std::tuple<string, >(planet1.begin(), iter);\n      |                      \
    \ ^~~~~~\n      |                       std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpz94zih_k.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpz94zih_k.cpp:42:31:\
    \ error: template argument 1 is invalid\n   42 |     return std::tuple<string,\
    \ >(planet1.begin(), iter);\n      |                               ^\n/tmp/tmpz94zih_k.cpp:42:31:\
    \ error: template argument 2 is invalid\n/tmp/tmpz94zih_k.cpp:46:32: error: template\
    \ argument 2 is invalid\n   46 |  return std:"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    bool valid1 = false;\n    bool valid2 = false;\n\
    \    bool valid3 = false;\n    bool valid4 = false;\n    bool valid5 = false;\n\
    \    bool valid6 = false;\n    bool valid7 = false;\n    bool valid8 = false;\n\
    \    if (planet1 == \"Mercury\") {\n        valid1 = true;\n    }\n    if (planet1\
    \ == \"Venus\") {\n        valid2 = true;\n    }\n    if (planet1 == \"Earth\"\
    ) {\n        valid3 = true;\n    }\n    if (planet1 == \"Mars\") {\n        valid4\
    \ = true;\n    }\n    if (planet1 == \"Jupiter\") {\n        valid5 = true;\n\
    \    }\n    if (planet1 == \"Saturn\") {\n        valid6 = true;\n    }\n    if\
    \ (planet1 == \"Uranus\") {\n        valid7 = true;\n    }\n    if (planet1 ==\
    \ \"Neptune\") {\n        valid8 = true;\n    }\n    if (planet2 == \"Mercury\"\
    ) {\n        valid1 = true;\n    }\n    if (planet2 == \"Venus\") {\n        valid2\
    \ = true;\n    }\n    if (planet2 == \"Earth\") {\n        valid3 = true;\n  \
    \  }\n    if (planet2 == \"Mars\") {\n        valid4 = true;\n    }\n    if (planet2\
    \ == \"Jupiter\") {\n        valid5 = true;\n    }\n    if (planet2 == \"Saturn\"\
    ) {\n        valid6 = true;\n    }\n    if (planet2 == \"Uranus\") {\n       \
    \ valid7 = true;\n    }\n    if (planet2 == \"Neptune\") {\n        valid8 = true;\n\
    \    }\n\n    if (valid1 && valid2 && valid3 && valid4 && valid5 && valid6 &&\
    \ valid7 && valid8) {\n        std::tuple<std::string, > results;\n        results\
    \ = std::make_tuple(planet1, planet2);\n        return results;\n    } else {\n\
    \        return std::tuple<std::string, >();\n    }\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_kvpz6gi.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp_kvpz6gi.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp_kvpz6gi.cpp:75:33: error: template\
    \ argument 2 is invalid\n   75 |         std::tuple<std::string, > results;\n\
    \      |                                 ^\n/tmp/tmp_kvpz6gi.cpp:76:34: error:\
    \ cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in assignment\n   76 |   \
    \      results = std::make_tuple(planet1, planet2);\n      |                 \
    \  ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                                \
    \  |\n      |                                  std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmp_kvpz6gi.cpp:79:40:\
    \ error: template argument 2 is invalid\n   79 |         return std::tuple<std::string,\
    \ >();\n      |                                        ^\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_kvpz6gi.cpp:2:\n/tmp/tmp_kvpz6gi.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp_kvpz6gi.cpp:84:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   84 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1.length() != planet2.length()) return\
    \ std::tuple<std::string, >();\n    double sun_dist = get_distance();\n    double\
    \ orbits_dist[MAX_NUM_ORBITS] = {0};\n    for (int i = 0; i < MAX_NUM_ORBITS;\
    \ ++i)\n        orbits_dist[i] = std::abs((i - get_orbit(planet1, planet2)) %\
    \ MAX_NUM_ORBITS);\n    sort_by_proximity(orbits_dist);\n    auto it = std::upper_bound(orbits_dist,\
    \ orbits_dist[MAX_NUM_ORBITS - 1] + 1, sun_dist);\n    if (it == orbits_dist[MAX_NUM_ORBITS\
    \ - 1] + 1) {\n        return std::make_tuple(planet1);\n    }\n    if (*it ==\
    \ sun_dist) {\n        return std::make_tuple(planet1);\n    }\n    auto it2 =\
    \ std::upper_bound(orbits_dist, orbits_dist[MAX_NUM_ORBITS - 1] + 1, *it);\n \
    \   if (it2 == orbits_dist[MAX_NUM_ORBITS - 1] + 1) {\n        return std::make_tuple(planet2);\n\
    \    }\n    if (*it2 == *it) {\n        return std::make_tuple(planet1, planet2);\n\
    \    }\n    if (*it2 > *it) {\n        return bf(planet2, planet1);\n    }\n \
    \   return std::make_tuple(planet2, planet1);\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpdwof_6sa.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpdwof_6sa.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpdwof_6sa.cpp:17:78: error: template\
    \ argument 2 is invalid\n   17 |     if (planet1.length() != planet2.length())\
    \ return std::tuple<std::string, >();\n      |                               \
    \                                               ^\n/tmp/tmpdwof_6sa.cpp:18:23:\
    \ error: \u2018get_distance\u2019 was not declared in this scope\n   18 |    \
    \ double sun_dist = get_distance();\n      |                       ^~~~~~~~~~~~\n\
    /tmp/tmpdwof_6sa.cpp:19:24: error: \u2018MAX_NUM_ORBITS\u2019 was not declared\
    \ in this scope\n   19 |     double orbits_dist[MAX_NUM_ORBITS] = {0};\n     \
    \ |                        ^~~~~~~~~~~~~~\n/tmp/tmpdwof_6sa.cpp:21:9: error: \u2018\
    orbits_dist\u2019 was not declared in this scope\n   21 |         orbits_dist[i]\
    \ = std::abs((i - get_orbit(planet1, planet2)) % MAX_NUM_ORBITS);\n      |   \
    \      ^~~~~~~~~~~\n/tmp/tmpdwof_6sa.cpp:21:40: error: \u2018get_orbit\u2019 was\
    \ not declared in this scope\n   21 |         orbits_dist[i] = std::abs((i - get_orbit(planet1,\
    \ planet2)) % MAX_NUM_ORBITS);\n      |                                      \
    \  ^~~~~~~~~\n/tmp/tmpdwof_6sa.cpp:22:23: error: \u2018orbits_dist\u2019 was not\
    \ declared in this scope\n   22 |     sort_by_proximity(orbits_dist);\n      |\
    \                       ^~~~~~~~~~~\n/tmp/tmpdwof_6sa.cpp:22:5: error: \u2018\
    sort_by_proximity\u2019 was not declared in this scope\n   22 |     sort_by_proximity(orbits_dist);\n\
    \      |     ^~~~~~~~~~~~~~~~~\n/tmp/tmpdwof_6sa.cpp:25:31: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in return\n   25 |         return std::make_tuple(planet1);\n\
    \      |                ~~~~~~~~~~~~~~~^~~~~~~~~\n      |                    \
    \           |\n      |                               std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpdwof"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    if (planet1 == planet2) return std::make_tuple(planet1);\n\
    \    std::tuple<std::string, > ret;\n    if (planet1 == \"Mercury\" && planet2\
    \ == \"Venus\") {\n        ret.emplace_back(\"Saturn\");\n        ret.emplace_back(\"\
    Uranus\");\n    } else if (planet1 == \"Jupiter\" && planet2 == \"Saturn\") {\n\
    \        ret.emplace_back(\"Uranus\");\n    } else if (planet1 == \"Jupiter\"\
    \ && planet2 == \"Uranus\") {\n        ret.emplace_back(\"Venus\");\n    } else\
    \ if (planet1 == \"Venus\" && planet2 == \"Mercury\") {\n        ret.emplace_back(\"\
    Mercury\");\n    } else if (planet1 == \"Venus\" && planet2 == \"Earth\") {\n\
    \        ret.emplace_back(\"Earth\");\n    } else if (planet1 == \"Venus\" &&\
    \ planet2 == \"Mars\") {\n        ret.emplace_back(\"Mars\");\n    } else if (planet1\
    \ == \"Venus\" && planet2 == \"Jupiter\") {\n        ret.emplace_back(\"Jupiter\"\
    );\n    } else if (planet1 == \"Venus\" && planet2 == \"Saturn\") {\n        ret.emplace_back(\"\
    Saturn\");\n    } else if (planet1 == \"Venus\" && planet2 == \"Uranus\") {\n\
    \        ret.emplace_back(\"Uranus\");\n    } else if (planet1 == \"Mercury\"\
    \ && planet2 == \"Mars\") {\n        ret.emplace_back(\"Mars\");\n    } else if\
    \ (planet1 == \"Mercury\" && planet2 == \"Jupiter\") {\n        ret.emplace_back(\"\
    Jupiter\");\n    } else if (planet1 == \"Mercury\" && planet2 == \"Uranus\") {\n\
    \        ret.emplace_back(\"Uranus\");\n    } else if (planet1 == \"Mercury\"\
    \ && planet2 == \"Neptune\") {\n        ret.emplace_back(\"Neptune\");\n    }\
    \ else if (planet1 == \"Mercury\" && planet2 == \"Saturn\") {\n        ret.emplace_back(\"\
    Saturn\");\n    } else if (planet1 == \"Mercury\" && planet2 == \"Earth\") {\n\
    \        ret.emplace_back(\"Earth\");\n    } else if (planet1 == \"Mercury\" &&\
    \ planet2 == \"Earth\") {\n        ret.emplace_back(\"Mercury\");\n    } else\
    \ if (planet1 == \"Mercury\" && planet2 == \"Mars\") {\n        ret.emplace_back(\"\
    Mar\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp02airvqw.cpp:53:26: warning: missing terminating \" character\n\
    \   53 |         ret.emplace_back(\"Mar\n      |                          ^\n\
    /tmp/tmp02airvqw.cpp:53:26: error: missing terminating \" character\n   53 | \
    \        ret.emplace_back(\"Mar\n      |                          ^~~~\n/tmp/tmp02airvqw.cpp:16:25:\
    \ error: template argument 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                         ^\n/tmp/tmp02airvqw.cpp:\
    \ In function \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmp02airvqw.cpp:17:51:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   17 |     if\
    \ (planet1 == planet2) return std::make_tuple(planet1);\n      |             \
    \                       ~~~~~~~~~~~~~~~^~~~~~~~~\n      |                    \
    \                               |\n      |                                   \
    \                std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\n/tmp/tmp02airvqw.cpp:18:29: error: template argument\
    \ 2 is invalid\n   18 |     std::tuple<std::string, > ret;\n      |          \
    \                   ^\n/tmp/tmp02airvqw.cpp:20:13: error: request for member \u2018\
    emplace_back\u2019 in \u2018ret\u2019, which is of non-class type \u2018int\u2019\
    \n   20 |         ret.emplace_back(\"Saturn\");\n      |             ^~~~~~~~~~~~\n\
    /tmp/tmp02airvqw.cpp:21:13: error: request for member \u2018emplace_back\u2019\
    \ in \u2018ret\u2019, which is of non-class type \u2018int\u2019\n   21 |    \
    \     ret.emplace_back(\"Uranus\");\n      |             ^~~~~~~~~~~~\n/tmp/tmp02airvqw.cpp:23:13:\
    \ error: request for member \u2018emplace_back\u2019 in \u2018ret\u2019, which\
    \ is of non-class type \u2018int\u2019\n   23 |         ret.emplace_back(\"Uranus\"\
    );\n      |             ^~~~~~~~~~~~\n/tmp/tmp02airvqw.cpp:25:13: error: request\
    \ for member \u2018emplace_back\u2019 in \u2018ret\u2019, which is of non-class\
    \ type \u2018int\u2019\n   25 |         ret.emplace_back(\"Venus\");\n      |\
    \             ^~~~~~~~~~~~\n/tmp/tmp02airvqw.cpp:27:13: error: request for member\
    \ \u2018emplace_back\u2019 in \u2018ret\u2019, which is of non-cla"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    planet1 = planet1.toLower();\n    planet2 = planet2.toLower();\n\
    \    std::tuple<std::string, > result;\n    int d1 = 0, d2 = 0, d3 = 0, d4 = 0,\
    \ d5 = 0, d6 = 0, d7 = 0, d8 = 0;\n    int m1 = 0, m2 = 0, m3 = 0, m4 = 0, m5\
    \ = 0, m6 = 0, m7 = 0, m8 = 0;\n    int a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0,\
    \ a6 = 0, a7 = 0, a8 = 0;\n    double a1_r = 0, a2_r = 0, a3_r = 0, a4_r = 0,\
    \ a5_r = 0, a6_r = 0, a7_r = 0, a8_r = 0.0;\n    double a1_g = 0, a2_g = 0, a3_g\
    \ = 0, a4_g = 0, a5_g = 0, a6_g = 0, a7_g = 0, a8_g = 0.0;\n    double a1_b =\
    \ 0, a2_b = 0, a3_b = 0, a4_b = 0, a5_b = 0, a6_b = 0, a7_b = 0, a8_b = 0.0;\n\
    \    double a1_r = 0, a2_r = 0, a3_r = 0, a4_r = 0, a5_r = 0, a6_r = 0, a7_r =\
    \ 0, a8_r = 0.0;\n    double a1_g = 0, a2_g = 0, a3_g = 0, a4_g = 0, a5_g = 0,\
    \ a6_g = 0, a7_g = 0, a8_g = 0.0;\n    double a1_b = 0, a2_b = 0, a3_b = 0, a4_b\
    \ = 0, a5_b = 0, a6_b = 0, a7_b = 0, a8_b = 0.0;\n    int i1 = 0, i2 = 0, i3 =\
    \ 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0;\n    double i1_r = 0, i2_r = 0, i3_r\
    \ = 0, i4_r = 0, i5_r = 0, i6_r = 0, i7_r = 0, i8_r = 0.0;\n    double i1_g =\
    \ 0, i2_g = 0, i3_g = 0, i4_g = 0, i5_g = 0, i6_g = 0, i7_g = 0, i8_g = 0.0;\n\
    \    double i1_b = 0, i2_b = 0, i3_b = 0, i4_b = 0, i5_b = 0, i6_b = 0, i7_b =\
    \ 0, i8_b = 0.0;\n    double i1_r = 0, i2_r = 0, i3_r = 0, i4_r = 0, i5_r = 0,\
    \ i6_r = 0, i7_r = 0, i8_r = 0.0;\n    double i1_g = 0, i2_g = 0, i3_g = 0, i4_g\
    \ = 0, i5_g = 0, i6_g = 0, i7_g = 0, i8_g = 0.0;\n    double \n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptfg48_2b.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmptfg48_2b.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmptfg48_2b.cpp:17:23: error: \u2018\
    std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019} has\
    \ no member named \u2018toLower\u2019\n   17 |     planet1 = planet1.toLower();\n\
    \      |                       ^~~~~~~\n/tmp/tmptfg48_2b.cpp:18:23: error: \u2018\
    std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019} has\
    \ no member named \u2018toLower\u2019\n   18 |     planet2 = planet2.toLower();\n\
    \      |                       ^~~~~~~\n/tmp/tmptfg48_2b.cpp:19:29: error: template\
    \ argument 2 is invalid\n   19 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmptfg48_2b.cpp:26:12: error: redeclaration\
    \ of \u2018double a1_r\u2019\n   26 |     double a1_r = 0, a2_r = 0, a3_r = 0,\
    \ a4_r = 0, a5_r = 0, a6_r = 0, a7_r = 0, a8_r = 0.0;\n      |            ^~~~\n\
    /tmp/tmptfg48_2b.cpp:23:12: note: \u2018double a1_r\u2019 previously declared\
    \ here\n   23 |     double a1_r = 0, a2_r = 0, a3_r = 0, a4_r = 0, a5_r = 0, a6_r\
    \ = 0, a7_r = 0, a8_r = 0.0;\n      |            ^~~~\n/tmp/tmptfg48_2b.cpp:26:22:\
    \ error: redeclaration of \u2018double a2_r\u2019\n   26 |     double a1_r = 0,\
    \ a2_r = 0, a3_r = 0, a4_r = 0, a5_r = 0, a6_r = 0, a7_r = 0, a8_r = 0.0;\n  \
    \    |                      ^~~~\n/tmp/tmptfg48_2b.cpp:23:22: note: \u2018double\
    \ a2_r\u2019 previously declared here\n   23 |     double a1_r = 0, a2_r = 0,\
    \ a3_r = 0, a4_r = 0, a5_r = 0, a6_r = 0, a7_r = 0, a8_r = 0.0;\n      |     \
    \                 ^~~~\n/tmp/tmptfg48_2b.cpp:26:32: error: redeclaration of \u2018\
    double a3_r\u2019\n   26 |     double a1_r = 0, a2_r = 0, a3_r = 0, a4_r = 0,\
    \ a5_r = 0, a6_r = 0, a7_r = 0, a8_r = 0.0;\n      |                         \
    \       ^~~~\n/tmp/tmptfg48_2b.cpp:23:32: note: \u2018double a3_r\u2019 previously\
    \ declared here\n   23 |     double a1_r = 0, a2_r = 0, a3_r = 0, a4_r = 0, a5_r\
    \ = 0, a6_r = 0, a7_r = 0, a8_r = 0.0;\n      |                              \
    \  ^~~~\n/tmp/tmptf"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 != planet2);\n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6a22jxh3.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp6a22jxh3.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp6a22jxh3.cpp:18:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   18 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6a22jxh3.cpp:2:\n/tmp/tmp6a22jxh3.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp6a22jxh3.cpp:22:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   22 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp6a22jxh3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    std::tuple<std::string, > res;\n    std::string\
    \ name1=planet1;\n    std::string name2=planet2;\n    int i=1;\n    int j=0;\n\
    \    // If either name or both are wrong, return an empty tuple\n    if (name1.empty()\
    \ || name2.empty()) {\n        return std::tuple<std::string, >();\n    }\n  \
    \  // If both names are the same then return an empty tuple\n    if (name1 ==\
    \ name2) {\n        return std::tuple<std::string, >();\n    }\n    std::vector<std::string>\
    \ names;\n    names.push_back(name1);\n    names.push_back(name2);\n    // Create\
    \ a vector with all names and sort them\n    std::vector<std::string> name_vec(names);\n\
    \    std::sort(name_vec.begin(), name_vec.end());\n    // Create a vector with\
    \ all names and sort them\n    std::vector<std::string> name_vec1(names);\n  \
    \  std::sort(name_vec1.begin(), name_vec1.end());\n    // Create a vector with\
    \ all names and sort them\n    std::vector<std::string> name_vec2(names);\n  \
    \  std::sort(name_vec2.begin(), name_vec2.end());\n    // Create a vector with\
    \ all names and sort them\n    std::vector<std::string> name_vec3(names);\n  \
    \  std::sort(name_vec3.begin(), name_vec3.end());\n    // Create a vector with\
    \ all names and sort them\n    std::vector<std::string> name_vec4(names);\n  \
    \  std::sort(name_vec4.begin(), name_vec4.end());\n    // Create a vector with\
    \ all names and sort them\n    std::vector<std::string> name_vec5(names);\n  \
    \  std::sort(name_vec5.begin(), name_vec5.end());\n    // Create a vector with\
    \ all names and sort them\n    std::vector<std::string> name_vec6(names);\n  \
    \  std::sort(name_vec6.begin(), name_vec6.end());\n    // Create a vector with\
    \ all names and sort them\n    std::vector<std::string> name_vec7(names);\n  \
    \  std::sort(name_vec7.begin(), name_vec7.end());\n    // Create a vector with\
    \ all names and sort them\n    std::vector<std::string> name_vec8(names);\n  \
    \  std::sort(name_vec8.begin(), name_vec8.end());\n    // Create a vector with\
    \ all names and sort them\n    std::vector<std::string> name_vec9(names);\n  \
    \  std::sort(name_vec9.begin(), name_vec9.end());\n    // Create a vector with\
    \ all names and sort them\n    std::vector<std::string> name_vec10(names);\n \
    \   std::sort(name_vec10.begin(), name_vec10.end());\n    // Create a vector with\
    \ all names and sort them\n    std::vector<std::string> name_vec11(names);\n \
    \   std::sort(name_vec11.begin(), name_vec11.end());\n    // Create a vector with\
    \ all names and sort them\n    std::vector<std::string> name_vec12\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphascdm1i.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmphascdm1i.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmphascdm1i.cpp:18:29: error: template\
    \ argument 2 is invalid\n   18 |     std::tuple<std::string, > res;\n      | \
    \                            ^\n/tmp/tmphascdm1i.cpp:25:40: error: template argument\
    \ 2 is invalid\n   25 |         return std::tuple<std::string, >();\n      | \
    \                                       ^\n/tmp/tmphascdm1i.cpp:29:40: error:\
    \ template argument 2 is invalid\n   29 |         return std::tuple<std::string,\
    \ >();\n      |                                        ^\n/tmp/tmphascdm1i.cpp:72:1:\
    \ error: expected initializer before \u2018}\u2019 token\n   72 | }\n      | ^\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphascdm1i.cpp:2:\n/tmp/tmphascdm1i.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmphascdm1i.cpp:75:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   75 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmphascdm1i.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Your code here\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_y15rhlc.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp_y15rhlc.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp_y15rhlc.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_y15rhlc.cpp:2:\n/tmp/tmp_y15rhlc.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp_y15rhlc.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp_y15rhlc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    using namespace std;\n    // Define the distance\
    \ function \n    auto distance = decltype(distance)::apply(sun, planet1);\n  \
    \  auto distance = decltype(distance)::apply(sun, planet2);\n    // Define the\
    \ return type as tuple\n    tuple<string, > ans;\n    // If we have no planet\
    \ names \n    if (planet1.empty() || planet2.empty())\n        return tuple<string,\
    \ >();\n    // If we pass wrong planet names \n    if (planet1 != planet2)\n \
    \       return tuple<string, >();\n    // Else we pass right planet names \n \
    \   for (int i = 0; i <= 8; i++)\n        if (planet1[i] != planet2[i])\n    \
    \        break;\n    return ans;\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpf7iaybk1.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpf7iaybk1.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpf7iaybk1.cpp:19:30: error: use\
    \ of \u2018distance\u2019 before deduction of \u2018auto\u2019\n   19 |     auto\
    \ distance = decltype(distance)::apply(sun, planet1);\n      |               \
    \               ^~~~~~~~\n/tmp/tmpf7iaybk1.cpp:19:21: error: decltype evaluates\
    \ to \u2018<type error>\u2019, which is not a class or enumeration type\n   19\
    \ |     auto distance = decltype(distance)::apply(sun, planet1);\n      |    \
    \                 ^~~~~~~~\n/tmp/tmpf7iaybk1.cpp:19:47: error: \u2018sun\u2019\
    \ was not declared in this scope; did you mean \u2018sin\u2019?\n   19 |     auto\
    \ distance = decltype(distance)::apply(sun, planet1);\n      |               \
    \                                ^~~\n      |                                \
    \               sin\n/tmp/tmpf7iaybk1.cpp:20:21: error: decltype evaluates to\
    \ \u2018<type error>\u2019, which is not a class or enumeration type\n   20 |\
    \     auto distance = decltype(distance)::apply(sun, planet2);\n      |      \
    \               ^~~~~~~~\n/tmp/tmpf7iaybk1.cpp:22:19: error: template argument\
    \ 2 is invalid\n   22 |     tuple<string, > ans;\n      |                   ^\n\
    /tmp/tmpf7iaybk1.cpp:25:30: error: template argument 2 is invalid\n   25 |   \
    \      return tuple<string, >();\n      |                              ^\n/tmp/tmpf7iaybk1.cpp:28:30:\
    \ error: template argument 2 is invalid\n   28 |         return tuple<string,\
    \ >();\n      |                              ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpf7iaybk1.cpp:2:\n/tmp/tmpf7iaybk1.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpf7iaybk1.cpp:37:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   37 |     assert(candidate((\"Jupiter\"),"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n  // Your code here\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpe3jv3d2y.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpe3jv3d2y.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpe3jv3d2y.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe3jv3d2y.cpp:2:\n/tmp/tmpe3jv3d2y.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpe3jv3d2y.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpe3jv3d2y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double x = 0.0, y = 0.0, z = 0.0;\n    double sun_rad\
    \ = M_PI/180.0;\n    double sun_long = 262.098; // degrees = arcminutes/60 \n\
    \    double sun_lat = -0.00035;\n    // Write your code here.\n    x = sun_rad\
    \ * cos(sun_long * M_PI/180.0);\n    y = sun_rad * sin(sun_long * M_PI/180.0);\n\
    \    z = sun_rad * sin(sun_lat * M_PI/180.0);\n    double dist1 = distance(x,\
    \ y, z, planet1.c_str());\n    double dist2 = distance(x, y, z, planet2.c_str());\n\
    \    return std::make_tuple(planet1, planet2);\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp0mu9dsx5.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp0mu9dsx5.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp0mu9dsx5.cpp:25:20: error: \u2018\
    distance\u2019 was not declared in this scope; did you mean \u2018std::distance\u2019\
    ?\n   25 |     double dist1 = distance(x, y, z, planet1.c_str());\n      |   \
    \                 ^~~~~~~~\n      |                    std::distance\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:66,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0mu9dsx5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator_base_funcs.h:138:5:\
    \ note: \u2018std::distance\u2019 declared here\n  138 |     distance(_InputIterator\
    \ __first, _InputIterator __last)\n      |     ^~~~~~~~\n/tmp/tmp0mu9dsx5.cpp:27:27:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   27 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::ch"
  exit_code: 1
  status: SyntaxError
