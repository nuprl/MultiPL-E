name: HumanEval_44_change_base
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of\
  \ input number x to base.\n// return string representation after the conversion.\n\
  // base numbers are less than 10.\n// >>> change_base(8, 3)\n// '22'\n// >>> change_base(8,\
  \ 2)\n// '1000'\n// >>> change_base(7, 2)\n// '111'\nstd::string change_base(long\
  \ x, long base) {\n"
tests: "}\nint main() {\n    auto candidate = change_base;\n    assert(candidate((8),\
  \ (3)) == (\"22\"));\n    assert(candidate((9), (3)) == (\"100\"));\n    assert(candidate((234),\
  \ (2)) == (\"11101010\"));\n    assert(candidate((16), (2)) == (\"10000\"));\n \
  \   assert(candidate((8), (2)) == (\"1000\"));\n    assert(candidate((7), (2)) ==\
  \ (\"111\"));\n    assert(candidate((2), (3)) == (\"2\"));\n    assert(candidate((3),\
  \ (4)) == (\"3\"));\n    assert(candidate((4), (5)) == (\"4\"));\n    assert(candidate((5),\
  \ (6)) == (\"5\"));\n    assert(candidate((6), (7)) == (\"6\"));\n    assert(candidate((7),\
  \ (8)) == (\"7\"));\n}\n"
completions: ["    if (x < 10) {\n        x += (base - 1);\n    }\n    int a = 1;\n\
    \    int b = x;\n    long ans = 0;\n    int i = 0;\n    while (a != 0) {\n   \
    \     if ((b - a) % base == 0) {\n            ans = ans * base + (b - a / base);\n\
    \            a = 1;\n            b = x;\n            i++;\n        } else {\n\
    \            a *= base;\n        }\n    }\n    return to_string(ans);", "  if(x\
    \ < 0) {\n    return \"Invalid Value\";\n  }\n  if(base > 10) {\n    return \"\
    Base value invalid\";\n  }\n  if(base < 2 || base > 36) {\n    return \"Base value\
    \ invalid\";\n  }\n  if(base == 2 || base == 36) {\n    // base == 2 means change\
    \ binary numbers to octal numbers\n    base %= 4;\n    if(x == 1) {\n      return\
    \ \"1\";\n    }\n    if(x == -1) {\n      return \"-1\";\n    }\n  }\n  if(base\
    \ == 10) {\n    // base == 10 means change decimal numbers to binary numbers\n\
    \    base %= 2;\n    if(x == 0) {\n      return \"0\";\n    }\n    if(x == 1)\
    \ {\n      return \"1\";\n    }\n  }\n  std::string s;\n  while(x > 0) {\n   \
    \ if(x == 1) {\n      s.insert(0, \"1\");\n    }\n    else if(x == -1) {\n   \
    \   s.insert(0, \"-1\");\n    }\n    else if(x == 0 && base == 10) {\n      s.insert(0,\
    \ \"0\");\n    }\n    else {\n      s.insert(0, \"0\");\n      if(x % base ==\
    \ 0) {\n        std::reverse(s.begin(), s.end());\n        break;\n      }\n \
    \     x = x / base;\n    }\n  }\n  return s;", "    if (base < 2 || base > 10)\n\
    \        return \"Invalid Base Number\";\n    long num = 0, res = 0;\n    while\
    \ (x / base > 0) {\n        num %= base;\n        x /= base;\n        res = (res\
    \ * base) + num;\n    }\n    // The rest is the same as \"num\".\n    while (x\
    \ / base > 0) {\n        num %= base;\n        x /= base;\n        res = (num\
    \ * base) + res;\n    }\n    return std::to_string(res);", "    // base numbers\
    \ are less than 10.\n    assert(base < 11);\n\n    std::string res;\n    while\
    \ (x > 0) {\n        long d = x % base;\n        res += (char)(d + '0');\n   \
    \     x /= base;\n    }\n    res.insert(0, 1, '0');\n    return res;", "    std::string\
    \ result;\n    while (x != 0) {\n        long r = x % base;\n        x /= base;\n\
    \        std::string s = std::to_string(r);\n        result += s;\n    }\n   \
    \ return result;", "    long res = 0;\n    do {\n        res = (res << 1) + (x\
    \ % base);\n        x /= base;\n    } while (x != 0);\n    res %= base;\n    while\
    \ (res >= base)\n        res -= base;\n    std::string s = std::to_string(res);\n\
    \    std::reverse(s.begin(), s.end());\n    return s;", "    std::string result;\n\
    \    long temp = x;\n    while (temp > 0) {\n        temp = temp / base;\n   \
    \     result += std::to_string(base * temp);\n    }\n    return result;", "  \
    \  std::string res;\n    do {\n        if ((res = std::to_string((x % base))).empty())\
    \ break;\n        x /= base;\n    } while (x > 0);\n    if (x != 1) std::to_string(x\
    \ - 1); //add the last digit\n    return res;", "  string s;\n  if (base < 2 ||\
    \ base > 10)\n    s = \"ERROR\";\n  else\n    s = to_string(x);\n  if (base ==\
    \ 2)\n    while (s.size() % 2 != 0)\n      s.insert(s.size() - 1, 1);\n  return\
    \ s;", "    std::string ret;\n    if (x < 10) {\n        ret = (std::string)std::to_string(static_cast<long\
    \ long>(base * x));\n    }\n    else {\n        long n = x;\n        while (n\
    \ > 9) {\n            int digit = (n % base);\n            n /= base;\n      \
    \      ret += (std::string)std::to_string(digit);\n        }\n        ret += (std::string)std::to_string(base\
    \ * n);\n    }\n    return ret;", "    string ans;\n    if (x<=0) return \"0\"\
    ;\n    int n = std::log(x) / std::log(base);\n    while (n > 0)\n    {\n     \
    \   long temp = (long)(x * base);\n        ans.push_back((char)('0' + std::remainder(temp,base)));\n\
    \        x /= base;\n        n--;\n    }\n    return ans;", "    std::string ans\
    \ = \"\";\n    int tmp = x;\n    while (tmp > 0) {\n        tmp = tmp / base;\n\
    \        if (tmp > 0 && tmp < base) {\n            ans += '0';\n            ans\
    \ += static_cast<char>(base);\n            tmp = tmp - base;\n        }\n    }\n\
    \    return ans;", "    std::string ans = \"\";\n    do {\n        if (x % base\
    \ == 0) ans += (char)(x % base);\n        x /= base;\n    } while (x != 0);\n\
    \    return ans;", "    if (base == 0) return std::to_string(x);\n    if (base\
    \ > 10) {\n        std::cerr << \"change_base: base number must be less than 10.\\\
    n\";\n        exit(-1);\n    }\n    std::string res;\n    do {\n        res =\
    \ std::to_string(x%base) + res;\n    } while (x / base = base);\n    return res;",
  "    std::stringstream ss;\n    ss << std::setw(base) << std::setfill('0') << std::hex\
    \ << x;\n    return ss.str();", "    string str = \"\";\n    if (x == 0) return\
    \ \"0\";\n    while (x >= base) {\n        str = base_to_string(base % x) + str;\n\
    \        x /= base;\n    }\n    return base_to_string(x % base) + str;", "   \
    \ long val = x;\n    int digit = 0;\n    std::string res = \"\";\n    while (val\
    \ > 0) {\n        digit = val % base;\n        res += char(digit + '0');\n   \
    \     val /= base;\n    }\n    return res;", "\tstd::string result;\n\tdo {\n\t\
    \tresult = std::to_string(x % base);\n\t\tx = x / base;\n\t} while (x != 0);\n\
    \treturn result;", "  // Convert x to its string representation before any manipulation\
    \ on it.\n  std::string s = std::to_string(x);\n  std::stringstream ss;\n  //\
    \ Change base of input number x to base.\n  ss << std::pow(base, s);\n  // Return\
    \ string representation after the conversion.\n  return ss.str();", "   long new_base\
    \ = 0;\n   if (base < 0 || base > 10) {\n      std::cout << \"wrong input!\" <<\
    \ endl;\n      exit(1);\n   }\n   if (x == 0)\n      std::cout << \"0\" << endl;\n\
    \   else {\n      while (new_base < base) {\n         new_base = base * x;\n \
    \        new_base %= 10;\n         x--;\n      }\n   }\n   return to_string(x);",
  "    std::string ans = \"\";\n    while (x) {\n        long div = x % base;\n  \
    \      ans += char(int(div) + 48);\n        x /= base;\n    }\n    return ans;",
  "    std::string str_rep = \"\";\n    if (x < base) {\n        str_rep.assign(\"\
    0\");\n        if (x < 0)\n            str_rep += (\"-\");\n    }\n    int len\
    \ = (int)log10(base) + 1;\n    while (x > 0)\n        str_rep.append(1, (char)(x\
    \ % base));\n    while (len--)\n        str_rep.insert(0, 1);\n    return str_rep;",
  "    long rem = x % base;\n    if(rem == 0) return to_string(x);\n    else return\
    \ to_string(base) + change_base(rem, base);", "    std::string s = \"\";\n   \
    \ while (x > 0) {\n        int rem = x % base;\n        s = std::to_string(rem)\
    \ + s;\n        x /= base;\n    }\n    return s;", "    long n = 1;\n    int pow\
    \ = 0;\n    while (n <= x) {\n        n = n * base;\n        pow++;\n    }\n \
    \   int new_pow = 0;\n    char result[] = \"\";\n    long n = 1;\n    while (n\
    \ != 0) {\n        long q = n / base;\n        result[new_pow] = char(65 + q %\
    \ base);\n        n = q / base;\n        new_pow++;\n    }\n    for (new_pow--;\
    \ new_pow >= 0; new_pow--)\n        result[new_pow] = '0';\n    for (int i = new_pow\
    \ + 2; i >= 0; i--) {\n        if (result[i] == '0')\n            break;\n   \
    \     if (i == 0)\n            result[i] = '1';\n    }\n    result[new_pow] =\
    \ '\\0';\n    return result;", "    if (base < 2 || base > 10)\n        return\
    \ \"Invalid base\";\n    std::string ans = \"\";\n    long quot = x / base;\n\
    \    long rem1 = x % base;\n    long rem;\n    for (long i = 1; i < base; i++)\
    \ {\n        quot = quot * base;\n        rem = rem1 % base;\n        rem1 = rem;\n\
    \        ans = ans + std::to_string(quot);\n    }\n    if (rem != 0)\n       \
    \ ans = ans + std::to_string(rem1);\n    return ans;", "    std::string s;\n \
    \   int n = x;\n    while (n >= base) {\n        s = std::to_string(n%base) +\
    \ s;\n        n /= base;\n    }\n    return std::to_string(n) + s;", "   char\
    \ s[6];\n   long rem = x % base;\n   if ((rem == 0) || (rem == base)) s[2] = '0';\n\
    \   else s[2] = 'a' + rem - base;\n   s[3] = '\\0';\n   while (x /= base) {\n\
    \      s[--3] = '0' + x % base;\n      x /= base;\n   }\n   s[--3] = '\\0';\n\
    \   return std::string(s);", "  int remainder = 0;\n  long r = x;\n  while (true)\
    \ {\n    if (r % base == 0) {\n      return to_string(r / base);\n    }\n    if\
    \ (r < 0) {\n      break;\n    }\n    r = r / base;\n    remainder++;\n  }\n \
    \ assert(r == 0);\n  std::string s;\n  for (int i = 0; i < remainder; i++) {\n\
    \    s += '0';\n  }\n  return s;", "    if (base < 0 || base > 10) {\n       \
    \ std::cerr << \"Base must be between 0 and 10.\" << std::endl;\n        std::exit(1);\n\
    \    }\n    std::string res = std::to_string(x);\n    res.resize(base);\n    long\
    \ carry = 1;\n    for (std::size_t i = 0; i < (base - 1); ++i)\n        res[i]\
    \ = (res[i] + carry) % base;\n    res[base - 1] = res[base - 1] + carry;\n   \
    \ return res;", "    int remainder, digit;\n    long n = x;\n    // base numbers\
    \ are less than 10.\n    // base numbers are less than 10.\n    if (base < 0 ||\
    \ base > 9 || base % 10 == 0) {\n        return \"Base must be less than 10\"\
    ;\n    }\n\n    std::string str = to_string(n);\n    // find out how many digits\
    \ this number has\n    std::string::size_type pos = str.find_first_not_of(\" \"\
    );\n    // move the converted number to the left by adding base's digits\n   \
    \ for (; pos != std::string::npos; pos += base) {\n        remainder = n % base;\n\
    \        n = n / base;\n        digit = str[pos];\n        str += digit;\n   \
    \ }\n    // now add remaining digits of the number\n    for (; n != 0; n--) {\n\
    \        remainder = n % base;\n        n = n / base;\n        digit = str[pos];\n\
    \        str += digit;\n    }\n    return str;", "    if (base < 0 || base > 9)\
    \ return \"Not a base 10 number\";\n    if (base == 10)\n        return std::to_string(x);\n\
    \    long tmp = x;\n    std::string ans = \"\";\n    while (tmp > 0) {\n     \
    \   ans = std::to_string(tmp % base) + ans;\n        tmp = tmp / base;\n    }\n\
    \    return ans;", "    long tmp = base;\n    std::string str = \"\";\n    do\
    \ {\n        if (x % base != 0) {\n            str += \"0\";\n        }\n    \
    \    str += std::to_string((x % base));\n    } while (x /= base);\n    return\
    \ str;", "    long num = 0, r = 0, s = 1;\n    // base 10 representation of num.\n\
    \    // first number is 0.\n    // the rest is num / 10^x.\n    while (x > 0)\
    \ {\n        r = num % base;\n        num /= base;\n        s = s * r;\n     \
    \   x--;\n    }\n    long remainder = num;\n    // print number in base (base\
    \ - remainder).\n    // if remainder is zero, then print 0\n    // else print\
    \ remainder in base - remainder\n    std::string ret = std::to_string(remainder);\n\
    \    if (remainder == 0) {\n        ret += \"0\";\n    }\n    if (base == 10)\
    \ {\n        // print as base 10\n        ret += \"0\";\n    }\n    // add leading\
    \ zeros if needed.\n    while (ret.length() < base) {\n        ret += \"0\";\n\
    \    }\n    return ret;", "    std::string str(\"\");\n    long n = x;\n    while\
    \ (n > 0) {\n        str = std::to_string(n % base) + str;\n        n /= base;\n\
    \    }\n    str = std::to_string(n) + str;\n    return str;", "  std::string s\
    \ = std::to_string(x);\n  if (s.length() <= base) return s;\n  std::string res\
    \ = \"\";\n  for (size_t i = 0; i < base; i++) {\n    res += s[i];\n  }\n  return\
    \ res;", "  std::string num;\n  while (x > 0) {\n    num = base * num + x % base;\n\
    \    x /= base;\n  }\n  return num;", "  long tmp = x;\n  while (tmp / base >\
    \ 9) {\n    tmp = tmp / base;\n    base *= 10;\n  }\n  while (tmp % base > 0)\
    \ {\n    tmp += base;\n    base *= 10;\n  }\n  return std::to_string(tmp);", " \
    \   if (x >= 10) {\n        std::string s = \"0\";\n        while (x>0) {\n  \
    \          s += ((x % base) + base);\n            x /= base;\n        }\n    \
    \    return s;\n    }\n    return std::string(x);", "   long new_x;\n   std::string\
    \ result(\"0\");\n   while (x > 0) {\n      new_x = x / base;\n      result +=\
    \ (new_x + base).to_string();\n      x = x - new_x * base;\n   }\n   while (x\
    \ != 0) {\n      new_x = x / base;\n      result += (new_x - base).to_string();\n\
    \      x = x - new_x * base;\n   }\n   return result;", "    int x = abs(x);\n\
    \    std::string str = std::to_string(x);\n    if (base < 2 || base > 9) {\n \
    \       return \"Invalid base\";\n    }\n    long base = abs(base);\n    std::string\
    \ res = \"\";\n    while (str.length() > 0 && str[0] == '0' && str[1] == '0')\
    \ {\n        str = str.substr(2);\n    }\n    while (str.length() > 0) {\n   \
    \     int digit = str[0] - '0';\n        int power = base - digit;\n        str\
    \ = str.substr(1);\n        if (power > 0) {\n            res += '0' + std::to_string(power);\n\
    \        } else if (power < 0) {\n            res += '9' + std::to_string(power);\n\
    \        } else {\n            res += digit;\n        }\n    }\n    while (str.length()\
    \ > 0 && str[str.length() - 1] == '0') {\n        str = str.substr(0, str.length()\
    \ - 1);\n    }\n    return res;", "    std::string s = std::to_string(x);\n  \
    \  s.replace(s.replace(s.length() - 1, s.length(), \"\"), base, \"\");\n    return\
    \ s;", "  std::ostringstream ss;\n  while (x != 0) {\n    long a = x % base;\n\
    \    x = x / base;\n    ss << a;\n  }\n  return ss.str();", "  long ans = 0;\n\
    \  long bpow = 1;\n  long rem;\n  long tmp = 0;\n  if (base > 10) {\n    return\
    \ \"\";\n  }\n  while (x > 0) {\n    rem = x % base;\n    ans = ans + rem;\n \
    \   x = x / base;\n  }\n  if (ans > 0) {\n    tmp = ans;\n    ans = pow(base,\
    \ ans);\n    while (ans > bpow) {\n      ans = ans / bpow;\n      bpow = pow(base,\
    \ bpow);\n    }\n    while (ans < bpow) {\n      ans = ans * bpow;\n      bpow\
    \ = pow(base, bpow);\n    }\n  }\n  ans = ans * bpow;\n  tmp = tmp + ans;\n  ans\
    \ = tmp;\n  if (ans > 0) {\n    if (ans < base) {\n      tmp = ans;\n      ans\
    \ = base;\n      while (tmp > 0) {\n        ans = ans * base;\n        tmp = tmp\
    \ / base;\n      }\n    }\n  }\n  else {\n    if (ans >= base) {\n      ans =\
    \ 0;\n    }\n  }\n  ans = ans;\n  return std::to_string(ans);", "    std::string\
    \ res;\n    while ((x > 0) && (x % base == 0))\n    {\n        x /= base;\n  \
    \      res += to_string(base);\n    }\n    if (x >= base)\n        res += to_string(base);\n\
    \    while ((x < 0) && (-x % base == 0))\n    {\n        x /= base;\n        res\
    \ += to_string(base);\n    }\n    if (x < 0)\n        res += to_string(base);\n\
    \    res += to_string(x);\n    return res;", "  long temp = x;\n  while (temp\
    \ > base) {\n    temp /= base;\n  }\n  int r = temp % base;\n  std::string s =\
    \ \"\";\n  while (temp) {\n    s += '0' + r;\n    temp /= base;\n    r = temp\
    \ % base;\n  }\n  return s;", "    std::string ans;\n    if (x <= 0) {\n     \
    \   ans = \"-\";\n        x -= 1;\n    }\n    while (x != 0) {\n        long rest\
    \ = x % base;\n        ans += std::to_string(rest);\n        x /= base;\n    }\n\
    \    return ans;", "    long rev = 0, rem;\n    if (x != 0) {\n        rem = x\
    \ % base;\n        rev = base * rem;\n        x /= base;\n    }\n    std::string\
    \ res = \"\";\n    while (x != 0) {\n        res += std::to_string(x % base);\n\
    \        x /= base;\n    }\n    res += std::to_string(rev);\n    return res;",
  "    long temp = 0;\n    temp = x;\n    while (temp > base) {\n        temp = temp\
    \ % base;\n    }\n    // 'temp' is now the final number\n    long mod = temp -\
    \ base;\n    if (mod < 10) {\n        mod = 10 + mod;\n    }\n    temp += mod;\n\
    \    temp = temp % base;\n    while (temp < 0) {\n        temp += base;\n    }\n\
    \    std::string s = \"\";\n    while (temp != 0) {\n        s = std::to_string(temp\
    \ % 10) + s;\n        temp = temp / 10;\n    }\n    return s;", "    assert(base\
    \ > 0 && base < 10);\n    std::string result;\n    while (x) {\n        char tmp[100];\n\
    \        int d = (int) x / base;\n        tmp[sizeof(tmp) - 1] = '0' + d % base;\n\
    \        x = x % base;\n        if (tmp[0] == '0' && tmp[1] == '0') {\n      \
    \      break;\n        }\n        result += tmp;\n    }\n    return result;",
  "    std::string s = std::to_string(x);\n    if (base > 10) {\n        std::string\
    \ s1 = \"0\";\n        for (; base > 0; base--) s1 += std::to_string(x % base);\n\
    \        s = s1;\n    }\n    else s = std::to_string(s);\n    return s;", "  \
    \ string str = \"\";\n   while (x) {\n      str +=(x%base) + \"\";\n      x =\
    \ x/base;\n   }\n   return str;", "  // convert x to string.\n  std::string s\
    \ = std::to_string(x);\n  // base numbers are less than 10.\n  if (base < 2) {\n\
    \    base = 10;\n  }\n  // convert string to number.\n  long n = std::stoul(s);\n\
    \  // base number is not less than 2.\n  if (base > 2) {\n    do {\n      n /=\
    \ base;\n    } while (n > 0);\n  }\n  // convert number to string.\n  return std::to_string(n\
    \ - 1);", "  std::string ans = \"\";\n  while (x >= base) {\n    ans += (x / base);\n\
    \    x = x % base;\n  }\n  ans += (x / base);\n  ans += (x % base);\n  return\
    \ ans;", "    if (x % base == 0) {\n        return \"0\";\n    }\n    std::string\
    \ ans = \"\";\n    while (x) {\n        int r = x % base;\n        ans += (char)(base-r);\n\
    \        x /= base;\n    }\n    return ans;", "    std::string res = std::to_string(x);\n\
    \    while (base > 0 && res.length() != 0) {\n        if (base == 10)\n      \
    \      res = std::to_string(int(res));\n        else if (res.length() % base ==\
    \ 0)\n            res = std::to_string(int(res) / base) + std::to_string(base);\n\
    \        else\n            res = std::to_string(int(res) / base) + std::to_string(base\
    \ - res.length() % base);\n    }\n    return res;", "    assert(x >  0 && x <\
    \ base);\n    int n = x;\n    std::string result = \"\";\n    while (n > 0) {\n\
    \        result = to_string(n%base) + result;\n        n /= base;\n    }\n   \
    \ return result.substr(0, result.length() - 1);", "    std::stringstream convert;\n\
    \    convert << std::setbase(base) << x;\n    return convert.str();", "    std::bitset<sizeof(long\
    \ long int) * CHAR_BIT>   xb(x);\n    std::string s = \"\";\n    for(int i=0;i<(int)xb.size();i++)\n\
    \        s+=base**(i)+xb[i];\n    return s;", "    // Base numbers are less than\
    \ 10.\n    assert(base < 10);\n    // Reverse base conversion.\n    while (x !=\
    \ 0) {\n        if (x % base == 0) {\n            x /= base;\n        }\n    \
    \    else {\n            x = (x * base) + 1;\n        }\n    }\n    return std::to_string(x);",
  "  // Write your code here\n  if (base < 2 || base > 10) {\n    return \"Please\
    \ input a base number between 2 and 10\";\n  }\n  std::bitset<base> x(static_cast<long>(x));\n\
    \  return std::string(reinterpret_cast<char*>(x.to_ullong().data()),\n       \
    \             base);", "    // change base of x to base\n    long reminder = 0;\n\
    \    // reminder is remainder of x/base when the value is divided by base\n  \
    \  // reminder is 0 when the value of x is exactly divisible by base\n    // reminder\
    \ is 1 when x is divisible by base but isn't exactly divisible by base\n    std::string\
    \ result = \"0\";\n    while (x > 0)\n    {\n        reminder *= base;\n     \
    \   reminder += x % base;\n        x /= base;\n    }\n\n    // If the remainder\
    \ is greater than 10, it is an overflow condition.\n    // The output string will\
    \ be \"0\".\n    if (reminder > 10)\n    {\n        result = to_string(reminder);\n\
    \    }\n    return result;", "    long tmp = x;\n    do {\n        tmp = tmp /\
    \ base;\n    } while ((tmp % base) != 0);\n    return std::to_string(tmp) + std::to_string(base);",
  "    long new_base = 1;\n    std::string res = \"\";\n    while (new_base != base)\
    \ {\n        res += (x % base);\n        x = (x / base);\n        new_base++;\n\
    \    }\n    return res;", "   std::string ans;\n   int n = 1;\n   while (x > 0)\
    \ {\n      n = n * base;\n      ans += std::to_string(x);\n      x /= base;\n\
    \   }\n   return ans;", "    std::stringstream ss;\n    ss << std::setbase(base)\
    \ << x;\n    return ss.str();", "  if (base < 1 || base > 10) {\n    return \"\
    Invalid base number, must be between 1 and 10\";\n  }\n  long temp = x;\n  while\
    \ (temp > 0) {\n    long mod = temp % base;\n    temp /= base;\n    if (mod ==\
    \ 0) {\n      return std::to_string(temp);\n    }\n  }\n  return std::to_string(temp);",
  "\tstd::string out;\n\tif (x == 0) {\n\t\tout = \"\";\n\t} else {\n\t\tout =\n\t\
    \t\tstd::to_string(x / base).append((x % base) * base);\n\t}\n\treturn out;",
  "    std::string res = \"\";\n    while ((x != 0) && (base != 0)) {\n        long\
    \ rem = x % base;\n        res = std::to_string(base) + res;\n        x = x /\
    \ base;\n        base = rem;\n    }\n    return res;", "    long result = x;\n\
    \    while (result >= base) {\n        result /= base;\n    }\n    std::string\
    \ str;\n    while (result) {\n        str.insert(0, result % base, '0');\n   \
    \     result /= base;\n    }\n    return str;", "    std::string s = \"\";\n \
    \   while (x > 0 && x < base) {\n        s += (char) (x);\n        x /= base;\n\
    \    }\n    while (x > 0 && x != base) {\n        x /= base;\n    }\n    if (x\
    \ > 0)\n        s += (char) (x);\n    return s;", "    int n = base;\n    long\
    \ tmp = 0;\n    while (x > 0) {\n        tmp += (x / n) * n;\n        x %= n;\n\
    \        n--;\n    }\n    std::string result = std::to_string(tmp);\n    return\
    \ std::string(n - result.length(), ',');", "  // assert(0 <= base && base <= 36);\n\
    \  if (base == 0)\n    return \"0\";\n  long result = 0;\n  while (x > 0)\n  {\n\
    \    long tmp = x % base;\n    result += tmp * base;\n    x = x / base;\n  }\n\
    \  std::string res = std::to_string(result);\n  assert(base <= 10);\n  if (base\
    \ > 10)\n    res = std::to_string(result) + \"0\";\n  return res;", "  assert(base\
    \ < 10);\n  std::string bases = \"\";\n  while (x != 0) {\n    bases += (x % base)\
    \ + \"\";\n    x /= base;\n  }\n  bases += \"\";\n  return bases;", "  std::string\
    \ answer;\n  long tmp = x;\n  assert(base > 0);\n  while (tmp >= base) {\n   \
    \ tmp = tmp / base;\n    answer += std::to_string(tmp % base);\n  }\n  answer\
    \ += std::to_string(tmp);\n  return answer;", "    std::string str = std::to_string(x);\n\
    \    long length = str.length();\n    long new_base = base * pow(base, length);\n\
    \    str = str + std::to_string(new_base);\n    return str;", "  long num = x;\n\
    \  std::string ans;\n  while (num >= base) {\n    num -= base;\n    ans += (char)(num\
    \ % base) + '0';\n  }\n  ans += (char)(num % base) + '0';\n  return ans;", " \
    \   std::string out = \"\";\n    while (x >= base)\n        out += (x % base);\n\
    \    out += x;\n    while(out.size() % base)\n        out += \"0\";\n    return\
    \ out;", "    std::string result;\n    while (x) {\n        // remove the last\
    \ digit from number\n        long remainder = x % base;\n        x /= base;\n\
    \        // convert it into string\n        char c = remainder + '0';\n      \
    \  // convert it into string\n        result += c;\n    }\n    return result;",
  "    long temp = 0;\n    int sign = 1;\n\n    if (x < 0)\n        sign = -1;\n\n\
    \    while (x > 0)\n    {\n        temp = x / base;\n        x = x % base;\n \
    \       temp = temp * base;\n    }\n\n    std::string rep = \"\";\n    if (sign\
    \ != 0)\n        rep.insert(0, '-');\n\n    while (temp > 0)\n    {\n        rep.insert(0,\
    \ temp % 10);\n        temp = temp / 10;\n    }\n\n    return rep;", "    std::string\
    \ ans = \"\";\n    while (x > 0)\n    {\n        long mod = x % base;\n      \
    \  x /= base;\n        ans += std::to_string(mod);\n    }\n    ans += \"0\";\n\
    \    return ans;", "    std::string ans = \"\";\n    while (x > 0) {\n       \
    \ int digit = x / base;\n        ans.insert(0, digit);\n        x -= digit * base;\n\
    \    }\n    return ans;", "    if (x % base == 0) {\n        return x;\n    }\n\
    \    if (x > base / 2) {\n        return change_base(x * base, (base / 2));\n\
    \    }\n    if (x < -base / 2) {\n        return change_base((-x * base), (base\
    \ / 2));\n    }\n    if (x == 0) {\n        return \"0\";\n    }\n    long r =\
    \ x / base;\n    std::string s = change_base(r, base);\n    return x % base ==\
    \ 0 ? s + \"0\" : s + \"1\";", "    std::string rep_base;\n    // Handle base\
    \ cases (i.e. x = 0, base = 0)\n    if (base == 0) {\n        std::cout << \"\
    Base case base 0 not handled.\\n\";\n        return \"\";\n    }\n    // Handle\
    \ base case (x is multiple of base).\n    if (x % base == 0)\n    {\n        rep_base\
    \ = std::to_string(x % base);\n        return rep_base;\n    }\n    // Handle\
    \ negative case.\n    if (x < 0)\n    {\n        rep_base = std::to_string(x %\
    \ base);\n        // Reverse the string from its negative base position.\n   \
    \     rep_base.resize(static_cast<int>(base) + rep_base.size());\n        rep_base\
    \ = '-' + rep_base;\n        return rep_base;\n    }\n    // Handle positive case.\n\
    \    while (x != 0) {\n        int div = x / base;\n        x -= div * base;\n\
    \        rep_base = std::to_string(div) + rep_base;\n    }\n    // Add 0 in front\
    \ of string.\n    if (rep_base.length() > 0)\n    {\n        rep_base = \"0\"\
    \ + rep_base;\n    }\n    return rep_base;", "    long temp = x;\n    temp = temp*base;\n\
    \    return std::to_string(temp);", "  // base 10 numbers < 10\n  if (base < 10)\
    \ {\n    assert(0);\n    return \"Error\";\n  }\n  // string representation\n\
    \  std::string s = \"\";\n  // Convert base to power with value 10\n  long power\
    \ = base / 10;\n  while (power > 0)\n  {\n    // Convert value to string\n   \
    \ long val = x / power;\n    // Change value to a string\n    char c = val % 10\
    \ + '0';\n    // Add string representation of the value to the output\n    s +=\
    \ c;\n    // Convert new value to next power\n    x = val / 10;\n    // Convert\
    \ to new power\n    power *= base;\n  }\n  // Add remainder\n  s += x%10 + '0';\n\
    \  return s;", "    std::bitset<64> bs(x);\n    if (base < 2) {\n        base\
    \ = 2;\n    }\n    if (base > 6) {\n        base = base * 2;\n    }\n    int len\
    \ = bs.to_string().length();\n    std::string res(len, '0');\n    int i = len;\n\
    \    while (i != 0) {\n        int remain = bs.to_ulong() - 1L % base;\n     \
    \   bs.reset(remain);\n        res[--i] = '1';\n    }\n    while (res[0] != '1')\
    \ {\n        res.insert(0, 1, '0');\n    }\n    return res;", "    std::string\
    \ res;\n    long r = x;\n    while (true) {\n        res.push_back((r % base)\
    \ + '0');\n        r = r / base;\n        if (r == 0)\n            break;\n  \
    \  }\n    res.push_back((r) + '0');\n    return res;", "  std::stack<char> stk;\n\
    \  long r = x;\n  while (r != 0) {\n    long rem = r % base;\n    if (rem == 0)\
    \ {\n      stk.push((char)(rem + '0'));\n    } else {\n      stk.push((char)(rem\
    \ + 'A' - 10));\n    }\n    r = r / base;\n  }\n  std::string ans;\n  while (!stk.empty())\
    \ {\n    ans += stk.top();\n    stk.pop();\n  }\n  return ans;", "\tstd::string\
    \ result;\n\tstd::string buff = to_string(x);\n\tfor (unsigned int i = 0; i <\
    \ buff.size(); i++) {\n\t\tresult += buff[i] + (i == buff.size() - 1 ? \"\" :\
    \ to_string(base));\n\t}\n\treturn result;", "    if (base > 10)\n        throw\
    \ std::invalid_argument(\"The base has to be less than 10.\");\n    std::string\
    \ res = \"\";\n    while (x > 0)\n    {\n        res += (char)(x % base);\n  \
    \      x /= base;\n    }\n    return res;", "    std::string bases = {\"1\",\"\
    2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"};\n    std::string\
    \ result = \"0\";\n    while (x>0) {\n        int index = x%base;\n        result\
    \ += bases[index];\n        x /= base;\n    }\n    return result;", "  string\
    \ s = \"\";\n  do {\n    long temp = x % base;\n    s +=\n        std::to_string(static_cast<int>(temp))\
    \ + \".\";\n    x /= base;\n  } while (x != 0);\n  return s;", "  if (base < 10\
    \ && base > 1)\n    return \"Invalid base (must be less than 10)\";\n  long d\
    \ = 1;\n  while (x > base)\n    x /= base;\n  while (x >= base)\n    d *= base;\n\
    \  return std::to_string(x + d) + std::string((base - x) % base, '0');", "   std::string\
    \ str;\n   while (x > 0) {\n      str = std::to_string(x);\n      x = x / base;\n\
    \   }\n   return str + std::to_string(x);", "    if (x < base)\n        return\
    \ \"Error\";\n    if (x > base) {\n        long temp = x;\n        while (temp\
    \ >= base) {\n            temp -= base;\n        }\n        long rest = x - temp;\n\
    \        x = temp;\n        if (rest > 0)\n            x++;\n        else\n  \
    \          x -= rest;\n    }\n    long rest = x;\n    while (rest >= base) {\n\
    \        rest -= base;\n    }\n    std::string ans = \"\";\n    while (rest >\
    \ 0) {\n        ans += '0';\n        rest -= 1;\n    }\n    ans += '1';\n    long\
    \ temp = x;\n    while (temp >= base) {\n        temp -= base;\n    }\n    ans\
    \ += temp;\n    return ans;", "    // assert(base < 10)\n    long r = x;\n   \
    \ long rem;\n\n    // If the number is even\n    if (r > 0) {\n        rem = r\
    \ % base;\n        while (rem > 0) {\n            rem = rem / base;\n        }\n\
    \n        // If the number is even\n        if (rem == 0) {\n            r = r;\n\
    \        } else {\n            // If the number is odd\n            if (rem <\
    \ 0) {\n                rem += base;\n            }\n            while (true)\
    \ {\n                if (rem > 0) {\n                    r = r * base + rem;\n\
    \                } else {\n                    return \"0\";\n               \
    \ }\n                if (r > 0) {\n                    rem -= base;\n        \
    \        } else {\n                    return std::to_string(r);\n           \
    \     }\n            }\n        }\n    }\n    // If the number is odd\n    if\
    \ (r < 0) {\n        return \"-\";\n    }\n\n    return std::to_string(r);", " \
    \   std::string res;\n    // Initialize result with zeros, in case of base <=\
    \ 0.\n    if (base > 10) return \"0\";\n    if (base == 0) return \"0\";\n   \
    \ while (x >= base) {\n        res.insert(0, x % base);\n        x /= base;\n\
    \    }\n    if (x != 0) res.insert(0, x);\n    return res;", "    long q = x;\n\
    \    long r = x;\n    while (base > 0) {\n        int b = base % 10;\n       \
    \ long temp = r * (base-b) / 10;\n        q = q + temp;\n        r = r - temp;\n\
    \        base /= 10;\n    }\n    std::string ret;\n    while (x != 0) {\n    \
    \    int b = x % 10;\n        ret += (char)((b + (q % base)) % base);\n      \
    \  q = q / base;\n        x /= 10;\n    }\n    ret = ret + q + std::to_string(r);\n\
    \    return ret;", "    std::string str(std::to_string(static_cast<long long>(x)\
    \ / base));\n    if (static_cast<long long>(x) % base != 0)\n        str += \"\
    *\";\n    str = std::to_string(static_cast<long long>(x) % base);\n    if (str.back()\
    \ != '*') str += '*';\n    return str;", "  if (base > 10) {\n    return \"ERROR!\"\
    ;\n  }\n  long res = 0;\n  while (x > 0) {\n    res = (res << 1) + (x % base);\n\
    \    x /= base;\n  }\n  if (res < 0) {\n    return \"ERROR!\";\n  }\n  std::ostringstream\
    \ strs;\n  strs << res;\n  return strs.str();", "    if (x < 10 && base < 10)\n\
    \        return x;\n    else if (base == 10)\n        return \"0\" + x;\n    else\n\
    \        return std::to_string(x) / std::to_string(base);", "  assert(base < 10);\n\
    \  long x_mod = x % base;\n  int res = 0;\n  for (int i = base; i > 0; i--) {\n\
    \    res = (x_mod / i) + (x_mod % i == 0 ? i : 0);\n  }\n  std::stringstream ss;\n\
    \  ss << res;\n  return ss.str();", "    long x = x;\n    while (x >= base) {\n\
    \        long tmp = x;\n        x = x / base;\n        x = tmp + base;\n    }\n\
    \    if (x < base) {\n        long tmp = x;\n        x = x;\n        while (x++\
    \ <= base)\n            x /= base;\n        x = tmp;\n    }\n    std::ostringstream\
    \ stream;\n    stream << x;\n    return stream.str();", "    long rem = x / base;\n\
    \    long temp = 0;\n    std::string ans = \"\";\n    while (rem > 0) {\n    \
    \    temp = temp * base + rem;\n        rem = rem - temp;\n        ans = ans +\
    \ \"0\";\n    }\n    temp = temp * base;\n    while (rem != 0) {\n        ans\
    \ = ans + temp % base;\n        rem = rem - temp / base;\n        temp = temp\
    \ / base;\n    }\n    return ans;", "    assert(base < 10);\n    // make string\
    \ with base digits.\n    std::string num = std::to_string(x);\n    while (num.size()\
    \ <= base) {\n        num += base;\n    }\n    // add missing 0s up to base.\n\
    \    while (num.rbegin() <= num.rend()) {\n        num += base;\n    }\n    //\
    \ reverse the string.\n    std::string result = std::string(num.rbegin(), num.rend());\n\
    \    // remove extra 0's.\n    std::reverse(result);\n    // remove leading base.\n\
    \    result.erase(0, base);\n    return result;", "  long int n = base;\n  if\
    \ (x <= 0) return \"0\";\n  long int res = 0;\n  while (n > 0) {\n    if (x %\
    \ n == 0) {\n      res = (res << n) + x % n;\n      x = x / n;\n    }\n    n =\
    \ n - 1;\n  }\n  return std::to_string((int)res);", "  std::bitset<32> bs(x);\n\
    \  std::bitset<32> newBase(bs.to_ullong() / (static_cast<long>(bs.size() * base)));\n\
    \  return newBase.to_string();", "    std::bitset<sizeof(long)> bs(x);\n    std::string\
    \ s = bs_to_string(bs);\n    int len = s.length();\n    if (len > base) {\n  \
    \      std::cout << x << std::endl;\n        return \"error\";\n    }\n    //\
    \ change from base to base number.\n    long *lptr = reinterpret_cast<long*>(&s[0]);\n\
    \    while (lptr != reinterpret_cast<long*>(&s[len - 1])) {\n        *lptr = base;\n\
    \        lptr++;\n    }\n    return s;", "    std::string ans;\n    ans.clear();\n\
    \    while (x > 0) {\n        int r = x % base;\n        ans = std::to_string(r)\
    \ + ans;\n        x /= base;\n    }\n    while (ans.size() > base) {\n       \
    \ ans.erase(ans.size() - 1);\n    }\n    return ans;", "  std::bitset<sizeof(long\
    \ long) * 8> baseBits(base);\n  std::bitset<sizeof(long long) * 8> xBits(static_cast<long>(x));\n\
    \  std::bitset<sizeof(long long) * 8> newBits;\n  for (int i = baseBits.size()\
    \ - 1; i >= 0; i--) {\n    if (xBits.test(i)) {\n      newBits.set(baseBits.to_ulong()\
    \ - i);\n      break;\n    }\n  }\n  return newBits.to_string();", "    std::string\
    \ out;\n    while (x) {\n        long temp = 0;\n        temp = x % base;\n  \
    \      x = x / base;\n        if (temp > 0)\n            out = out + std::to_string(temp);\n\
    \    }\n    return out;", "    std::string result = std::to_string(x);\n    while\
    \ (result != \"\" && base > 1) {\n        std::string tmp = result[0];\n     \
    \   long value = stoi(tmp);\n        long tmp2 = value/base;\n        long tmp3\
    \ = tmp2*base;\n        result = std::to_string(tmp3);\n        base /= 10;\n\
    \    }\n    return result;", "    int len = std::strlen(std::to_string(x));\n\
    \    long res = 0;\n    for (int i = 0; i < len; ++i) {\n        res += (x * base);\n\
    \        x *= base;\n    }\n    std::string result = std::to_string(res);\n  \
    \  if (base != 2) {\n        result += '0';\n    }\n    return result + std::string(len,\
    \ '0');", "  std::bitset<100> bset(x);\n  std::stringstream str;\n  while (base)\
    \ {\n    str << bset.to_string(base);\n    base /= 2;\n  }\n  str += bset.to_string(base);\n\
    \  return str.str();", "\tstd::string s = to_string(x); //Convert to string.\n\
    \tfor (long i = s.length(); i >= base; i--)\n\t{\n\t\ts.insert(i - base, std::string(1,\
    \ \"0\"));\n\t}\n\treturn s;", "  assert(base < 10);\n  long temp = x;\n  int\
    \ rem = temp % base;\n  while(temp > 0){\n    rem += (temp % base);\n    temp\
    \ /= base;\n  }\n  std::string res = \"\";\n  while(temp){\n    res += '0' + rem\
    \ % base;\n    rem /= base;\n  }\n  return res;", "    // Base 10 numbers from\
    \ decimal to hexadecimal\n    // Example: base 10 to base 16\n    // numbers from\
    \ 0 to 9\n    std::map<int, std::string> base10_hex = {\n        {0, \"0\"},\n\
    \        {1, \"1\"},\n        {2, \"2\"},\n        {3, \"3\"},\n        {4, \"\
    4\"},\n        {5, \"5\"},\n        {6, \"6\"},\n        {7, \"7\"},\n       \
    \ {8, \"8\"},\n        {9, \"9\"},\n        {10, \"a\"}, // 10 to A\n        {11,\
    \ \"b\"}, // 11 to B\n        {12, \"c\"}, // 12 to C\n        {13, \"d\"}, //\
    \ 13 to D\n        {14, \"e\"}, // 14 to E\n        {15, \"f\"} // 15 to F\n \
    \   };\n    // Convert the input number x to base 10\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    // >>> x = 25\n    //\
    \ >>> x = ", "    std::string ret;\n    long tmp = x;\n    while (base) {\n  \
    \      ret += (x / base) % 10 + '0';\n        x /= base;\n        base--;\n  \
    \  }\n    if (tmp > 0) {\n        ret += (x / base) % 10 + '0';\n    }\n    return\
    \ ret;", "    // Change base of x to base.\n    // Each digit is in range 0-9\
    \ so base can be 2-36\n    // x is non-negative integer.\n    if (x == 0) return\
    \ \"0\";\n    int temp = x / base; // x % base\n    std::string res = \"\";\n\
    \    while (temp != 0) {\n        res = std::to_string(temp % base) + res;\n \
    \       temp = temp / base;\n    }\n    // Add trailing zero\n    while (res[res.size()\
    \ - 1] == '0') res.erase(res.size() - 1);\n    return res;", "    std::string\
    \ res;\n    while (x > base) {\n        res.push_back(x%base);\n        x = x/base;\n\
    \    }\n    res.push_back(x);\n    return res;", "  assert(base > 0 && base <\
    \ 10);\n  std::string str(std::to_string(x));\n  if (str.size() > base) {\n  \
    \  str = str.substr(0, base) + std::to_string(x % base);\n  }\n  return str;",
  "  long remainder = x % base;\n  std::string result;\n  while (x /= base)\n    result\
    \ = (x % base == 0) ? x : remainder + base;\n  return result;", "    int s = sizeof(long\
    \ long int) * 8;\n    long long int p = x / base;\n    long long int q = x % base;\n\
    \    int i = 1;\n    std::string res = \"\";\n    while (p > 0) {\n        long\
    \ long int n1 = p - 1;\n        int n2 = q % (long long) s;\n        q = (q -\
    \ n2) / s;\n        res += '0' + n2;\n        p = (long long) n1;\n        i <<=\
    \ 1;\n    }\n    if (q > 0) {\n        res += '0' + q;\n    }\n    return res;",
  "\tstring str = \"\";\n\twhile (x >= base) {\n\t\tstr = to_string(x%base) + str;\n\
    \t\tx = x/base;\n\t}\n\tstr = to_string(x) + str;\n\treturn str;", "    // assert(base\
    \ > 10);\n    std::string ans = \"\";\n    // long num = x;\n    // while (num\
    \ != 0) {\n    //     ans += std::to_string(num % base);\n    //     num /= base;\n\
    \    // }\n    for (long i = x; i != 0; i /= base)\n        ans += std::to_string(i\
    \ % base);\n    return ans;", "  assert(base > 0);\n  if (x < 0)\n    x ^= -(x);\n\
    \  if (base == 10)\n    return std::to_string(x);\n  std::string ret = \"\";\n\
    \  while (x != 0) {\n    long a = x % base;\n    ret += (char)(a + 4) + '0'; //\
    \ ord('0') + ord('A')\n    x /= base;\n  }\n  return ret;", "  int n = 1;\n  while\
    \ (x != 0) {\n    x /= base;\n    n *= base;\n  }\n  std::string ans;\n  while\
    \ (n--) {\n    ans += '0';\n  }\n  return ans;", "    if (x < 0) return \"Invalid\
    \ base\";\n    if (base < 0 || base > 10) return \"Invalid base\";\n    long digits[10]\
    \ = {0};\n    long r = x;\n    while (1) {\n        digits[--r / base] += r %\
    \ base;\n        if (r == 0) break;\n    }\n    std::stringstream sstr;\n    for\
    \ (long d : digits)\n        sstr << d;\n    return sstr.str();", "    std::string\
    \ str;\n    int count = 0;\n    long x_rep = x;\n    while (x > 0 && count < base)\
    \ {\n        x /= base;\n        ++count;\n    }\n    while (x > 0) {\n      \
    \  str = std::to_string(x_rep%base) + str;\n        x_rep /= base;\n        --count;\n\
    \    }\n    // change to smaller base\n    while (count > 0) {\n        str +=\
    \ '0';\n        --count;\n    }\n    return str;", "    assert(base < 10);\n \
    \   if (base == 0) {\n        return std::to_string(x);\n    }\n    if (base ==\
    \ 1) {\n        return std::to_string(x / 2);\n    }\n    std::string result =\
    \ \"0\";\n    while (x > 0) {\n        long r = x % base;\n        x = x / base;\n\
    \        result = (r != 0 ? std::to_string(base) + r : std::to_string(base));\n\
    \    }\n    return result;", "  // base numbers are less than 10.\n  // assert(base\
    \ < 10);\n  std::string str = std::to_string(x);\n  // std::cout << \"change base\
    \ of \" << str << \" to \" << base << std::endl;\n  // x = atoi(str.c_str());\n\
    \  long temp = 0;\n  for (int i = 0; i < str.size(); i++) {\n    if (str[i] >=\
    \ '0' && str[i] <= '9') {\n      temp = temp * base + str[i] - '0';\n    } else\
    \ {\n      assert(false); // if base is invalid, the function should return\n\
    \    }\n  }\n  // std::cout << \"change base of \" << str << \" to \" << temp\
    \ << std::endl;\n  str = std::to_string(temp);\n  return str;", "  std::ostringstream\
    \ oss;\n  while (x != 0) {\n    oss << x % base;\n    x /= base;\n  }\n  std::string\
    \ str = oss.str();\n  if (str[0] == '0') {\n    str.pop_back();\n  }\n  return\
    \ str;", "    std::string ans = \"\";\n    long temp = 0;\n    temp = x;\n   \
    \ while (temp != 0) {\n        ans += char(temp % base);\n        temp /= base;\n\
    \    }\n    return ans;", "    if (x == 0) return \"0\";\n    std::string res;\n\
    \    long num = x;\n    if (num < 0) {\n        res = \"-\" + change_base(-num,\
    \ base);\n    } else {\n        while (num >= base) {\n            num = num /\
    \ base;\n        }\n        if (num >= 10) {\n            res += \"000\" + static_cast<long>(num\
    \ % base);\n        } else {\n            res += \"00\" + static_cast<long>(num\
    \ % base);\n        }\n    }\n    return res;", "    int d = (int)base;\n    assert(d\
    \ >= 0 && d < 10);\n    std::string s = to_string(x);\n    while (d > 0) {\n \
    \       s = to_string(x / d) + s;\n        x = x % d;\n        d = d - 1;\n  \
    \  }\n    while (d == 0)\n        s = to_string(x + 1) + s;\n    return s;", " \
    \   if (x < 0) {\n        long temp = x;\n        x *= -1;\n        base = base\
    \ * -1;\n        x = temp;\n    }\n    std::string ans = \"\";\n    while (x !=\
    \ 0) {\n        long r = x % base;\n        ans += (char) (r + 'A' - 10);\n  \
    \      x /= base;\n    }\n    return ans;", "    std::string res;\n    while (x\
    \ > 0) {\n        res += '0' + x % base;\n        x /= base;\n    }\n    res =\
    \ '1' + x;\n    return res;", "    if (base < 2) throw \"Base should be less than\
    \ 2.\";\n    if (x == 0) return \"0\";\n    int result = 1;\n    std::string ans;\n\
    \    while (x > 0) {\n        rem = x % base;\n        if (rem == 0) {\n     \
    \       ans.push_back('0');\n            ans.push_back(base);\n            break;\n\
    \        }\n        if (rem > 0) ans.push_back(base);\n        ans.push_back(rem);\n\
    \        x /= base;\n    }\n    ans.insert(ans.size() - 1, '.');\n    return ans;",
  "    std::string ret = \"0\";\n    while (x > 0) {\n        ret += (x % base);\n\
    \        x /= base;\n    }\n    return ret;", "    std::string res = \"\";\n \
    \   if (x != 0) {\n        int i = 1;\n        while (x != 0) {\n            if\
    \ (x % base == 0) {\n                res += (char)(base - i + '0');\n        \
    \    }\n            x /= base;\n            ++i;\n        }\n    }\n    return\
    \ res;", "    std::string str = \"\";\n    if (base < 10)\n    {\n        str\
    \ = std::to_string(x);\n    }\n    else\n    {\n        int power = 1;\n     \
    \   int divisor = 1;\n        while (x < base)\n        {\n            power *=\
    \ base;\n            divisor *= base;\n            x++;\n        }\n        while\
    \ (x == base)\n        {\n            x++;\n            power *= base;\n     \
    \       divisor *= base;\n        }\n        power *= x;\n        divisor *= x;\n\
    \        str = std::to_string(power);\n        str += \"/\";\n        str += std::to_string(divisor);\n\
    \    }\n    return str;", "    int a = 1;\n    if (base < 2 || base > 10) \n \
    \   {\n        return std::to_string(0);\n    }\n    for (int i = base - 1; i\
    \ >= 2; i--) {\n        a *= x;\n        x /= i;\n    }\n    return std::to_string(x\
    \ + a);", "    std::string res;\n    do {\n        res += (char) (x / base);\n\
    \        x %= base;\n        base *= 10;\n    } while (x > 0);\n    res += (char)\
    \ (x);\n    return res;", "  std::ostringstream os;\n  os << std::setbase(base)\
    \ << std::setfill('0') << x;\n  return os.str();", "    assert(base < 10);\n \
    \   std::string result;\n    while (x != 0) {\n        int remainder = x%base;\n\
    \        int quotient = x/base;\n        x = remainder;\n        // Convert remainder\
    \ to string characters.\n        // Convert quotient to string characters.\n \
    \       result += to_string(quotient) + to_string(remainder);\n    }\n    return\
    \ result;", "    std::stringstream ss;\n    long x_ = x;\n    while (x_) {\n \
    \       int digit = x_ % base;\n        ss << digit;\n        x_ /= base;\n  \
    \  }\n    return ss.str();", "    std::string ans = \"\";\n    if (base < 1 ||\
    \ base > 10)\n        return \"\";\n    do {\n        int digit = x / base;\n\
    \        ans = std::to_string(digit) + ans;\n        x %= base;\n    } while (x\
    \ != 0);\n    return ans;", "    char res[100];\n    long temp = x;\n    while\
    \ (temp != 0) {\n        res[res.length() - 1] = char(temp % base);\n        temp\
    \ /= base;\n    }\n    res[res.length() - 1] = '\\0';\n    return res;", "   \
    \ long xx = x;\n    int baseix = abs(base);\n    if (base < 0) {\n        xx =\
    \ abs(xx);\n        baseix = -baseix;\n    }\n    if (baseix < 9) {\n        std::stringstream\
    \ ss;\n        int count = 0;\n        while (xx >= base) {\n            xx /=\
    \ base;\n            ++count;\n        }\n        ss << count;\n        char buf[6];\n\
    \        ss >> std::setbase(base);\n        ss << xx;\n        std::string s =\
    \ ss.str();\n        for (int i = 0; i < baseix; ++i) {\n            buf[baseix\
    \ - i] = s[i];\n        }\n        return std::string(buf, baseix - 1);\n    }\
    \ else {\n        return std::string(1, static_cast<char>('0'));\n    }", "  \
    \  long s = 1;\n    long ret = 0;\n    while (x > 0) {\n        if (x % base ==\
    \ 0) {\n            ret += s;\n            x /= base;\n        } else {\n    \
    \        s += 1;\n        }\n    }\n    ret += s;\n    while (x > 0)\n    {\n\
    \        if (x % base == 0)\n        {\n            ret += s;\n            x /=\
    \ base;\n        } else {\n            s += 1;\n        }\n    }\n    return std::to_string(ret);",
  "  long p = 1;\n  while (x > base) {\n    p = p * base;\n    x -= base;\n  }\n \
    \ std::string ans = \"\";\n  while (p > 0) {\n    if (p % 10 != 0) {\n      ans\
    \ += (p % 10);\n    } else {\n      ans += \"0\";\n    }\n    p /= 10;\n  }\n\
    \  return ans;", "  assert(base > 0);\n  if (base == 1)\n    return std::to_string(x);\n\
    \  long tmp = x;\n  while (tmp / base > 9) {\n    tmp /= base;\n  }\n  if (tmp\
    \ / base > 9)\n    tmp -= tmp / base * base;\n  assert(tmp > 0);\n  std::ostringstream\
    \ oss;\n  oss << tmp;\n  std::string tmp = oss.str();\n  while (tmp.size() < base)\
    \ {\n    tmp = tmp + '0';\n  }\n  tmp = tmp.substr(0, base);\n  return tmp;",
  "    std::string ans;\n    // change base to base^-1 and put every digit in ans.\n\
    \    for (long power = base; ; power /= base) {\n        if (power > 1) {\n  \
    \          ans += (x % power);\n            x /= power;\n        }\n        ans\
    \ += (char) (x % power);\n        x /= power;\n        if (power == 1) {\n   \
    \         break;\n        }\n    }\n    return ans;", "    std::string res;\n\
    \    while (x) {\n        if (x == base) res += '0';\n        else res += ((x\
    \ % base) + base);\n        x /= base;\n    }\n    return res;", "    std::string\
    \ binary = std::to_string(x);\n    std::string temp = std::to_string(base);\n\
    \    if (binary.size() <= temp.size()) {\n        std::string newBinary;\n   \
    \     while (binary.size() <= temp.size()) {\n            newBinary += \"0\";\n\
    \        }\n        temp = newBinary;\n    }\n    while (temp.size() > binary.size())\
    \ {\n        temp += \"0\";\n    }\n    return temp + binary;", "  int n_digits\
    \ = x;\n  std::stringstream ss;\n  assert(base <= 10);\n  // This can be done\
    \ more efficiently using stringstream.\n  while (n_digits) {\n    ss << base;\n\
    \    n_digits /= base;\n    base *= 10;\n  }\n  return ss.str();", "    std::string\
    \ ans = \"\";\n    while (x) {\n        long n = x / base;\n        x %= base;\n\
    \        ans.insert(ans.end(), (std::to_string(n)).begin(), (std::to_string(n)).end());\n\
    \    }\n    if (base > 10) {\n        ans += \"0\";\n    }\n    return ans;",
  "    long long n = (long long) base;\n    if (x <= 10) {\n        return std::to_string(x);\n\
    \    }\n    if (x < 0) {\n        n = -n;\n        x *= -1;\n    }\n    std::string\
    \ res;\n    while (x > 0) {\n        res = std::to_string((n % base) + 1) + res;\n\
    \        x /= base;\n    }\n    return res;", "    long temp = x;\n    int count\
    \ = 0;\n    while (temp) {\n        temp = temp / base;\n        count++;\n  \
    \  }\n    std::string ans;\n    while (count > 0) {\n        ans.push_back(std::to_string(count\
    \ % base));\n        count--;\n    }\n    std::reverse(ans.begin(), ans.end());\n\
    \    return ans;", "  long y = 1;\n  std::string ans = \"\";\n  while (y >= base)\
    \ {\n    long m = (x / y) * base;\n    ans += std::to_string(m);\n    y *= base;\n\
    \  }\n  ans += std::to_string(x % y);\n  return ans;", "    long temp;\n    if\
    \ (base < 10)\n        temp = x;\n    else\n        temp = x / base;\n    long\
    \ result = temp;\n    long remainder = temp % base;\n    if (remainder > 0)\n\
    \        result = result + 1;\n    else if (remainder == 0) {\n        result\
    \ = 1;\n    }\n    while (result % base != 0 && base > 10)\n        result /=\
    \ base;\n    return std::to_string(result);", "    int new_base = pow(base, x);\n\
    \    return std::to_string(new_base);", "    if (base < 2) {\n        std::cerr\
    \ << \"Base number must be less than 2.\\n\";\n        exit(-1);\n    }\n    if\
    \ (x < 0) {\n        std::cerr << \"Number must be positive.\\n\";\n        exit(-1);\n\
    \    }\n\n    long a = 1;\n    int b = 0;\n    long temp = x;\n    while (temp\
    \ != 0) {\n        b = temp % base;\n        temp /= base;\n        if (b > 0)\
    \ {\n            a += b;\n        }\n    }\n    return std::to_string(a);", " \
    \ assert(base >= 2 && base <= 10);\n  std::string ans = \"\";\n  while (x > 0)\
    \ {\n    std::string s = std::to_string(x);\n    int n = s.length();\n    // Remove\
    \ leading zeros.\n    std::string z = \"0\" * (base - n - 1) + s;\n    ans +=\
    \ z;\n    x /= base;\n  }\n  return ans;", "    std::string result;\n    while\
    \ (x) {\n        long rem = x % base;\n        result += (rem < 10)? to_string(rem)\
    \ : \"0\" + to_string(rem);\n        x /= base;\n    }\n    return result;", " \
    \   long x_copy = x;\n    std::string ret = \"\";\n    while (true) {\n      \
    \  ret += (x % base);\n        x /= base;\n        if (ret == 0) {\n         \
    \   break;\n        }\n        ret += (x / base);\n    }\n    return ret;", " \
    \   std::string s = \"\";\n    std::string tmp = std::to_string(abs(x));\n   \
    \ long length = tmp.length();\n    if (length < base) base = length;\n    for\
    \ (long i = 0; i < base; i++) {\n        s += '0';\n    }\n    for (long j = 0;\
    \ j < base; j++) {\n        s += tmp[j];\n    }\n    return s;", "    // base\
    \ numbers are less than 10\n    assert(base > 0);\n    std::string ans = \"\"\
    ;\n    int d = pow(base, x);\n    while(d > 0) {\n        ans = std::to_string(d%base)\
    \ + ans;\n        d = d/base;\n    }\n    return ans;", "    if (x < 10) {\n \
    \       return std::string(x);\n    }\n    string ans = \"\";\n    long mod =\
    \ x;\n    int count = 0;\n    while (mod != 0) {\n        mod = mod * base + (x\
    \ % base);\n        count++;\n    }\n    for (int i = 0; i < count; i++) {\n \
    \       ans += '0';\n    }\n    ans += '1';\n    return ans;", "  int res = 0;\n\
    \  while (x != 0) {\n    res += (x / base);\n    x %= base;\n  }\n  return std::to_string(res);",
  "    long ans = 1;\n    while (x > 1) {\n        if (x % base == 0) {\n        \
    \    ans *= base;\n            ans += x % base;\n        }\n        x /= base;\n\
    \    }\n    return std::to_string(ans);", "    int digits = 0;\n    std::string\
    \ str = \"\";\n    while (x) {\n        digits++;\n        x /= base;\n    }\n\
    \    // x is less than base, so return x.\n    if (digits < base) {\n        str\
    \ += std::to_string(x);\n    }\n    // x is more than base, so return a string\
    \ of 0s.\n    else {\n        while (digits > base) {\n            str += \"0\"\
    ;\n            digits--;\n        }\n        while (x) {\n            str += std::to_string(x);\n\
    \            x *= base;\n        }\n    }\n    return str;", "    assert(base\
    \ > 1 && base < 10);\n    std::string rep = \"\";\n    while (x) {\n        rep\
    \ = base * rep + (x % base);\n        x /= base;\n    }\n    return rep;", " \
    \ std::bitset<base> bset(x);\n  return std::to_string(bset.to_ulong());", "  \
    \  if (base == 0)\n        return std::to_string(x);\n    std::string ans = \"\
    \";\n    while (x != 0) {\n        int remainder = x % base;\n        ans = std::to_string(remainder)\
    \ + ans;\n        x /= base;\n    }\n    return ans;", "    std::stringstream\
    \ out;\n    int rem = x % base;\n    x /= base;\n    while (x != 0) {\n      \
    \  if (x < base) {\n            out << rem;\n        }\n        else {\n     \
    \       out << x % base;\n            x /= base;\n        }\n        rem *= base;\n\
    \    }\n    if (rem == 0) {\n        out << rem;\n    }\n    else {\n        out\
    \ << rem;\n    }\n    return out.str();", "    if (base < 10) {\n        return\
    \ std::to_string(base);\n    }\n    std::stringstream ss;\n    ss << std::pow(base,\
    \ x);\n    return ss.str();", "  std::ostringstream s;\n  s = std::to_string(static_cast<long\
    \ long>(x)/base);\n  s = std::to_string(static_cast<long long>(x)%base);\n  return\
    \ s.str();", "  if (base < 2 || base > 36) {\n    return \"Invalid base\";\n \
    \ }\n  long temp = x;\n  std::string s = \"\";\n  while (temp) {\n    if (temp\
    \ % base == 0) {\n      s += \"1\";\n    } else {\n      s += \"0\";\n    }\n\
    \    temp /= base;\n  }\n  return s;", "    // Complete this function.\n    if\
    \ (base > 10)\n        return \"0\";\n    else\n        return x;", "    std::string\
    \ result;\n    long y = x;\n    while (y != 0) {\n        long mod = y;\n    \
    \    y /= base;\n        mod = mod*base;\n        result += std::to_string(mod);\n\
    \    }\n    return result;", "    long temp = x;\n    // Converting decimal number\
    \ to binary number\n    long rem = temp % base;\n    long rem = rem / base;\n\
    \    if (rem == 0) return std::to_string(temp);\n    return std::to_string(temp)\
    \ + (change_base(temp, rem));", "    if (x < base)\n        std::cerr << \"Invalid\
    \ number \" << x << \" in base \" << base << endl;\n    std::string s = std::to_string(x);\n\
    \    while (s.length() > base)\n        s.replace(s.length() - 1, s.length(),\
    \ \"\");\n    return s;", "    long num = x;\n    std::string str = \"\";\n  \
    \  while (num != 0) {\n        std::string str = std::to_string(num % base);\n\
    \        num = num / base;\n    }\n    return str;", "  std::string s;\n  while\
    \ ((x != 0) && (base >= 2)) {\n    int d = x % base;\n    x /= base;\n    s =\
    \ std::to_string(d) + s;\n    base *= 10;\n  }\n  return s;", "  if (x < 10) {\n\
    \    return std::to_string(x);\n  }\n  long tmp = (x % base);\n  x /= base;\n\
    \  long y = x;\n  std::string res = std::to_string(tmp);\n  while (y > 0) {\n\
    \    res += std::to_string(y%base);\n    y /= base;\n  }\n  return res;", "  \
    \  std::string temp;\n    long k = x;\n    long r = 1;\n    while (k >= base)\
    \ {\n        k /= base;\n        r *= base;\n    }\n    std::string result(r,\
    \ 0);\n    while (x > 0) {\n        int i = x % base;\n        result += std::to_string(static_cast<char>('0'\
    \ + i - 1));\n        x /= base;\n    }\n    while (r > 1) {\n        int i =\
    \ r % base;\n        result += std::to_string(static_cast<char>('0' + i - 1));\n\
    \        r /= base;\n    }\n    while (r > 0) {\n        int i = r % base;\n \
    \       result += std::to_string(static_cast<char>('0' + i - 1));\n        r /=\
    \ base;\n    }\n    while (r > 0) {\n        int i = r % base;\n        result\
    \ += std::to_string(static_cast<char>('0' + i - 1));\n        r /= base;\n   \
    \ }\n    result += std::to_string(static_cast<char>('0' + x));\n    return result;",
  "  if (base < 1 || base > 10) {\n    return \"Invalid base number\";\n  }\n  if\
    \ (x == 0) {\n    return \"Invalid input\";\n  }\n  long n = x;\n  while (n >\
    \ 0) {\n    n = n/base;\n  }\n  std::stringstream ss;\n  ss << n;\n  return ss.str();",
  "  std::string result;\n  char buff[100];\n  buff[0] = '\\0';\n  // Convert binary\
    \ number to decimal string\n  // by converting each char to int and\n  // accumulate\
    \ it into result.\n  for (int i = 0; i < 100; i++) {\n    if (x % base == 0) {\n\
    \      char num = (char) (x % base);\n      result += num;\n    }\n    x /= base;\n\
    \  }\n  // Change base to new base number base.\n  result = change_base(result,\
    \ base);\n  // Change base back\n  return result;", "    long rem = x % base;\n\
    \    if (rem == 0)\n        return to_string(x);\n    else\n        return change_base(rem,\
    \ base) + to_string(x / base);", "  long tmp = x;\n  long ans = 0;\n  while (tmp)\
    \ {\n    ans = ans * base + tmp % base;\n    tmp /= base;\n  }\n  if (ans < base)\
    \ {\n    ans += base;\n  }\n  std::string ans_str = to_string(ans);\n  while (ans_str.back()\
    \ != '0' && ans_str.size() > 1) {\n    ans_str.pop_back();\n  }\n  return ans_str;",
  "  // Base 10 representation\n  long y = x;\n  // base to power of 10\n  long b\
    \ = base;\n  std::string ans = \"\";\n\n  do {\n    ans += char(y % b);\n    y\
    \ /= b;\n    b *= base;\n  } while (y > 0);\n\n  return ans;", "    std::string\
    \ result;\n    // Base is less than 10 then return original number.\n    if (base\
    \ < 10)\n        return to_string(std::abs(x));\n    // Convert x to string, multiply\
    \ by base and find number of digits in result.\n    while (x != 0) {\n       \
    \ long remainder = x % base;\n        // If remainder is greater than 0 then convert\
    \ remainder to string and add it to the result.\n        if (remainder > 0) {\n\
    \            result += to_string(remainder);\n        }\n        x /= base;\n\
    \    }\n    return result;", "    std::string ans = \"\";\n    while(x > 0) {\n\
    \        ans = to_string(x % base) + ans;\n        x /= base;\n    }\n    return\
    \ ans;", "  std::ostringstream os;\n  // Make sure that x is positive.\n  if (x\
    \ < 0) {\n    x = -x;\n    os << \"0\";\n  }\n  // Convert x to base 10 using\
    \ integer division.\n  while (x > 0) {\n    os.seekp(os.tellg() - 2);\n    os\
    \ << std::setw(2) << std::setfill('0') << (x / base);\n    x %= base;\n  }\n \
    \ // Add 0 if x is negative.\n  if (x < 0) {\n    os.seekp(os.tellg() - 2);\n\
    \    os << std::setw(2) << std::setfill('0') << (x / base);\n    os << \"0\";\n\
    \  }\n  return os.str();", "    long result = x;\n    while (base > 1 && result\
    \ % base != 0) {\n        result /= base;\n    }\n    std::string s = std::to_string(result);\n\
    \    while ((s.size() < base) || s[base - 1] == '0') {\n        s = \"0\" + s;\n\
    \    }\n    return s;", "  long num = x;\n  std::stack<long> nums;\n  // Iterate\
    \ through each digit.\n  while (num != 0) {\n    // Push the last digit into stack\
    \ if base is greater than 10.\n    if (num % base < 10) {\n      nums.push(num\
    \ % base);\n    }\n    // Take the last digit and push into stack if base is less\
    \ than 10.\n    if (num % base > 9) {\n      nums.push(num % base);\n    }\n \
    \   // Divide the current number by base.\n    num /= base;\n  }\n  // Now reverse\
    \ the stack and append a '.' at the end.\n  std::string s = \"\";\n  while ((nums.size()\
    \ != 0) || (!s.empty())) {\n    s += to_string(nums.top());\n    nums.pop();\n\
    \  }\n  if (s.empty()) {\n    s = \"0\";\n  }\n  return s;", "  std::string s\
    \ = std::to_string(x);\n  if(base < 10)\n    s = std::to_string(x);\n  else\n\
    \    s = std::to_string(base) + std::to_string(x - std::to_string(base));\n  return\
    \ s;", "  std::bitset<9> bx;\n  bx.set(static_cast<int>(x));\n  bx.reverse();\n\
    \  std::string result;\n  for (int i = 0; i < base; i++) {\n    result += bx[i];\n\
    \  }\n  return result;"]
stop_tokens:
- "\n}"
